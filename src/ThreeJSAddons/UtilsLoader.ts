// @ts-nocheck

import { runOnUI } from "react-native-reanimated";
import { runOnBackground } from '../Runtime';

import * as i1 from "three/addons/utils/BufferGeometryUtils";
import * as i2 from "three/addons/utils/CameraUtils";
import * as i3 from "three/addons/utils/GeometryCompressionUtils";
import * as i4 from "three/addons/utils/GeometryUtils";
import * as i5 from "three/addons/utils/LDrawUtils";
import * as i6 from "three/addons/utils/SceneUtils";
import * as i7 from "three/addons/utils/ShadowMapViewer";
import * as i8 from "three/addons/utils/SkeletonUtils";
import * as i9 from "three/addons/utils/SortUtils";
import * as i10 from "three/addons/utils/UVsDebug";

export type ThreeJSAddonsUtils = 
  typeof i1 
  & typeof i2 
  & typeof i3 
  & typeof i4 
  & typeof i5 
  & typeof i6 
  & typeof i7 
  & typeof i8 
  & typeof i9
  & typeof i10;

export function initThreeJSAddonsUtils() {

function init() {
  'worklet';

  const ImageBitmap = {};
  const HTMLImageElement = {};
  const HTMLCanvasElement = {};
  const OffscreenCanvas = {};
  const ImageData = {};
  const __THREE_DEVTOOLS__ = undefined;
  const createImageBitmap = undefined;
  const self = globalThis;

  class VideoFrame {}
  class CustomEvent {}
  class ReadableStream {}
  class ProgressEvent {}
  class DOMParser {}
  class TextDecoder {}
  class Response {}
  class Blob {};
  class Headers {};
  class Request {};

  //TODO
  const document = {};
  const window = {
    // innerWidth: windowWidth,
    // innerHeight: windowHeight,
  };

  var __BUNDLE_START_TIME__ = Date.now();
  var __DEV__ = true;
  var process = {};
  var __METRO_GLOBAL_PREFIX__ = '';
  var __requireCycleIgnorePatterns = [/(^|\/|\\)node_modules($|\/|\\)/];
  process.env = process.env || {};
  process.env.NODE_ENV = process.env.NODE_ENV || "development";

// ---------------------------------------------------------------------------

(function (global) {
  "use strict";

  global.__r = metroRequire;
  global[`${__METRO_GLOBAL_PREFIX__}__d`] = define;
  global.__c = clear;
  global.__registerSegment = registerSegment;
  var modules = clear();
  var EMPTY = {};
  var CYCLE_DETECTED = {};
  var _ref = {},
    hasOwnProperty = _ref.hasOwnProperty;
  if (__DEV__) {
    global.$RefreshReg$ = function () {};
    global.$RefreshSig$ = function () {
      return function (type) {
        return type;
      };
    };
  }
  function clear() {
    modules = new Map();
    return modules;
  }
  if (__DEV__) {
    var verboseNamesToModuleIds = new Map();
    var getModuleIdForVerboseName = function getModuleIdForVerboseName(verboseName) {
      var moduleId = verboseNamesToModuleIds.get(verboseName);
      if (moduleId == null) {
        throw new Error(`Unknown named module: "${verboseName}"`);
      }
      return moduleId;
    };
    var initializingModuleIds = [];
  }
  function define(factory, moduleId, dependencyMap) {
    if (modules.has(moduleId)) {
      if (__DEV__) {
        var inverseDependencies = arguments[4];
        if (inverseDependencies) {
          global.__accept(moduleId, factory, dependencyMap, inverseDependencies);
        }
      }
      return;
    }
    var mod = {
      dependencyMap: dependencyMap,
      factory: factory,
      hasError: false,
      importedAll: EMPTY,
      importedDefault: EMPTY,
      isInitialized: false,
      publicModule: {
        exports: {}
      }
    };
    modules.set(moduleId, mod);
    if (__DEV__) {
      mod.hot = createHotReloadingObject();
      var verboseName = arguments[3];
      if (verboseName) {
        mod.verboseName = verboseName;
        verboseNamesToModuleIds.set(verboseName, moduleId);
      }
    }
  }
  function metroRequire(moduleId) {
    if (__DEV__ && typeof moduleId === "string") {
      var verboseName = moduleId;
      moduleId = getModuleIdForVerboseName(verboseName);
      console.warn(`Requiring module "${verboseName}" by name is only supported for ` + "debugging purposes and will BREAK IN PRODUCTION!");
    }
    var moduleIdReallyIsNumber = moduleId;
    if (__DEV__) {
      var initializingIndex = initializingModuleIds.indexOf(moduleIdReallyIsNumber);
      if (initializingIndex !== -1) {
        var cycle = initializingModuleIds.slice(initializingIndex).map(function (id) {
          var _modules$get$verboseN, _modules$get;
          return (_modules$get$verboseN = (_modules$get = modules.get(id)) == null ? void 0 : _modules$get.verboseName) != null ? _modules$get$verboseN : "[unknown]";
        });
        if (shouldPrintRequireCycle(cycle)) {
          cycle.push(cycle[0]);
          console.warn(`Require cycle: ${cycle.join(" -> ")}\n\n` + "Require cycles are allowed, but can result in uninitialized values. " + "Consider refactoring to remove the need for a cycle.");
        }
      }
    }
    var module = modules.get(moduleIdReallyIsNumber);
    return module && module.isInitialized ? module.publicModule.exports : guardedLoadModule(moduleIdReallyIsNumber, module);
  }
  function shouldPrintRequireCycle(modules) {
    var regExps = global[__METRO_GLOBAL_PREFIX__ + "__requireCycleIgnorePatterns"];
    if (!Array.isArray(regExps)) {
      return true;
    }
    var isIgnored = function isIgnored(module) {
      return module != null && regExps.some(function (regExp) {
        return regExp.test(module);
      });
    };
    return modules.every(function (module) {
      return !isIgnored(module);
    });
  }
  function metroImportDefault(moduleId) {
    if (__DEV__ && typeof moduleId === "string") {
      var verboseName = moduleId;
      moduleId = getModuleIdForVerboseName(verboseName);
    }
    var moduleIdReallyIsNumber = moduleId;
    var maybeInitializedModule = modules.get(moduleIdReallyIsNumber);
    if (maybeInitializedModule && maybeInitializedModule.importedDefault !== EMPTY) {
      return maybeInitializedModule.importedDefault;
    }
    var exports = metroRequire(moduleIdReallyIsNumber);
    var importedDefault = exports && exports.__esModule ? exports.default : exports;
    var initializedModule = modules.get(moduleIdReallyIsNumber);
    return initializedModule.importedDefault = importedDefault;
  }
  metroRequire.importDefault = metroImportDefault;
  function metroImportAll(moduleId) {
    if (__DEV__ && typeof moduleId === "string") {
      var verboseName = moduleId;
      moduleId = getModuleIdForVerboseName(verboseName);
    }
    var moduleIdReallyIsNumber = moduleId;
    var maybeInitializedModule = modules.get(moduleIdReallyIsNumber);
    if (maybeInitializedModule && maybeInitializedModule.importedAll !== EMPTY) {
      return maybeInitializedModule.importedAll;
    }
    var exports = metroRequire(moduleIdReallyIsNumber);
    var importedAll;
    if (exports && exports.__esModule) {
      importedAll = exports;
    } else {
      importedAll = {};
      if (exports) {
        for (var key in exports) {
          if (hasOwnProperty.call(exports, key)) {
            importedAll[key] = exports[key];
          }
        }
      }
      importedAll.default = exports;
    }
    var initializedModule = modules.get(moduleIdReallyIsNumber);
    return initializedModule.importedAll = importedAll;
  }
  metroRequire.importAll = metroImportAll;
  metroRequire.context = function fallbackRequireContext() {
    if (__DEV__) {
      throw new Error("The experimental Metro feature `require.context` is not enabled in your project.\nThis can be enabled by setting the `transformer.unstable_allowRequireContext` property to `true` in your Metro configuration.");
    }
    throw new Error("The experimental Metro feature `require.context` is not enabled in your project.");
  };
  metroRequire.resolveWeak = function fallbackRequireResolveWeak() {
    if (__DEV__) {
      throw new Error("require.resolveWeak cannot be called dynamically. Ensure you are using the same version of `metro` and `metro-runtime`.");
    }
    throw new Error("require.resolveWeak cannot be called dynamically.");
  };
  var inGuard = false;
  function guardedLoadModule(moduleId, module) {
    if (!inGuard && global.ErrorUtils) {
      inGuard = true;
      var returnValue;
      try {
        returnValue = loadModuleImplementation(moduleId, module);
      } catch (e) {
        global.ErrorUtils.reportFatalError(e);
      }
      inGuard = false;
      return returnValue;
    } else {
      return loadModuleImplementation(moduleId, module);
    }
  }
  var ID_MASK_SHIFT = 16;
  var LOCAL_ID_MASK = ~0 >>> ID_MASK_SHIFT;
  function unpackModuleId(moduleId) {
    var segmentId = moduleId >>> ID_MASK_SHIFT;
    var localId = moduleId & LOCAL_ID_MASK;
    return {
      segmentId: segmentId,
      localId: localId
    };
  }
  metroRequire.unpackModuleId = unpackModuleId;
  function packModuleId(value) {
    return (value.segmentId << ID_MASK_SHIFT) + value.localId;
  }
  metroRequire.packModuleId = packModuleId;
  var moduleDefinersBySegmentID = [];
  var definingSegmentByModuleID = new Map();
  function registerSegment(segmentId, moduleDefiner, moduleIds) {
    moduleDefinersBySegmentID[segmentId] = moduleDefiner;
    if (__DEV__) {
      if (segmentId === 0 && moduleIds) {
        throw new Error("registerSegment: Expected moduleIds to be null for main segment");
      }
      if (segmentId !== 0 && !moduleIds) {
        throw new Error("registerSegment: Expected moduleIds to be passed for segment #" + segmentId);
      }
    }
    if (moduleIds) {
      moduleIds.forEach(function (moduleId) {
        if (!modules.has(moduleId) && !definingSegmentByModuleID.has(moduleId)) {
          definingSegmentByModuleID.set(moduleId, segmentId);
        }
      });
    }
  }
  function loadModuleImplementation(moduleId, module) {
    if (!module && moduleDefinersBySegmentID.length > 0) {
      var _definingSegmentByMod;
      var segmentId = (_definingSegmentByMod = definingSegmentByModuleID.get(moduleId)) != null ? _definingSegmentByMod : 0;
      var definer = moduleDefinersBySegmentID[segmentId];
      if (definer != null) {
        definer(moduleId);
        module = modules.get(moduleId);
        definingSegmentByModuleID.delete(moduleId);
      }
    }
    var nativeRequire = global.nativeRequire;
    if (!module && nativeRequire) {
      var _unpackModuleId = unpackModuleId(moduleId),
        _segmentId = _unpackModuleId.segmentId,
        localId = _unpackModuleId.localId;
      nativeRequire(localId, _segmentId);
      module = modules.get(moduleId);
    }
    if (!module) {
      throw unknownModuleError(moduleId);
    }
    if (module.hasError) {
      throw module.error;
    }
    if (__DEV__) {
      var Systrace = requireSystrace();
      var Refresh = requireRefresh();
    }
    module.isInitialized = true;
    var _module = module,
      factory = _module.factory,
      dependencyMap = _module.dependencyMap;
    if (__DEV__) {
      initializingModuleIds.push(moduleId);
    }
    try {
      if (__DEV__) {
        Systrace.beginEvent("JS_require_" + (module.verboseName || moduleId));
      }
      var moduleObject = module.publicModule;
      if (__DEV__) {
        moduleObject.hot = module.hot;
        var prevRefreshReg = global.$RefreshReg$;
        var prevRefreshSig = global.$RefreshSig$;
        if (Refresh != null) {
          var RefreshRuntime = Refresh;
          global.$RefreshReg$ = function (type, id) {
            RefreshRuntime.register(type, moduleId + " " + id);
          };
          global.$RefreshSig$ = RefreshRuntime.createSignatureFunctionForTransform;
        }
      }
      moduleObject.id = moduleId;
      factory(global, metroRequire, metroImportDefault, metroImportAll, moduleObject, moduleObject.exports, dependencyMap);
      if (!__DEV__) {
        module.factory = undefined;
        module.dependencyMap = undefined;
      }
      if (__DEV__) {
        Systrace.endEvent();
        if (Refresh != null) {
          registerExportsForReactRefresh(Refresh, moduleObject.exports, moduleId);
        }
      }
      return moduleObject.exports;
    } catch (e) {
      module.hasError = true;
      module.error = e;
      module.isInitialized = false;
      module.publicModule.exports = undefined;
      throw e;
    } finally {
      if (__DEV__) {
        if (initializingModuleIds.pop() !== moduleId) {
          throw new Error("initializingModuleIds is corrupt; something is terribly wrong");
        }
        global.$RefreshReg$ = prevRefreshReg;
        global.$RefreshSig$ = prevRefreshSig;
      }
    }
  }
  function unknownModuleError(id) {
    var message = 'Requiring unknown module "' + id + '".';
    if (__DEV__) {
      message += " If you are sure the module exists, try restarting Metro. " + "You may also want to run `yarn` or `npm install`.";
    }
    return Error(message);
  }
  if (__DEV__) {
    metroRequire.Systrace = {
      beginEvent: function beginEvent() {},
      endEvent: function endEvent() {}
    };
    metroRequire.getModules = function () {
      return modules;
    };
    var createHotReloadingObject = function createHotReloadingObject() {
      var hot = {
        _acceptCallback: null,
        _disposeCallback: null,
        _didAccept: false,
        accept: function accept(callback) {
          hot._didAccept = true;
          hot._acceptCallback = callback;
        },
        dispose: function dispose(callback) {
          hot._disposeCallback = callback;
        }
      };
      return hot;
    };
    var reactRefreshTimeout = null;
    var metroHotUpdateModule = function metroHotUpdateModule(id, factory, dependencyMap, inverseDependencies) {
      var mod = modules.get(id);
      if (!mod) {
        if (factory) {
          return;
        }
        throw unknownModuleError(id);
      }
      if (!mod.hasError && !mod.isInitialized) {
        mod.factory = factory;
        mod.dependencyMap = dependencyMap;
        return;
      }
      var Refresh = requireRefresh();
      var refreshBoundaryIDs = new Set();
      var didBailOut = false;
      var updatedModuleIDs;
      try {
        updatedModuleIDs = topologicalSort([id], function (pendingID) {
          var pendingModule = modules.get(pendingID);
          if (pendingModule == null) {
            return [];
          }
          var pendingHot = pendingModule.hot;
          if (pendingHot == null) {
            throw new Error("[Refresh] Expected module.hot to always exist in DEV.");
          }
          var canAccept = pendingHot._didAccept;
          if (!canAccept && Refresh != null) {
            var isBoundary = isReactRefreshBoundary(Refresh, pendingModule.publicModule.exports);
            if (isBoundary) {
              canAccept = true;
              refreshBoundaryIDs.add(pendingID);
            }
          }
          if (canAccept) {
            return [];
          }
          var parentIDs = inverseDependencies[pendingID];
          if (parentIDs.length === 0) {
            performFullRefresh("No root boundary", {
              source: mod,
              failed: pendingModule
            });
            didBailOut = true;
            return [];
          }
          return parentIDs;
        }, function () {
          return didBailOut;
        }).reverse();
      } catch (e) {
        if (e === CYCLE_DETECTED) {
          performFullRefresh("Dependency cycle", {
            source: mod
          });
          return;
        }
        throw e;
      }
      if (didBailOut) {
        return;
      }
      var seenModuleIDs = new Set();
      for (var i = 0; i < updatedModuleIDs.length; i++) {
        var updatedID = updatedModuleIDs[i];
        if (seenModuleIDs.has(updatedID)) {
          continue;
        }
        seenModuleIDs.add(updatedID);
        var updatedMod = modules.get(updatedID);
        if (updatedMod == null) {
          throw new Error("[Refresh] Expected to find the updated module.");
        }
        var prevExports = updatedMod.publicModule.exports;
        var didError = runUpdatedModule(updatedID, updatedID === id ? factory : undefined, updatedID === id ? dependencyMap : undefined);
        var nextExports = updatedMod.publicModule.exports;
        if (didError) {
          return;
        }
        if (refreshBoundaryIDs.has(updatedID)) {
          var isNoLongerABoundary = !isReactRefreshBoundary(Refresh, nextExports);
          var didInvalidate = shouldInvalidateReactRefreshBoundary(Refresh, prevExports, nextExports);
          if (isNoLongerABoundary || didInvalidate) {
            var parentIDs = inverseDependencies[updatedID];
            if (parentIDs.length === 0) {
              performFullRefresh(isNoLongerABoundary ? "No longer a boundary" : "Invalidated boundary", {
                source: mod,
                failed: updatedMod
              });
              return;
            }
            for (var j = 0; j < parentIDs.length; j++) {
              var parentID = parentIDs[j];
              var parentMod = modules.get(parentID);
              if (parentMod == null) {
                throw new Error("[Refresh] Expected to find parent module.");
              }
              var canAcceptParent = isReactRefreshBoundary(Refresh, parentMod.publicModule.exports);
              if (canAcceptParent) {
                refreshBoundaryIDs.add(parentID);
                updatedModuleIDs.push(parentID);
              } else {
                performFullRefresh("Invalidated boundary", {
                  source: mod,
                  failed: parentMod
                });
                return;
              }
            }
          }
        }
      }
      if (Refresh != null) {
        if (reactRefreshTimeout == null) {
          reactRefreshTimeout = setTimeout(function () {
            reactRefreshTimeout = null;
            Refresh.performReactRefresh();
          }, 30);
        }
      }
    };
    var topologicalSort = function topologicalSort(roots, getEdges, earlyStop) {
      var result = [];
      var visited = new Set();
      var stack = new Set();
      function traverseDependentNodes(node) {
        if (stack.has(node)) {
          throw CYCLE_DETECTED;
        }
        if (visited.has(node)) {
          return;
        }
        visited.add(node);
        stack.add(node);
        var dependentNodes = getEdges(node);
        if (earlyStop(node)) {
          stack.delete(node);
          return;
        }
        dependentNodes.forEach(function (dependent) {
          traverseDependentNodes(dependent);
        });
        stack.delete(node);
        result.push(node);
      }
      roots.forEach(function (root) {
        traverseDependentNodes(root);
      });
      return result;
    };
    var runUpdatedModule = function runUpdatedModule(id, factory, dependencyMap) {
      var mod = modules.get(id);
      if (mod == null) {
        throw new Error("[Refresh] Expected to find the module.");
      }
      var hot = mod.hot;
      if (!hot) {
        throw new Error("[Refresh] Expected module.hot to always exist in DEV.");
      }
      if (hot._disposeCallback) {
        try {
          hot._disposeCallback();
        } catch (error) {
          console.error(`Error while calling dispose handler for module ${id}: `, error);
        }
      }
      if (factory) {
        mod.factory = factory;
      }
      if (dependencyMap) {
        mod.dependencyMap = dependencyMap;
      }
      mod.hasError = false;
      mod.error = undefined;
      mod.importedAll = EMPTY;
      mod.importedDefault = EMPTY;
      mod.isInitialized = false;
      var prevExports = mod.publicModule.exports;
      mod.publicModule.exports = {};
      hot._didAccept = false;
      hot._acceptCallback = null;
      hot._disposeCallback = null;
      metroRequire(id);
      if (mod.hasError) {
        mod.hasError = false;
        mod.isInitialized = true;
        mod.error = null;
        mod.publicModule.exports = prevExports;
        return true;
      }
      if (hot._acceptCallback) {
        try {
          hot._acceptCallback();
        } catch (error) {
          console.error(`Error while calling accept handler for module ${id}: `, error);
        }
      }
      return false;
    };
    var performFullRefresh = function performFullRefresh(reason, modules) {
      if (typeof window !== "undefined" && window.location != null && typeof window.location.reload === "function") {
        window.location.reload();
      } else {
        var Refresh = requireRefresh();
        if (Refresh != null) {
          var _modules$source$verbo, _modules$source, _modules$failed$verbo, _modules$failed;
          var sourceName = (_modules$source$verbo = (_modules$source = modules.source) == null ? void 0 : _modules$source.verboseName) != null ? _modules$source$verbo : "unknown";
          var failedName = (_modules$failed$verbo = (_modules$failed = modules.failed) == null ? void 0 : _modules$failed.verboseName) != null ? _modules$failed$verbo : "unknown";
          Refresh.performFullRefresh(`Fast Refresh - ${reason} <${sourceName}> <${failedName}>`);
        } else {
          console.warn("Could not reload the application after an edit.");
        }
      }
    };
    var isReactRefreshBoundary = function isReactRefreshBoundary(Refresh, moduleExports) {
      if (Refresh.isLikelyComponentType(moduleExports)) {
        return true;
      }
      if (moduleExports == null || typeof moduleExports !== "object") {
        return false;
      }
      var hasExports = false;
      var areAllExportsComponents = true;
      for (var key in moduleExports) {
        hasExports = true;
        if (key === "__esModule") {
          continue;
        }
        var desc = Object.getOwnPropertyDescriptor(moduleExports, key);
        if (desc && desc.get) {
          return false;
        }
        var exportValue = moduleExports[key];
        if (!Refresh.isLikelyComponentType(exportValue)) {
          areAllExportsComponents = false;
        }
      }
      return hasExports && areAllExportsComponents;
    };
    var shouldInvalidateReactRefreshBoundary = function shouldInvalidateReactRefreshBoundary(Refresh, prevExports, nextExports) {
      var prevSignature = getRefreshBoundarySignature(Refresh, prevExports);
      var nextSignature = getRefreshBoundarySignature(Refresh, nextExports);
      if (prevSignature.length !== nextSignature.length) {
        return true;
      }
      for (var i = 0; i < nextSignature.length; i++) {
        if (prevSignature[i] !== nextSignature[i]) {
          return true;
        }
      }
      return false;
    };
    var getRefreshBoundarySignature = function getRefreshBoundarySignature(Refresh, moduleExports) {
      var signature = [];
      signature.push(Refresh.getFamilyByType(moduleExports));
      if (moduleExports == null || typeof moduleExports !== "object") {
        return signature;
      }
      for (var key in moduleExports) {
        if (key === "__esModule") {
          continue;
        }
        var desc = Object.getOwnPropertyDescriptor(moduleExports, key);
        if (desc && desc.get) {
          continue;
        }
        var exportValue = moduleExports[key];
        signature.push(key);
        signature.push(Refresh.getFamilyByType(exportValue));
      }
      return signature;
    };
    var registerExportsForReactRefresh = function registerExportsForReactRefresh(Refresh, moduleExports, moduleID) {
      Refresh.register(moduleExports, moduleID + " %exports%");
      if (moduleExports == null || typeof moduleExports !== "object") {
        return;
      }
      for (var key in moduleExports) {
        var desc = Object.getOwnPropertyDescriptor(moduleExports, key);
        if (desc && desc.get) {
          continue;
        }
        var exportValue = moduleExports[key];
        var typeID = moduleID + " %exports% " + key;
        Refresh.register(exportValue, typeID);
      }
    };
    global.__accept = metroHotUpdateModule;
  }
  if (__DEV__) {
    var requireSystrace = function requireSystrace() {
      return global[__METRO_GLOBAL_PREFIX__ + "__SYSTRACE"] || metroRequire.Systrace;
    };
    var requireRefresh = function requireRefresh() {
      return global[__METRO_GLOBAL_PREFIX__ + "__ReactRefresh"] || metroRequire.Refresh;
    };
  }
})(typeof globalThis !== 'undefined' ? globalThis : typeof global !== 'undefined' ? global : typeof window !== 'undefined' ? window : this);
(function (global) {
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * @polyfill
   * @nolint
   * @format
   */

  /* eslint-disable no-shadow, eqeqeq, curly, no-unused-vars, no-void, no-control-regex  */

  /**
   * This pipes all of our console logging functions to native logging so that
   * JavaScript errors in required modules show up in Xcode via NSLog.
   */
  var inspect = function () {
    // Copyright Joyent, Inc. and other Node contributors.
    //
    // Permission is hereby granted, free of charge, to any person obtaining a
    // copy of this software and associated documentation files (the
    // "Software"), to deal in the Software without restriction, including
    // without limitation the rights to use, copy, modify, merge, publish,
    // distribute, sublicense, and/or sell copies of the Software, and to permit
    // persons to whom the Software is furnished to do so, subject to the
    // following conditions:
    //
    // The above copyright notice and this permission notice shall be included
    // in all copies or substantial portions of the Software.
    //
    // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
    // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
    // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
    // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
    // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
    // USE OR OTHER DEALINGS IN THE SOFTWARE.
    //
    // https://github.com/joyent/node/blob/master/lib/util.js

    function inspect(obj, opts) {
      var ctx = {
        seen: [],
        formatValueCalls: 0,
        stylize: stylizeNoColor
      };
      return formatValue(ctx, obj, opts.depth);
    }
    function stylizeNoColor(str, styleType) {
      return str;
    }
    function arrayToHash(array) {
      var hash = {};
      array.forEach(function (val, idx) {
        hash[val] = true;
      });
      return hash;
    }
    function formatValue(ctx, value, recurseTimes) {
      ctx.formatValueCalls++;
      if (ctx.formatValueCalls > 200) {
        return `[TOO BIG formatValueCalls ${ctx.formatValueCalls} exceeded limit of 200]`;
      }

      // Primitive types cannot have properties
      var primitive = formatPrimitive(ctx, value);
      if (primitive) {
        return primitive;
      }

      // Look up the keys of the object.
      var keys = Object.keys(value);
      var visibleKeys = arrayToHash(keys);

      // IE doesn't make error fields non-enumerable
      // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
      if (isError(value) && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
        return formatError(value);
      }

      // Some type of object without properties can be shortcutted.
      if (keys.length === 0) {
        if (isFunction(value)) {
          var name = value.name ? ': ' + value.name : '';
          return ctx.stylize('[Function' + name + ']', 'special');
        }
        if (isRegExp(value)) {
          return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
        }
        if (isDate(value)) {
          return ctx.stylize(Date.prototype.toString.call(value), 'date');
        }
        if (isError(value)) {
          return formatError(value);
        }
      }
      var base = '',
        array = false,
        braces = ['{', '}'];

      // Make Array say that they are Array
      if (isArray(value)) {
        array = true;
        braces = ['[', ']'];
      }

      // Make functions say that they are functions
      if (isFunction(value)) {
        var n = value.name ? ': ' + value.name : '';
        base = ' [Function' + n + ']';
      }

      // Make RegExps say that they are RegExps
      if (isRegExp(value)) {
        base = ' ' + RegExp.prototype.toString.call(value);
      }

      // Make dates with properties first say the date
      if (isDate(value)) {
        base = ' ' + Date.prototype.toUTCString.call(value);
      }

      // Make error with message first say the error
      if (isError(value)) {
        base = ' ' + formatError(value);
      }
      if (keys.length === 0 && (!array || value.length == 0)) {
        return braces[0] + base + braces[1];
      }
      if (recurseTimes < 0) {
        if (isRegExp(value)) {
          return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
        } else {
          return ctx.stylize('[Object]', 'special');
        }
      }
      ctx.seen.push(value);
      var output;
      if (array) {
        output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
      } else {
        output = keys.map(function (key) {
          return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
        });
      }
      ctx.seen.pop();
      return reduceToSingleString(output, base, braces);
    }
    function formatPrimitive(ctx, value) {
      if (isUndefined(value)) return ctx.stylize('undefined', 'undefined');
      if (isString(value)) {
        var simple = "'" + JSON.stringify(value).replace(/^"|"$/g, '').replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
        return ctx.stylize(simple, 'string');
      }
      if (isNumber(value)) return ctx.stylize('' + value, 'number');
      if (isBoolean(value)) return ctx.stylize('' + value, 'boolean');
      // For some reason typeof null is "object", so special case here.
      if (isNull(value)) return ctx.stylize('null', 'null');
    }
    function formatError(value) {
      return '[' + Error.prototype.toString.call(value) + ']';
    }
    function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
      var output = [];
      for (var i = 0, l = value.length; i < l; ++i) {
        if (hasOwnProperty(value, String(i))) {
          output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, String(i), true));
        } else {
          output.push('');
        }
      }
      keys.forEach(function (key) {
        if (!key.match(/^\d+$/)) {
          output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, key, true));
        }
      });
      return output;
    }
    function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
      var name, str, desc;
      desc = Object.getOwnPropertyDescriptor(value, key) || {
        value: value[key]
      };
      if (desc.get) {
        if (desc.set) {
          str = ctx.stylize('[Getter/Setter]', 'special');
        } else {
          str = ctx.stylize('[Getter]', 'special');
        }
      } else {
        if (desc.set) {
          str = ctx.stylize('[Setter]', 'special');
        }
      }
      if (!hasOwnProperty(visibleKeys, key)) {
        name = '[' + key + ']';
      }
      if (!str) {
        if (ctx.seen.indexOf(desc.value) < 0) {
          if (isNull(recurseTimes)) {
            str = formatValue(ctx, desc.value, null);
          } else {
            str = formatValue(ctx, desc.value, recurseTimes - 1);
          }
          if (str.indexOf('\n') > -1) {
            if (array) {
              str = str.split('\n').map(function (line) {
                return '  ' + line;
              }).join('\n').slice(2);
            } else {
              str = '\n' + str.split('\n').map(function (line) {
                return '   ' + line;
              }).join('\n');
            }
          }
        } else {
          str = ctx.stylize('[Circular]', 'special');
        }
      }
      if (isUndefined(name)) {
        if (array && key.match(/^\d+$/)) {
          return str;
        }
        name = JSON.stringify('' + key);
        if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
          name = name.slice(1, name.length - 1);
          name = ctx.stylize(name, 'name');
        } else {
          name = name.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
          name = ctx.stylize(name, 'string');
        }
      }
      return name + ': ' + str;
    }
    function reduceToSingleString(output, base, braces) {
      var numLinesEst = 0;
      var length = output.reduce(function (prev, cur) {
        numLinesEst++;
        if (cur.indexOf('\n') >= 0) numLinesEst++;
        return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
      }, 0);
      if (length > 60) {
        return braces[0] + (base === '' ? '' : base + '\n ') + ' ' + output.join(',\n  ') + ' ' + braces[1];
      }
      return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
    }

    // NOTE: These type checking functions intentionally don't use `instanceof`
    // because it is fragile and can be easily faked with `Object.create()`.
    function isArray(ar) {
      return Array.isArray(ar);
    }
    function isBoolean(arg) {
      return typeof arg === 'boolean';
    }
    function isNull(arg) {
      return arg === null;
    }
    function isNullOrUndefined(arg) {
      return arg == null;
    }
    function isNumber(arg) {
      return typeof arg === 'number';
    }
    function isString(arg) {
      return typeof arg === 'string';
    }
    function isSymbol(arg) {
      return typeof arg === 'symbol';
    }
    function isUndefined(arg) {
      return arg === void 0;
    }
    function isRegExp(re) {
      return isObject(re) && objectToString(re) === '[object RegExp]';
    }
    function isObject(arg) {
      return typeof arg === 'object' && arg !== null;
    }
    function isDate(d) {
      return isObject(d) && objectToString(d) === '[object Date]';
    }
    function isError(e) {
      return isObject(e) && (objectToString(e) === '[object Error]' || e instanceof Error);
    }
    function isFunction(arg) {
      return typeof arg === 'function';
    }
    function objectToString(o) {
      return Object.prototype.toString.call(o);
    }
    function hasOwnProperty(obj, prop) {
      return Object.prototype.hasOwnProperty.call(obj, prop);
    }
    return inspect;
  }();
  var OBJECT_COLUMN_NAME = '(index)';
  var LOG_LEVELS = {
    trace: 0,
    info: 1,
    warn: 2,
    error: 3
  };
  var INSPECTOR_LEVELS = [];
  INSPECTOR_LEVELS[LOG_LEVELS.trace] = 'debug';
  INSPECTOR_LEVELS[LOG_LEVELS.info] = 'log';
  INSPECTOR_LEVELS[LOG_LEVELS.warn] = 'warning';
  INSPECTOR_LEVELS[LOG_LEVELS.error] = 'error';

  // Strip the inner function in getNativeLogFunction(), if in dev also
  // strip method printing to originalConsole.
  var INSPECTOR_FRAMES_TO_SKIP = __DEV__ ? 2 : 1;
  function getNativeLogFunction(level) {
    return function () {
      var str;
      if (arguments.length === 1 && typeof arguments[0] === 'string') {
        str = arguments[0];
      } else {
        str = Array.prototype.map.call(arguments, function (arg) {
          return inspect(arg, {
            depth: 10
          });
        }).join(', ');
      }

      // TRICKY
      // If more than one argument is provided, the code above collapses them all
      // into a single formatted string. This transform wraps string arguments in
      // single quotes (e.g. "foo" -> "'foo'") which then breaks the "Warning:"
      // check below. So it's important that we look at the first argument, rather
      // than the formatted argument string.
      var firstArg = arguments[0];
      var logLevel = level;
      if (typeof firstArg === 'string' && firstArg.slice(0, 9) === 'Warning: ' && logLevel >= LOG_LEVELS.error) {
        // React warnings use console.error so that a stack trace is shown,
        // but we don't (currently) want these to show a redbox
        // (Note: Logic duplicated in ExceptionsManager.js.)
        logLevel = LOG_LEVELS.warn;
      }
      if (global.__inspectorLog) {
        global.__inspectorLog(INSPECTOR_LEVELS[logLevel], str, [].slice.call(arguments), INSPECTOR_FRAMES_TO_SKIP);
      }
      if (groupStack.length) {
        str = groupFormat('', str);
      }
      global.nativeLoggingHook(str, logLevel);
    };
  }
  function repeat(element, n) {
    return Array.apply(null, Array(n)).map(function () {
      return element;
    });
  }
  function consoleTablePolyfill(rows) {
    // convert object -> array
    if (!Array.isArray(rows)) {
      var data = rows;
      rows = [];
      for (var key in data) {
        if (data.hasOwnProperty(key)) {
          var row = data[key];
          row[OBJECT_COLUMN_NAME] = key;
          rows.push(row);
        }
      }
    }
    if (rows.length === 0) {
      global.nativeLoggingHook('', LOG_LEVELS.info);
      return;
    }
    var columns = Object.keys(rows[0]).sort();
    var stringRows = [];
    var columnWidths = [];

    // Convert each cell to a string. Also
    // figure out max cell width for each column
    columns.forEach(function (k, i) {
      columnWidths[i] = k.length;
      for (var j = 0; j < rows.length; j++) {
        var cellStr = (rows[j][k] || '?').toString();
        stringRows[j] = stringRows[j] || [];
        stringRows[j][i] = cellStr;
        columnWidths[i] = Math.max(columnWidths[i], cellStr.length);
      }
    });

    // Join all elements in the row into a single string with | separators
    // (appends extra spaces to each cell to make separators  | aligned)
    function joinRow(row, space) {
      var cells = row.map(function (cell, i) {
        var extraSpaces = repeat(' ', columnWidths[i] - cell.length).join('');
        return cell + extraSpaces;
      });
      space = space || ' ';
      return cells.join(space + '|' + space);
    }
    var separators = columnWidths.map(function (columnWidth) {
      return repeat('-', columnWidth).join('');
    });
    var separatorRow = joinRow(separators, '-');
    var header = joinRow(columns);
    var table = [header, separatorRow];
    for (var i = 0; i < rows.length; i++) {
      table.push(joinRow(stringRows[i]));
    }

    // Notice extra empty line at the beginning.
    // Native logging hook adds "RCTLog >" at the front of every
    // logged string, which would shift the header and screw up
    // the table
    global.nativeLoggingHook('\n' + table.join('\n'), LOG_LEVELS.info);
  }
  var GROUP_PAD = "\u2502"; // Box light vertical
  var GROUP_OPEN = "\u2510"; // Box light down+left
  var GROUP_CLOSE = "\u2518"; // Box light up+left

  var groupStack = [];
  function groupFormat(prefix, msg) {
    // Insert group formatting before the console message
    return groupStack.join('') + prefix + ' ' + (msg || '');
  }
  function consoleGroupPolyfill(label) {
    global.nativeLoggingHook(groupFormat(GROUP_OPEN, label), LOG_LEVELS.info);
    groupStack.push(GROUP_PAD);
  }
  function consoleGroupCollapsedPolyfill(label) {
    global.nativeLoggingHook(groupFormat(GROUP_CLOSE, label), LOG_LEVELS.info);
    groupStack.push(GROUP_PAD);
  }
  function consoleGroupEndPolyfill() {
    groupStack.pop();
    global.nativeLoggingHook(groupFormat(GROUP_CLOSE), LOG_LEVELS.info);
  }
  function consoleAssertPolyfill(expression, label) {
    if (!expression) {
      global.nativeLoggingHook('Assertion failed: ' + label, LOG_LEVELS.error);
    }
  }
  if (global.nativeLoggingHook) {
    var originalConsole = global.console;
    // Preserve the original `console` as `originalConsole`
    if (__DEV__ && originalConsole) {
      var descriptor = Object.getOwnPropertyDescriptor(global, 'console');
      if (descriptor) {
        Object.defineProperty(global, 'originalConsole', descriptor);
      }
    }
    global.console = {
      error: getNativeLogFunction(LOG_LEVELS.error),
      info: getNativeLogFunction(LOG_LEVELS.info),
      log: getNativeLogFunction(LOG_LEVELS.info),
      warn: getNativeLogFunction(LOG_LEVELS.warn),
      trace: getNativeLogFunction(LOG_LEVELS.trace),
      debug: getNativeLogFunction(LOG_LEVELS.trace),
      table: consoleTablePolyfill,
      group: consoleGroupPolyfill,
      groupEnd: consoleGroupEndPolyfill,
      groupCollapsed: consoleGroupCollapsedPolyfill,
      assert: consoleAssertPolyfill
    };
    Object.defineProperty(console, '_isPolyfilled', {
      value: true,
      enumerable: false
    });

    // If available, also call the original `console` method since that is
    // sometimes useful. Ex: on OS X, this will let you see rich output in
    // the Safari Web Inspector console.
    if (__DEV__ && originalConsole) {
      Object.keys(console).forEach(function (methodName) {
        var reactNativeMethod = console[methodName];
        if (originalConsole[methodName]) {
          console[methodName] = function () {
            originalConsole[methodName].apply(originalConsole, arguments);
            reactNativeMethod.apply(console, arguments);
          };
        }
      });

      // The following methods are not supported by this polyfill but
      // we still should pass them to original console if they are
      // supported by it.
      ['clear', 'dir', 'dirxml', 'profile', 'profileEnd'].forEach(function (methodName) {
        if (typeof originalConsole[methodName] === 'function') {
          console[methodName] = function () {
            originalConsole[methodName].apply(originalConsole, arguments);
          };
        }
      });
    }
  } else if (!global.console) {
    var stub = function stub() {};
    var log = global.print || stub;
    global.console = {
      debug: log,
      error: log,
      info: log,
      log: log,
      trace: log,
      warn: log,
      assert: function assert(expression, label) {
        if (!expression) {
          log('Assertion failed: ' + label);
        }
      },
      clear: stub,
      dir: stub,
      dirxml: stub,
      group: stub,
      groupCollapsed: stub,
      groupEnd: stub,
      profile: stub,
      profileEnd: stub,
      table: stub
    };
    Object.defineProperty(console, '_isPolyfilled', {
      value: true,
      enumerable: false
    });
  }
})(typeof globalThis !== 'undefined' ? globalThis : typeof global !== 'undefined' ? global : typeof window !== 'undefined' ? window : this);
(function (global) {
  /**
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *
   * @format
   * 
   * @polyfill
   */

  var _inGuard = 0;
  /**
   * This is the error handler that is called when we encounter an exception
   * when loading a module. This will report any errors encountered before
   * ExceptionsManager is configured.
   */
  var _globalHandler = function onError(e, isFatal) {
    throw e;
  };

  /**
   * The particular require runtime that we are using looks for a global
   * `ErrorUtils` object and if it exists, then it requires modules with the
   * error handler specified via ErrorUtils.setGlobalHandler by calling the
   * require function with applyWithGuard. Since the require module is loaded
   * before any of the modules, this ErrorUtils must be defined (and the handler
   * set) globally before requiring anything.
   */
  var ErrorUtils = {
    setGlobalHandler: function setGlobalHandler(fun) {
      _globalHandler = fun;
    },
    getGlobalHandler: function getGlobalHandler() {
      return _globalHandler;
    },
    reportError: function reportError(error) {
      _globalHandler && _globalHandler(error, false);
    },
    reportFatalError: function reportFatalError(error) {
      // NOTE: This has an untyped call site in Metro.
      _globalHandler && _globalHandler(error, true);
    },
    applyWithGuard: function applyWithGuard(fun, context, args,
    // Unused, but some code synced from www sets it to null.
    unused_onError,
    // Some callers pass a name here, which we ignore.
    unused_name) {
      try {
        _inGuard++;
        /* $FlowFixMe[incompatible-call] : TODO T48204745 (1) apply(context,
         * null) is fine. (2) array -> rest array should work */
        /* $FlowFixMe[incompatible-type] : TODO T48204745 (1) apply(context,
         * null) is fine. (2) array -> rest array should work */
        return fun.apply(context, args);
      } catch (e) {
        ErrorUtils.reportError(e);
      } finally {
        _inGuard--;
      }
      return null;
    },
    applyWithGuardIfNeeded: function applyWithGuardIfNeeded(fun, context, args) {
      if (ErrorUtils.inGuard()) {
        /* $FlowFixMe[incompatible-call] : TODO T48204745 (1) apply(context,
         * null) is fine. (2) array -> rest array should work */
        /* $FlowFixMe[incompatible-type] : TODO T48204745 (1) apply(context,
         * null) is fine. (2) array -> rest array should work */
        return fun.apply(context, args);
      } else {
        ErrorUtils.applyWithGuard(fun, context, args);
      }
      return null;
    },
    inGuard: function inGuard() {
      return !!_inGuard;
    },
    guard: function guard(fun, name, context) {
      var _ref;
      // TODO: (moti) T48204753 Make sure this warning is never hit and remove it - types
      // should be sufficient.
      if (typeof fun !== 'function') {
        console.warn('A function must be passed to ErrorUtils.guard, got ', fun);
        return null;
      }
      var guardName = (_ref = name != null ? name : fun.name) != null ? _ref : '<generated guard>';
      /* $FlowFixMe[missing-this-annot] The 'this' type annotation(s) required by
       * Flow's LTI update could not be added via codemod */
      function guarded() {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        return ErrorUtils.applyWithGuard(fun, context != null ? context : this, args, null, guardName);
      }
      return guarded;
    }
  };
  global.ErrorUtils = ErrorUtils;
})(typeof globalThis !== 'undefined' ? globalThis : typeof global !== 'undefined' ? global : typeof window !== 'undefined' ? window : this);
global.__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  var _exportNames = {
    BufferGeometryUtils: true,
    CameraUtils: true,
    GeometryCompressionUtils: true,
    GeometryUtils: true,
    SceneUtils: true,
    SkeletonUtils: true,
    SortUtils: true
  };
  exports.SortUtils = exports.SkeletonUtils = exports.SceneUtils = exports.GeometryUtils = exports.GeometryCompressionUtils = exports.CameraUtils = exports.BufferGeometryUtils = void 0;
  var _BufferGeometryUtils = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[0], "three/addons/utils/BufferGeometryUtils"));
  exports.BufferGeometryUtils = _BufferGeometryUtils;
  var _CameraUtils = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[1], "three/addons/utils/CameraUtils"));
  exports.CameraUtils = _CameraUtils;
  var _GeometryCompressionUtils = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[2], "three/addons/utils/GeometryCompressionUtils"));
  exports.GeometryCompressionUtils = _GeometryCompressionUtils;
  var _GeometryUtils = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[3], "three/addons/utils/GeometryUtils"));
  exports.GeometryUtils = _GeometryUtils;
  Object.keys(_$$_REQUIRE(_dependencyMap[4], "three/addons/utils/LDrawUtils")).forEach(function (key) {
    if (key === "default" || key === "__esModule") return;
    if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
    if (key in exports && exports[key] === _$$_REQUIRE(_dependencyMap[4], "three/addons/utils/LDrawUtils")[key]) return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function get() {
        return _$$_REQUIRE(_dependencyMap[4], "three/addons/utils/LDrawUtils")[key];
      }
    });
  });
  var _SceneUtils = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[5], "three/addons/utils/SceneUtils"));
  exports.SceneUtils = _SceneUtils;
  Object.keys(_$$_REQUIRE(_dependencyMap[6], "three/addons/utils/ShadowMapViewer")).forEach(function (key) {
    if (key === "default" || key === "__esModule") return;
    if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
    if (key in exports && exports[key] === _$$_REQUIRE(_dependencyMap[6], "three/addons/utils/ShadowMapViewer")[key]) return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function get() {
        return _$$_REQUIRE(_dependencyMap[6], "three/addons/utils/ShadowMapViewer")[key];
      }
    });
  });
  var _SkeletonUtils = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[7], "three/addons/utils/SkeletonUtils"));
  exports.SkeletonUtils = _SkeletonUtils;
  var _SortUtils = _interopRequireWildcard(_$$_REQUIRE(_dependencyMap[8], "three/addons/utils/SortUtils"));
  exports.SortUtils = _SortUtils;
  Object.keys(_$$_REQUIRE(_dependencyMap[9], "three/addons/utils/UVsDebug")).forEach(function (key) {
    if (key === "default" || key === "__esModule") return;
    if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
    if (key in exports && exports[key] === _$$_REQUIRE(_dependencyMap[9], "three/addons/utils/UVsDebug")[key]) return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function get() {
        return _$$_REQUIRE(_dependencyMap[9], "three/addons/utils/UVsDebug")[key];
      }
    });
  });
  Object.keys(_$$_REQUIRE(_dependencyMap[10], "three/addons/utils/WebGLTextureUtils")).forEach(function (key) {
    if (key === "default" || key === "__esModule") return;
    if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
    if (key in exports && exports[key] === _$$_REQUIRE(_dependencyMap[10], "three/addons/utils/WebGLTextureUtils")[key]) return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function get() {
        return _$$_REQUIRE(_dependencyMap[10], "three/addons/utils/WebGLTextureUtils")[key];
      }
    });
  });
  Object.keys(_$$_REQUIRE(_dependencyMap[11], "three/addons/utils/WorkerPool")).forEach(function (key) {
    if (key === "default" || key === "__esModule") return;
    if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
    if (key in exports && exports[key] === _$$_REQUIRE(_dependencyMap[11], "three/addons/utils/WorkerPool")[key]) return;
    Object.defineProperty(exports, key, {
      enumerable: true,
      get: function get() {
        return _$$_REQUIRE(_dependencyMap[11], "three/addons/utils/WorkerPool")[key];
      }
    });
  });
  function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(e) { return e ? t : r; })(e); }
  function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
},0,[1,34,35,36,37,38,39,41,42,43,44,45],"test.js");
global.__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.computeMikkTSpaceTangents = computeMikkTSpaceTangents;
  exports.computeMorphedAttributes = computeMorphedAttributes;
  exports.deepCloneAttribute = deepCloneAttribute;
  exports.deinterleaveAttribute = deinterleaveAttribute;
  exports.deinterleaveGeometry = deinterleaveGeometry;
  exports.estimateBytesUsed = estimateBytesUsed;
  exports.interleaveAttributes = interleaveAttributes;
  exports.mergeAttributes = mergeAttributes;
  exports.mergeGeometries = mergeGeometries;
  exports.mergeGroups = mergeGroups;
  exports.mergeVertices = mergeVertices;
  exports.toCreasedNormals = toCreasedNormals;
  exports.toTrianglesDrawMode = toTrianglesDrawMode;
  function computeMikkTSpaceTangents(geometry, MikkTSpace) {
    var negateSign = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
    if (!MikkTSpace || !MikkTSpace.isReady) {
      throw new Error('BufferGeometryUtils: Initialized MikkTSpace library required.');
    }
    if (!geometry.hasAttribute('position') || !geometry.hasAttribute('normal') || !geometry.hasAttribute('uv')) {
      throw new Error('BufferGeometryUtils: Tangents require "position", "normal", and "uv" attributes.');
    }
    function getAttributeArray(attribute) {
      if (attribute.normalized || attribute.isInterleavedBufferAttribute) {
        var dstArray = new Float32Array(attribute.count * attribute.itemSize);
        for (var i = 0, j = 0; i < attribute.count; i++) {
          dstArray[j++] = attribute.getX(i);
          dstArray[j++] = attribute.getY(i);
          if (attribute.itemSize > 2) {
            dstArray[j++] = attribute.getZ(i);
          }
        }
        return dstArray;
      }
      if (attribute.array instanceof Float32Array) {
        return attribute.array;
      }
      return new Float32Array(attribute.array);
    }

    // MikkTSpace algorithm requires non-indexed input.

    var _geometry = geometry.index ? geometry.toNonIndexed() : geometry;

    // Compute vertex tangents.

    var tangents = MikkTSpace.generateTangents(getAttributeArray(_geometry.attributes.position), getAttributeArray(_geometry.attributes.normal), getAttributeArray(_geometry.attributes.uv));

    // Texture coordinate convention of glTF differs from the apparent
    // default of the MikkTSpace library; .w component must be flipped.

    if (negateSign) {
      for (var i = 3; i < tangents.length; i += 4) {
        tangents[i] *= -1;
      }
    }

    //

    _geometry.setAttribute('tangent', new (_$$_REQUIRE(_dependencyMap[0], "three").BufferAttribute)(tangents, 4));
    if (geometry !== _geometry) {
      geometry.copy(_geometry);
    }
    return geometry;
  }

  /**
   * @param  {Array<BufferGeometry>} geometries
   * @param  {Boolean} useGroups
   * @return {BufferGeometry}
   */
  function mergeGeometries(geometries) {
    var useGroups = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    var isIndexed = geometries[0].index !== null;
    var attributesUsed = new Set(Object.keys(geometries[0].attributes));
    var morphAttributesUsed = new Set(Object.keys(geometries[0].morphAttributes));
    var attributes = {};
    var morphAttributes = {};
    var morphTargetsRelative = geometries[0].morphTargetsRelative;
    var mergedGeometry = new (_$$_REQUIRE(_dependencyMap[0], "three").BufferGeometry)();
    var offset = 0;
    for (var i = 0; i < geometries.length; ++i) {
      var geometry = geometries[i];
      var attributesCount = 0;

      // ensure that all geometries are indexed, or none

      if (isIndexed !== (geometry.index !== null)) {
        console.error('THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index ' + i + '. All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them.');
        return null;
      }

      // gather attributes, exit early if they're different

      for (var name in geometry.attributes) {
        if (!attributesUsed.has(name)) {
          console.error('THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index ' + i + '. All geometries must have compatible attributes; make sure "' + name + '" attribute exists among all geometries, or in none of them.');
          return null;
        }
        if (attributes[name] === undefined) attributes[name] = [];
        attributes[name].push(geometry.attributes[name]);
        attributesCount++;
      }

      // ensure geometries have the same number of attributes

      if (attributesCount !== attributesUsed.size) {
        console.error('THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index ' + i + '. Make sure all geometries have the same number of attributes.');
        return null;
      }

      // gather morph attributes, exit early if they're different

      if (morphTargetsRelative !== geometry.morphTargetsRelative) {
        console.error('THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index ' + i + '. .morphTargetsRelative must be consistent throughout all geometries.');
        return null;
      }
      for (var _name in geometry.morphAttributes) {
        if (!morphAttributesUsed.has(_name)) {
          console.error('THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index ' + i + '.  .morphAttributes must be consistent throughout all geometries.');
          return null;
        }
        if (morphAttributes[_name] === undefined) morphAttributes[_name] = [];
        morphAttributes[_name].push(geometry.morphAttributes[_name]);
      }
      if (useGroups) {
        var count = void 0;
        if (isIndexed) {
          count = geometry.index.count;
        } else if (geometry.attributes.position !== undefined) {
          count = geometry.attributes.position.count;
        } else {
          console.error('THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index ' + i + '. The geometry must have either an index or a position attribute');
          return null;
        }
        mergedGeometry.addGroup(offset, count, i);
        offset += count;
      }
    }

    // merge indices

    if (isIndexed) {
      var indexOffset = 0;
      var mergedIndex = [];
      for (var _i = 0; _i < geometries.length; ++_i) {
        var index = geometries[_i].index;
        for (var j = 0; j < index.count; ++j) {
          mergedIndex.push(index.getX(j) + indexOffset);
        }
        indexOffset += geometries[_i].attributes.position.count;
      }
      mergedGeometry.setIndex(mergedIndex);
    }

    // merge attributes

    for (var _name2 in attributes) {
      var mergedAttribute = mergeAttributes(attributes[_name2]);
      if (!mergedAttribute) {
        console.error('THREE.BufferGeometryUtils: .mergeGeometries() failed while trying to merge the ' + _name2 + ' attribute.');
        return null;
      }
      mergedGeometry.setAttribute(_name2, mergedAttribute);
    }

    // merge morph attributes

    for (var _name3 in morphAttributes) {
      var numMorphTargets = morphAttributes[_name3][0].length;
      if (numMorphTargets === 0) break;
      mergedGeometry.morphAttributes = mergedGeometry.morphAttributes || {};
      mergedGeometry.morphAttributes[_name3] = [];
      for (var _i2 = 0; _i2 < numMorphTargets; ++_i2) {
        var morphAttributesToMerge = [];
        for (var _j = 0; _j < morphAttributes[_name3].length; ++_j) {
          morphAttributesToMerge.push(morphAttributes[_name3][_j][_i2]);
        }
        var mergedMorphAttribute = mergeAttributes(morphAttributesToMerge);
        if (!mergedMorphAttribute) {
          console.error('THREE.BufferGeometryUtils: .mergeGeometries() failed while trying to merge the ' + _name3 + ' morphAttribute.');
          return null;
        }
        mergedGeometry.morphAttributes[_name3].push(mergedMorphAttribute);
      }
    }
    return mergedGeometry;
  }

  /**
   * @param {Array<BufferAttribute>} attributes
   * @return {BufferAttribute}
   */
  function mergeAttributes(attributes) {
    var TypedArray;
    var itemSize;
    var normalized;
    var gpuType = -1;
    var arrayLength = 0;
    for (var i = 0; i < attributes.length; ++i) {
      var attribute = attributes[i];
      if (TypedArray === undefined) TypedArray = attribute.array.constructor;
      if (TypedArray !== attribute.array.constructor) {
        console.error('THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes.');
        return null;
      }
      if (itemSize === undefined) itemSize = attribute.itemSize;
      if (itemSize !== attribute.itemSize) {
        console.error('THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes.');
        return null;
      }
      if (normalized === undefined) normalized = attribute.normalized;
      if (normalized !== attribute.normalized) {
        console.error('THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes.');
        return null;
      }
      if (gpuType === -1) gpuType = attribute.gpuType;
      if (gpuType !== attribute.gpuType) {
        console.error('THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.gpuType must be consistent across matching attributes.');
        return null;
      }
      arrayLength += attribute.count * itemSize;
    }
    var array = new TypedArray(arrayLength);
    var result = new (_$$_REQUIRE(_dependencyMap[0], "three").BufferAttribute)(array, itemSize, normalized);
    var offset = 0;
    for (var _i3 = 0; _i3 < attributes.length; ++_i3) {
      var _attribute = attributes[_i3];
      if (_attribute.isInterleavedBufferAttribute) {
        var tupleOffset = offset / itemSize;
        for (var j = 0, l = _attribute.count; j < l; j++) {
          for (var c = 0; c < itemSize; c++) {
            var value = _attribute.getComponent(j, c);
            result.setComponent(j + tupleOffset, c, value);
          }
        }
      } else {
        array.set(_attribute.array, offset);
      }
      offset += _attribute.count * itemSize;
    }
    if (gpuType !== undefined) {
      result.gpuType = gpuType;
    }
    return result;
  }

  /**
   * @param {BufferAttribute} attribute
   * @return {BufferAttribute}
   */
  function deepCloneAttribute(attribute) {
    if (attribute.isInstancedInterleavedBufferAttribute || attribute.isInterleavedBufferAttribute) {
      return deinterleaveAttribute(attribute);
    }
    if (attribute.isInstancedBufferAttribute) {
      return new (_$$_REQUIRE(_dependencyMap[0], "three").InstancedBufferAttribute)().copy(attribute);
    }
    return new (_$$_REQUIRE(_dependencyMap[0], "three").BufferAttribute)().copy(attribute);
  }

  /**
   * @param {Array<BufferAttribute>} attributes
   * @return {Array<InterleavedBufferAttribute>}
   */
  function interleaveAttributes(attributes) {
    // Interleaves the provided attributes into an InterleavedBuffer and returns
    // a set of InterleavedBufferAttributes for each attribute
    var TypedArray;
    var arrayLength = 0;
    var stride = 0;

    // calculate the length and type of the interleavedBuffer
    for (var i = 0, l = attributes.length; i < l; ++i) {
      var attribute = attributes[i];
      if (TypedArray === undefined) TypedArray = attribute.array.constructor;
      if (TypedArray !== attribute.array.constructor) {
        console.error('AttributeBuffers of different types cannot be interleaved');
        return null;
      }
      arrayLength += attribute.array.length;
      stride += attribute.itemSize;
    }

    // Create the set of buffer attributes
    var interleavedBuffer = new (_$$_REQUIRE(_dependencyMap[0], "three").InterleavedBuffer)(new TypedArray(arrayLength), stride);
    var offset = 0;
    var res = [];
    var getters = ['getX', 'getY', 'getZ', 'getW'];
    var setters = ['setX', 'setY', 'setZ', 'setW'];
    for (var j = 0, _l = attributes.length; j < _l; j++) {
      var _attribute2 = attributes[j];
      var itemSize = _attribute2.itemSize;
      var count = _attribute2.count;
      var iba = new (_$$_REQUIRE(_dependencyMap[0], "three").InterleavedBufferAttribute)(interleavedBuffer, itemSize, offset, _attribute2.normalized);
      res.push(iba);
      offset += itemSize;

      // Move the data for each attribute into the new interleavedBuffer
      // at the appropriate offset
      for (var c = 0; c < count; c++) {
        for (var k = 0; k < itemSize; k++) {
          iba[setters[k]](c, _attribute2[getters[k]](c));
        }
      }
    }
    return res;
  }

  // returns a new, non-interleaved version of the provided attribute
  function deinterleaveAttribute(attribute) {
    var cons = attribute.data.array.constructor;
    var count = attribute.count;
    var itemSize = attribute.itemSize;
    var normalized = attribute.normalized;
    var array = new cons(count * itemSize);
    var newAttribute;
    if (attribute.isInstancedInterleavedBufferAttribute) {
      newAttribute = new (_$$_REQUIRE(_dependencyMap[0], "three").InstancedBufferAttribute)(array, itemSize, normalized, attribute.meshPerAttribute);
    } else {
      newAttribute = new (_$$_REQUIRE(_dependencyMap[0], "three").BufferAttribute)(array, itemSize, normalized);
    }
    for (var i = 0; i < count; i++) {
      newAttribute.setX(i, attribute.getX(i));
      if (itemSize >= 2) {
        newAttribute.setY(i, attribute.getY(i));
      }
      if (itemSize >= 3) {
        newAttribute.setZ(i, attribute.getZ(i));
      }
      if (itemSize >= 4) {
        newAttribute.setW(i, attribute.getW(i));
      }
    }
    return newAttribute;
  }

  // deinterleaves all attributes on the geometry
  function deinterleaveGeometry(geometry) {
    var attributes = geometry.attributes;
    var morphTargets = geometry.morphTargets;
    var attrMap = new Map();
    for (var key in attributes) {
      var attr = attributes[key];
      if (attr.isInterleavedBufferAttribute) {
        if (!attrMap.has(attr)) {
          attrMap.set(attr, deinterleaveAttribute(attr));
        }
        attributes[key] = attrMap.get(attr);
      }
    }
    for (var _key in morphTargets) {
      var _attr = morphTargets[_key];
      if (_attr.isInterleavedBufferAttribute) {
        if (!attrMap.has(_attr)) {
          attrMap.set(_attr, deinterleaveAttribute(_attr));
        }
        morphTargets[_key] = attrMap.get(_attr);
      }
    }
  }

  /**
   * @param {BufferGeometry} geometry
   * @return {number}
   */
  function estimateBytesUsed(geometry) {
    // Return the estimated memory used by this geometry in bytes
    // Calculate using itemSize, count, and BYTES_PER_ELEMENT to account
    // for InterleavedBufferAttributes.
    var mem = 0;
    for (var name in geometry.attributes) {
      var attr = geometry.getAttribute(name);
      mem += attr.count * attr.itemSize * attr.array.BYTES_PER_ELEMENT;
    }
    var indices = geometry.getIndex();
    mem += indices ? indices.count * indices.itemSize * indices.array.BYTES_PER_ELEMENT : 0;
    return mem;
  }

  /**
   * @param {BufferGeometry} geometry
   * @param {number} tolerance
   * @return {BufferGeometry}
   */
  function mergeVertices(geometry) {
    var tolerance = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1e-4;
    tolerance = Math.max(tolerance, Number.EPSILON);

    // Generate an index buffer if the geometry doesn't have one, or optimize it
    // if it's already available.
    var hashToIndex = {};
    var indices = geometry.getIndex();
    var positions = geometry.getAttribute('position');
    var vertexCount = indices ? indices.count : positions.count;

    // next value for triangle indices
    var nextIndex = 0;

    // attributes and new attribute arrays
    var attributeNames = Object.keys(geometry.attributes);
    var tmpAttributes = {};
    var tmpMorphAttributes = {};
    var newIndices = [];
    var getters = ['getX', 'getY', 'getZ', 'getW'];
    var setters = ['setX', 'setY', 'setZ', 'setW'];

    // Initialize the arrays, allocating space conservatively. Extra
    // space will be trimmed in the last step.
    var _loop = function _loop() {
      var name = attributeNames[i];
      var attr = geometry.attributes[name];
      tmpAttributes[name] = new attr.constructor(new attr.array.constructor(attr.count * attr.itemSize), attr.itemSize, attr.normalized);
      var morphAttributes = geometry.morphAttributes[name];
      if (morphAttributes) {
        if (!tmpMorphAttributes[name]) tmpMorphAttributes[name] = [];
        morphAttributes.forEach(function (morphAttr, i) {
          var array = new morphAttr.array.constructor(morphAttr.count * morphAttr.itemSize);
          tmpMorphAttributes[name][i] = new morphAttr.constructor(array, morphAttr.itemSize, morphAttr.normalized);
        });
      }
    };
    for (var i = 0, l = attributeNames.length; i < l; i++) {
      _loop();
    }

    // convert the error tolerance to an amount of decimal places to truncate to
    var halfTolerance = tolerance * 0.5;
    var exponent = Math.log10(1 / tolerance);
    var hashMultiplier = Math.pow(10, exponent);
    var hashAdditive = halfTolerance * hashMultiplier;
    for (var _i4 = 0; _i4 < vertexCount; _i4++) {
      var index = indices ? indices.getX(_i4) : _i4;

      // Generate a hash for the vertex attributes at the current index 'i'
      var hash = '';
      for (var j = 0, _l2 = attributeNames.length; j < _l2; j++) {
        var name = attributeNames[j];
        var attribute = geometry.getAttribute(name);
        var itemSize = attribute.itemSize;
        for (var k = 0; k < itemSize; k++) {
          // double tilde truncates the decimal value
          hash += `${~~(attribute[getters[k]](index) * hashMultiplier + hashAdditive)},`;
        }
      }

      // Add another reference to the vertex if it's already
      // used by another index
      if (hash in hashToIndex) {
        newIndices.push(hashToIndex[hash]);
      } else {
        // copy data to the new index in the temporary attributes
        for (var _j2 = 0, _l3 = attributeNames.length; _j2 < _l3; _j2++) {
          var _name4 = attributeNames[_j2];
          var _attribute3 = geometry.getAttribute(_name4);
          var morphAttributes = geometry.morphAttributes[_name4];
          var _itemSize = _attribute3.itemSize;
          var newArray = tmpAttributes[_name4];
          var newMorphArrays = tmpMorphAttributes[_name4];
          for (var _k = 0; _k < _itemSize; _k++) {
            var getterFunc = getters[_k];
            var setterFunc = setters[_k];
            newArray[setterFunc](nextIndex, _attribute3[getterFunc](index));
            if (morphAttributes) {
              for (var m = 0, ml = morphAttributes.length; m < ml; m++) {
                newMorphArrays[m][setterFunc](nextIndex, morphAttributes[m][getterFunc](index));
              }
            }
          }
        }
        hashToIndex[hash] = nextIndex;
        newIndices.push(nextIndex);
        nextIndex++;
      }
    }

    // generate result BufferGeometry
    var result = geometry.clone();
    for (var _name5 in geometry.attributes) {
      var tmpAttribute = tmpAttributes[_name5];
      result.setAttribute(_name5, new tmpAttribute.constructor(tmpAttribute.array.slice(0, nextIndex * tmpAttribute.itemSize), tmpAttribute.itemSize, tmpAttribute.normalized));
      if (!(_name5 in tmpMorphAttributes)) continue;
      for (var _j3 = 0; _j3 < tmpMorphAttributes[_name5].length; _j3++) {
        var tmpMorphAttribute = tmpMorphAttributes[_name5][_j3];
        result.morphAttributes[_name5][_j3] = new tmpMorphAttribute.constructor(tmpMorphAttribute.array.slice(0, nextIndex * tmpMorphAttribute.itemSize), tmpMorphAttribute.itemSize, tmpMorphAttribute.normalized);
      }
    }

    // indices

    result.setIndex(newIndices);
    return result;
  }

  /**
   * @param {BufferGeometry} geometry
   * @param {number} drawMode
   * @return {BufferGeometry}
   */
  function toTrianglesDrawMode(geometry, drawMode) {
    if (drawMode === _$$_REQUIRE(_dependencyMap[0], "three").TrianglesDrawMode) {
      console.warn('THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles.');
      return geometry;
    }
    if (drawMode === _$$_REQUIRE(_dependencyMap[0], "three").TriangleFanDrawMode || drawMode === _$$_REQUIRE(_dependencyMap[0], "three").TriangleStripDrawMode) {
      var index = geometry.getIndex();

      // generate index if not present

      if (index === null) {
        var indices = [];
        var position = geometry.getAttribute('position');
        if (position !== undefined) {
          for (var i = 0; i < position.count; i++) {
            indices.push(i);
          }
          geometry.setIndex(indices);
          index = geometry.getIndex();
        } else {
          console.error('THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible.');
          return geometry;
        }
      }

      //

      var numberOfTriangles = index.count - 2;
      var newIndices = [];
      if (drawMode === _$$_REQUIRE(_dependencyMap[0], "three").TriangleFanDrawMode) {
        // gl.TRIANGLE_FAN

        for (var _i5 = 1; _i5 <= numberOfTriangles; _i5++) {
          newIndices.push(index.getX(0));
          newIndices.push(index.getX(_i5));
          newIndices.push(index.getX(_i5 + 1));
        }
      } else {
        // gl.TRIANGLE_STRIP

        for (var _i6 = 0; _i6 < numberOfTriangles; _i6++) {
          if (_i6 % 2 === 0) {
            newIndices.push(index.getX(_i6));
            newIndices.push(index.getX(_i6 + 1));
            newIndices.push(index.getX(_i6 + 2));
          } else {
            newIndices.push(index.getX(_i6 + 2));
            newIndices.push(index.getX(_i6 + 1));
            newIndices.push(index.getX(_i6));
          }
        }
      }
      if (newIndices.length / 3 !== numberOfTriangles) {
        console.error('THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.');
      }

      // build final geometry

      var newGeometry = geometry.clone();
      newGeometry.setIndex(newIndices);
      newGeometry.clearGroups();
      return newGeometry;
    } else {
      console.error('THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:', drawMode);
      return geometry;
    }
  }

  /**
   * Calculates the morphed attributes of a morphed/skinned BufferGeometry.
   * Helpful for Raytracing or Decals.
   * @param {Mesh | Line | Points} object An instance of Mesh, Line or Points.
   * @return {Object} An Object with original position/normal attributes and morphed ones.
   */
  function computeMorphedAttributes(object) {
    var _vA = new (_$$_REQUIRE(_dependencyMap[0], "three").Vector3)();
    var _vB = new (_$$_REQUIRE(_dependencyMap[0], "three").Vector3)();
    var _vC = new (_$$_REQUIRE(_dependencyMap[0], "three").Vector3)();
    var _tempA = new (_$$_REQUIRE(_dependencyMap[0], "three").Vector3)();
    var _tempB = new (_$$_REQUIRE(_dependencyMap[0], "three").Vector3)();
    var _tempC = new (_$$_REQUIRE(_dependencyMap[0], "three").Vector3)();
    var _morphA = new (_$$_REQUIRE(_dependencyMap[0], "three").Vector3)();
    var _morphB = new (_$$_REQUIRE(_dependencyMap[0], "three").Vector3)();
    var _morphC = new (_$$_REQUIRE(_dependencyMap[0], "three").Vector3)();
    function _calculateMorphedAttributeData(object, attribute, morphAttribute, morphTargetsRelative, a, b, c, modifiedAttributeArray) {
      _vA.fromBufferAttribute(attribute, a);
      _vB.fromBufferAttribute(attribute, b);
      _vC.fromBufferAttribute(attribute, c);
      var morphInfluences = object.morphTargetInfluences;
      if (morphAttribute && morphInfluences) {
        _morphA.set(0, 0, 0);
        _morphB.set(0, 0, 0);
        _morphC.set(0, 0, 0);
        for (var _i7 = 0, _il = morphAttribute.length; _i7 < _il; _i7++) {
          var influence = morphInfluences[_i7];
          var morph = morphAttribute[_i7];
          if (influence === 0) continue;
          _tempA.fromBufferAttribute(morph, a);
          _tempB.fromBufferAttribute(morph, b);
          _tempC.fromBufferAttribute(morph, c);
          if (morphTargetsRelative) {
            _morphA.addScaledVector(_tempA, influence);
            _morphB.addScaledVector(_tempB, influence);
            _morphC.addScaledVector(_tempC, influence);
          } else {
            _morphA.addScaledVector(_tempA.sub(_vA), influence);
            _morphB.addScaledVector(_tempB.sub(_vB), influence);
            _morphC.addScaledVector(_tempC.sub(_vC), influence);
          }
        }
        _vA.add(_morphA);
        _vB.add(_morphB);
        _vC.add(_morphC);
      }
      if (object.isSkinnedMesh) {
        object.applyBoneTransform(a, _vA);
        object.applyBoneTransform(b, _vB);
        object.applyBoneTransform(c, _vC);
      }
      modifiedAttributeArray[a * 3 + 0] = _vA.x;
      modifiedAttributeArray[a * 3 + 1] = _vA.y;
      modifiedAttributeArray[a * 3 + 2] = _vA.z;
      modifiedAttributeArray[b * 3 + 0] = _vB.x;
      modifiedAttributeArray[b * 3 + 1] = _vB.y;
      modifiedAttributeArray[b * 3 + 2] = _vB.z;
      modifiedAttributeArray[c * 3 + 0] = _vC.x;
      modifiedAttributeArray[c * 3 + 1] = _vC.y;
      modifiedAttributeArray[c * 3 + 2] = _vC.z;
    }
    var geometry = object.geometry;
    var material = object.material;
    var a, b, c;
    var index = geometry.index;
    var positionAttribute = geometry.attributes.position;
    var morphPosition = geometry.morphAttributes.position;
    var morphTargetsRelative = geometry.morphTargetsRelative;
    var normalAttribute = geometry.attributes.normal;
    var morphNormal = geometry.morphAttributes.position;
    var groups = geometry.groups;
    var drawRange = geometry.drawRange;
    var i, j, il, jl;
    var group;
    var start, end;
    var modifiedPosition = new Float32Array(positionAttribute.count * positionAttribute.itemSize);
    var modifiedNormal = new Float32Array(normalAttribute.count * normalAttribute.itemSize);
    if (index !== null) {
      // indexed buffer geometry

      if (Array.isArray(material)) {
        for (i = 0, il = groups.length; i < il; i++) {
          group = groups[i];
          start = Math.max(group.start, drawRange.start);
          end = Math.min(group.start + group.count, drawRange.start + drawRange.count);
          for (j = start, jl = end; j < jl; j += 3) {
            a = index.getX(j);
            b = index.getX(j + 1);
            c = index.getX(j + 2);
            _calculateMorphedAttributeData(object, positionAttribute, morphPosition, morphTargetsRelative, a, b, c, modifiedPosition);
            _calculateMorphedAttributeData(object, normalAttribute, morphNormal, morphTargetsRelative, a, b, c, modifiedNormal);
          }
        }
      } else {
        start = Math.max(0, drawRange.start);
        end = Math.min(index.count, drawRange.start + drawRange.count);
        for (i = start, il = end; i < il; i += 3) {
          a = index.getX(i);
          b = index.getX(i + 1);
          c = index.getX(i + 2);
          _calculateMorphedAttributeData(object, positionAttribute, morphPosition, morphTargetsRelative, a, b, c, modifiedPosition);
          _calculateMorphedAttributeData(object, normalAttribute, morphNormal, morphTargetsRelative, a, b, c, modifiedNormal);
        }
      }
    } else {
      // non-indexed buffer geometry

      if (Array.isArray(material)) {
        for (i = 0, il = groups.length; i < il; i++) {
          group = groups[i];
          start = Math.max(group.start, drawRange.start);
          end = Math.min(group.start + group.count, drawRange.start + drawRange.count);
          for (j = start, jl = end; j < jl; j += 3) {
            a = j;
            b = j + 1;
            c = j + 2;
            _calculateMorphedAttributeData(object, positionAttribute, morphPosition, morphTargetsRelative, a, b, c, modifiedPosition);
            _calculateMorphedAttributeData(object, normalAttribute, morphNormal, morphTargetsRelative, a, b, c, modifiedNormal);
          }
        }
      } else {
        start = Math.max(0, drawRange.start);
        end = Math.min(positionAttribute.count, drawRange.start + drawRange.count);
        for (i = start, il = end; i < il; i += 3) {
          a = i;
          b = i + 1;
          c = i + 2;
          _calculateMorphedAttributeData(object, positionAttribute, morphPosition, morphTargetsRelative, a, b, c, modifiedPosition);
          _calculateMorphedAttributeData(object, normalAttribute, morphNormal, morphTargetsRelative, a, b, c, modifiedNormal);
        }
      }
    }
    var morphedPositionAttribute = new (_$$_REQUIRE(_dependencyMap[0], "three").Float32BufferAttribute)(modifiedPosition, 3);
    var morphedNormalAttribute = new (_$$_REQUIRE(_dependencyMap[0], "three").Float32BufferAttribute)(modifiedNormal, 3);
    return {
      positionAttribute: positionAttribute,
      normalAttribute: normalAttribute,
      morphedPositionAttribute: morphedPositionAttribute,
      morphedNormalAttribute: morphedNormalAttribute
    };
  }
  function mergeGroups(geometry) {
    if (geometry.groups.length === 0) {
      console.warn('THREE.BufferGeometryUtils.mergeGroups(): No groups are defined. Nothing to merge.');
      return geometry;
    }
    var groups = geometry.groups;

    // sort groups by material index

    groups = groups.sort(function (a, b) {
      if (a.materialIndex !== b.materialIndex) return a.materialIndex - b.materialIndex;
      return a.start - b.start;
    });

    // create index for non-indexed geometries

    if (geometry.getIndex() === null) {
      var positionAttribute = geometry.getAttribute('position');
      var indices = [];
      for (var i = 0; i < positionAttribute.count; i += 3) {
        indices.push(i, i + 1, i + 2);
      }
      geometry.setIndex(indices);
    }

    // sort index

    var index = geometry.getIndex();
    var newIndices = [];
    for (var _i8 = 0; _i8 < groups.length; _i8++) {
      var group = groups[_i8];
      var groupStart = group.start;
      var groupLength = groupStart + group.count;
      for (var j = groupStart; j < groupLength; j++) {
        newIndices.push(index.getX(j));
      }
    }
    geometry.dispose(); // Required to force buffer recreation
    geometry.setIndex(newIndices);

    // update groups indices

    var start = 0;
    for (var _i9 = 0; _i9 < groups.length; _i9++) {
      var _group = groups[_i9];
      _group.start = start;
      start += _group.count;
    }

    // merge groups

    var currentGroup = groups[0];
    geometry.groups = [currentGroup];
    for (var _i10 = 1; _i10 < groups.length; _i10++) {
      var _group2 = groups[_i10];
      if (currentGroup.materialIndex === _group2.materialIndex) {
        currentGroup.count += _group2.count;
      } else {
        currentGroup = _group2;
        geometry.groups.push(currentGroup);
      }
    }
    return geometry;
  }

  /**
   * Modifies the supplied geometry if it is non-indexed, otherwise creates a new,
   * non-indexed geometry. Returns the geometry with smooth normals everywhere except
   * faces that meet at an angle greater than the crease angle.
   *
   * @param {BufferGeometry} geometry
   * @param {number} [creaseAngle]
   * @return {BufferGeometry}
   */
  function toCreasedNormals(geometry) {
    var creaseAngle = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Math.PI / 3;
    var creaseDot = Math.cos(creaseAngle);
    var hashMultiplier = (1 + 1e-10) * 1e2;

    // reusable vectors
    var verts = [new (_$$_REQUIRE(_dependencyMap[0], "three").Vector3)(), new (_$$_REQUIRE(_dependencyMap[0], "three").Vector3)(), new (_$$_REQUIRE(_dependencyMap[0], "three").Vector3)()];
    var tempVec1 = new (_$$_REQUIRE(_dependencyMap[0], "three").Vector3)();
    var tempVec2 = new (_$$_REQUIRE(_dependencyMap[0], "three").Vector3)();
    var tempNorm = new (_$$_REQUIRE(_dependencyMap[0], "three").Vector3)();
    var tempNorm2 = new (_$$_REQUIRE(_dependencyMap[0], "three").Vector3)();

    // hashes a vector
    function hashVertex(v) {
      var x = ~~(v.x * hashMultiplier);
      var y = ~~(v.y * hashMultiplier);
      var z = ~~(v.z * hashMultiplier);
      return `${x},${y},${z}`;
    }

    // BufferGeometry.toNonIndexed() warns if the geometry is non-indexed
    // and returns the original geometry
    var resultGeometry = geometry.index ? geometry.toNonIndexed() : geometry;
    var posAttr = resultGeometry.attributes.position;
    var vertexMap = {};

    // find all the normals shared by commonly located vertices
    for (var i = 0, l = posAttr.count / 3; i < l; i++) {
      var i3 = 3 * i;
      var a = verts[0].fromBufferAttribute(posAttr, i3 + 0);
      var b = verts[1].fromBufferAttribute(posAttr, i3 + 1);
      var c = verts[2].fromBufferAttribute(posAttr, i3 + 2);
      tempVec1.subVectors(c, b);
      tempVec2.subVectors(a, b);

      // add the normal to the map for all vertices
      var normal = new (_$$_REQUIRE(_dependencyMap[0], "three").Vector3)().crossVectors(tempVec1, tempVec2).normalize();
      for (var n = 0; n < 3; n++) {
        var vert = verts[n];
        var hash = hashVertex(vert);
        if (!(hash in vertexMap)) {
          vertexMap[hash] = [];
        }
        vertexMap[hash].push(normal);
      }
    }

    // average normals from all vertices that share a common location if they are within the
    // provided crease threshold
    var normalArray = new Float32Array(posAttr.count * 3);
    var normAttr = new (_$$_REQUIRE(_dependencyMap[0], "three").BufferAttribute)(normalArray, 3, false);
    for (var _i11 = 0, _l4 = posAttr.count / 3; _i11 < _l4; _i11++) {
      // get the face normal for this vertex
      var _i12 = 3 * _i11;
      var _a = verts[0].fromBufferAttribute(posAttr, _i12 + 0);
      var _b = verts[1].fromBufferAttribute(posAttr, _i12 + 1);
      var _c = verts[2].fromBufferAttribute(posAttr, _i12 + 2);
      tempVec1.subVectors(_c, _b);
      tempVec2.subVectors(_a, _b);
      tempNorm.crossVectors(tempVec1, tempVec2).normalize();

      // average all normals that meet the threshold and set the normal value
      for (var _n = 0; _n < 3; _n++) {
        var _vert = verts[_n];
        var _hash = hashVertex(_vert);
        var otherNormals = vertexMap[_hash];
        tempNorm2.set(0, 0, 0);
        for (var k = 0, lk = otherNormals.length; k < lk; k++) {
          var otherNorm = otherNormals[k];
          if (tempNorm.dot(otherNorm) > creaseDot) {
            tempNorm2.add(otherNorm);
          }
        }
        tempNorm2.normalize();
        normAttr.setXYZ(_i12 + _n, tempNorm2.x, tempNorm2.y, tempNorm2.z);
      }
    }
    resultGeometry.setAttribute('normal', normAttr);
    return resultGeometry;
  }
},1,[2],"../../node_modules/three/examples/jsm/utils/BufferGeometryUtils.js");
global.__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  Object.defineProperty(exports, "ACESFilmicToneMapping", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").ACESFilmicToneMapping;
    }
  });
  exports.AONode = void 0;
  Object.defineProperty(exports, "AddEquation", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").AddEquation;
    }
  });
  Object.defineProperty(exports, "AddOperation", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").AddOperation;
    }
  });
  Object.defineProperty(exports, "AdditiveAnimationBlendMode", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").AdditiveAnimationBlendMode;
    }
  });
  Object.defineProperty(exports, "AdditiveBlending", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").AdditiveBlending;
    }
  });
  Object.defineProperty(exports, "AgXToneMapping", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").AgXToneMapping;
    }
  });
  Object.defineProperty(exports, "AlphaFormat", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").AlphaFormat;
    }
  });
  Object.defineProperty(exports, "AlwaysCompare", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").AlwaysCompare;
    }
  });
  Object.defineProperty(exports, "AlwaysDepth", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").AlwaysDepth;
    }
  });
  Object.defineProperty(exports, "AlwaysStencilFunc", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").AlwaysStencilFunc;
    }
  });
  Object.defineProperty(exports, "AmbientLight", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").AmbientLight;
    }
  });
  exports.AnalyticLightNode = exports.AmbientLightNode = void 0;
  Object.defineProperty(exports, "AnimationAction", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").AnimationAction;
    }
  });
  Object.defineProperty(exports, "AnimationClip", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").AnimationClip;
    }
  });
  Object.defineProperty(exports, "AnimationLoader", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").AnimationLoader;
    }
  });
  Object.defineProperty(exports, "AnimationMixer", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").AnimationMixer;
    }
  });
  Object.defineProperty(exports, "AnimationObjectGroup", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").AnimationObjectGroup;
    }
  });
  Object.defineProperty(exports, "AnimationUtils", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").AnimationUtils;
    }
  });
  Object.defineProperty(exports, "ArcCurve", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").ArcCurve;
    }
  });
  Object.defineProperty(exports, "ArrayCamera", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").ArrayCamera;
    }
  });
  exports.ArrayElementNode = void 0;
  Object.defineProperty(exports, "ArrowHelper", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").ArrowHelper;
    }
  });
  exports.AssignNode = void 0;
  Object.defineProperty(exports, "AttachedBindMode", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").AttachedBindMode;
    }
  });
  exports.AttributeNode = void 0;
  Object.defineProperty(exports, "Audio", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").Audio;
    }
  });
  Object.defineProperty(exports, "AudioAnalyser", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").AudioAnalyser;
    }
  });
  Object.defineProperty(exports, "AudioContext", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").AudioContext;
    }
  });
  Object.defineProperty(exports, "AudioListener", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").AudioListener;
    }
  });
  Object.defineProperty(exports, "AudioLoader", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").AudioLoader;
    }
  });
  Object.defineProperty(exports, "AxesHelper", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").AxesHelper;
    }
  });
  Object.defineProperty(exports, "BackSide", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").BackSide;
    }
  });
  Object.defineProperty(exports, "BasicDepthPacking", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").BasicDepthPacking;
    }
  });
  exports.BasicEnvironmentNode = void 0;
  Object.defineProperty(exports, "BasicShadowMap", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").BasicShadowMap;
    }
  });
  exports.BatchNode = void 0;
  Object.defineProperty(exports, "BatchedMesh", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").BatchedMesh;
    }
  });
  Object.defineProperty(exports, "Bone", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").Bone;
    }
  });
  Object.defineProperty(exports, "BooleanKeyframeTrack", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").BooleanKeyframeTrack;
    }
  });
  Object.defineProperty(exports, "Box2", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").Box2;
    }
  });
  Object.defineProperty(exports, "Box3", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").Box3;
    }
  });
  Object.defineProperty(exports, "Box3Helper", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").Box3Helper;
    }
  });
  Object.defineProperty(exports, "BoxGeometry", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").BoxGeometry;
    }
  });
  Object.defineProperty(exports, "BoxHelper", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").BoxHelper;
    }
  });
  Object.defineProperty(exports, "BufferAttribute", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").BufferAttribute;
    }
  });
  exports.BufferAttributeNode = void 0;
  Object.defineProperty(exports, "BufferGeometry", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").BufferGeometry;
    }
  });
  Object.defineProperty(exports, "BufferGeometryLoader", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").BufferGeometryLoader;
    }
  });
  exports.BypassNode = exports.BundleGroup = exports.BumpMapNode = exports.BufferNode = void 0;
  Object.defineProperty(exports, "ByteType", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").ByteType;
    }
  });
  Object.defineProperty(exports, "Cache", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").Cache;
    }
  });
  exports.CacheNode = void 0;
  Object.defineProperty(exports, "Camera", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").Camera;
    }
  });
  Object.defineProperty(exports, "CameraHelper", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").CameraHelper;
    }
  });
  Object.defineProperty(exports, "CanvasTexture", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").CanvasTexture;
    }
  });
  Object.defineProperty(exports, "CapsuleGeometry", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").CapsuleGeometry;
    }
  });
  Object.defineProperty(exports, "CatmullRomCurve3", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").CatmullRomCurve3;
    }
  });
  Object.defineProperty(exports, "CineonToneMapping", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").CineonToneMapping;
    }
  });
  Object.defineProperty(exports, "CircleGeometry", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").CircleGeometry;
    }
  });
  Object.defineProperty(exports, "ClampToEdgeWrapping", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").ClampToEdgeWrapping;
    }
  });
  exports.ClippingGroup = void 0;
  Object.defineProperty(exports, "Clock", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").Clock;
    }
  });
  exports.CodeNode = void 0;
  Object.defineProperty(exports, "Color", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").Color;
    }
  });
  Object.defineProperty(exports, "ColorKeyframeTrack", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").ColorKeyframeTrack;
    }
  });
  Object.defineProperty(exports, "ColorManagement", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").ColorManagement;
    }
  });
  exports.ColorSpaceNode = void 0;
  Object.defineProperty(exports, "CompressedArrayTexture", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").CompressedArrayTexture;
    }
  });
  Object.defineProperty(exports, "CompressedCubeTexture", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").CompressedCubeTexture;
    }
  });
  Object.defineProperty(exports, "CompressedTexture", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").CompressedTexture;
    }
  });
  Object.defineProperty(exports, "CompressedTextureLoader", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").CompressedTextureLoader;
    }
  });
  exports.ComputeNode = void 0;
  Object.defineProperty(exports, "ConeGeometry", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").ConeGeometry;
    }
  });
  exports.ConstNode = void 0;
  Object.defineProperty(exports, "ConstantAlphaFactor", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").ConstantAlphaFactor;
    }
  });
  Object.defineProperty(exports, "ConstantColorFactor", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").ConstantColorFactor;
    }
  });
  exports.ContextNode = void 0;
  Object.defineProperty(exports, "Controls", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").Controls;
    }
  });
  exports.ConvertNode = void 0;
  Object.defineProperty(exports, "CubeCamera", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").CubeCamera;
    }
  });
  Object.defineProperty(exports, "CubeReflectionMapping", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").CubeReflectionMapping;
    }
  });
  Object.defineProperty(exports, "CubeRefractionMapping", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").CubeRefractionMapping;
    }
  });
  Object.defineProperty(exports, "CubeTexture", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").CubeTexture;
    }
  });
  Object.defineProperty(exports, "CubeTextureLoader", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").CubeTextureLoader;
    }
  });
  exports.CubeTextureNode = void 0;
  Object.defineProperty(exports, "CubeUVReflectionMapping", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").CubeUVReflectionMapping;
    }
  });
  Object.defineProperty(exports, "CubicBezierCurve", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").CubicBezierCurve;
    }
  });
  Object.defineProperty(exports, "CubicBezierCurve3", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").CubicBezierCurve3;
    }
  });
  Object.defineProperty(exports, "CubicInterpolant", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").CubicInterpolant;
    }
  });
  Object.defineProperty(exports, "CullFaceBack", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").CullFaceBack;
    }
  });
  Object.defineProperty(exports, "CullFaceFront", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").CullFaceFront;
    }
  });
  Object.defineProperty(exports, "CullFaceFrontBack", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").CullFaceFrontBack;
    }
  });
  Object.defineProperty(exports, "CullFaceNone", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").CullFaceNone;
    }
  });
  Object.defineProperty(exports, "Curve", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").Curve;
    }
  });
  Object.defineProperty(exports, "CurvePath", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").CurvePath;
    }
  });
  Object.defineProperty(exports, "CustomBlending", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").CustomBlending;
    }
  });
  Object.defineProperty(exports, "CustomToneMapping", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").CustomToneMapping;
    }
  });
  Object.defineProperty(exports, "CylinderGeometry", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").CylinderGeometry;
    }
  });
  Object.defineProperty(exports, "Cylindrical", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").Cylindrical;
    }
  });
  Object.defineProperty(exports, "Data3DTexture", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").Data3DTexture;
    }
  });
  Object.defineProperty(exports, "DataArrayTexture", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").DataArrayTexture;
    }
  });
  Object.defineProperty(exports, "DataTexture", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").DataTexture;
    }
  });
  Object.defineProperty(exports, "DataTextureLoader", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").DataTextureLoader;
    }
  });
  Object.defineProperty(exports, "DataUtils", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").DataUtils;
    }
  });
  Object.defineProperty(exports, "DecrementStencilOp", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").DecrementStencilOp;
    }
  });
  Object.defineProperty(exports, "DecrementWrapStencilOp", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").DecrementWrapStencilOp;
    }
  });
  Object.defineProperty(exports, "DefaultLoadingManager", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").DefaultLoadingManager;
    }
  });
  Object.defineProperty(exports, "DepthFormat", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").DepthFormat;
    }
  });
  Object.defineProperty(exports, "DepthStencilFormat", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").DepthStencilFormat;
    }
  });
  Object.defineProperty(exports, "DepthTexture", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").DepthTexture;
    }
  });
  Object.defineProperty(exports, "DetachedBindMode", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").DetachedBindMode;
    }
  });
  Object.defineProperty(exports, "DirectionalLight", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").DirectionalLight;
    }
  });
  Object.defineProperty(exports, "DirectionalLightHelper", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").DirectionalLightHelper;
    }
  });
  exports.DirectionalLightNode = void 0;
  Object.defineProperty(exports, "DiscreteInterpolant", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").DiscreteInterpolant;
    }
  });
  Object.defineProperty(exports, "DodecahedronGeometry", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").DodecahedronGeometry;
    }
  });
  Object.defineProperty(exports, "DoubleSide", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").DoubleSide;
    }
  });
  Object.defineProperty(exports, "DstAlphaFactor", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").DstAlphaFactor;
    }
  });
  Object.defineProperty(exports, "DstColorFactor", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").DstColorFactor;
    }
  });
  Object.defineProperty(exports, "DynamicCopyUsage", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").DynamicCopyUsage;
    }
  });
  Object.defineProperty(exports, "DynamicDrawUsage", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").DynamicDrawUsage;
    }
  });
  Object.defineProperty(exports, "DynamicReadUsage", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").DynamicReadUsage;
    }
  });
  Object.defineProperty(exports, "EdgesGeometry", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").EdgesGeometry;
    }
  });
  Object.defineProperty(exports, "EllipseCurve", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").EllipseCurve;
    }
  });
  exports.EnvironmentNode = void 0;
  Object.defineProperty(exports, "EqualCompare", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").EqualCompare;
    }
  });
  Object.defineProperty(exports, "EqualDepth", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").EqualDepth;
    }
  });
  Object.defineProperty(exports, "EqualStencilFunc", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").EqualStencilFunc;
    }
  });
  exports.EquirectUVNode = void 0;
  Object.defineProperty(exports, "EquirectangularReflectionMapping", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").EquirectangularReflectionMapping;
    }
  });
  Object.defineProperty(exports, "EquirectangularRefractionMapping", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").EquirectangularRefractionMapping;
    }
  });
  Object.defineProperty(exports, "Euler", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").Euler;
    }
  });
  Object.defineProperty(exports, "EventDispatcher", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").EventDispatcher;
    }
  });
  exports.ExpressionNode = void 0;
  Object.defineProperty(exports, "ExtrudeGeometry", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").ExtrudeGeometry;
    }
  });
  Object.defineProperty(exports, "FileLoader", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").FileLoader;
    }
  });
  Object.defineProperty(exports, "Float16BufferAttribute", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").Float16BufferAttribute;
    }
  });
  Object.defineProperty(exports, "Float32BufferAttribute", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").Float32BufferAttribute;
    }
  });
  Object.defineProperty(exports, "FloatType", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").FloatType;
    }
  });
  Object.defineProperty(exports, "Fog", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").Fog;
    }
  });
  Object.defineProperty(exports, "FogExp2", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").FogExp2;
    }
  });
  Object.defineProperty(exports, "FramebufferTexture", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").FramebufferTexture;
    }
  });
  exports.FrontFacingNode = void 0;
  Object.defineProperty(exports, "FrontSide", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").FrontSide;
    }
  });
  Object.defineProperty(exports, "Frustum", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").Frustum;
    }
  });
  exports.FunctionOverloadingNode = exports.FunctionNode = exports.FunctionCallNode = void 0;
  Object.defineProperty(exports, "GLBufferAttribute", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").GLBufferAttribute;
    }
  });
  Object.defineProperty(exports, "GLSL1", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").GLSL1;
    }
  });
  Object.defineProperty(exports, "GLSL3", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").GLSL3;
    }
  });
  exports.GLSLNodeParser = void 0;
  Object.defineProperty(exports, "GreaterCompare", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").GreaterCompare;
    }
  });
  Object.defineProperty(exports, "GreaterDepth", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").GreaterDepth;
    }
  });
  Object.defineProperty(exports, "GreaterEqualCompare", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").GreaterEqualCompare;
    }
  });
  Object.defineProperty(exports, "GreaterEqualDepth", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").GreaterEqualDepth;
    }
  });
  Object.defineProperty(exports, "GreaterEqualStencilFunc", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").GreaterEqualStencilFunc;
    }
  });
  Object.defineProperty(exports, "GreaterStencilFunc", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").GreaterStencilFunc;
    }
  });
  Object.defineProperty(exports, "GridHelper", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").GridHelper;
    }
  });
  Object.defineProperty(exports, "Group", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").Group;
    }
  });
  Object.defineProperty(exports, "HalfFloatType", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").HalfFloatType;
    }
  });
  Object.defineProperty(exports, "HemisphereLight", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").HemisphereLight;
    }
  });
  Object.defineProperty(exports, "HemisphereLightHelper", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").HemisphereLightHelper;
    }
  });
  exports.IESSpotLightNode = exports.IESSpotLight = exports.HemisphereLightNode = void 0;
  Object.defineProperty(exports, "IcosahedronGeometry", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").IcosahedronGeometry;
    }
  });
  Object.defineProperty(exports, "ImageBitmapLoader", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").ImageBitmapLoader;
    }
  });
  Object.defineProperty(exports, "ImageLoader", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").ImageLoader;
    }
  });
  Object.defineProperty(exports, "ImageUtils", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").ImageUtils;
    }
  });
  Object.defineProperty(exports, "IncrementStencilOp", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").IncrementStencilOp;
    }
  });
  Object.defineProperty(exports, "IncrementWrapStencilOp", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").IncrementWrapStencilOp;
    }
  });
  exports.InstanceNode = exports.IndirectStorageBufferAttribute = exports.IndexNode = void 0;
  Object.defineProperty(exports, "InstancedBufferAttribute", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").InstancedBufferAttribute;
    }
  });
  Object.defineProperty(exports, "InstancedBufferGeometry", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").InstancedBufferGeometry;
    }
  });
  Object.defineProperty(exports, "InstancedInterleavedBuffer", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").InstancedInterleavedBuffer;
    }
  });
  Object.defineProperty(exports, "InstancedMesh", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").InstancedMesh;
    }
  });
  exports.InstancedPointsNodeMaterial = exports.InstancedMeshNode = void 0;
  Object.defineProperty(exports, "Int16BufferAttribute", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").Int16BufferAttribute;
    }
  });
  Object.defineProperty(exports, "Int32BufferAttribute", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").Int32BufferAttribute;
    }
  });
  Object.defineProperty(exports, "Int8BufferAttribute", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").Int8BufferAttribute;
    }
  });
  Object.defineProperty(exports, "IntType", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").IntType;
    }
  });
  Object.defineProperty(exports, "InterleavedBuffer", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").InterleavedBuffer;
    }
  });
  Object.defineProperty(exports, "InterleavedBufferAttribute", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").InterleavedBufferAttribute;
    }
  });
  Object.defineProperty(exports, "Interpolant", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").Interpolant;
    }
  });
  Object.defineProperty(exports, "InterpolateDiscrete", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").InterpolateDiscrete;
    }
  });
  Object.defineProperty(exports, "InterpolateLinear", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").InterpolateLinear;
    }
  });
  Object.defineProperty(exports, "InterpolateSmooth", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").InterpolateSmooth;
    }
  });
  Object.defineProperty(exports, "InvertStencilOp", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").InvertStencilOp;
    }
  });
  exports.JoinNode = exports.IrradianceNode = void 0;
  Object.defineProperty(exports, "KeepStencilOp", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").KeepStencilOp;
    }
  });
  Object.defineProperty(exports, "KeyframeTrack", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").KeyframeTrack;
    }
  });
  Object.defineProperty(exports, "LOD", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").LOD;
    }
  });
  Object.defineProperty(exports, "LatheGeometry", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").LatheGeometry;
    }
  });
  Object.defineProperty(exports, "Layers", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").Layers;
    }
  });
  Object.defineProperty(exports, "LessCompare", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").LessCompare;
    }
  });
  Object.defineProperty(exports, "LessDepth", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").LessDepth;
    }
  });
  Object.defineProperty(exports, "LessEqualCompare", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").LessEqualCompare;
    }
  });
  Object.defineProperty(exports, "LessEqualDepth", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").LessEqualDepth;
    }
  });
  Object.defineProperty(exports, "LessEqualStencilFunc", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").LessEqualStencilFunc;
    }
  });
  Object.defineProperty(exports, "LessStencilFunc", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").LessStencilFunc;
    }
  });
  Object.defineProperty(exports, "Light", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").Light;
    }
  });
  Object.defineProperty(exports, "LightProbe", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").LightProbe;
    }
  });
  exports.LightsNode = exports.LightingNode = exports.LightingModel = exports.LightingContextNode = exports.Lighting = exports.LightProbeNode = void 0;
  Object.defineProperty(exports, "Line", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").Line;
    }
  });
  exports.Line2NodeMaterial = void 0;
  Object.defineProperty(exports, "Line3", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").Line3;
    }
  });
  Object.defineProperty(exports, "LineBasicMaterial", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").LineBasicMaterial;
    }
  });
  exports.LineBasicNodeMaterial = void 0;
  Object.defineProperty(exports, "LineCurve", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").LineCurve;
    }
  });
  Object.defineProperty(exports, "LineCurve3", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").LineCurve3;
    }
  });
  Object.defineProperty(exports, "LineDashedMaterial", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").LineDashedMaterial;
    }
  });
  exports.LineDashedNodeMaterial = void 0;
  Object.defineProperty(exports, "LineLoop", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").LineLoop;
    }
  });
  Object.defineProperty(exports, "LineSegments", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").LineSegments;
    }
  });
  Object.defineProperty(exports, "LinearFilter", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").LinearFilter;
    }
  });
  Object.defineProperty(exports, "LinearInterpolant", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").LinearInterpolant;
    }
  });
  Object.defineProperty(exports, "LinearMipMapLinearFilter", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").LinearMipMapLinearFilter;
    }
  });
  Object.defineProperty(exports, "LinearMipMapNearestFilter", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").LinearMipMapNearestFilter;
    }
  });
  Object.defineProperty(exports, "LinearMipmapLinearFilter", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").LinearMipmapLinearFilter;
    }
  });
  Object.defineProperty(exports, "LinearMipmapNearestFilter", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").LinearMipmapNearestFilter;
    }
  });
  Object.defineProperty(exports, "LinearSRGBColorSpace", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").LinearSRGBColorSpace;
    }
  });
  Object.defineProperty(exports, "LinearToneMapping", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").LinearToneMapping;
    }
  });
  Object.defineProperty(exports, "LinearTransfer", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").LinearTransfer;
    }
  });
  Object.defineProperty(exports, "Loader", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").Loader;
    }
  });
  Object.defineProperty(exports, "LoaderUtils", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").LoaderUtils;
    }
  });
  Object.defineProperty(exports, "LoadingManager", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").LoadingManager;
    }
  });
  exports.LoopNode = void 0;
  Object.defineProperty(exports, "LoopOnce", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").LoopOnce;
    }
  });
  Object.defineProperty(exports, "LoopPingPong", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").LoopPingPong;
    }
  });
  Object.defineProperty(exports, "LoopRepeat", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").LoopRepeat;
    }
  });
  Object.defineProperty(exports, "LuminanceAlphaFormat", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").LuminanceAlphaFormat;
    }
  });
  Object.defineProperty(exports, "LuminanceFormat", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").LuminanceFormat;
    }
  });
  Object.defineProperty(exports, "MOUSE", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").MOUSE;
    }
  });
  exports.MatcapUVNode = exports.MRTNode = void 0;
  Object.defineProperty(exports, "Material", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").Material;
    }
  });
  Object.defineProperty(exports, "MaterialLoader", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").MaterialLoader;
    }
  });
  exports.MaterialReferenceNode = exports.MaterialNode = void 0;
  Object.defineProperty(exports, "MathUtils", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").MathUtils;
    }
  });
  Object.defineProperty(exports, "Matrix2", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").Matrix2;
    }
  });
  Object.defineProperty(exports, "Matrix3", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").Matrix3;
    }
  });
  Object.defineProperty(exports, "Matrix4", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").Matrix4;
    }
  });
  Object.defineProperty(exports, "MaxEquation", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").MaxEquation;
    }
  });
  exports.MaxMipLevelNode = void 0;
  Object.defineProperty(exports, "Mesh", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").Mesh;
    }
  });
  Object.defineProperty(exports, "MeshBasicMaterial", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").MeshBasicMaterial;
    }
  });
  exports.MeshBasicNodeMaterial = void 0;
  Object.defineProperty(exports, "MeshDepthMaterial", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").MeshDepthMaterial;
    }
  });
  Object.defineProperty(exports, "MeshDistanceMaterial", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").MeshDistanceMaterial;
    }
  });
  Object.defineProperty(exports, "MeshLambertMaterial", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").MeshLambertMaterial;
    }
  });
  exports.MeshLambertNodeMaterial = void 0;
  Object.defineProperty(exports, "MeshMatcapMaterial", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").MeshMatcapMaterial;
    }
  });
  exports.MeshMatcapNodeMaterial = void 0;
  Object.defineProperty(exports, "MeshNormalMaterial", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").MeshNormalMaterial;
    }
  });
  exports.MeshNormalNodeMaterial = void 0;
  Object.defineProperty(exports, "MeshPhongMaterial", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").MeshPhongMaterial;
    }
  });
  exports.MeshPhongNodeMaterial = void 0;
  Object.defineProperty(exports, "MeshPhysicalMaterial", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").MeshPhysicalMaterial;
    }
  });
  exports.MeshSSSNodeMaterial = exports.MeshPhysicalNodeMaterial = void 0;
  Object.defineProperty(exports, "MeshStandardMaterial", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").MeshStandardMaterial;
    }
  });
  exports.MeshStandardNodeMaterial = void 0;
  Object.defineProperty(exports, "MeshToonMaterial", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").MeshToonMaterial;
    }
  });
  exports.MeshToonNodeMaterial = void 0;
  Object.defineProperty(exports, "MinEquation", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").MinEquation;
    }
  });
  Object.defineProperty(exports, "MirroredRepeatWrapping", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").MirroredRepeatWrapping;
    }
  });
  Object.defineProperty(exports, "MixOperation", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").MixOperation;
    }
  });
  exports.MorphNode = exports.ModelNode = void 0;
  Object.defineProperty(exports, "MultiplyBlending", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").MultiplyBlending;
    }
  });
  Object.defineProperty(exports, "MultiplyOperation", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").MultiplyOperation;
    }
  });
  Object.defineProperty(exports, "NearestFilter", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").NearestFilter;
    }
  });
  Object.defineProperty(exports, "NearestMipMapLinearFilter", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").NearestMipMapLinearFilter;
    }
  });
  Object.defineProperty(exports, "NearestMipMapNearestFilter", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").NearestMipMapNearestFilter;
    }
  });
  Object.defineProperty(exports, "NearestMipmapLinearFilter", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").NearestMipmapLinearFilter;
    }
  });
  Object.defineProperty(exports, "NearestMipmapNearestFilter", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").NearestMipmapNearestFilter;
    }
  });
  Object.defineProperty(exports, "NeutralToneMapping", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").NeutralToneMapping;
    }
  });
  Object.defineProperty(exports, "NeverCompare", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").NeverCompare;
    }
  });
  Object.defineProperty(exports, "NeverDepth", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").NeverDepth;
    }
  });
  Object.defineProperty(exports, "NeverStencilFunc", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").NeverStencilFunc;
    }
  });
  Object.defineProperty(exports, "NoBlending", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").NoBlending;
    }
  });
  Object.defineProperty(exports, "NoColorSpace", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").NoColorSpace;
    }
  });
  Object.defineProperty(exports, "NoToneMapping", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").NoToneMapping;
    }
  });
  exports.Node = void 0;
  exports.NodeVarying = exports.NodeVar = exports.NodeUtils = exports.NodeUpdateType = exports.NodeUniform = exports.NodeType = exports.NodeShaderStage = exports.NodeObjectLoader = exports.NodeMaterialObserver = exports.NodeMaterialLoader = exports.NodeMaterial = exports.NodeLoader = exports.NodeFunctionInput = exports.NodeFrame = exports.NodeCode = exports.NodeCache = exports.NodeBuilder = exports.NodeAttribute = exports.NodeAccess = void 0;
  Object.defineProperty(exports, "NormalAnimationBlendMode", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").NormalAnimationBlendMode;
    }
  });
  Object.defineProperty(exports, "NormalBlending", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").NormalBlending;
    }
  });
  exports.NormalMapNode = void 0;
  Object.defineProperty(exports, "NotEqualCompare", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").NotEqualCompare;
    }
  });
  Object.defineProperty(exports, "NotEqualDepth", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").NotEqualDepth;
    }
  });
  Object.defineProperty(exports, "NotEqualStencilFunc", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").NotEqualStencilFunc;
    }
  });
  Object.defineProperty(exports, "NumberKeyframeTrack", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").NumberKeyframeTrack;
    }
  });
  Object.defineProperty(exports, "Object3D", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").Object3D;
    }
  });
  exports.Object3DNode = void 0;
  Object.defineProperty(exports, "ObjectLoader", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").ObjectLoader;
    }
  });
  Object.defineProperty(exports, "ObjectSpaceNormalMap", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").ObjectSpaceNormalMap;
    }
  });
  Object.defineProperty(exports, "OctahedronGeometry", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").OctahedronGeometry;
    }
  });
  Object.defineProperty(exports, "OneFactor", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").OneFactor;
    }
  });
  Object.defineProperty(exports, "OneMinusConstantAlphaFactor", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").OneMinusConstantAlphaFactor;
    }
  });
  Object.defineProperty(exports, "OneMinusConstantColorFactor", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").OneMinusConstantColorFactor;
    }
  });
  Object.defineProperty(exports, "OneMinusDstAlphaFactor", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").OneMinusDstAlphaFactor;
    }
  });
  Object.defineProperty(exports, "OneMinusDstColorFactor", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").OneMinusDstColorFactor;
    }
  });
  Object.defineProperty(exports, "OneMinusSrcAlphaFactor", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").OneMinusSrcAlphaFactor;
    }
  });
  Object.defineProperty(exports, "OneMinusSrcColorFactor", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").OneMinusSrcColorFactor;
    }
  });
  Object.defineProperty(exports, "OrthographicCamera", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").OrthographicCamera;
    }
  });
  exports.OutputStructNode = void 0;
  Object.defineProperty(exports, "PCFShadowMap", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").PCFShadowMap;
    }
  });
  Object.defineProperty(exports, "PCFSoftShadowMap", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").PCFSoftShadowMap;
    }
  });
  exports.PassNode = exports.ParameterNode = exports.PMREMNode = exports.PMREMGenerator = void 0;
  Object.defineProperty(exports, "Path", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").Path;
    }
  });
  Object.defineProperty(exports, "PerspectiveCamera", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").PerspectiveCamera;
    }
  });
  exports.PhysicalLightingModel = exports.PhongLightingModel = void 0;
  Object.defineProperty(exports, "Plane", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").Plane;
    }
  });
  Object.defineProperty(exports, "PlaneGeometry", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").PlaneGeometry;
    }
  });
  Object.defineProperty(exports, "PlaneHelper", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").PlaneHelper;
    }
  });
  Object.defineProperty(exports, "PointLight", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").PointLight;
    }
  });
  Object.defineProperty(exports, "PointLightHelper", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").PointLightHelper;
    }
  });
  exports.PointUVNode = exports.PointLightNode = void 0;
  Object.defineProperty(exports, "Points", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").Points;
    }
  });
  Object.defineProperty(exports, "PointsMaterial", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").PointsMaterial;
    }
  });
  exports.PointsNodeMaterial = void 0;
  Object.defineProperty(exports, "PolarGridHelper", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").PolarGridHelper;
    }
  });
  Object.defineProperty(exports, "PolyhedronGeometry", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").PolyhedronGeometry;
    }
  });
  Object.defineProperty(exports, "PositionalAudio", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").PositionalAudio;
    }
  });
  exports.PosterizeNode = exports.PostProcessing = void 0;
  Object.defineProperty(exports, "PropertyBinding", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").PropertyBinding;
    }
  });
  Object.defineProperty(exports, "PropertyMixer", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").PropertyMixer;
    }
  });
  exports.QuadMesh = exports.PropertyNode = void 0;
  Object.defineProperty(exports, "QuadraticBezierCurve", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").QuadraticBezierCurve;
    }
  });
  Object.defineProperty(exports, "QuadraticBezierCurve3", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").QuadraticBezierCurve3;
    }
  });
  Object.defineProperty(exports, "Quaternion", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").Quaternion;
    }
  });
  Object.defineProperty(exports, "QuaternionKeyframeTrack", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").QuaternionKeyframeTrack;
    }
  });
  Object.defineProperty(exports, "QuaternionLinearInterpolant", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").QuaternionLinearInterpolant;
    }
  });
  Object.defineProperty(exports, "RED_GREEN_RGTC2_Format", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").RED_GREEN_RGTC2_Format;
    }
  });
  Object.defineProperty(exports, "RED_RGTC1_Format", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").RED_RGTC1_Format;
    }
  });
  Object.defineProperty(exports, "REVISION", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").REVISION;
    }
  });
  Object.defineProperty(exports, "RGBADepthPacking", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").RGBADepthPacking;
    }
  });
  Object.defineProperty(exports, "RGBAFormat", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").RGBAFormat;
    }
  });
  Object.defineProperty(exports, "RGBAIntegerFormat", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").RGBAIntegerFormat;
    }
  });
  Object.defineProperty(exports, "RGBA_ASTC_10x10_Format", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").RGBA_ASTC_10x10_Format;
    }
  });
  Object.defineProperty(exports, "RGBA_ASTC_10x5_Format", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").RGBA_ASTC_10x5_Format;
    }
  });
  Object.defineProperty(exports, "RGBA_ASTC_10x6_Format", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").RGBA_ASTC_10x6_Format;
    }
  });
  Object.defineProperty(exports, "RGBA_ASTC_10x8_Format", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").RGBA_ASTC_10x8_Format;
    }
  });
  Object.defineProperty(exports, "RGBA_ASTC_12x10_Format", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").RGBA_ASTC_12x10_Format;
    }
  });
  Object.defineProperty(exports, "RGBA_ASTC_12x12_Format", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").RGBA_ASTC_12x12_Format;
    }
  });
  Object.defineProperty(exports, "RGBA_ASTC_4x4_Format", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").RGBA_ASTC_4x4_Format;
    }
  });
  Object.defineProperty(exports, "RGBA_ASTC_5x4_Format", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").RGBA_ASTC_5x4_Format;
    }
  });
  Object.defineProperty(exports, "RGBA_ASTC_5x5_Format", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").RGBA_ASTC_5x5_Format;
    }
  });
  Object.defineProperty(exports, "RGBA_ASTC_6x5_Format", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").RGBA_ASTC_6x5_Format;
    }
  });
  Object.defineProperty(exports, "RGBA_ASTC_6x6_Format", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").RGBA_ASTC_6x6_Format;
    }
  });
  Object.defineProperty(exports, "RGBA_ASTC_8x5_Format", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").RGBA_ASTC_8x5_Format;
    }
  });
  Object.defineProperty(exports, "RGBA_ASTC_8x6_Format", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").RGBA_ASTC_8x6_Format;
    }
  });
  Object.defineProperty(exports, "RGBA_ASTC_8x8_Format", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").RGBA_ASTC_8x8_Format;
    }
  });
  Object.defineProperty(exports, "RGBA_BPTC_Format", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").RGBA_BPTC_Format;
    }
  });
  Object.defineProperty(exports, "RGBA_ETC2_EAC_Format", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").RGBA_ETC2_EAC_Format;
    }
  });
  Object.defineProperty(exports, "RGBA_PVRTC_2BPPV1_Format", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").RGBA_PVRTC_2BPPV1_Format;
    }
  });
  Object.defineProperty(exports, "RGBA_PVRTC_4BPPV1_Format", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").RGBA_PVRTC_4BPPV1_Format;
    }
  });
  Object.defineProperty(exports, "RGBA_S3TC_DXT1_Format", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").RGBA_S3TC_DXT1_Format;
    }
  });
  Object.defineProperty(exports, "RGBA_S3TC_DXT3_Format", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").RGBA_S3TC_DXT3_Format;
    }
  });
  Object.defineProperty(exports, "RGBA_S3TC_DXT5_Format", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").RGBA_S3TC_DXT5_Format;
    }
  });
  Object.defineProperty(exports, "RGBDepthPacking", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").RGBDepthPacking;
    }
  });
  Object.defineProperty(exports, "RGBFormat", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").RGBFormat;
    }
  });
  Object.defineProperty(exports, "RGBIntegerFormat", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").RGBIntegerFormat;
    }
  });
  Object.defineProperty(exports, "RGB_BPTC_SIGNED_Format", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").RGB_BPTC_SIGNED_Format;
    }
  });
  Object.defineProperty(exports, "RGB_BPTC_UNSIGNED_Format", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").RGB_BPTC_UNSIGNED_Format;
    }
  });
  Object.defineProperty(exports, "RGB_ETC1_Format", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").RGB_ETC1_Format;
    }
  });
  Object.defineProperty(exports, "RGB_ETC2_Format", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").RGB_ETC2_Format;
    }
  });
  Object.defineProperty(exports, "RGB_PVRTC_2BPPV1_Format", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").RGB_PVRTC_2BPPV1_Format;
    }
  });
  Object.defineProperty(exports, "RGB_PVRTC_4BPPV1_Format", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").RGB_PVRTC_4BPPV1_Format;
    }
  });
  Object.defineProperty(exports, "RGB_S3TC_DXT1_Format", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").RGB_S3TC_DXT1_Format;
    }
  });
  Object.defineProperty(exports, "RGDepthPacking", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").RGDepthPacking;
    }
  });
  Object.defineProperty(exports, "RGFormat", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").RGFormat;
    }
  });
  Object.defineProperty(exports, "RGIntegerFormat", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").RGIntegerFormat;
    }
  });
  exports.RangeNode = exports.RTTNode = void 0;
  Object.defineProperty(exports, "RawShaderMaterial", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").RawShaderMaterial;
    }
  });
  Object.defineProperty(exports, "Ray", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").Ray;
    }
  });
  Object.defineProperty(exports, "Raycaster", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").Raycaster;
    }
  });
  Object.defineProperty(exports, "RectAreaLight", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").RectAreaLight;
    }
  });
  exports.RectAreaLightNode = void 0;
  Object.defineProperty(exports, "RedFormat", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").RedFormat;
    }
  });
  Object.defineProperty(exports, "RedIntegerFormat", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").RedIntegerFormat;
    }
  });
  exports.ReflectorNode = exports.ReferenceNode = void 0;
  Object.defineProperty(exports, "ReinhardToneMapping", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").ReinhardToneMapping;
    }
  });
  exports.RenderOutputNode = exports.RemapNode = void 0;
  Object.defineProperty(exports, "RenderTarget", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").RenderTarget;
    }
  });
  Object.defineProperty(exports, "RenderTarget3D", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").RenderTarget3D;
    }
  });
  Object.defineProperty(exports, "RenderTargetArray", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").RenderTargetArray;
    }
  });
  exports.RendererUtils = exports.RendererReferenceNode = void 0;
  Object.defineProperty(exports, "RepeatWrapping", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").RepeatWrapping;
    }
  });
  Object.defineProperty(exports, "ReplaceStencilOp", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").ReplaceStencilOp;
    }
  });
  Object.defineProperty(exports, "ReverseSubtractEquation", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").ReverseSubtractEquation;
    }
  });
  Object.defineProperty(exports, "RingGeometry", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").RingGeometry;
    }
  });
  exports.RotateNode = void 0;
  Object.defineProperty(exports, "SIGNED_RED_GREEN_RGTC2_Format", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").SIGNED_RED_GREEN_RGTC2_Format;
    }
  });
  Object.defineProperty(exports, "SIGNED_RED_RGTC1_Format", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").SIGNED_RED_RGTC1_Format;
    }
  });
  Object.defineProperty(exports, "SRGBColorSpace", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").SRGBColorSpace;
    }
  });
  Object.defineProperty(exports, "SRGBTransfer", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").SRGBTransfer;
    }
  });
  Object.defineProperty(exports, "Scene", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").Scene;
    }
  });
  exports.SetNode = exports.ScriptableValueNode = exports.ScriptableNode = exports.ScreenNode = exports.SceneNode = void 0;
  Object.defineProperty(exports, "ShaderMaterial", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").ShaderMaterial;
    }
  });
  exports.ShadowBaseNode = void 0;
  Object.defineProperty(exports, "ShadowMaterial", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").ShadowMaterial;
    }
  });
  exports.ShadowNodeMaterial = exports.ShadowNode = void 0;
  Object.defineProperty(exports, "Shape", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").Shape;
    }
  });
  Object.defineProperty(exports, "ShapeGeometry", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").ShapeGeometry;
    }
  });
  Object.defineProperty(exports, "ShapePath", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").ShapePath;
    }
  });
  Object.defineProperty(exports, "ShapeUtils", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").ShapeUtils;
    }
  });
  Object.defineProperty(exports, "ShortType", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").ShortType;
    }
  });
  Object.defineProperty(exports, "Skeleton", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").Skeleton;
    }
  });
  Object.defineProperty(exports, "SkeletonHelper", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").SkeletonHelper;
    }
  });
  Object.defineProperty(exports, "SkinnedMesh", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").SkinnedMesh;
    }
  });
  exports.SkinningNode = void 0;
  Object.defineProperty(exports, "Source", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").Source;
    }
  });
  Object.defineProperty(exports, "Sphere", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").Sphere;
    }
  });
  Object.defineProperty(exports, "SphereGeometry", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").SphereGeometry;
    }
  });
  Object.defineProperty(exports, "Spherical", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").Spherical;
    }
  });
  Object.defineProperty(exports, "SphericalHarmonics3", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").SphericalHarmonics3;
    }
  });
  Object.defineProperty(exports, "SplineCurve", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").SplineCurve;
    }
  });
  exports.SplitNode = void 0;
  Object.defineProperty(exports, "SpotLight", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").SpotLight;
    }
  });
  Object.defineProperty(exports, "SpotLightHelper", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").SpotLightHelper;
    }
  });
  exports.SpotLightNode = void 0;
  Object.defineProperty(exports, "Sprite", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").Sprite;
    }
  });
  Object.defineProperty(exports, "SpriteMaterial", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").SpriteMaterial;
    }
  });
  exports.SpriteSheetUVNode = exports.SpriteNodeMaterial = void 0;
  Object.defineProperty(exports, "SrcAlphaFactor", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").SrcAlphaFactor;
    }
  });
  Object.defineProperty(exports, "SrcAlphaSaturateFactor", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").SrcAlphaSaturateFactor;
    }
  });
  Object.defineProperty(exports, "SrcColorFactor", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").SrcColorFactor;
    }
  });
  exports.StackNode = void 0;
  Object.defineProperty(exports, "StaticCopyUsage", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").StaticCopyUsage;
    }
  });
  Object.defineProperty(exports, "StaticDrawUsage", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").StaticDrawUsage;
    }
  });
  Object.defineProperty(exports, "StaticReadUsage", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").StaticReadUsage;
    }
  });
  Object.defineProperty(exports, "StereoCamera", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").StereoCamera;
    }
  });
  exports.StorageTextureNode = exports.StorageTexture = exports.StorageInstancedBufferAttribute = exports.StorageBufferNode = exports.StorageBufferAttribute = exports.StorageArrayElementNode = void 0;
  Object.defineProperty(exports, "StreamCopyUsage", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").StreamCopyUsage;
    }
  });
  Object.defineProperty(exports, "StreamDrawUsage", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").StreamDrawUsage;
    }
  });
  Object.defineProperty(exports, "StreamReadUsage", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").StreamReadUsage;
    }
  });
  Object.defineProperty(exports, "StringKeyframeTrack", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").StringKeyframeTrack;
    }
  });
  Object.defineProperty(exports, "SubtractEquation", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").SubtractEquation;
    }
  });
  Object.defineProperty(exports, "SubtractiveBlending", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").SubtractiveBlending;
    }
  });
  Object.defineProperty(exports, "TOUCH", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").TOUCH;
    }
  });
  exports.TSL = void 0;
  Object.defineProperty(exports, "TangentSpaceNormalMap", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").TangentSpaceNormalMap;
    }
  });
  exports.TempNode = void 0;
  Object.defineProperty(exports, "TetrahedronGeometry", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").TetrahedronGeometry;
    }
  });
  Object.defineProperty(exports, "Texture", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").Texture;
    }
  });
  exports.Texture3DNode = void 0;
  Object.defineProperty(exports, "TextureLoader", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").TextureLoader;
    }
  });
  exports.TextureSizeNode = exports.TextureNode = void 0;
  Object.defineProperty(exports, "TextureUtils", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").TextureUtils;
    }
  });
  exports.ToonOutlinePassNode = exports.ToneMappingNode = void 0;
  Object.defineProperty(exports, "TorusGeometry", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").TorusGeometry;
    }
  });
  Object.defineProperty(exports, "TorusKnotGeometry", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").TorusKnotGeometry;
    }
  });
  Object.defineProperty(exports, "Triangle", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").Triangle;
    }
  });
  Object.defineProperty(exports, "TriangleFanDrawMode", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").TriangleFanDrawMode;
    }
  });
  Object.defineProperty(exports, "TriangleStripDrawMode", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").TriangleStripDrawMode;
    }
  });
  Object.defineProperty(exports, "TrianglesDrawMode", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").TrianglesDrawMode;
    }
  });
  exports.TriplanarTexturesNode = void 0;
  Object.defineProperty(exports, "TubeGeometry", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").TubeGeometry;
    }
  });
  Object.defineProperty(exports, "UVMapping", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").UVMapping;
    }
  });
  Object.defineProperty(exports, "Uint16BufferAttribute", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").Uint16BufferAttribute;
    }
  });
  Object.defineProperty(exports, "Uint32BufferAttribute", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").Uint32BufferAttribute;
    }
  });
  Object.defineProperty(exports, "Uint8BufferAttribute", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").Uint8BufferAttribute;
    }
  });
  Object.defineProperty(exports, "Uint8ClampedBufferAttribute", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").Uint8ClampedBufferAttribute;
    }
  });
  Object.defineProperty(exports, "Uniform", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").Uniform;
    }
  });
  exports.UniformNode = exports.UniformGroupNode = exports.UniformArrayNode = void 0;
  Object.defineProperty(exports, "UniformsGroup", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").UniformsGroup;
    }
  });
  Object.defineProperty(exports, "UnsignedByteType", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").UnsignedByteType;
    }
  });
  Object.defineProperty(exports, "UnsignedInt248Type", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").UnsignedInt248Type;
    }
  });
  Object.defineProperty(exports, "UnsignedInt5999Type", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").UnsignedInt5999Type;
    }
  });
  Object.defineProperty(exports, "UnsignedIntType", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").UnsignedIntType;
    }
  });
  Object.defineProperty(exports, "UnsignedShort4444Type", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").UnsignedShort4444Type;
    }
  });
  Object.defineProperty(exports, "UnsignedShort5551Type", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").UnsignedShort5551Type;
    }
  });
  Object.defineProperty(exports, "UnsignedShortType", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").UnsignedShortType;
    }
  });
  exports.UserDataNode = void 0;
  Object.defineProperty(exports, "VSMShadowMap", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").VSMShadowMap;
    }
  });
  exports.VaryingNode = exports.VarNode = void 0;
  Object.defineProperty(exports, "Vector2", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").Vector2;
    }
  });
  Object.defineProperty(exports, "Vector3", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").Vector3;
    }
  });
  Object.defineProperty(exports, "Vector4", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").Vector4;
    }
  });
  Object.defineProperty(exports, "VectorKeyframeTrack", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").VectorKeyframeTrack;
    }
  });
  exports.VertexColorNode = void 0;
  Object.defineProperty(exports, "VideoTexture", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").VideoTexture;
    }
  });
  exports.VolumeNodeMaterial = exports.ViewportTextureNode = exports.ViewportSharedTextureNode = exports.ViewportDepthTextureNode = exports.ViewportDepthNode = void 0;
  Object.defineProperty(exports, "WebGL3DRenderTarget", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").WebGL3DRenderTarget;
    }
  });
  Object.defineProperty(exports, "WebGLArrayRenderTarget", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").WebGLArrayRenderTarget;
    }
  });
  Object.defineProperty(exports, "WebGLCoordinateSystem", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").WebGLCoordinateSystem;
    }
  });
  Object.defineProperty(exports, "WebGLCubeRenderTarget", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").WebGLCubeRenderTarget;
    }
  });
  Object.defineProperty(exports, "WebGLRenderTarget", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").WebGLRenderTarget;
    }
  });
  Object.defineProperty(exports, "WebGPUCoordinateSystem", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").WebGPUCoordinateSystem;
    }
  });
  exports.WebGPURenderer = void 0;
  Object.defineProperty(exports, "WireframeGeometry", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").WireframeGeometry;
    }
  });
  Object.defineProperty(exports, "WrapAroundEnding", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").WrapAroundEnding;
    }
  });
  Object.defineProperty(exports, "ZeroCurvatureEnding", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").ZeroCurvatureEnding;
    }
  });
  Object.defineProperty(exports, "ZeroFactor", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").ZeroFactor;
    }
  });
  Object.defineProperty(exports, "ZeroSlopeEnding", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").ZeroSlopeEnding;
    }
  });
  Object.defineProperty(exports, "ZeroStencilOp", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").ZeroStencilOp;
    }
  });
  Object.defineProperty(exports, "createCanvasElement", {
    enumerable: true,
    get: function get() {
      return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").createCanvasElement;
    }
  });
  exports.vectorComponents = exports.shaderStages = exports.defaultShaderStages = exports.defaultBuildStages = void 0;
  var _defineProperty2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[2], "@babel/runtime/helpers/defineProperty"));
  var _readOnlyError2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[3], "@babel/runtime/helpers/readOnlyError"));
  var _wrapNativeSuper2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[4], "@babel/runtime/helpers/wrapNativeSuper"));
  var _asyncToGenerator2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[5], "@babel/runtime/helpers/asyncToGenerator"));
  var _slicedToArray2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[6], "@babel/runtime/helpers/slicedToArray"));
  var _get2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[7], "@babel/runtime/helpers/get"));
  var _possibleConstructorReturn2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[8], "@babel/runtime/helpers/possibleConstructorReturn"));
  var _getPrototypeOf2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[9], "@babel/runtime/helpers/getPrototypeOf"));
  var _inherits2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[10], "@babel/runtime/helpers/inherits"));
  var _construct2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[11], "@babel/runtime/helpers/construct"));
  var _toConsumableArray2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[12], "@babel/runtime/helpers/toConsumableArray"));
  var _classCallCheck2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[13], "@babel/runtime/helpers/classCallCheck"));
  var _createClass2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[14], "@babel/runtime/helpers/createClass"));
  function _superPropGet(t, o, e, r) { var p = (0, _get2.default)((0, _getPrototypeOf2.default)(1 & r ? t.prototype : t), o, e); return 2 & r && "function" == typeof p ? function (t) { return p.apply(e, t); } : p; }
  function _callSuper(t, o, e) { return o = (0, _getPrototypeOf2.default)(o), (0, _possibleConstructorReturn2.default)(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], (0, _getPrototypeOf2.default)(t).constructor) : o.apply(t, e)); }
  function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); } /**
 * @license
 * Copyright 2010-2024 Three.js Authors
 * SPDX-License-Identifier: MIT
 */
  var refreshUniforms = ['alphaMap', 'alphaTest', 'anisotropy', 'anisotropyMap', 'anisotropyRotation', 'aoMap', 'attenuationColor', 'attenuationDistance', 'bumpMap', 'clearcoat', 'clearcoatMap', 'clearcoatNormalMap', 'clearcoatNormalScale', 'clearcoatRoughness', 'color', 'dispersion', 'displacementMap', 'emissive', 'emissiveMap', 'envMap', 'gradientMap', 'ior', 'iridescence', 'iridescenceIOR', 'iridescenceMap', 'iridescenceThicknessMap', 'lightMap', 'map', 'matcap', 'metalness', 'metalnessMap', 'normalMap', 'normalScale', 'opacity', 'roughness', 'roughnessMap', 'sheen', 'sheenColor', 'sheenColorMap', 'sheenRoughnessMap', 'shininess', 'specular', 'specularColor', 'specularColorMap', 'specularIntensity', 'specularIntensityMap', 'specularMap', 'thickness', 'transmission', 'transmissionMap'];

  /**
   * This class is used by {@link WebGPURenderer} as management component.
   * It's primary purpose is to determine whether render objects require a
   * refresh right before they are going to be rendered or not.
   */
  var NodeMaterialObserver = exports.NodeMaterialObserver = /*#__PURE__*/function () {
    /**
     * Constructs a new node material observer.
     *
     * @param {NodeBuilder} builder - The node builder.
     */
    function NodeMaterialObserver(builder) {
      (0, _classCallCheck2.default)(this, NodeMaterialObserver);
      /**
       * A node material can be used by more than one render object so the
       * monitor must maintain a list of render objects.
       *
       * @type {WeakMap<RenderObject,Object>}
       */
      this.renderObjects = new WeakMap();

      /**
       * Whether the material uses node objects or not.
       *
       * @type {Boolean}
       */
      this.hasNode = this.containsNode(builder);

      /**
       * Whether the node builder's 3D object is animated or not.
       *
       * @type {Boolean}
       */
      this.hasAnimation = builder.object.isSkinnedMesh === true;

      /**
       * A list of all possible material uniforms
       *
       * @type {Array<String>}
       */
      this.refreshUniforms = refreshUniforms;

      /**
       * Holds the current render ID from the node frame.
       *
       * @type {Number}
       * @default 0
       */
      this.renderId = 0;
    }

    /**
     * Returns `true` if the given render object is verified for the first time of this observer.
     *
     * @param {RenderObject} renderObject - The render object.
     * @return {Boolean} Whether the given render object is verified for the first time of this observer.
     */
    return (0, _createClass2.default)(NodeMaterialObserver, [{
      key: "firstInitialization",
      value: function firstInitialization(renderObject) {
        var hasInitialized = this.renderObjects.has(renderObject);
        if (hasInitialized === false) {
          this.getRenderObjectData(renderObject);
          return true;
        }
        return false;
      }

      /**
       * Returns monitoring data for the given render object.
       *
       * @param {RenderObject} renderObject - The render object.
       * @return {Object} The monitoring data.
       */
    }, {
      key: "getRenderObjectData",
      value: function getRenderObjectData(renderObject) {
        var data = this.renderObjects.get(renderObject);
        if (data === undefined) {
          var geometry = renderObject.geometry,
            material = renderObject.material,
            object = renderObject.object;
          data = {
            material: this.getMaterialData(material),
            geometry: {
              attributes: this.getAttributesData(geometry.attributes),
              indexVersion: geometry.index ? geometry.index.version : null,
              drawRange: {
                start: geometry.drawRange.start,
                count: geometry.drawRange.count
              }
            },
            worldMatrix: object.matrixWorld.clone()
          };
          if (object.center) {
            data.center = object.center.clone();
          }
          if (object.morphTargetInfluences) {
            data.morphTargetInfluences = object.morphTargetInfluences.slice();
          }
          if (renderObject.bundle !== null) {
            data.version = renderObject.bundle.version;
          }
          if (data.material.transmission > 0) {
            var _renderObject$context = renderObject.context,
              width = _renderObject$context.width,
              height = _renderObject$context.height;
            data.bufferWidth = width;
            data.bufferHeight = height;
          }
          this.renderObjects.set(renderObject, data);
        }
        return data;
      }

      /**
       * Returns an attribute data structure holding the attributes versions for
       * monitoring.
       *
       * @param {Object} attributes - The geometry attributes.
       * @return {Object} An object for monitoring the versions of attributes.
       */
    }, {
      key: "getAttributesData",
      value: function getAttributesData(attributes) {
        var attributesData = {};
        for (var name in attributes) {
          var _attribute = attributes[name];
          attributesData[name] = {
            version: _attribute.version
          };
        }
        return attributesData;
      }

      /**
       * Returns `true` if the node builder's material uses
       * node properties.
       *
       * @param {NodeBuilder} builder - The current node builder.
       * @return {Boolean} Whether the node builder's material uses node properties or not.
       */
    }, {
      key: "containsNode",
      value: function containsNode(builder) {
        var material = builder.material;
        for (var _property in material) {
          if (material[_property] && material[_property].isNode) return true;
        }
        if (builder.renderer.nodes.modelViewMatrix !== null || builder.renderer.nodes.modelNormalViewMatrix !== null) return true;
        return false;
      }

      /**
       * Returns a material data structure holding the material property values for
       * monitoring.
       *
       * @param {Material} material - The material.
       * @return {Object} An object for monitoring material properties.
       */
    }, {
      key: "getMaterialData",
      value: function getMaterialData(material) {
        var data = {};
        for (var _property2 of this.refreshUniforms) {
          var value = material[_property2];
          if (value === null || value === undefined) continue;
          if (typeof value === 'object' && value.clone !== undefined) {
            if (value.isTexture === true) {
              data[_property2] = {
                id: value.id,
                version: value.version
              };
            } else {
              data[_property2] = value.clone();
            }
          } else {
            data[_property2] = value;
          }
        }
        return data;
      }

      /**
       * Returns `true` if the given render object has not changed its state.
       *
       * @param {RenderObject} renderObject - The render object.
       * @return {Boolean} Whether the given render object has changed its state or not.
       */
    }, {
      key: "equals",
      value: function equals(renderObject) {
        var object = renderObject.object,
          material = renderObject.material,
          geometry = renderObject.geometry;
        var renderObjectData = this.getRenderObjectData(renderObject);

        // world matrix

        if (renderObjectData.worldMatrix.equals(object.matrixWorld) !== true) {
          renderObjectData.worldMatrix.copy(object.matrixWorld);
          return false;
        }

        // material

        var materialData = renderObjectData.material;
        for (var _property3 in materialData) {
          var value = materialData[_property3];
          var mtlValue = material[_property3];
          if (value.equals !== undefined) {
            if (value.equals(mtlValue) === false) {
              value.copy(mtlValue);
              return false;
            }
          } else if (mtlValue.isTexture === true) {
            if (value.id !== mtlValue.id || value.version !== mtlValue.version) {
              value.id = mtlValue.id;
              value.version = mtlValue.version;
              return false;
            }
          } else if (value !== mtlValue) {
            materialData[_property3] = mtlValue;
            return false;
          }
        }
        if (materialData.transmission > 0) {
          var _renderObject$context2 = renderObject.context,
            width = _renderObject$context2.width,
            height = _renderObject$context2.height;
          if (renderObjectData.bufferWidth !== width || renderObjectData.bufferHeight !== height) {
            renderObjectData.bufferWidth = width;
            renderObjectData.bufferHeight = height;
            return false;
          }
        }

        // geometry

        var storedGeometryData = renderObjectData.geometry;
        var attributes = geometry.attributes;
        var storedAttributes = storedGeometryData.attributes;
        var storedAttributeNames = Object.keys(storedAttributes);
        var currentAttributeNames = Object.keys(attributes);
        if (storedAttributeNames.length !== currentAttributeNames.length) {
          renderObjectData.geometry.attributes = this.getAttributesData(attributes);
          return false;
        }

        // compare each attribute

        for (var name of storedAttributeNames) {
          var storedAttributeData = storedAttributes[name];
          var _attribute2 = attributes[name];
          if (_attribute2 === undefined) {
            // attribute was removed
            delete storedAttributes[name];
            return false;
          }
          if (storedAttributeData.version !== _attribute2.version) {
            storedAttributeData.version = _attribute2.version;
            return false;
          }
        }

        // check index

        var index = geometry.index;
        var storedIndexVersion = storedGeometryData.indexVersion;
        var currentIndexVersion = index ? index.version : null;
        if (storedIndexVersion !== currentIndexVersion) {
          storedGeometryData.indexVersion = currentIndexVersion;
          return false;
        }

        // check drawRange

        if (storedGeometryData.drawRange.start !== geometry.drawRange.start || storedGeometryData.drawRange.count !== geometry.drawRange.count) {
          storedGeometryData.drawRange.start = geometry.drawRange.start;
          storedGeometryData.drawRange.count = geometry.drawRange.count;
          return false;
        }

        // morph targets

        if (renderObjectData.morphTargetInfluences) {
          var morphChanged = false;
          for (var i = 0; i < renderObjectData.morphTargetInfluences.length; i++) {
            if (renderObjectData.morphTargetInfluences[i] !== object.morphTargetInfluences[i]) {
              morphChanged = true;
            }
          }
          if (morphChanged) return true;
        }

        // center

        if (renderObjectData.center) {
          if (renderObjectData.center.equals(object.center) === false) {
            renderObjectData.center.copy(object.center);
            return true;
          }
        }

        // bundle

        if (renderObject.bundle !== null) {
          renderObjectData.version = renderObject.bundle.version;
        }
        return true;
      }

      /**
       * Checks if the given render object requires a refresh.
       *
       * @param {RenderObject} renderObject - The render object.
       * @param {NodeFrame} nodeFrame - The current node frame.
       * @return {Boolean} Whether the given render object requires a refresh or not.
       */
    }, {
      key: "needsRefresh",
      value: function needsRefresh(renderObject, nodeFrame) {
        if (this.hasNode || this.hasAnimation || this.firstInitialization(renderObject)) return true;
        var renderId = nodeFrame.renderId;
        if (this.renderId !== renderId) {
          this.renderId = renderId;
          return true;
        }
        var isStatic = renderObject.object.static === true;
        var isBundle = renderObject.bundle !== null && renderObject.bundle.static === true && this.getRenderObjectData(renderObject).version === renderObject.bundle.version;
        if (isStatic || isBundle) return false;
        var notEqual = this.equals(renderObject) !== true;
        return notEqual;
      }
    }]);
  }();
  /** @module NodeUtils **/
  // cyrb53 (c) 2018 bryc (github.com/bryc). License: Public domain. Attribution appreciated.
  // A fast and simple 64-bit (or 53-bit) string hash function with decent collision resistance.
  // Largely inspired by MurmurHash2/3, but with a focus on speed/simplicity.
  // See https://stackoverflow.com/questions/7616461/generate-a-hash-from-string-in-javascript/52171480#52171480
  // https://github.com/bryc/code/blob/master/jshash/experimental/cyrb53.js
  function cyrb53(value) {
    var seed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var h1 = 0xdeadbeef ^ seed,
      h2 = 0x41c6ce57 ^ seed;
    if (value instanceof Array) {
      for (var i = 0, val; i < value.length; i++) {
        val = value[i];
        h1 = Math.imul(h1 ^ val, 2654435761);
        h2 = Math.imul(h2 ^ val, 1597334677);
      }
    } else {
      for (var _i = 0, ch; _i < value.length; _i++) {
        ch = value.charCodeAt(_i);
        h1 = Math.imul(h1 ^ ch, 2654435761);
        h2 = Math.imul(h2 ^ ch, 1597334677);
      }
    }
    h1 = Math.imul(h1 ^ h1 >>> 16, 2246822507);
    h1 ^= Math.imul(h2 ^ h2 >>> 13, 3266489909);
    h2 = Math.imul(h2 ^ h2 >>> 16, 2246822507);
    h2 ^= Math.imul(h1 ^ h1 >>> 13, 3266489909);
    return 4294967296 * (2097151 & h2) + (h1 >>> 0);
  }

  /**
   * Computes a hash for the given string.
   *
   * @method
   * @param {String} str - The string to be hashed.
   * @return {Number} The hash.
   */
  var hashString = function hashString(str) {
    return cyrb53(str);
  };

  /**
   * Computes a hash for the given array.
   *
   * @method
   * @param {Array<Number>} array - The array to be hashed.
   * @return {Number} The hash.
   */
  var hashArray = function hashArray(array) {
    return cyrb53(array);
  };

  /**
   * Computes a hash for the given list of parameters.
   *
   * @method
   * @param {...Number} params - A list of parameters.
   * @return {Number} The hash.
   */
  var hash$1 = function hash$1() {
    for (var _len = arguments.length, params = new Array(_len), _key = 0; _key < _len; _key++) {
      params[_key] = arguments[_key];
    }
    return cyrb53(params);
  };

  /**
   * Computes a cache key for the given node.
   *
   * @method
   * @param {Object} object - The object to be hashed.
   * @param {Boolean} [force=false] - Whether to force a cache key computation or not.
   * @return {Number} The hash.
   */
  function getCacheKey$1(object) {
    var force = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    var values = [];
    if (object.isNode === true) {
      values.push(object.id);
      object = object.getSelf();
    }
    for (var _ref of getNodeChildren(object)) {
      var _property4 = _ref.property;
      var childNode = _ref.childNode;
      values.push(values, cyrb53(_property4.slice(0, -4)), childNode.getCacheKey(force));
    }
    return cyrb53(values);
  }

  /**
   * This generator function can be used to iterate over the node children
   * of the given object.
   *
   * @generator
   * @param {Object} node - The object to be hashed.
   * @param {Boolean} [toJSON=false] - Whether to return JSON or not.
   * @yields {Object} A result node holding the property, index (if available) and the child node.
   */
  function getNodeChildren(node) {
    var toJSON = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    return function* () {
      for (var _property5 in node) {
        // Ignore private properties.
        if (_property5.startsWith('_') === true) continue;
        var object = node[_property5];
        if (Array.isArray(object) === true) {
          for (var i = 0; i < object.length; i++) {
            var child = object[i];
            if (child && (child.isNode === true || toJSON && typeof child.toJSON === 'function')) {
              yield {
                property: _property5,
                index: i,
                childNode: child
              };
            }
          }
        } else if (object && object.isNode === true) {
          yield {
            property: _property5,
            childNode: object
          };
        } else if (typeof object === 'object') {
          for (var subProperty in object) {
            var _child = object[subProperty];
            if (_child && (_child.isNode === true || toJSON && typeof _child.toJSON === 'function')) {
              yield {
                property: _property5,
                index: subProperty,
                childNode: _child
              };
            }
          }
        }
      }
    }();
  }
  var typeFromLength = /*@__PURE__*/new Map([[1, 'float'], [2, 'vec2'], [3, 'vec3'], [4, 'vec4'], [9, 'mat3'], [16, 'mat4']]);
  var dataFromObject = /*@__PURE__*/new WeakMap();

  /**
   * Returns the data type for the given the length.
   *
   * @method
   * @param {Number} length - The length.
   * @return {String} The data type.
   */
  function _getTypeFromLength(length) {
    return typeFromLength.get(length);
  }

  /**
   * Returns the typed array for the given data type.
   *
   * @method
   * @param {String} type - The data type.
   * @return {TypedArray} The typed array.
   */
  function getTypedArrayFromType(type) {
    // Handle component type for vectors and matrices
    if (/[iu]?vec\d/.test(type)) {
      // Handle int vectors
      if (type.startsWith('ivec')) return Int32Array;
      // Handle uint vectors
      if (type.startsWith('uvec')) return Uint32Array;
      // Default to float vectors
      return Float32Array;
    }

    // Handle matrices (always float)
    if (/mat\d/.test(type)) return Float32Array;

    // Basic types
    if (/float/.test(type)) return Float32Array;
    if (/uint/.test(type)) return Uint32Array;
    if (/int/.test(type)) return Int32Array;
    throw new Error(`THREE.NodeUtils: Unsupported type: ${type}`);
  }

  /**
   * Returns the length for the given data type.
   *
   * @method
   * @param {String} type - The data type.
   * @return {Number} The length.
   */
  function getLengthFromType(type) {
    if (/float|int|uint/.test(type)) return 1;
    if (/vec2/.test(type)) return 2;
    if (/vec3/.test(type)) return 3;
    if (/vec4/.test(type)) return 4;
    if (/mat3/.test(type)) return 9;
    if (/mat4/.test(type)) return 16;
    console.error('THREE.TSL: Unsupported type:', type);
  }

  /**
   * Returns the data type for the given value.
   *
   * @method
   * @param {Any} value - The value.
   * @return {String?} The data type.
   */
  function getValueType(value) {
    if (value === undefined || value === null) return null;
    var typeOf = typeof value;
    if (value.isNode === true) {
      return 'node';
    } else if (typeOf === 'number') {
      return 'float';
    } else if (typeOf === 'boolean') {
      return 'bool';
    } else if (typeOf === 'string') {
      return 'string';
    } else if (typeOf === 'function') {
      return 'shader';
    } else if (value.isVector2 === true) {
      return 'vec2';
    } else if (value.isVector3 === true) {
      return 'vec3';
    } else if (value.isVector4 === true) {
      return 'vec4';
    } else if (value.isMatrix3 === true) {
      return 'mat3';
    } else if (value.isMatrix4 === true) {
      return 'mat4';
    } else if (value.isColor === true) {
      return 'color';
    } else if (value instanceof ArrayBuffer) {
      return 'ArrayBuffer';
    }
    return null;
  }

  /**
   * Returns the value/object for the given data type and parameters.
   *
   * @method
   * @param {String} type - The given type.
   * @param {...Any} params - A parameter list.
   * @return {Any} The value/object.
   */
  function getValueFromType(type) {
    for (var _len2 = arguments.length, params = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
      params[_key2 - 1] = arguments[_key2];
    }
    var last4 = type ? type.slice(-4) : undefined;
    if (params.length === 1) {
      // ensure same behaviour as in NodeBuilder.format()

      if (last4 === 'vec2') params = [params[0], params[0]];else if (last4 === 'vec3') params = [params[0], params[0], params[0]];else if (last4 === 'vec4') params = [params[0], params[0], params[0], params[0]];
    }
    if (type === 'color') {
      return (0, _construct2.default)(_$$_REQUIRE(_dependencyMap[1], "./three.core.js").Color, (0, _toConsumableArray2.default)(params));
    } else if (last4 === 'vec2') {
      return (0, _construct2.default)(_$$_REQUIRE(_dependencyMap[1], "./three.core.js").Vector2, (0, _toConsumableArray2.default)(params));
    } else if (last4 === 'vec3') {
      return (0, _construct2.default)(_$$_REQUIRE(_dependencyMap[1], "./three.core.js").Vector3, (0, _toConsumableArray2.default)(params));
    } else if (last4 === 'vec4') {
      return (0, _construct2.default)(_$$_REQUIRE(_dependencyMap[1], "./three.core.js").Vector4, (0, _toConsumableArray2.default)(params));
    } else if (last4 === 'mat3') {
      return (0, _construct2.default)(_$$_REQUIRE(_dependencyMap[1], "./three.core.js").Matrix3, (0, _toConsumableArray2.default)(params));
    } else if (last4 === 'mat4') {
      return (0, _construct2.default)(_$$_REQUIRE(_dependencyMap[1], "./three.core.js").Matrix4, (0, _toConsumableArray2.default)(params));
    } else if (type === 'bool') {
      return params[0] || false;
    } else if (type === 'float' || type === 'int' || type === 'uint') {
      return params[0] || 0;
    } else if (type === 'string') {
      return params[0] || '';
    } else if (type === 'ArrayBuffer') {
      return base64ToArrayBuffer(params[0]);
    }
    return null;
  }

  /**
   * Gets the object data that can be shared between different rendering steps.
   *
   * @param {Object} object - The object to get the data for.
   * @return {Object} The object data.
   */
  function getDataFromObject(object) {
    var data = dataFromObject.get(object);
    if (data === undefined) {
      data = {};
      dataFromObject.set(object, data);
    }
    return data;
  }

  /**
   * Converts the given array buffer to a Base64 string.
   *
   * @method
   * @param {ArrayBuffer} arrayBuffer - The array buffer.
   * @return {String} The Base64 string.
   */
  function arrayBufferToBase64(arrayBuffer) {
    var chars = '';
    var array = new Uint8Array(arrayBuffer);
    for (var i = 0; i < array.length; i++) {
      chars += String.fromCharCode(array[i]);
    }
    return btoa(chars);
  }

  /**
   * Converts the given Base64 string to an array buffer.
   *
   * @method
   * @param {String} base64 - The Base64 string.
   * @return {ArrayBuffer} The array buffer.
   */
  function base64ToArrayBuffer(base64) {
    return Uint8Array.from(atob(base64), function (c) {
      return c.charCodeAt(0);
    }).buffer;
  }
  var NodeUtils = exports.NodeUtils = /*#__PURE__*/Object.freeze({
    __proto__: null,
    arrayBufferToBase64: arrayBufferToBase64,
    base64ToArrayBuffer: base64ToArrayBuffer,
    getCacheKey: getCacheKey$1,
    getDataFromObject: getDataFromObject,
    getLengthFromType: getLengthFromType,
    getNodeChildren: getNodeChildren,
    getTypeFromLength: _getTypeFromLength,
    getTypedArrayFromType: getTypedArrayFromType,
    getValueFromType: getValueFromType,
    getValueType: getValueType,
    hash: hash$1,
    hashArray: hashArray,
    hashString: hashString
  });

  /** @module NodeConstants **/

  /**
   * Possible shader stages.
   *
   * @property {string} VERTEX The vertex shader stage.
   * @property {string} FRAGMENT The fragment shader stage.
   */
  var NodeShaderStage = exports.NodeShaderStage = {
    VERTEX: 'vertex',
    FRAGMENT: 'fragment'
  };

  /**
   * Update types of a node.
   *
   * @property {string} NONE The update method is not executed.
   * @property {string} FRAME The update method is executed per frame.
   * @property {string} RENDER The update method is executed per render. A frame might be produced by multiple render calls so this value allows more detailed updates than FRAME.
   * @property {string} OBJECT The update method is executed per {@link Object3D} that uses the node for rendering.
   */
  var NodeUpdateType = exports.NodeUpdateType = {
    NONE: 'none',
    FRAME: 'frame',
    RENDER: 'render',
    OBJECT: 'object'
  };

  /**
   * Data types of a node.
   *
   * @property {string} BOOLEAN Boolean type.
   * @property {string} INTEGER Integer type.
   * @property {string} FLOAT Float type.
   * @property {string} VECTOR2 Two-dimensional vector type.
   * @property {string} VECTOR3 Three-dimensional vector type.
   * @property {string} VECTOR4 Four-dimensional vector type.
   * @property {string} MATRIX2 2x2 matrix type.
   * @property {string} MATRIX3 3x3 matrix type.
   * @property {string} MATRIX4 4x4 matrix type.
   */
  var NodeType = exports.NodeType = {
    BOOLEAN: 'bool',
    INTEGER: 'int',
    FLOAT: 'float',
    VECTOR2: 'vec2',
    VECTOR3: 'vec3',
    VECTOR4: 'vec4',
    MATRIX2: 'mat2',
    MATRIX3: 'mat3',
    MATRIX4: 'mat4'
  };

  /**
   * Access types of a node. These are relevant for compute and storage usage.
   *
   * @property {string} READ_ONLY Read-only access
   * @property {string} WRITE_ONLY Write-only access.
   * @property {string} READ_WRITE Read and write access.
   */
  var NodeAccess = exports.NodeAccess = {
    READ_ONLY: 'readOnly',
    WRITE_ONLY: 'writeOnly',
    READ_WRITE: 'readWrite'
  };
  var defaultShaderStages = exports.defaultShaderStages = ['fragment', 'vertex'];
  var defaultBuildStages = exports.defaultBuildStages = ['setup', 'analyze', 'generate'];
  var shaderStages = exports.shaderStages = [].concat(defaultShaderStages, ['compute']);
  var vectorComponents = exports.vectorComponents = ['x', 'y', 'z', 'w'];
  var _nodeId = 0;

  /**
   * Base class for all nodes.
   *
   * @augments EventDispatcher
   */
  var Node = exports.Node = /*#__PURE__*/function (_EventDispatcher) {
    /**
     * Constructs a new node.
     *
     * @param {String?} nodeType - The node type.
     */
    function Node() {
      var _this;
      var nodeType = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      (0, _classCallCheck2.default)(this, Node);
      _this = _callSuper(this, Node);

      /**
       * The node type. This represents the result type of the node (e.g. `float` or `vec3`).
       *
       * @type {String?}
       * @default null
       */
      _this.nodeType = nodeType;

      /**
       * The update type of the node's {@link Node#update} method. Possible values are listed in {@link NodeUpdateType}.
       *
       * @type {String}
       * @default 'none'
       */
      _this.updateType = NodeUpdateType.NONE;

      /**
       * The update type of the node's {@link Node#updateBefore} method. Possible values are listed in {@link NodeUpdateType}.
       *
       * @type {String}
       * @default 'none'
       */
      _this.updateBeforeType = NodeUpdateType.NONE;

      /**
       * The update type of the node's {@link Node#updateAfter} method. Possible values are listed in {@link NodeUpdateType}.
       *
       * @type {String}
       * @default 'none'
       */
      _this.updateAfterType = NodeUpdateType.NONE;

      /**
       * The UUID of the node.
       *
       * @type {String}
       * @readonly
       */
      _this.uuid = _$$_REQUIRE(_dependencyMap[1], "./three.core.js").MathUtils.generateUUID();

      /**
       * The version of the node. The version automatically is increased when {@link Node#needsUpdate} is set to `true`.
       *
       * @type {Number}
       * @readonly
       * @default 0
       */
      _this.version = 0;

      /**
       * Whether this node is global or not. This property is relevant for the internal
       * node caching system. All nodes which should be declared just once should
       * set this flag to `true` (a typical example is {@link AttributeNode}).
       *
       * @type {Boolean}
       * @default false
       */
      _this.global = false;

      /**
       * This flag can be used for type testing.
       *
       * @type {Boolean}
       * @readonly
       * @default true
       */
      _this.isNode = true;

      // private

      /**
       * The cache key of this node.
       *
       * @private
       * @type {Number?}
       * @default null
       */
      _this._cacheKey = null;

      /**
       * The cache key 's version.
       *
       * @private
       * @type {Number}
       * @default 0
       */
      _this._cacheKeyVersion = 0;
      Object.defineProperty(_this, 'id', {
        value: _nodeId++
      });
      return _this;
    }

    /**
     * Set this property to `true` when the node should be regenerated.
     *
     * @type {Boolean}
     * @default false
     * @param {boolean} value
     */
    (0, _inherits2.default)(Node, _EventDispatcher);
    return (0, _createClass2.default)(Node, [{
      key: "needsUpdate",
      set: function set(value) {
        if (value === true) {
          this.version++;
        }
      }

      /**
       * The type of the class. The value is usually the constructor name.
       *
       * @type {String}
      	 * @readonly
       */
    }, {
      key: "type",
      get: function get() {
        return this.constructor.type;
      }

      /**
       * Convenient method for defining {@link Node#update}.
       *
       * @param {Function} callback - The update method.
       * @param {String} updateType - The update type.
       * @return {Node} A reference to this node.
       */
    }, {
      key: "onUpdate",
      value: function onUpdate(callback, updateType) {
        this.updateType = updateType;
        this.update = callback.bind(this.getSelf());
        return this;
      }

      /**
       * Convenient method for defining {@link Node#update}. Similar to {@link Node#onUpdate}, but
       * this method automatically sets the update type to `FRAME`.
       *
       * @param {Function} callback - The update method.
       * @return {Node} A reference to this node.
       */
    }, {
      key: "onFrameUpdate",
      value: function onFrameUpdate(callback) {
        return this.onUpdate(callback, NodeUpdateType.FRAME);
      }

      /**
       * Convenient method for defining {@link Node#update}. Similar to {@link Node#onUpdate}, but
       * this method automatically sets the update type to `RENDER`.
       *
       * @param {Function} callback - The update method.
       * @return {Node} A reference to this node.
       */
    }, {
      key: "onRenderUpdate",
      value: function onRenderUpdate(callback) {
        return this.onUpdate(callback, NodeUpdateType.RENDER);
      }

      /**
       * Convenient method for defining {@link Node#update}. Similar to {@link Node#onUpdate}, but
       * this method automatically sets the update type to `OBJECT`.
       *
       * @param {Function} callback - The update method.
       * @return {Node} A reference to this node.
       */
    }, {
      key: "onObjectUpdate",
      value: function onObjectUpdate(callback) {
        return this.onUpdate(callback, NodeUpdateType.OBJECT);
      }

      /**
       * Convenient method for defining {@link Node#updateReference}.
       *
       * @param {Function} callback - The update method.
       * @return {Node} A reference to this node.
       */
    }, {
      key: "onReference",
      value: function onReference(callback) {
        this.updateReference = callback.bind(this.getSelf());
        return this;
      }

      /**
       * The `this` reference might point to a Proxy so this method can be used
       * to get the reference to the actual node instance.
       *
       * @return {Node} A reference to the node.
       */
    }, {
      key: "getSelf",
      value: function getSelf() {
        // Returns non-node object.

        return this.self || this;
      }

      /**
       * Nodes might refer to other objects like materials. This method allows to dynamically update the reference
       * to such objects based on a given state (e.g. the current node frame or builder).
       *
       * @param {Any} state - This method can be invocated in different contexts so `state` can refer to any object type.
       * @return {Any} The updated reference.
       */
    }, {
      key: "updateReference",
      value: function updateReference(/*state*/
      ) {
        return this;
      }

      /**
       * By default this method returns the value of the {@link Node#global} flag. This method
       * can be overwritten in derived classes if an analytical way is required to determine the
       * global status.
       *
       * @param {NodeBuilder} builder - The current node builder.
       * @return {Boolean} Whether this node is global or not.
       */
    }, {
      key: "isGlobal",
      value: function isGlobal(/*builder*/
      ) {
        return this.global;
      }

      /**
       * Generator function that can be used to iterate over the child nodes.
       *
       * @generator
       * @yields {Node} A child node.
       */
    }, {
      key: "getChildren",
      value: function* getChildren() {
        for (var _ref2 of getNodeChildren(this)) {
          var childNode = _ref2.childNode;
          yield childNode;
        }
      }

      /**
       * Calling this method dispatches the `dispose` event. This event can be used
       * to register event listeners for clean up tasks.
       */
    }, {
      key: "dispose",
      value: function dispose() {
        this.dispatchEvent({
          type: 'dispose'
        });
      }

      /**
       * Callback for {@link Node#traverse}.
       *
       * @callback traverseCallback
       * @param {Node} node - The current node.
       */

      /**
       * Can be used to traverse through the node's hierarchy.
       *
       * @param {traverseCallback} callback - A callback that is executed per node.
       */
    }, {
      key: "traverse",
      value: function traverse(callback) {
        callback(this);
        for (var childNode of this.getChildren()) {
          childNode.traverse(callback);
        }
      }

      /**
       * Returns the cache key for this node.
       *
       * @param {Boolean} [force=false] - When set to `true`, a recomputation of the cache key is forced.
       * @return {Number} The cache key of the node.
       */
    }, {
      key: "getCacheKey",
      value: function getCacheKey() {
        var force = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
        force = force || this.version !== this._cacheKeyVersion;
        if (force === true || this._cacheKey === null) {
          this._cacheKey = hash$1(getCacheKey$1(this, force), this.customCacheKey());
          this._cacheKeyVersion = this.version;
        }
        return this._cacheKey;
      }

      /**
       * Generate a custom cache key for this node.
       *
       * @return {Number} The cache key of the node.
       */
    }, {
      key: "customCacheKey",
      value: function customCacheKey() {
        return 0;
      }

      /**
       * Returns the references to this node which is by default `this`.
       *
       * @return {Node} A reference to this node.
       */
    }, {
      key: "getScope",
      value: function getScope() {
        return this;
      }

      /**
       * Returns the hash of the node which is used to identify the node. By default it's
       * the {@link Node#uuid} however derived node classes might have to overwrite this method
       * depending on their implementation.
       *
       * @param {NodeBuilder} builder - The current node builder.
       * @return {String} The hash.
       */
    }, {
      key: "getHash",
      value: function getHash(/*builder*/
      ) {
        return this.uuid;
      }

      /**
       * Returns the update type of {@link Node#update}.
       *
       * @return {NodeUpdateType} The update type.
       */
    }, {
      key: "getUpdateType",
      value: function getUpdateType() {
        return this.updateType;
      }

      /**
       * Returns the update type of {@link Node#updateBefore}.
       *
       * @return {NodeUpdateType} The update type.
       */
    }, {
      key: "getUpdateBeforeType",
      value: function getUpdateBeforeType() {
        return this.updateBeforeType;
      }

      /**
       * Returns the update type of {@link Node#updateAfter}.
       *
       * @return {NodeUpdateType} The update type.
       */
    }, {
      key: "getUpdateAfterType",
      value: function getUpdateAfterType() {
        return this.updateAfterType;
      }

      /**
       * Certain types are composed of multiple elements. For example a `vec3`
       * is composed of three `float` values. This method returns the type of
       * these elements.
       *
       * @param {NodeBuilder} builder - The current node builder.
       * @return {String} The type of the node.
       */
    }, {
      key: "getElementType",
      value: function getElementType(builder) {
        var type = this.getNodeType(builder);
        var elementType = builder.getElementType(type);
        return elementType;
      }

      /**
       * Returns the node's type.
       *
       * @param {NodeBuilder} builder - The current node builder.
       * @return {String} The type of the node.
       */
    }, {
      key: "getNodeType",
      value: function getNodeType(builder) {
        var nodeProperties = builder.getNodeProperties(this);
        if (nodeProperties.outputNode) {
          return nodeProperties.outputNode.getNodeType(builder);
        }
        return this.nodeType;
      }

      /**
       * This method is used during the build process of a node and ensures
       * equal nodes are not built multiple times but just once. For example if
       * `attribute( 'uv' )` is used multiple times by the user, the build
       * process makes sure to process just the first node.
       *
       * @param {NodeBuilder} builder - The current node builder.
       * @return {Node} The shared node if possible. Otherwise `this` is returned.
       */
    }, {
      key: "getShared",
      value: function getShared(builder) {
        var hash = this.getHash(builder);
        var nodeFromHash = builder.getNodeFromHash(hash);
        return nodeFromHash || this;
      }

      /**
       * Represents the setup stage which is the first step of the build process, see {@link Node#build} method.
       * This method is often overwritten in derived modules to prepare the node which is used as the output/result.
       * The output node must be returned in the `return` statement.
       *
       * @param {NodeBuilder} builder - The current node builder.
       * @return {Node?} The output node.
       */
    }, {
      key: "setup",
      value: function setup(builder) {
        var nodeProperties = builder.getNodeProperties(this);
        var index = 0;
        for (var childNode of this.getChildren()) {
          nodeProperties['node' + index++] = childNode;
        }

        // return a outputNode if exists or null

        return nodeProperties.outputNode || null;
      }

      /**
       * Represents the analyze stage which is the second step of the build process, see {@link Node#build} method.
       * This stage analyzes the node hierarchy and ensures descendent nodes are built.
       *
       * @param {NodeBuilder} builder - The current node builder.
       */
    }, {
      key: "analyze",
      value: function analyze(builder) {
        var usageCount = builder.increaseUsage(this);
        if (usageCount === 1) {
          // node flow children

          var nodeProperties = builder.getNodeProperties(this);
          for (var childNode of Object.values(nodeProperties)) {
            if (childNode && childNode.isNode === true) {
              childNode.build(builder);
            }
          }
        }
      }

      /**
       * Represents the generate stage which is the third step of the build process, see {@link Node#build} method.
       * This state builds the output node and returns the resulting shader string.
       *
       * @param {NodeBuilder} builder - The current node builder.
       * @param {String?} output - Can be used to define the output type.
       * @return {String?} The generated shader string.
       */
    }, {
      key: "generate",
      value: function generate(builder, output) {
        var _builder$getNodePrope = builder.getNodeProperties(this),
          outputNode = _builder$getNodePrope.outputNode;
        if (outputNode && outputNode.isNode === true) {
          return outputNode.build(builder, output);
        }
      }

      /**
       * The method can be implemented to update the node's internal state before it is used to render an object.
       * The {@link Node#updateBeforeType} property defines how often the update is executed.
       *
       * @abstract
       * @param {NodeFrame} frame - A reference to the current node frame.
       * @return {Boolean?} An optional bool that indicates whether the implementation actually performed an update or not (e.g. due to caching).
       */
    }, {
      key: "updateBefore",
      value: function updateBefore(/*frame*/
      ) {
        console.warn('Abstract function.');
      }

      /**
       * The method can be implemented to update the node's internal state after it was used to render an object.
       * The {@link Node#updateAfterType} property defines how often the update is executed.
       *
       * @abstract
       * @param {NodeFrame} frame - A reference to the current node frame.
       * @return {Boolean?} An optional bool that indicates whether the implementation actually performed an update or not (e.g. due to caching).
       */
    }, {
      key: "updateAfter",
      value: function updateAfter(/*frame*/
      ) {
        console.warn('Abstract function.');
      }

      /**
       * The method can be implemented to update the node's internal state when it is used to render an object.
       * The {@link Node#updateType} property defines how often the update is executed.
       *
       * @abstract
       * @param {NodeFrame} frame - A reference to the current node frame.
       * @return {Boolean?} An optional bool that indicates whether the implementation actually performed an update or not (e.g. due to caching).
       */
    }, {
      key: "update",
      value: function update(/*frame*/
      ) {
        console.warn('Abstract function.');
      }

      /**
       * This method performs the build of a node. The behavior of this method as well as its return value depend
       * on the current build stage (setup, analyze or generate).
       *
       * @param {NodeBuilder} builder - The current node builder.
       * @param {String?} output - Can be used to define the output type.
       * @return {String?} When this method is executed in the setup or analyze stage, `null` is returned. In the generate stage, the generated shader string.
       */
    }, {
      key: "build",
      value: function build(builder) {
        var output = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
        var refNode = this.getShared(builder);
        if (this !== refNode) {
          return refNode.build(builder, output);
        }
        builder.addNode(this);
        builder.addChain(this);

        /* Build stages expected results:
        	- "setup"		-> Node
        	- "analyze"		-> null
        	- "generate"	-> String
        */
        var result = null;
        var buildStage = builder.getBuildStage();
        if (buildStage === 'setup') {
          this.updateReference(builder);
          var properties = builder.getNodeProperties(this);
          if (properties.initialized !== true) {
            //const stackNodesBeforeSetup = builder.stack.nodes.length;

            properties.initialized = true;
            var outputNode = this.setup(builder); // return a node or null
            var isNodeOutput = outputNode && outputNode.isNode === true;

            /*if ( isNodeOutput && builder.stack.nodes.length !== stackNodesBeforeSetup ) {
            		// !! no outputNode !!
            	//outputNode = builder.stack;
            	}*/

            for (var childNode of Object.values(properties)) {
              if (childNode && childNode.isNode === true) {
                childNode.build(builder);
              }
            }
            if (isNodeOutput) {
              outputNode.build(builder);
            }
            properties.outputNode = outputNode;
          }
        } else if (buildStage === 'analyze') {
          this.analyze(builder);
        } else if (buildStage === 'generate') {
          var isGenerateOnce = this.generate.length === 1;
          if (isGenerateOnce) {
            var type = this.getNodeType(builder);
            var nodeData = builder.getDataFromNode(this);
            result = nodeData.snippet;
            if (result === undefined) {
              result = this.generate(builder) || '';
              nodeData.snippet = result;
            } else if (nodeData.flowCodes !== undefined && builder.context.nodeBlock !== undefined) {
              builder.addFlowCodeHierarchy(this, builder.context.nodeBlock);
            }
            result = builder.format(result, type, output);
          } else {
            result = this.generate(builder, output) || '';
          }
        }
        builder.removeChain(this);
        builder.addSequentialNode(this);
        return result;
      }

      /**
       * Returns the child nodes as a JSON object.
       *
       * @return {Object} The serialized child objects as JSON.
       */
    }, {
      key: "getSerializeChildren",
      value: function getSerializeChildren() {
        return getNodeChildren(this);
      }

      /**
       * Serializes the node to JSON.
       *
       * @param {Object} json - The output JSON object.
       */
    }, {
      key: "serialize",
      value: function serialize(json) {
        var nodeChildren = this.getSerializeChildren();
        var inputNodes = {};
        for (var _ref3 of nodeChildren) {
          var _property6 = _ref3.property;
          var index = _ref3.index;
          var childNode = _ref3.childNode;
          if (index !== undefined) {
            if (inputNodes[_property6] === undefined) {
              inputNodes[_property6] = Number.isInteger(index) ? [] : {};
            }
            inputNodes[_property6][index] = childNode.toJSON(json.meta).uuid;
          } else {
            inputNodes[_property6] = childNode.toJSON(json.meta).uuid;
          }
        }
        if (Object.keys(inputNodes).length > 0) {
          json.inputNodes = inputNodes;
        }
      }

      /**
       * Deserializes the node from the given JSON.
       *
       * @param {Object} json - The JSON object.
       */
    }, {
      key: "deserialize",
      value: function deserialize(json) {
        if (json.inputNodes !== undefined) {
          var nodes = json.meta.nodes;
          for (var _property7 in json.inputNodes) {
            if (Array.isArray(json.inputNodes[_property7])) {
              var inputArray = [];
              for (var uuid of json.inputNodes[_property7]) {
                inputArray.push(nodes[uuid]);
              }
              this[_property7] = inputArray;
            } else if (typeof json.inputNodes[_property7] === 'object') {
              var inputObject = {};
              for (var subProperty in json.inputNodes[_property7]) {
                var _uuid = json.inputNodes[_property7][subProperty];
                inputObject[subProperty] = nodes[_uuid];
              }
              this[_property7] = inputObject;
            } else {
              var _uuid2 = json.inputNodes[_property7];
              this[_property7] = nodes[_uuid2];
            }
          }
        }
      }

      /**
       * Serializes the node into the three.js JSON Object/Scene format.
       *
       * @param {Object?} meta - An optional JSON object that already holds serialized data from other scene objects.
       * @return {Object} The serialized node.
       */
    }, {
      key: "toJSON",
      value: function toJSON(meta) {
        var uuid = this.uuid,
          type = this.type;
        var isRoot = meta === undefined || typeof meta === 'string';
        if (isRoot) {
          meta = {
            textures: {},
            images: {},
            nodes: {}
          };
        }

        // serialize

        var data = meta.nodes[uuid];
        if (data === undefined) {
          data = {
            uuid: uuid,
            type: type,
            meta: meta,
            metadata: {
              version: 4.6,
              type: 'Node',
              generator: 'Node.toJSON'
            }
          };
          if (isRoot !== true) meta.nodes[data.uuid] = data;
          this.serialize(data);
          delete data.meta;
        }

        // TODO: Copied from Object3D.toJSON

        function extractFromCache(cache) {
          var values = [];
          for (var key in cache) {
            var _data = cache[key];
            delete _data.metadata;
            values.push(_data);
          }
          return values;
        }
        if (isRoot) {
          var textures = extractFromCache(meta.textures);
          var images = extractFromCache(meta.images);
          var nodes = extractFromCache(meta.nodes);
          if (textures.length > 0) data.textures = textures;
          if (images.length > 0) data.images = images;
          if (nodes.length > 0) data.nodes = nodes;
        }
        return data;
      }
    }], [{
      key: "type",
      get: function get() {
        return 'Node';
      }
    }]);
  }(_$$_REQUIRE(_dependencyMap[1], "./three.core.js").EventDispatcher);
  /**
   * Base class for representing element access on an array-like
   * node data structures.
   *
   * @augments Node
   */
  var ArrayElementNode = exports.ArrayElementNode = /*#__PURE__*/function (_Node) {
    /**
     * Constructs an array element node.
     *
     * @param {Node} node - The array-like node.
     * @param {Node} indexNode - The index node that defines the element access.
     */
    function ArrayElementNode(node, indexNode) {
      var _this2;
      (0, _classCallCheck2.default)(this, ArrayElementNode);
      _this2 = _callSuper(this, ArrayElementNode);

      /**
       * The array-like node.
       *
       * @type {Node}
       */
      _this2.node = node;

      /**
       * The index node that defines the element access.
       *
       * @type {Node}
       */
      _this2.indexNode = indexNode;

      /**
       * This flag can be used for type testing.
       *
       * @type {Boolean}
       * @readonly
       * @default true
       */
      _this2.isArrayElementNode = true;
      return _this2;
    }

    /**
     * This method is overwritten since the node type is inferred from the array-like node.
     *
     * @param {NodeBuilder} builder - The current node builder.
     * @return {String} The node type.
     */
    (0, _inherits2.default)(ArrayElementNode, _Node);
    return (0, _createClass2.default)(ArrayElementNode, [{
      key: "getNodeType",
      value: function getNodeType(builder) {
        return this.node.getElementType(builder);
      }
    }, {
      key: "generate",
      value: function generate(builder) {
        var nodeSnippet = this.node.build(builder);
        var indexSnippet = this.indexNode.build(builder, 'uint');
        return `${nodeSnippet}[ ${indexSnippet} ]`;
      }
    }], [{
      key: "type",
      get:
      // @TODO: If extending from TempNode it breaks webgpu_compute

      function get() {
        return 'ArrayElementNode';
      }
    }]);
  }(Node);
  /**
   * This module is part of the TSL core and usually not used in app level code.
   * It represents a convert operation during the shader generation process
   * meaning it converts the data type of a node to a target data type.
   *
   * @augments Node
   */
  var ConvertNode = exports.ConvertNode = /*#__PURE__*/function (_Node2) {
    /**
     * Constructs a new convert node.
     *
     * @param {Node} node - The node which type should be converted.
     * @param {String} convertTo - The target node type. Multiple types can be defined by separating them with a `|` sign.
     */
    function ConvertNode(node, convertTo) {
      var _this3;
      (0, _classCallCheck2.default)(this, ConvertNode);
      _this3 = _callSuper(this, ConvertNode);

      /**
       * The node which type should be converted.
       *
       * @type {Node}
       */
      _this3.node = node;

      /**
       * The target node type. Multiple types can be defined by separating them with a `|` sign.
       *
       * @type {String}
       */
      _this3.convertTo = convertTo;
      return _this3;
    }

    /**
     * This method is overwritten since the implementation tries to infer the best
     * matching type from the {@link ConvertNode#convertTo} property.
     *
     * @param {NodeBuilder} builder - The current node builder.
     * @return {String} The node type.
     */
    (0, _inherits2.default)(ConvertNode, _Node2);
    return (0, _createClass2.default)(ConvertNode, [{
      key: "getNodeType",
      value: function getNodeType(builder) {
        var requestType = this.node.getNodeType(builder);
        var convertTo = null;
        for (var overloadingType of this.convertTo.split('|')) {
          if (convertTo === null || builder.getTypeLength(requestType) === builder.getTypeLength(overloadingType)) {
            convertTo = overloadingType;
          }
        }
        return convertTo;
      }
    }, {
      key: "serialize",
      value: function serialize(data) {
        _superPropGet(ConvertNode, "serialize", this, 3)([data]);
        data.convertTo = this.convertTo;
      }
    }, {
      key: "deserialize",
      value: function deserialize(data) {
        _superPropGet(ConvertNode, "deserialize", this, 3)([data]);
        this.convertTo = data.convertTo;
      }
    }, {
      key: "generate",
      value: function generate(builder, output) {
        var node = this.node;
        var type = this.getNodeType(builder);
        var snippet = node.build(builder, type);
        return builder.format(snippet, type, output);
      }
    }], [{
      key: "type",
      get: function get() {
        return 'ConvertNode';
      }
    }]);
  }(Node);
  /**
   * This module uses cache management to create temporary variables
   * if the node is used more than once to prevent duplicate calculations.
   *
   * The class acts as a base class for many other nodes types.
   *
   * @augments Node
   */
  var TempNode = exports.TempNode = /*#__PURE__*/function (_Node3) {
    /**
     * Constructs a temp node.
     *
     * @param {String?} nodeType - The node type.
     */
    function TempNode() {
      var _this4;
      var nodeType = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      (0, _classCallCheck2.default)(this, TempNode);
      _this4 = _callSuper(this, TempNode, [nodeType]);

      /**
       * This flag can be used for type testing.
       *
       * @type {Boolean}
       * @readonly
       * @default true
       */
      _this4.isTempNode = true;
      return _this4;
    }

    /**
     * Whether this node is used more than once in context of other nodes.
     *
     * @param {NodeBuilder} builder - The node builder.
     * @return {Boolean} A flag that indicates if there is more than one dependency to other nodes.
     */
    (0, _inherits2.default)(TempNode, _Node3);
    return (0, _createClass2.default)(TempNode, [{
      key: "hasDependencies",
      value: function hasDependencies(builder) {
        return builder.getDataFromNode(this).usageCount > 1;
      }
    }, {
      key: "build",
      value: function build(builder, output) {
        var buildStage = builder.getBuildStage();
        if (buildStage === 'generate') {
          var type = builder.getVectorType(this.getNodeType(builder, output));
          var nodeData = builder.getDataFromNode(this);
          if (nodeData.propertyName !== undefined) {
            return builder.format(nodeData.propertyName, type, output);
          } else if (type !== 'void' && output !== 'void' && this.hasDependencies(builder)) {
            var snippet = _superPropGet(TempNode, "build", this, 3)([builder, type]);
            var nodeVar = builder.getVarFromNode(this, null, type);
            var propertyName = builder.getPropertyName(nodeVar);
            builder.addLineFlowCode(`${propertyName} = ${snippet}`, this);
            nodeData.snippet = snippet;
            nodeData.propertyName = propertyName;
            return builder.format(nodeData.propertyName, type, output);
          }
        }
        return _superPropGet(TempNode, "build", this, 3)([builder, output]);
      }
    }], [{
      key: "type",
      get: function get() {
        return 'TempNode';
      }
    }]);
  }(Node);
  /**
   * This module is part of the TSL core and usually not used in app level code.
   * It represents a join operation during the shader generation process.
   * For example in can compose/join two single floats into a `vec2` type.
   *
   * @augments TempNode
   */
  var JoinNode = exports.JoinNode = /*#__PURE__*/function (_TempNode) {
    /**
     * Constructs a new join node.
     *
     * @param {Array<Node>} nodes - An array of nodes that should be joined.
     * @param {String?} [nodeType=null] - The node type.
     */
    function JoinNode() {
      var _this5;
      var nodes = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      var nodeType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      (0, _classCallCheck2.default)(this, JoinNode);
      _this5 = _callSuper(this, JoinNode, [nodeType]);

      /**
       * An array of nodes that should be joined.
       *
       * @type {Array<Node>}
       */
      _this5.nodes = nodes;
      return _this5;
    }

    /**
     * This method is overwritten since the node type must be inferred from the
     * joined data length if not explicitly defined.
     *
     * @param {NodeBuilder} builder - The current node builder.
     * @return {String} The node type.
     */
    (0, _inherits2.default)(JoinNode, _TempNode);
    return (0, _createClass2.default)(JoinNode, [{
      key: "getNodeType",
      value: function getNodeType(builder) {
        if (this.nodeType !== null) {
          return builder.getVectorType(this.nodeType);
        }
        return builder.getTypeFromLength(this.nodes.reduce(function (count, cur) {
          return count + builder.getTypeLength(cur.getNodeType(builder));
        }, 0));
      }
    }, {
      key: "generate",
      value: function generate(builder, output) {
        var type = this.getNodeType(builder);
        var nodes = this.nodes;
        var primitiveType = builder.getComponentType(type);
        var snippetValues = [];
        for (var input of nodes) {
          var inputSnippet = input.build(builder);
          var inputPrimitiveType = builder.getComponentType(input.getNodeType(builder));
          if (inputPrimitiveType !== primitiveType) {
            inputSnippet = builder.format(inputSnippet, inputPrimitiveType, primitiveType);
          }
          snippetValues.push(inputSnippet);
        }
        var snippet = `${builder.getType(type)}( ${snippetValues.join(', ')} )`;
        return builder.format(snippet, type, output);
      }
    }], [{
      key: "type",
      get: function get() {
        return 'JoinNode';
      }
    }]);
  }(TempNode);
  var _stringVectorComponents = vectorComponents.join('');

  /**
   * This module is part of the TSL core and usually not used in app level code.
   * `SplitNode` represents a property access operation which means it is
   * used to implement any `.xyzw`, `.rgba` and `stpq` usage on node objects.
   * For example:
   * ```js
   * const redValue = color.r;
   * ```
   *
   * @augments Node
   */
  var SplitNode = exports.SplitNode = /*#__PURE__*/function (_Node4) {
    /**
     * Constructs a new split node.
     *
     * @param {Node} node - The node that should be accessed.
     * @param {String} [components='x'] - The components that should be accessed.
     */
    function SplitNode(node) {
      var _this6;
      var components = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'x';
      (0, _classCallCheck2.default)(this, SplitNode);
      _this6 = _callSuper(this, SplitNode);

      /**
       * The node that should be accessed.
       *
       * @type {Node}
       */
      _this6.node = node;

      /**
       * The components that should be accessed.
       *
       * @type {string}
       */
      _this6.components = components;

      /**
       * This flag can be used for type testing.
       *
       * @type {Boolean}
       * @readonly
       * @default true
       */
      _this6.isSplitNode = true;
      return _this6;
    }

    /**
     * Returns the vector length which is computed based on the requested components.
     *
     * @return {Number} The vector length.
     */
    (0, _inherits2.default)(SplitNode, _Node4);
    return (0, _createClass2.default)(SplitNode, [{
      key: "getVectorLength",
      value: function getVectorLength() {
        var vectorLength = this.components.length;
        for (var c of this.components) {
          vectorLength = Math.max(vectorComponents.indexOf(c) + 1, vectorLength);
        }
        return vectorLength;
      }

      /**
       * Returns the component type of the node's type.
       *
       * @param {NodeBuilder} builder - The current node builder.
       * @return {String} The component type.
       */
    }, {
      key: "getComponentType",
      value: function getComponentType(builder) {
        return builder.getComponentType(this.node.getNodeType(builder));
      }

      /**
       * This method is overwritten since the node type is inferred from requested components.
       *
       * @param {NodeBuilder} builder - The current node builder.
       * @return {String} The node type.
       */
    }, {
      key: "getNodeType",
      value: function getNodeType(builder) {
        return builder.getTypeFromLength(this.components.length, this.getComponentType(builder));
      }
    }, {
      key: "generate",
      value: function generate(builder, output) {
        var node = this.node;
        var nodeTypeLength = builder.getTypeLength(node.getNodeType(builder));
        var snippet = null;
        if (nodeTypeLength > 1) {
          var type = null;
          var componentsLength = this.getVectorLength();
          if (componentsLength >= nodeTypeLength) {
            // needed expand the input node

            type = builder.getTypeFromLength(this.getVectorLength(), this.getComponentType(builder));
          }
          var nodeSnippet = node.build(builder, type);
          if (this.components.length === nodeTypeLength && this.components === _stringVectorComponents.slice(0, this.components.length)) {
            // unnecessary swizzle

            snippet = builder.format(nodeSnippet, type, output);
          } else {
            snippet = builder.format(`${nodeSnippet}.${this.components}`, this.getNodeType(builder), output);
          }
        } else {
          // ignore .components if .node returns float/integer

          snippet = node.build(builder, output);
        }
        return snippet;
      }
    }, {
      key: "serialize",
      value: function serialize(data) {
        _superPropGet(SplitNode, "serialize", this, 3)([data]);
        data.components = this.components;
      }
    }, {
      key: "deserialize",
      value: function deserialize(data) {
        _superPropGet(SplitNode, "deserialize", this, 3)([data]);
        this.components = data.components;
      }
    }], [{
      key: "type",
      get: function get() {
        return 'SplitNode';
      }
    }]);
  }(Node);
  /**
   * This module is part of the TSL core and usually not used in app level code.
   * `SetNode` represents a set operation which means it is used to implement any
   * `setXYZW()`, `setRGBA()` and `setSTPQ()` method invocations on node objects.
   * For example:
   * ```js
   * materialLine.colorNode = color( 0, 0, 0 ).setR( float( 1 ) );
   * ```
   *
   * @augments TempNode
   */
  var SetNode = exports.SetNode = /*#__PURE__*/function (_TempNode2) {
    /**
     * Constructs a new set node.
     *
     * @param {Node} sourceNode - The node that should be updated.
     * @param {String} components - The components that should be updated.
     * @param {Node} targetNode - The value node.
     */
    function SetNode(sourceNode, components, targetNode) {
      var _this7;
      (0, _classCallCheck2.default)(this, SetNode);
      _this7 = _callSuper(this, SetNode);

      /**
       * The node that should be updated.
       *
       * @type {Node}
       */
      _this7.sourceNode = sourceNode;

      /**
       * The components that should be updated.
       *
       * @type {String}
       */
      _this7.components = components;

      /**
       * The value node.
       *
       * @type {Node}
       */
      _this7.targetNode = targetNode;
      return _this7;
    }

    /**
     * This method is overwritten since the node type is inferred from {@link SetNode#sourceNode}.
     *
     * @param {NodeBuilder} builder - The current node builder.
     * @return {String} The node type.
     */
    (0, _inherits2.default)(SetNode, _TempNode2);
    return (0, _createClass2.default)(SetNode, [{
      key: "getNodeType",
      value: function getNodeType(builder) {
        return this.sourceNode.getNodeType(builder);
      }
    }, {
      key: "generate",
      value: function generate(builder) {
        var sourceNode = this.sourceNode,
          components = this.components,
          targetNode = this.targetNode;
        var sourceType = this.getNodeType(builder);
        var componentType = builder.getComponentType(targetNode.getNodeType(builder));
        var targetType = builder.getTypeFromLength(components.length, componentType);
        var targetSnippet = targetNode.build(builder, targetType);
        var sourceSnippet = sourceNode.build(builder, sourceType);
        var length = builder.getTypeLength(sourceType);
        var snippetValues = [];
        for (var i = 0; i < length; i++) {
          var component = vectorComponents[i];
          if (component === components[0]) {
            snippetValues.push(targetSnippet);
            i += components.length - 1;
          } else {
            snippetValues.push(sourceSnippet + '.' + component);
          }
        }
        return `${builder.getType(sourceType)}( ${snippetValues.join(', ')} )`;
      }
    }], [{
      key: "type",
      get: function get() {
        return 'SetNode';
      }
    }]);
  }(TempNode);
  /**
   * This module is part of the TSL core and usually not used in app level code.
   * It represents a flip operation during the shader generation process
   * meaning it flips normalized values with the following formula:
   * ```
   * x = 1 - x;
   * ```
   * `FlipNode` is internally used to implement any `flipXYZW()`, `flipRGBA()` and
   * `flipSTPQ()` method invocations on node objects. For example:
   * ```js
   * uvNode = uvNode.flipY();
   * ```
   *
   * @augments TempNode
   */
  var FlipNode = /*#__PURE__*/function (_TempNode3) {
    /**
     * Constructs a new flip node.
     *
     * @param {Node} sourceNode - The node which component(s) should be flipped.
     * @param {String} components - The components that should be flipped e.g. `'x'` or `'xy'`.
     */
    function FlipNode(sourceNode, components) {
      var _this8;
      (0, _classCallCheck2.default)(this, FlipNode);
      _this8 = _callSuper(this, FlipNode);

      /**
       * The node which component(s) should be flipped.
       *
       * @type {Node}
       */
      _this8.sourceNode = sourceNode;

      /**
       * The components that should be flipped e.g. `'x'` or `'xy'`.
       *
       * @type {String}
       */
      _this8.components = components;
      return _this8;
    }

    /**
     * This method is overwritten since the node type is inferred from the source node.
     *
     * @param {NodeBuilder} builder - The current node builder.
     * @return {String} The node type.
     */
    (0, _inherits2.default)(FlipNode, _TempNode3);
    return (0, _createClass2.default)(FlipNode, [{
      key: "getNodeType",
      value: function getNodeType(builder) {
        return this.sourceNode.getNodeType(builder);
      }
    }, {
      key: "generate",
      value: function generate(builder) {
        var components = this.components,
          sourceNode = this.sourceNode;
        var sourceType = this.getNodeType(builder);
        var sourceSnippet = sourceNode.build(builder);
        var sourceCache = builder.getVarFromNode(this);
        var sourceProperty = builder.getPropertyName(sourceCache);
        builder.addLineFlowCode(sourceProperty + ' = ' + sourceSnippet, this);
        var length = builder.getTypeLength(sourceType);
        var snippetValues = [];
        var componentIndex = 0;
        for (var i = 0; i < length; i++) {
          var component = vectorComponents[i];
          if (component === components[componentIndex]) {
            snippetValues.push('1.0 - ' + (sourceProperty + '.' + component));
            componentIndex++;
          } else {
            snippetValues.push(sourceProperty + '.' + component);
          }
        }
        return `${builder.getType(sourceType)}( ${snippetValues.join(', ')} )`;
      }
    }], [{
      key: "type",
      get: function get() {
        return 'FlipNode';
      }
    }]);
  }(TempNode);
  /**
   * Base class for representing data input nodes.
   *
   * @augments Node
   */
  var InputNode = /*#__PURE__*/function (_Node5) {
    /**
     * Constructs a new input node.
     *
     * @param {Any} value - The value of this node. This can be a any JS primitive, functions, array buffers or even three.js objects (vector, matrices, colors).
     * @param {String?} nodeType - The node type. If no explicit type is defined, the node tries to derive the type from its value.
     */
    function InputNode(value) {
      var _this9;
      var nodeType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      (0, _classCallCheck2.default)(this, InputNode);
      _this9 = _callSuper(this, InputNode, [nodeType]);

      /**
       * This flag can be used for type testing.
       *
       * @type {Boolean}
       * @readonly
       * @default true
       */
      _this9.isInputNode = true;

      /**
       * The value of this node. This can be a any JS primitive, functions, array buffers or even three.js objects (vector, matrices, colors).
       *
       * @type {Any}
       */
      _this9.value = value;

      /**
       * The precision of the value in the shader.
       *
       * @type {('low'|'medium'|'high')?}
       * @default null
       */
      _this9.precision = null;
      return _this9;
    }
    (0, _inherits2.default)(InputNode, _Node5);
    return (0, _createClass2.default)(InputNode, [{
      key: "getNodeType",
      value: function getNodeType(/*builder*/
      ) {
        if (this.nodeType === null) {
          return getValueType(this.value);
        }
        return this.nodeType;
      }

      /**
       * Returns the input type of the node which is by default the node type. Derived modules
       * might overwrite this method and use a fixed type or compute one analytically.
       *
       * A typical example for different input and node types are textures. The input type of a
       * normal RGBA texture is `texture` whereas its node type is `vec4`.
       *
       * @param {NodeBuilder} builder - The current node builder.
       * @return {String} The input type.
       */
    }, {
      key: "getInputType",
      value: function getInputType(builder) {
        return this.getNodeType(builder);
      }

      /**
       * Sets the precision to the given value. The method can be
       * overwritten in derived classes if the final precision must be computed
       * analytically.
       *
       * @param {('low'|'medium'|'high')} precision - The precision of the input value in the shader.
       * @return {InputNode} A reference to this node.
       */
    }, {
      key: "setPrecision",
      value: function setPrecision(precision) {
        this.precision = precision;
        return this;
      }
    }, {
      key: "serialize",
      value: function serialize(data) {
        _superPropGet(InputNode, "serialize", this, 3)([data]);
        data.value = this.value;
        if (this.value && this.value.toArray) data.value = this.value.toArray();
        data.valueType = getValueType(this.value);
        data.nodeType = this.nodeType;
        if (data.valueType === 'ArrayBuffer') data.value = arrayBufferToBase64(data.value);
        data.precision = this.precision;
      }
    }, {
      key: "deserialize",
      value: function deserialize(data) {
        _superPropGet(InputNode, "deserialize", this, 3)([data]);
        this.nodeType = data.nodeType;
        this.value = Array.isArray(data.value) ? getValueFromType.apply(void 0, [data.valueType].concat((0, _toConsumableArray2.default)(data.value))) : data.value;
        this.precision = data.precision || null;
        if (this.value && this.value.fromArray) this.value = this.value.fromArray(data.value);
      }
    }, {
      key: "generate",
      value: function generate(/*builder, output*/
      ) {
        console.warn('Abstract function.');
      }
    }], [{
      key: "type",
      get: function get() {
        return 'InputNode';
      }
    }]);
  }(Node);
  /**
   * Class for representing a constant value in the shader.
   *
   * @augments InputNode
   */
  var ConstNode = exports.ConstNode = /*#__PURE__*/function (_InputNode) {
    /**
     * Constructs a new input node.
     *
     * @param {Any} value - The value of this node. Usually a JS primitive or three.js object (vector, matrix, color).
     * @param {String?} nodeType - The node type. If no explicit type is defined, the node tries to derive the type from its value.
     */
    function ConstNode(value) {
      var _this10;
      var nodeType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      (0, _classCallCheck2.default)(this, ConstNode);
      _this10 = _callSuper(this, ConstNode, [value, nodeType]);

      /**
       * This flag can be used for type testing.
       *
       * @type {Boolean}
       * @readonly
       * @default true
       */
      _this10.isConstNode = true;
      return _this10;
    }

    /**
     * Generates the shader string of the value with the current node builder.
     *
     * @param {NodeBuilder} builder - The current node builder.
     * @return {String} The generated value as a shader string.
     */
    (0, _inherits2.default)(ConstNode, _InputNode);
    return (0, _createClass2.default)(ConstNode, [{
      key: "generateConst",
      value: function generateConst(builder) {
        return builder.generateConst(this.getNodeType(builder), this.value);
      }
    }, {
      key: "generate",
      value: function generate(builder, output) {
        var type = this.getNodeType(builder);
        return builder.format(this.generateConst(builder), type, output);
      }
    }], [{
      key: "type",
      get: function get() {
        return 'ConstNode';
      }
    }]);
  }(InputNode); //
  var currentStack = null;
  var NodeElements = new Map();
  function addMethodChaining(name, nodeElement) {
    if (NodeElements.has(name)) {
      console.warn(`Redefinition of method chaining ${name}`);
      return;
    }
    if (typeof nodeElement !== 'function') throw new Error(`Node element ${name} is not a function`);
    NodeElements.set(name, nodeElement);
  }
  var parseSwizzle = function parseSwizzle(props) {
    return props.replace(/r|s/g, 'x').replace(/g|t/g, 'y').replace(/b|p/g, 'z').replace(/a|q/g, 'w');
  };
  var parseSwizzleAndSort = function parseSwizzleAndSort(props) {
    return parseSwizzle(props).split('').sort().join('');
  };
  var shaderNodeHandler = {
    setup: function setup(NodeClosure, params) {
      var inputs = params.shift();
      return NodeClosure.apply(void 0, [nodeObjects(inputs)].concat((0, _toConsumableArray2.default)(params)));
    },
    get: function get(node, prop, nodeObj) {
      if (typeof prop === 'string' && node[prop] === undefined) {
        if (node.isStackNode !== true && prop === 'assign') {
          return function () {
            var _currentStack;
            for (var _len3 = arguments.length, params = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
              params[_key3] = arguments[_key3];
            }
            (_currentStack = currentStack).assign.apply(_currentStack, [nodeObj].concat(params));
            return nodeObj;
          };
        } else if (NodeElements.has(prop)) {
          var nodeElement = NodeElements.get(prop);
          return node.isStackNode ? function () {
            return nodeObj.add(nodeElement.apply(void 0, arguments));
          } : function () {
            for (var _len4 = arguments.length, params = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
              params[_key4] = arguments[_key4];
            }
            return nodeElement.apply(void 0, [nodeObj].concat(params));
          };
        } else if (prop === 'self') {
          return node;
        } else if (prop.endsWith('Assign') && NodeElements.has(prop.slice(0, prop.length - 'Assign'.length))) {
          var _nodeElement = NodeElements.get(prop.slice(0, prop.length - 'Assign'.length));
          return node.isStackNode ? function () {
            return nodeObj.assign(arguments.length <= 0 ? undefined : arguments[0], _nodeElement.apply(void 0, arguments));
          } : function () {
            for (var _len5 = arguments.length, params = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
              params[_key5] = arguments[_key5];
            }
            return nodeObj.assign(_nodeElement.apply(void 0, [nodeObj].concat(params)));
          };
        } else if (/^[xyzwrgbastpq]{1,4}$/.test(prop) === true) {
          // accessing properties ( swizzle )

          prop = parseSwizzle(prop);
          return nodeObject(new SplitNode(nodeObj, prop));
        } else if (/^set[XYZWRGBASTPQ]{1,4}$/.test(prop) === true) {
          // set properties ( swizzle ) and sort to xyzw sequence

          prop = parseSwizzleAndSort(prop.slice(3).toLowerCase());
          return function (value) {
            return nodeObject(new SetNode(node, prop, value));
          };
        } else if (/^flip[XYZWRGBASTPQ]{1,4}$/.test(prop) === true) {
          // set properties ( swizzle ) and sort to xyzw sequence

          prop = parseSwizzleAndSort(prop.slice(4).toLowerCase());
          return function () {
            return nodeObject(new FlipNode(nodeObject(node), prop));
          };
        } else if (prop === 'width' || prop === 'height' || prop === 'depth') {
          // accessing property

          if (prop === 'width') prop = 'x';else if (prop === 'height') prop = 'y';else if (prop === 'depth') prop = 'z';
          return nodeObject(new SplitNode(node, prop));
        } else if (/^\d+$/.test(prop) === true) {
          // accessing array

          return nodeObject(new ArrayElementNode(nodeObj, new ConstNode(Number(prop), 'uint')));
        }
      }
      return Reflect.get(node, prop, nodeObj);
    },
    set: function set(node, prop, value, nodeObj) {
      if (typeof prop === 'string' && node[prop] === undefined) {
        // setting properties

        if (/^[xyzwrgbastpq]{1,4}$/.test(prop) === true || prop === 'width' || prop === 'height' || prop === 'depth' || /^\d+$/.test(prop) === true) {
          nodeObj[prop].assign(value);
          return true;
        }
      }
      return Reflect.set(node, prop, value, nodeObj);
    }
  };
  var nodeObjectsCacheMap = new WeakMap();
  var nodeBuilderFunctionsCacheMap = new WeakMap();
  var ShaderNodeObject = function ShaderNodeObject(obj) {
    var altType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    var type = getValueType(obj);
    if (type === 'node') {
      var _nodeObject = nodeObjectsCacheMap.get(obj);
      if (_nodeObject === undefined) {
        _nodeObject = new Proxy(obj, shaderNodeHandler);
        nodeObjectsCacheMap.set(obj, _nodeObject);
        nodeObjectsCacheMap.set(_nodeObject, _nodeObject);
      }
      return _nodeObject;
    } else if (altType === null && (type === 'float' || type === 'boolean') || type && type !== 'shader' && type !== 'string') {
      return nodeObject(getConstNode(obj, altType));
    } else if (type === 'shader') {
      return Fn(obj);
    }
    return obj;
  };
  var ShaderNodeObjects = function ShaderNodeObjects(objects) {
    var altType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    for (var name in objects) {
      objects[name] = nodeObject(objects[name], altType);
    }
    return objects;
  };
  var ShaderNodeArray = function ShaderNodeArray(array) {
    var altType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    var len = array.length;
    for (var i = 0; i < len; i++) {
      array[i] = nodeObject(array[i], altType);
    }
    return array;
  };
  var ShaderNodeProxy = function ShaderNodeProxy(NodeClass) {
    var scope = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    var factor = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
    var settings = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
    var assignNode = function assignNode(node) {
      return nodeObject(settings !== null ? Object.assign(node, settings) : node);
    };
    if (scope === null) {
      return function () {
        for (var _len6 = arguments.length, params = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
          params[_key6] = arguments[_key6];
        }
        return assignNode((0, _construct2.default)(NodeClass, (0, _toConsumableArray2.default)(nodeArray(params))));
      };
    } else if (factor !== null) {
      factor = nodeObject(factor);
      return function () {
        for (var _len7 = arguments.length, params = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {
          params[_key7] = arguments[_key7];
        }
        return assignNode((0, _construct2.default)(NodeClass, [scope].concat((0, _toConsumableArray2.default)(nodeArray(params)), [factor])));
      };
    } else {
      return function () {
        for (var _len8 = arguments.length, params = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {
          params[_key8] = arguments[_key8];
        }
        return assignNode((0, _construct2.default)(NodeClass, [scope].concat((0, _toConsumableArray2.default)(nodeArray(params)))));
      };
    }
  };
  var ShaderNodeImmutable = function ShaderNodeImmutable(NodeClass) {
    for (var _len9 = arguments.length, params = new Array(_len9 > 1 ? _len9 - 1 : 0), _key9 = 1; _key9 < _len9; _key9++) {
      params[_key9 - 1] = arguments[_key9];
    }
    return nodeObject((0, _construct2.default)(NodeClass, (0, _toConsumableArray2.default)(nodeArray(params))));
  };
  var ShaderCallNodeInternal = /*#__PURE__*/function (_Node6) {
    function ShaderCallNodeInternal(shaderNode, inputNodes) {
      var _this11;
      (0, _classCallCheck2.default)(this, ShaderCallNodeInternal);
      _this11 = _callSuper(this, ShaderCallNodeInternal);
      _this11.shaderNode = shaderNode;
      _this11.inputNodes = inputNodes;
      return _this11;
    }
    (0, _inherits2.default)(ShaderCallNodeInternal, _Node6);
    return (0, _createClass2.default)(ShaderCallNodeInternal, [{
      key: "getNodeType",
      value: function getNodeType(builder) {
        return this.shaderNode.nodeType || this.getOutputNode(builder).getNodeType(builder);
      }
    }, {
      key: "call",
      value: function call(builder) {
        var shaderNode = this.shaderNode,
          inputNodes = this.inputNodes;
        var properties = builder.getNodeProperties(shaderNode);
        if (properties.onceOutput) return properties.onceOutput;

        //

        var result = null;
        if (shaderNode.layout) {
          var functionNodesCacheMap = nodeBuilderFunctionsCacheMap.get(builder.constructor);
          if (functionNodesCacheMap === undefined) {
            functionNodesCacheMap = new WeakMap();
            nodeBuilderFunctionsCacheMap.set(builder.constructor, functionNodesCacheMap);
          }
          var functionNode = functionNodesCacheMap.get(shaderNode);
          if (functionNode === undefined) {
            functionNode = nodeObject(builder.buildFunctionNode(shaderNode));
            functionNodesCacheMap.set(shaderNode, functionNode);
          }
          if (builder.currentFunctionNode !== null) {
            builder.currentFunctionNode.includes.push(functionNode);
          }
          result = nodeObject(functionNode.call(inputNodes));
        } else {
          var jsFunc = shaderNode.jsFunc;
          var outputNode = inputNodes !== null ? jsFunc(inputNodes, builder) : jsFunc(builder);
          result = nodeObject(outputNode);
        }
        if (shaderNode.once) {
          properties.onceOutput = result;
        }
        return result;
      }
    }, {
      key: "getOutputNode",
      value: function getOutputNode(builder) {
        var properties = builder.getNodeProperties(this);
        if (properties.outputNode === null) {
          properties.outputNode = this.setupOutput(builder);
        }
        return properties.outputNode;
      }
    }, {
      key: "setup",
      value: function setup(builder) {
        return this.getOutputNode(builder);
      }
    }, {
      key: "setupOutput",
      value: function setupOutput(builder) {
        builder.addStack();
        builder.stack.outputNode = this.call(builder);
        return builder.removeStack();
      }
    }, {
      key: "generate",
      value: function generate(builder, output) {
        var outputNode = this.getOutputNode(builder);
        return outputNode.build(builder, output);
      }
    }]);
  }(Node);
  var ShaderNodeInternal = /*#__PURE__*/function (_Node7) {
    function ShaderNodeInternal(jsFunc, nodeType) {
      var _this12;
      (0, _classCallCheck2.default)(this, ShaderNodeInternal);
      _this12 = _callSuper(this, ShaderNodeInternal, [nodeType]);
      _this12.jsFunc = jsFunc;
      _this12.layout = null;
      _this12.global = true;
      _this12.once = false;
      return _this12;
    }
    (0, _inherits2.default)(ShaderNodeInternal, _Node7);
    return (0, _createClass2.default)(ShaderNodeInternal, [{
      key: "setLayout",
      value: function setLayout(layout) {
        this.layout = layout;
        return this;
      }
    }, {
      key: "call",
      value: function call() {
        var inputs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
        nodeObjects(inputs);
        return nodeObject(new ShaderCallNodeInternal(this, inputs));
      }
    }, {
      key: "setup",
      value: function setup() {
        return this.call();
      }
    }]);
  }(Node);
  var bools = [false, true];
  var uints = [0, 1, 2, 3];
  var ints = [-1, -2];
  var floats = [0.5, 1.5, 1 / 3, 1e-6, 1e6, Math.PI, Math.PI * 2, 1 / Math.PI, 2 / Math.PI, 1 / (Math.PI * 2), Math.PI / 2];
  var boolsCacheMap = new Map();
  for (var _bool of bools) boolsCacheMap.set(_bool, new ConstNode(_bool));
  var uintsCacheMap = new Map();
  for (var _uint of uints) uintsCacheMap.set(_uint, new ConstNode(_uint, 'uint'));
  var intsCacheMap = new Map((0, _toConsumableArray2.default)(uintsCacheMap).map(function (el) {
    return new ConstNode(el.value, 'int');
  }));
  for (var _int of ints) intsCacheMap.set(_int, new ConstNode(_int, 'int'));
  var floatsCacheMap = new Map((0, _toConsumableArray2.default)(intsCacheMap).map(function (el) {
    return new ConstNode(el.value);
  }));
  for (var _float of floats) floatsCacheMap.set(_float, new ConstNode(_float));
  for (var _float2 of floats) floatsCacheMap.set(-_float2, new ConstNode(-_float2));
  var cacheMaps = {
    bool: boolsCacheMap,
    uint: uintsCacheMap,
    ints: intsCacheMap,
    float: floatsCacheMap
  };
  var constNodesCacheMap = new Map([].concat((0, _toConsumableArray2.default)(boolsCacheMap), (0, _toConsumableArray2.default)(floatsCacheMap)));
  var getConstNode = function getConstNode(value, type) {
    if (constNodesCacheMap.has(value)) {
      return constNodesCacheMap.get(value);
    } else if (value.isNode === true) {
      return value;
    } else {
      return new ConstNode(value, type);
    }
  };
  var safeGetNodeType = function safeGetNodeType(node) {
    try {
      return node.getNodeType();
    } catch (_) {
      return undefined;
    }
  };
  var ConvertType = function ConvertType(type) {
    var cacheMap = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    return function () {
      for (var _len10 = arguments.length, params = new Array(_len10), _key10 = 0; _key10 < _len10; _key10++) {
        params[_key10] = arguments[_key10];
      }
      if (params.length === 0 || !['bool', 'float', 'int', 'uint'].includes(type) && params.every(function (param) {
        return typeof param !== 'object';
      })) {
        params = [getValueFromType.apply(void 0, [type].concat((0, _toConsumableArray2.default)(params)))];
      }
      if (params.length === 1 && cacheMap !== null && cacheMap.has(params[0])) {
        return nodeObject(cacheMap.get(params[0]));
      }
      if (params.length === 1) {
        var node = getConstNode(params[0], type);
        if (safeGetNodeType(node) === type) return nodeObject(node);
        return nodeObject(new ConvertNode(node, type));
      }
      var nodes = params.map(function (param) {
        return getConstNode(param);
      });
      return nodeObject(new JoinNode(nodes, type));
    };
  };

  // exports

  var defined = function defined(v) {
    return typeof v === 'object' && v !== null ? v.value : v;
  }; // TODO: remove boolean conversion and defined function

  // utils

  var getConstNodeType = function getConstNodeType(value) {
    return value !== undefined && value !== null ? value.nodeType || value.convertTo || (typeof value === 'string' ? value : null) : null;
  };

  // shader node base

  function ShaderNode(jsFunc, nodeType) {
    return new Proxy(new ShaderNodeInternal(jsFunc, nodeType), shaderNodeHandler);
  }
  var nodeObject = function nodeObject(val) {
    var altType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    return /* new */ShaderNodeObject(val, altType);
  };
  var nodeObjects = function nodeObjects(val) {
    var altType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    return new ShaderNodeObjects(val, altType);
  };
  var nodeArray = function nodeArray(val) {
    var altType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    return new ShaderNodeArray(val, altType);
  };
  var nodeProxy = function nodeProxy() {
    for (var _len11 = arguments.length, params = new Array(_len11), _key11 = 0; _key11 < _len11; _key11++) {
      params[_key11] = arguments[_key11];
    }
    return (0, _construct2.default)(ShaderNodeProxy, params);
  };
  var nodeImmutable = function nodeImmutable() {
    for (var _len12 = arguments.length, params = new Array(_len12), _key12 = 0; _key12 < _len12; _key12++) {
      params[_key12] = arguments[_key12];
    }
    return (0, _construct2.default)(ShaderNodeImmutable, params);
  };
  var Fn = function Fn(jsFunc, nodeType) {
    var shaderNode = new ShaderNode(jsFunc, nodeType);
    var fn = function fn() {
      var inputs;
      for (var _len13 = arguments.length, params = new Array(_len13), _key13 = 0; _key13 < _len13; _key13++) {
        params[_key13] = arguments[_key13];
      }
      nodeObjects(params);
      if (params[0] && params[0].isNode) {
        inputs = [].concat(params);
      } else {
        inputs = params[0];
      }
      return shaderNode.call(inputs);
    };
    fn.shaderNode = shaderNode;
    fn.setLayout = function (layout) {
      shaderNode.setLayout(layout);
      return fn;
    };
    fn.once = function () {
      shaderNode.once = true;
      return fn;
    };
    return fn;
  };
  var tslFn = function tslFn() {
    // @deprecated, r168

    console.warn('TSL.ShaderNode: tslFn() has been renamed to Fn().');
    return Fn.apply(void 0, arguments);
  };

  //

  addMethodChaining('toGlobal', function (node) {
    node.global = true;
    return node;
  });

  //

  var setCurrentStack = function setCurrentStack(stack) {
    currentStack = stack;
  };
  var getCurrentStack = function getCurrentStack() {
    return currentStack;
  };
  var If = function If() {
    var _currentStack2;
    return (_currentStack2 = currentStack).If.apply(_currentStack2, arguments);
  };
  function append(node) {
    if (currentStack) currentStack.add(node);
    return node;
  }
  addMethodChaining('append', append);

  // types

  var color = new ConvertType('color');
  var float = new ConvertType('float', cacheMaps.float);
  var int = new ConvertType('int', cacheMaps.ints);
  var uint = new ConvertType('uint', cacheMaps.uint);
  var bool = new ConvertType('bool', cacheMaps.bool);
  var vec2 = new ConvertType('vec2');
  var ivec2 = new ConvertType('ivec2');
  var uvec2 = new ConvertType('uvec2');
  var bvec2 = new ConvertType('bvec2');
  var vec3 = new ConvertType('vec3');
  var ivec3 = new ConvertType('ivec3');
  var uvec3 = new ConvertType('uvec3');
  var bvec3 = new ConvertType('bvec3');
  var vec4 = new ConvertType('vec4');
  var ivec4 = new ConvertType('ivec4');
  var uvec4 = new ConvertType('uvec4');
  var bvec4 = new ConvertType('bvec4');
  var mat2 = new ConvertType('mat2');
  var mat3 = new ConvertType('mat3');
  var mat4 = new ConvertType('mat4');
  var string = function string() {
    var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
    return nodeObject(new ConstNode(value, 'string'));
  };
  var arrayBuffer = function arrayBuffer(value) {
    return nodeObject(new ConstNode(value, 'ArrayBuffer'));
  };
  addMethodChaining('toColor', color);
  addMethodChaining('toFloat', float);
  addMethodChaining('toInt', int);
  addMethodChaining('toUint', uint);
  addMethodChaining('toBool', bool);
  addMethodChaining('toVec2', vec2);
  addMethodChaining('toIVec2', ivec2);
  addMethodChaining('toUVec2', uvec2);
  addMethodChaining('toBVec2', bvec2);
  addMethodChaining('toVec3', vec3);
  addMethodChaining('toIVec3', ivec3);
  addMethodChaining('toUVec3', uvec3);
  addMethodChaining('toBVec3', bvec3);
  addMethodChaining('toVec4', vec4);
  addMethodChaining('toIVec4', ivec4);
  addMethodChaining('toUVec4', uvec4);
  addMethodChaining('toBVec4', bvec4);
  addMethodChaining('toMat2', mat2);
  addMethodChaining('toMat3', mat3);
  addMethodChaining('toMat4', mat4);

  // basic nodes

  var element = /*@__PURE__*/nodeProxy(ArrayElementNode);
  var convert = function convert(node, types) {
    return nodeObject(new ConvertNode(nodeObject(node), types));
  };
  var split = function split(node, channels) {
    return nodeObject(new SplitNode(nodeObject(node), channels));
  };
  addMethodChaining('element', element);
  addMethodChaining('convert', convert);

  /** @module UniformGroupNode **/

  /**
   * This node can be used to group single instances of {@link UniformNode}
   * and manage them as a uniform buffer.
   *
   * In most cases, the predefined nodes `objectGroup`, `renderGroup` and `frameGroup`
   * will be used when defining the {@link UniformNode#groupNode} property.
   *
   * - `objectGroup`: Uniform buffer per object.
   * - `renderGroup`: Shared uniform buffer, updated once per render call.
   * - `frameGroup`: Shared uniform buffer, updated once per frame.
   *
   * @augments Node
   */
  var UniformGroupNode = exports.UniformGroupNode = /*#__PURE__*/function (_Node8) {
    /**
     * Constructs a new uniform group node.
     *
     * @param {String} name - The name of the uniform group node.
     * @param {Boolean} [shared=false] - Whether this uniform group node is shared or not.
     * @param {Number} [order=1] - Influences the internal sorting.
     */
    function UniformGroupNode(name) {
      var _this13;
      var shared = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      var order = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
      (0, _classCallCheck2.default)(this, UniformGroupNode);
      _this13 = _callSuper(this, UniformGroupNode, ['string']);

      /**
       * The name of the uniform group node.
       *
       * @type {String}
       */
      _this13.name = name;

      /**
       * Whether this uniform group node is shared or not.
       *
       * @type {Boolean}
       * @default false
       */
      _this13.shared = shared;

      /**
       * Influences the internal sorting.
       * TODO: Add details when this property should be changed.
       *
       * @type {Number}
       * @default 1
       */
      _this13.order = order;

      /**
       * This flag can be used for type testing.
       *
       * @type {Boolean}
       * @readonly
       * @default true
       */
      _this13.isUniformGroup = true;
      return _this13;
    }
    (0, _inherits2.default)(UniformGroupNode, _Node8);
    return (0, _createClass2.default)(UniformGroupNode, [{
      key: "serialize",
      value: function serialize(data) {
        _superPropGet(UniformGroupNode, "serialize", this, 3)([data]);
        data.name = this.name;
        data.version = this.version;
        data.shared = this.shared;
      }
    }, {
      key: "deserialize",
      value: function deserialize(data) {
        _superPropGet(UniformGroupNode, "deserialize", this, 3)([data]);
        this.name = data.name;
        this.version = data.version;
        this.shared = data.shared;
      }
    }], [{
      key: "type",
      get: function get() {
        return 'UniformGroupNode';
      }
    }]);
  }(Node);
  /**
   * TSL function for creating a uniform group node with the given name.
   *
   * @function
   * @param {String} name - The name of the uniform group node.
   * @returns {UniformGroupNode}
   */
  var uniformGroup = function uniformGroup(name) {
    return new UniformGroupNode(name);
  };

  /**
   * TSL function for creating a shared uniform group node with the given name and order.
   *
   * @function
   * @param {String} name - The name of the uniform group node.
   * @param {Number} [order=0] - Influences the internal sorting.
   * @returns {UniformGroupNode}
   */
  var sharedUniformGroup = function sharedUniformGroup(name) {
    var order = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    return new UniformGroupNode(name, true, order);
  };

  /**
   * TSL object that represents a shared uniform group node which is updated once per frame.
   *
   * @type {UniformGroupNode}
   */
  var frameGroup = /*@__PURE__*/sharedUniformGroup('frame');

  /**
   * TSL object that represents a shared uniform group node which is updated once per render.
   *
   * @type {UniformGroupNode}
   */
  var renderGroup = /*@__PURE__*/sharedUniformGroup('render');

  /**
   * TSL object that represents a uniform group node which is updated once per object.
   *
   * @type {UniformGroupNode}
   */
  var objectGroup = /*@__PURE__*/uniformGroup('object');

  /** @module UniformNode **/

  /**
   * Class for representing a uniform.
   *
   * @augments InputNode
   */
  var UniformNode = exports.UniformNode = /*#__PURE__*/function (_InputNode2) {
    /**
     * Constructs a new uniform node.
     *
     * @param {Any} value - The value of this node. Usually a JS primitive or three.js object (vector, matrix, color, texture).
     * @param {String?} nodeType - The node type. If no explicit type is defined, the node tries to derive the type from its value.
     */
    function UniformNode(value) {
      var _this14;
      var nodeType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      (0, _classCallCheck2.default)(this, UniformNode);
      _this14 = _callSuper(this, UniformNode, [value, nodeType]);

      /**
       * This flag can be used for type testing.
       *
       * @type {Boolean}
       * @readonly
       * @default true
       */
      _this14.isUniformNode = true;

      /**
       * The name or label of the uniform.
       *
       * @type {String}
       * @default ''
       */
      _this14.name = '';

      /**
       * The uniform group of this uniform. By default, uniforms are
       * managed per object but they might belong to a shared group
       * which is updated per frame or render call.
       *
       * @type {UniformGroupNode}
       */
      _this14.groupNode = objectGroup;
      return _this14;
    }

    /**
     * Sets the {@link UniformNode#name} property.
     *
     * @param {String} name - The name of the uniform.
     * @return {UniformNode} A reference to this node.
     */
    (0, _inherits2.default)(UniformNode, _InputNode2);
    return (0, _createClass2.default)(UniformNode, [{
      key: "label",
      value: function label(name) {
        this.name = name;
        return this;
      }

      /**
       * Sets the {@link UniformNode#groupNode} property.
       *
       * @param {UniformGroupNode} group - The uniform group.
       * @return {UniformNode} A reference to this node.
       */
    }, {
      key: "setGroup",
      value: function setGroup(group) {
        this.groupNode = group;
        return this;
      }

      /**
       * Returns the {@link UniformNode#groupNode}.
       *
       * @return {UniformGroupNode} The uniform group.
       */
    }, {
      key: "getGroup",
      value: function getGroup() {
        return this.groupNode;
      }

      /**
       * By default, this method returns the result of {@link Node#getHash} but derived
       * classes might overwrite this method with a different implementation.
       *
       * @param {NodeBuilder} builder - The current node builder.
       * @return {String} The uniform hash.
       */
    }, {
      key: "getUniformHash",
      value: function getUniformHash(builder) {
        return this.getHash(builder);
      }
    }, {
      key: "onUpdate",
      value: function onUpdate(callback, updateType) {
        var _this15 = this;
        var self = this.getSelf();
        callback = callback.bind(self);
        return _superPropGet(UniformNode, "onUpdate", this, 3)([function (frame) {
          var value = callback(frame, self);
          if (value !== undefined) {
            _this15.value = value;
          }
        }, updateType]);
      }
    }, {
      key: "generate",
      value: function generate(builder, output) {
        var type = this.getNodeType(builder);
        var hash = this.getUniformHash(builder);
        var sharedNode = builder.getNodeFromHash(hash);
        if (sharedNode === undefined) {
          builder.setHashNode(this, hash);
          sharedNode = this;
        }
        var sharedNodeType = sharedNode.getInputType(builder);
        var nodeUniform = builder.getUniformFromNode(sharedNode, sharedNodeType, builder.shaderStage, this.name || builder.context.label);
        var propertyName = builder.getPropertyName(nodeUniform);
        if (builder.context.label !== undefined) delete builder.context.label;
        return builder.format(propertyName, type, output);
      }
    }], [{
      key: "type",
      get: function get() {
        return 'UniformNode';
      }
    }]);
  }(InputNode);
  /**
   * TSL function for creating a uniform node.
   *
   * @function
   * @param {Any} arg1 - The value of this node. Usually a JS primitive or three.js object (vector, matrix, color, texture).
   * @param {String?} arg2 - The node type. If no explicit type is defined, the node tries to derive the type from its value.
   * @returns {UniformNode}
   */
  var uniform = function uniform(arg1, arg2) {
    var nodeType = getConstNodeType(arg2 || arg1);

    // @TODO: get ConstNode from .traverse() in the future
    var value = arg1 && arg1.isNode === true ? arg1.node && arg1.node.value || arg1.value : arg1;
    return nodeObject(new UniformNode(value, nodeType));
  };

  /** @module PropertyNode **/

  /**
   * This class represents a shader property. It can be used
   * to explicitly define a property and assign a value to it.
   *
   * ```js
   * const threshold = property( 'float', 'threshold' ).assign( THRESHOLD );
   *```
   * `PropertyNode` is used by the engine to predefined common material properties
   * for TSL code.
   *
   * @augments Node
   */
  var PropertyNode = exports.PropertyNode = /*#__PURE__*/function (_Node9) {
    /**
     * Constructs a new property node.
     *
     * @param {String} nodeType - The type of the node.
     * @param {String?} [name=null] - The name of the property in the shader.
     * @param {Boolean} [varying=false] - Whether this property is a varying or not.
     */
    function PropertyNode(nodeType) {
      var _this16;
      var name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      var varying = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      (0, _classCallCheck2.default)(this, PropertyNode);
      _this16 = _callSuper(this, PropertyNode, [nodeType]);

      /**
       * The name of the property in the shader. If no name is defined,
       * the node system auto-generates one.
       *
       * @type {String?}
       * @default null
       */
      _this16.name = name;

      /**
       * Whether this property is a varying or not.
       *
       * @type {Boolean}
       * @default false
       */
      _this16.varying = varying;

      /**
       * This flag can be used for type testing.
       *
       * @type {Boolean}
       * @readonly
       * @default true
       */
      _this16.isPropertyNode = true;
      return _this16;
    }
    (0, _inherits2.default)(PropertyNode, _Node9);
    return (0, _createClass2.default)(PropertyNode, [{
      key: "getHash",
      value: function getHash(builder) {
        return this.name || _superPropGet(PropertyNode, "getHash", this, 3)([builder]);
      }

      /**
       * The method is overwritten so it always returns `true`.
       *
       * @param {NodeBuilder} builder - The current node builder.
       * @return {Boolean} Whether this node is global or not.
       */
    }, {
      key: "isGlobal",
      value: function isGlobal(/*builder*/
      ) {
        return true;
      }
    }, {
      key: "generate",
      value: function generate(builder) {
        var nodeVar;
        if (this.varying === true) {
          nodeVar = builder.getVaryingFromNode(this, this.name);
          nodeVar.needsInterpolation = true;
        } else {
          nodeVar = builder.getVarFromNode(this, this.name);
        }
        return builder.getPropertyName(nodeVar);
      }
    }], [{
      key: "type",
      get: function get() {
        return 'PropertyNode';
      }
    }]);
  }(Node);
  /**
   * TSL function for creating a property node.
   *
   * @function
   * @param {String} type - The type of the node.
   * @param {String?} [name=null] - The name of the property in the shader.
   * @returns {PropertyNode}
   */
  var property = function property(type, name) {
    return nodeObject(new PropertyNode(type, name));
  };

  /**
   * TSL function for creating a varying property node.
   *
   * @function
   * @param {String} type - The type of the node.
   * @param {String?} [name=null] - The name of the varying in the shader.
   * @returns {PropertyNode}
   */
  var varyingProperty = function varyingProperty(type, name) {
    return nodeObject(new PropertyNode(type, name, true));
  };

  /**
   * TSL object that represents the shader variable `DiffuseColor`.
   *
   * @type {PropertyNode<vec4>}
   */
  var diffuseColor = /*@__PURE__*/nodeImmutable(PropertyNode, 'vec4', 'DiffuseColor');

  /**
   * TSL object that represents the shader variable `EmissiveColor`.
   *
   * @type {PropertyNode<vec3>}
   */
  var emissive = /*@__PURE__*/nodeImmutable(PropertyNode, 'vec3', 'EmissiveColor');

  /**
   * TSL object that represents the shader variable `Roughness`.
   *
   * @type {PropertyNode<float>}
   */
  var roughness = /*@__PURE__*/nodeImmutable(PropertyNode, 'float', 'Roughness');

  /**
   * TSL object that represents the shader variable `Metalness`.
   *
   * @type {PropertyNode<float>}
   */
  var metalness = /*@__PURE__*/nodeImmutable(PropertyNode, 'float', 'Metalness');

  /**
   * TSL object that represents the shader variable `Clearcoat`.
   *
   * @type {PropertyNode<float>}
   */
  var clearcoat = /*@__PURE__*/nodeImmutable(PropertyNode, 'float', 'Clearcoat');

  /**
   * TSL object that represents the shader variable `ClearcoatRoughness`.
   *
   * @type {PropertyNode<float>}
   */
  var clearcoatRoughness = /*@__PURE__*/nodeImmutable(PropertyNode, 'float', 'ClearcoatRoughness');

  /**
   * TSL object that represents the shader variable `Sheen`.
   *
   * @type {PropertyNode<vec3>}
   */
  var sheen = /*@__PURE__*/nodeImmutable(PropertyNode, 'vec3', 'Sheen');

  /**
   * TSL object that represents the shader variable `SheenRoughness`.
   *
   * @type {PropertyNode<float>}
   */
  var sheenRoughness = /*@__PURE__*/nodeImmutable(PropertyNode, 'float', 'SheenRoughness');

  /**
   * TSL object that represents the shader variable `Iridescence`.
   *
   * @type {PropertyNode<float>}
   */
  var iridescence = /*@__PURE__*/nodeImmutable(PropertyNode, 'float', 'Iridescence');

  /**
   * TSL object that represents the shader variable `IridescenceIOR`.
   *
   * @type {PropertyNode<float>}
   */
  var iridescenceIOR = /*@__PURE__*/nodeImmutable(PropertyNode, 'float', 'IridescenceIOR');

  /**
   * TSL object that represents the shader variable `IridescenceThickness`.
   *
   * @type {PropertyNode<float>}
   */
  var iridescenceThickness = /*@__PURE__*/nodeImmutable(PropertyNode, 'float', 'IridescenceThickness');

  /**
   * TSL object that represents the shader variable `AlphaT`.
   *
   * @type {PropertyNode<float>}
   */
  var alphaT = /*@__PURE__*/nodeImmutable(PropertyNode, 'float', 'AlphaT');

  /**
   * TSL object that represents the shader variable `Anisotropy`.
   *
   * @type {PropertyNode<float>}
   */
  var anisotropy = /*@__PURE__*/nodeImmutable(PropertyNode, 'float', 'Anisotropy');

  /**
   * TSL object that represents the shader variable `AnisotropyT`.
   *
   * @type {PropertyNode<vec3>}
   */
  var anisotropyT = /*@__PURE__*/nodeImmutable(PropertyNode, 'vec3', 'AnisotropyT');

  /**
   * TSL object that represents the shader variable `AnisotropyB`.
   *
   * @type {PropertyNode<vec3>}
   */
  var anisotropyB = /*@__PURE__*/nodeImmutable(PropertyNode, 'vec3', 'AnisotropyB');

  /**
   * TSL object that represents the shader variable `SpecularColor`.
   *
   * @type {PropertyNode<color>}
   */
  var specularColor = /*@__PURE__*/nodeImmutable(PropertyNode, 'color', 'SpecularColor');

  /**
   * TSL object that represents the shader variable `SpecularF90`.
   *
   * @type {PropertyNode<float>}
   */
  var specularF90 = /*@__PURE__*/nodeImmutable(PropertyNode, 'float', 'SpecularF90');

  /**
   * TSL object that represents the shader variable `Shininess`.
   *
   * @type {PropertyNode<float>}
   */
  var shininess = /*@__PURE__*/nodeImmutable(PropertyNode, 'float', 'Shininess');

  /**
   * TSL object that represents the shader variable `Output`.
   *
   * @type {PropertyNode<vec4>}
   */
  var output = /*@__PURE__*/nodeImmutable(PropertyNode, 'vec4', 'Output');

  /**
   * TSL object that represents the shader variable `dashSize`.
   *
   * @type {PropertyNode<float>}
   */
  var dashSize = /*@__PURE__*/nodeImmutable(PropertyNode, 'float', 'dashSize');

  /**
   * TSL object that represents the shader variable `gapSize`.
   *
   * @type {PropertyNode<float>}
   */
  var gapSize = /*@__PURE__*/nodeImmutable(PropertyNode, 'float', 'gapSize');

  /**
   * TSL object that represents the shader variable `pointWidth`.
   *
   * @type {PropertyNode<float>}
   */
  var pointWidth = /*@__PURE__*/nodeImmutable(PropertyNode, 'float', 'pointWidth');

  /**
   * TSL object that represents the shader variable `IOR`.
   *
   * @type {PropertyNode<float>}
   */
  var ior = /*@__PURE__*/nodeImmutable(PropertyNode, 'float', 'IOR');

  /**
   * TSL object that represents the shader variable `Transmission`.
   *
   * @type {PropertyNode<float>}
   */
  var transmission = /*@__PURE__*/nodeImmutable(PropertyNode, 'float', 'Transmission');

  /**
   * TSL object that represents the shader variable `Thickness`.
   *
   * @type {PropertyNode<float>}
   */
  var thickness = /*@__PURE__*/nodeImmutable(PropertyNode, 'float', 'Thickness');

  /**
   * TSL object that represents the shader variable `AttenuationDistance`.
   *
   * @type {PropertyNode<float>}
   */
  var attenuationDistance = /*@__PURE__*/nodeImmutable(PropertyNode, 'float', 'AttenuationDistance');

  /**
   * TSL object that represents the shader variable `AttenuationColor`.
   *
   * @type {PropertyNode<color>}
   */
  var attenuationColor = /*@__PURE__*/nodeImmutable(PropertyNode, 'color', 'AttenuationColor');

  /**
   * TSL object that represents the shader variable `Dispersion`.
   *
   * @type {PropertyNode<float>}
   */
  var dispersion = /*@__PURE__*/nodeImmutable(PropertyNode, 'float', 'Dispersion');

  /** @module AssignNode **/

  /**
   * These node represents an assign operation. Meaning a node is assigned
   * to another node.
   *
   * @augments TempNode
   */
  var AssignNode = exports.AssignNode = /*#__PURE__*/function (_TempNode4) {
    /**
     * Constructs a new assign node.
     *
     * @param {Node} targetNode - The target node.
     * @param {Node} sourceNode - The source type.
     */
    function AssignNode(targetNode, sourceNode) {
      var _this17;
      (0, _classCallCheck2.default)(this, AssignNode);
      _this17 = _callSuper(this, AssignNode);

      /**
       * The target node.
       *
       * @type {Node}
       */
      _this17.targetNode = targetNode;

      /**
       * The source node.
       *
       * @type {Node}
       */
      _this17.sourceNode = sourceNode;
      return _this17;
    }

    /**
     * Whether this node is used more than once in context of other nodes. This method
     * is overwritten since it always returns `false` (assigns are unique).
     *
     * @return {Boolean} A flag that indicates if there is more than one dependency to other nodes. Always `false`.
     */
    (0, _inherits2.default)(AssignNode, _TempNode4);
    return (0, _createClass2.default)(AssignNode, [{
      key: "hasDependencies",
      value: function hasDependencies() {
        return false;
      }
    }, {
      key: "getNodeType",
      value: function getNodeType(builder, output) {
        return output !== 'void' ? this.targetNode.getNodeType(builder) : 'void';
      }

      /**
       * Whether a split is required when assigning source to target. This can happen when the component length of
       * target and source data type does not match.
       *
       * @param {NodeBuilder} builder - The current node builder.
       * @return {Boolean} Whether a split is required when assigning source to target.
       */
    }, {
      key: "needsSplitAssign",
      value: function needsSplitAssign(builder) {
        var targetNode = this.targetNode;
        if (builder.isAvailable('swizzleAssign') === false && targetNode.isSplitNode && targetNode.components.length > 1) {
          var targetLength = builder.getTypeLength(targetNode.node.getNodeType(builder));
          var assignDifferentVector = vectorComponents.join('').slice(0, targetLength) !== targetNode.components;
          return assignDifferentVector;
        }
        return false;
      }
    }, {
      key: "generate",
      value: function generate(builder, output) {
        var targetNode = this.targetNode,
          sourceNode = this.sourceNode;
        var needsSplitAssign = this.needsSplitAssign(builder);
        var targetType = targetNode.getNodeType(builder);
        var target = targetNode.context({
          assign: true
        }).build(builder);
        var source = sourceNode.build(builder, targetType);
        var sourceType = sourceNode.getNodeType(builder);
        var nodeData = builder.getDataFromNode(this);

        //

        var snippet;
        if (nodeData.initialized === true) {
          if (output !== 'void') {
            snippet = target;
          }
        } else if (needsSplitAssign) {
          var sourceVar = builder.getVarFromNode(this, null, targetType);
          var sourceProperty = builder.getPropertyName(sourceVar);
          builder.addLineFlowCode(`${sourceProperty} = ${source}`, this);
          var targetRoot = targetNode.node.context({
            assign: true
          }).build(builder);
          for (var i = 0; i < targetNode.components.length; i++) {
            var component = targetNode.components[i];
            builder.addLineFlowCode(`${targetRoot}.${component} = ${sourceProperty}[ ${i} ]`, this);
          }
          if (output !== 'void') {
            snippet = target;
          }
        } else {
          snippet = `${target} = ${source}`;
          if (output === 'void' || sourceType === 'void') {
            builder.addLineFlowCode(snippet, this);
            if (output !== 'void') {
              snippet = target;
            }
          }
        }
        nodeData.initialized = true;
        return builder.format(snippet, targetType, output);
      }
    }], [{
      key: "type",
      get: function get() {
        return 'AssignNode';
      }
    }]);
  }(TempNode);
  /**
   * TSL function for creating an assign node.
   *
   * @function
   * @param {Node} targetNode - The target node.
   * @param {Node} sourceNode - The source type.
   * @returns {AssignNode}
   */
  var assign = /*@__PURE__*/nodeProxy(AssignNode);
  addMethodChaining('assign', assign);

  /**
   * This module represents the call of a {@link FunctionNode}. Developers are usually not confronted
   * with this module since they use the predefined TSL syntax `wgslFn` and `glslFn` which encapsulate
   * this logic.
   *
   * @augments TempNode
   */
  var FunctionCallNode = exports.FunctionCallNode = /*#__PURE__*/function (_TempNode5) {
    /**
     * Constructs a new function call node.
     *
     * @param {FunctionNode?} functionNode - The function node.
     * @param {Object<String, Node>} [parameters={}] - The parameters for the function call.
     */
    function FunctionCallNode() {
      var _this18;
      var functionNode = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      var parameters = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      (0, _classCallCheck2.default)(this, FunctionCallNode);
      _this18 = _callSuper(this, FunctionCallNode);

      /**
       * The function node.
       *
       * @type {FunctionNode}
       * @default null
       */
      _this18.functionNode = functionNode;

      /**
       * The parameters of the function call.
       *
       * @type {Object<String, Node>}
       * @default {}
       */
      _this18.parameters = parameters;
      return _this18;
    }

    /**
     * Sets the parameters of the function call node.
     *
     * @param {Object<String, Node>} parameters - The parameters to set.
     * @return {FunctionCallNode} A reference to this node.
     */
    (0, _inherits2.default)(FunctionCallNode, _TempNode5);
    return (0, _createClass2.default)(FunctionCallNode, [{
      key: "setParameters",
      value: function setParameters(parameters) {
        this.parameters = parameters;
        return this;
      }

      /**
       * Returns the parameters of the function call node.
       *
       * @return {Object<String, Node>} The parameters of this node.
       */
    }, {
      key: "getParameters",
      value: function getParameters() {
        return this.parameters;
      }
    }, {
      key: "getNodeType",
      value: function getNodeType(builder) {
        return this.functionNode.getNodeType(builder);
      }
    }, {
      key: "generate",
      value: function generate(builder) {
        var params = [];
        var functionNode = this.functionNode;
        var inputs = functionNode.getInputs(builder);
        var parameters = this.parameters;
        var generateInput = function generateInput(node, inputNode) {
          var type = inputNode.type;
          var pointer = type === 'pointer';
          var output;
          if (pointer) output = '&' + node.build(builder);else output = node.build(builder, type);
          return output;
        };
        if (Array.isArray(parameters)) {
          for (var i = 0; i < parameters.length; i++) {
            params.push(generateInput(parameters[i], inputs[i]));
          }
        } else {
          for (var inputNode of inputs) {
            var node = parameters[inputNode.name];
            if (node !== undefined) {
              params.push(generateInput(node, inputNode));
            } else {
              throw new Error(`FunctionCallNode: Input '${inputNode.name}' not found in FunctionNode.`);
            }
          }
        }
        var functionName = functionNode.build(builder, 'property');
        return `${functionName}( ${params.join(', ')} )`;
      }
    }], [{
      key: "type",
      get: function get() {
        return 'FunctionCallNode';
      }
    }]);
  }(TempNode);
  var call = function call(func) {
    for (var _len14 = arguments.length, params = new Array(_len14 > 1 ? _len14 - 1 : 0), _key14 = 1; _key14 < _len14; _key14++) {
      params[_key14 - 1] = arguments[_key14];
    }
    params = params.length > 1 || params[0] && params[0].isNode === true ? nodeArray(params) : nodeObjects(params[0]);
    return nodeObject(new FunctionCallNode(nodeObject(func), params));
  };
  addMethodChaining('call', call);

  /** @module OperatorNode **/

  /**
   * This node represents basic mathematical and logical operations like addition,
   * subtraction or comparisons (e.g. `equal()`).
   *
   * @augments TempNode
   */
  var OperatorNode = /*#__PURE__*/function (_TempNode6) {
    /**
     * Constructs a new operator node.
     *
     * @param {String} op - The operator.
     * @param {Node} aNode - The first input.
     * @param {Node} bNode - The second input.
     * @param {...Node} params - Additional input parameters.
     */
    function OperatorNode(op, aNode, bNode) {
      var _this19;
      (0, _classCallCheck2.default)(this, OperatorNode);
      _this19 = _callSuper(this, OperatorNode);
      if ((arguments.length <= 3 ? 0 : arguments.length - 3) > 0) {
        var _ref4;
        var finalOp = new OperatorNode(op, aNode, bNode);
        for (var i = 0; i < (arguments.length <= 3 ? 0 : arguments.length - 3) - 1; i++) {
          finalOp = new OperatorNode(op, finalOp, i + 3 < 3 || arguments.length <= i + 3 ? undefined : arguments[i + 3]);
        }
        aNode = finalOp;
        bNode = (_ref4 = (arguments.length <= 3 ? 0 : arguments.length - 3) - 1 + 3, _ref4 < 3 || arguments.length <= _ref4 ? undefined : arguments[_ref4]);
      }

      /**
       * The operator.
       *
       * @type {String}
       */
      _this19.op = op;

      /**
       * The first input.
       *
       * @type {Node}
       */
      _this19.aNode = aNode;

      /**
       * The second input.
       *
       * @type {Node}
       */
      _this19.bNode = bNode;
      return _this19;
    }

    /**
     * This method is overwritten since the node type is inferred from the operator
     * and the input node types.
     *
     * @param {NodeBuilder} builder - The current node builder.
     * @param {String} output - The current output string.
     * @return {String} The node type.
     */
    (0, _inherits2.default)(OperatorNode, _TempNode6);
    return (0, _createClass2.default)(OperatorNode, [{
      key: "getNodeType",
      value: function getNodeType(builder, output) {
        var op = this.op;
        var aNode = this.aNode;
        var bNode = this.bNode;
        var typeA = aNode.getNodeType(builder);
        var typeB = typeof bNode !== 'undefined' ? bNode.getNodeType(builder) : null;
        if (typeA === 'void' || typeB === 'void') {
          return 'void';
        } else if (op === '%') {
          return typeA;
        } else if (op === '~' || op === '&' || op === '|' || op === '^' || op === '>>' || op === '<<') {
          return builder.getIntegerType(typeA);
        } else if (op === '!' || op === '==' || op === '&&' || op === '||' || op === '^^') {
          return 'bool';
        } else if (op === '<' || op === '>' || op === '<=' || op === '>=') {
          var typeLength = output ? builder.getTypeLength(output) : Math.max(builder.getTypeLength(typeA), builder.getTypeLength(typeB));
          return typeLength > 1 ? `bvec${typeLength}` : 'bool';
        } else {
          if (typeA === 'float' && builder.isMatrix(typeB)) {
            return typeB;
          } else if (builder.isMatrix(typeA) && builder.isVector(typeB)) {
            // matrix x vector

            return builder.getVectorFromMatrix(typeA);
          } else if (builder.isVector(typeA) && builder.isMatrix(typeB)) {
            // vector x matrix

            return builder.getVectorFromMatrix(typeB);
          } else if (builder.getTypeLength(typeB) > builder.getTypeLength(typeA)) {
            // anytype x anytype: use the greater length vector

            return typeB;
          }
          return typeA;
        }
      }
    }, {
      key: "generate",
      value: function generate(builder, output) {
        var op = this.op;
        var aNode = this.aNode;
        var bNode = this.bNode;
        var type = this.getNodeType(builder, output);
        var typeA = null;
        var typeB = null;
        if (type !== 'void') {
          typeA = aNode.getNodeType(builder);
          typeB = typeof bNode !== 'undefined' ? bNode.getNodeType(builder) : null;
          if (op === '<' || op === '>' || op === '<=' || op === '>=' || op === '==') {
            if (builder.isVector(typeA)) {
              typeB = typeA;
            } else if (typeA !== typeB) {
              typeA = typeB = 'float';
            }
          } else if (op === '>>' || op === '<<') {
            typeA = type;
            typeB = builder.changeComponentType(typeB, 'uint');
          } else if (builder.isMatrix(typeA) && builder.isVector(typeB)) {
            // matrix x vector

            typeB = builder.getVectorFromMatrix(typeA);
          } else if (builder.isVector(typeA) && builder.isMatrix(typeB)) {
            // vector x matrix

            typeA = builder.getVectorFromMatrix(typeB);
          } else {
            // anytype x anytype

            typeA = typeB = type;
          }
        } else {
          typeA = typeB = type;
        }
        var a = aNode.build(builder, typeA);
        var b = typeof bNode !== 'undefined' ? bNode.build(builder, typeB) : null;
        var outputLength = builder.getTypeLength(output);
        var fnOpSnippet = builder.getFunctionOperator(op);
        if (output !== 'void') {
          if (op === '<' && outputLength > 1) {
            if (builder.useComparisonMethod) {
              return builder.format(`${builder.getMethod('lessThan', output)}( ${a}, ${b} )`, type, output);
            } else {
              return builder.format(`( ${a} < ${b} )`, type, output);
            }
          } else if (op === '<=' && outputLength > 1) {
            if (builder.useComparisonMethod) {
              return builder.format(`${builder.getMethod('lessThanEqual', output)}( ${a}, ${b} )`, type, output);
            } else {
              return builder.format(`( ${a} <= ${b} )`, type, output);
            }
          } else if (op === '>' && outputLength > 1) {
            if (builder.useComparisonMethod) {
              return builder.format(`${builder.getMethod('greaterThan', output)}( ${a}, ${b} )`, type, output);
            } else {
              return builder.format(`( ${a} > ${b} )`, type, output);
            }
          } else if (op === '>=' && outputLength > 1) {
            if (builder.useComparisonMethod) {
              return builder.format(`${builder.getMethod('greaterThanEqual', output)}( ${a}, ${b} )`, type, output);
            } else {
              return builder.format(`( ${a} >= ${b} )`, type, output);
            }
          } else if (op === '!' || op === '~') {
            return builder.format(`(${op}${a})`, typeA, output);
          } else if (fnOpSnippet) {
            return builder.format(`${fnOpSnippet}( ${a}, ${b} )`, type, output);
          } else {
            return builder.format(`( ${a} ${op} ${b} )`, type, output);
          }
        } else if (typeA !== 'void') {
          if (fnOpSnippet) {
            return builder.format(`${fnOpSnippet}( ${a}, ${b} )`, type, output);
          } else {
            return builder.format(`${a} ${op} ${b}`, type, output);
          }
        }
      }
    }, {
      key: "serialize",
      value: function serialize(data) {
        _superPropGet(OperatorNode, "serialize", this, 3)([data]);
        data.op = this.op;
      }
    }, {
      key: "deserialize",
      value: function deserialize(data) {
        _superPropGet(OperatorNode, "deserialize", this, 3)([data]);
        this.op = data.op;
      }
    }], [{
      key: "type",
      get: function get() {
        return 'OperatorNode';
      }
    }]);
  }(TempNode);
  /**
   * Returns the addition of two or more value.
   *
   * @function
   * @param {Node} aNode - The first input.
   * @param {Node} bNode - The second input.
   * @param {...Node} params - Additional input parameters.
   * @returns {OperatorNode}
   */
  var add = /*@__PURE__*/nodeProxy(OperatorNode, '+');

  /**
   * Returns the subtraction of two or more value.
   *
   * @function
   * @param {Node} aNode - The first input.
   * @param {Node} bNode - The second input.
   * @param {...Node} params - Additional input parameters.
   * @returns {OperatorNode}
   */
  var sub = /*@__PURE__*/nodeProxy(OperatorNode, '-');

  /**
   * Returns the multiplication of two or more value.
   *
   * @function
   * @param {Node} aNode - The first input.
   * @param {Node} bNode - The second input.
   * @param {...Node} params - Additional input parameters.
   * @returns {OperatorNode}
   */
  var mul = /*@__PURE__*/nodeProxy(OperatorNode, '*');

  /**
   * Returns the division of two or more value.
   *
   * @function
   * @param {Node} aNode - The first input.
   * @param {Node} bNode - The second input.
   * @param {...Node} params - Additional input parameters.
   * @returns {OperatorNode}
   */
  var div = /*@__PURE__*/nodeProxy(OperatorNode, '/');

  /**
   * Computes the remainder of dividing the first node by the second, for integer values.
   *
   * @function
   * @param {Node} aNode - The first input.
   * @param {Node} bNode - The second input.
   * @returns {OperatorNode}
   */
  var modInt = /*@__PURE__*/nodeProxy(OperatorNode, '%');

  /**
   * Checks if two nodes are equal.
   *
   * @function
   * @param {Node} aNode - The first input.
   * @param {Node} bNode - The second input.
   * @returns {OperatorNode}
   */
  var equal = /*@__PURE__*/nodeProxy(OperatorNode, '==');

  /**
   * Checks if two nodes are not equal.
   *
   * @function
   * @param {Node} aNode - The first input.
   * @param {Node} bNode - The second input.
   * @returns {OperatorNode}
   */
  var notEqual = /*@__PURE__*/nodeProxy(OperatorNode, '!=');

  /**
   * Checks if the first node is less than the second.
   *
   * @function
   * @param {Node} aNode - The first input.
   * @param {Node} bNode - The second input.
   * @returns {OperatorNode}
   */
  var lessThan = /*@__PURE__*/nodeProxy(OperatorNode, '<');

  /**
   * Checks if the first node is greater than the second.
   *
   * @function
   * @param {Node} aNode - The first input.
   * @param {Node} bNode - The second input.
   * @returns {OperatorNode}
   */
  var greaterThan = /*@__PURE__*/nodeProxy(OperatorNode, '>');

  /**
   * Checks if the first node is less than or equal to the second.
   *
   * @function
   * @param {Node} aNode - The first input.
   * @param {Node} bNode - The second input.
   * @returns {OperatorNode}
   */
  var lessThanEqual = /*@__PURE__*/nodeProxy(OperatorNode, '<=');

  /**
   * Checks if the first node is greater than or equal to the second.
   *
   * @function
   * @param {Node} aNode - The first input.
   * @param {Node} bNode - The second input.
   * @returns {OperatorNode}
   */
  var greaterThanEqual = /*@__PURE__*/nodeProxy(OperatorNode, '>=');

  /**
   * Performs logical AND on two nodes.
   *
   * @function
   * @param {Node} aNode - The first input.
   * @param {Node} bNode - The second input.
   * @returns {OperatorNode}
   */
  var and = /*@__PURE__*/nodeProxy(OperatorNode, '&&');

  /**
   * Performs logical OR on two nodes.
   *
   * @function
   * @param {Node} aNode - The first input.
   * @param {Node} bNode - The second input.
   * @returns {OperatorNode}
   */
  var or = /*@__PURE__*/nodeProxy(OperatorNode, '||');

  /**
   * Performs logical NOT on a node.
   *
   * @function
   * @param {Node} aNode - The first input.
   * @param {Node} bNode - The second input.
   * @returns {OperatorNode}
   */
  var not = /*@__PURE__*/nodeProxy(OperatorNode, '!');

  /**
   * Performs logical XOR on two nodes.
   *
   * @function
   * @param {Node} aNode - The first input.
   * @param {Node} bNode - The second input.
   * @returns {OperatorNode}
   */
  var xor = /*@__PURE__*/nodeProxy(OperatorNode, '^^');

  /**
   * Performs bitwise AND on two nodes.
   *
   * @function
   * @param {Node} aNode - The first input.
   * @param {Node} bNode - The second input.
   * @returns {OperatorNode}
   */
  var bitAnd = /*@__PURE__*/nodeProxy(OperatorNode, '&');

  /**
   * Performs bitwise NOT on a node.
   *
   * @function
   * @param {Node} aNode - The first input.
   * @param {Node} bNode - The second input.
   * @returns {OperatorNode}
   */
  var bitNot = /*@__PURE__*/nodeProxy(OperatorNode, '~');

  /**
   * Performs bitwise OR on two nodes.
   *
   * @function
   * @param {Node} aNode - The first input.
   * @param {Node} bNode - The second input.
   * @returns {OperatorNode}
   */
  var bitOr = /*@__PURE__*/nodeProxy(OperatorNode, '|');

  /**
   * Performs bitwise XOR on two nodes.
   *
   * @function
   * @param {Node} aNode - The first input.
   * @param {Node} bNode - The second input.
   * @returns {OperatorNode}
   */
  var bitXor = /*@__PURE__*/nodeProxy(OperatorNode, '^');

  /**
   * Shifts a node to the left.
   *
   * @function
   * @param {Node} aNode - The node to shift.
   * @param {Node} bNode - The value to shift.
   * @returns {OperatorNode}
   */
  var shiftLeft = /*@__PURE__*/nodeProxy(OperatorNode, '<<');

  /**
   * Shifts a node to the right.
   *
   * @function
   * @param {Node} aNode - The node to shift.
   * @param {Node} bNode - The value to shift.
   * @returns {OperatorNode}
   */
  var shiftRight = /*@__PURE__*/nodeProxy(OperatorNode, '>>');
  addMethodChaining('add', add);
  addMethodChaining('sub', sub);
  addMethodChaining('mul', mul);
  addMethodChaining('div', div);
  addMethodChaining('modInt', modInt);
  addMethodChaining('equal', equal);
  addMethodChaining('notEqual', notEqual);
  addMethodChaining('lessThan', lessThan);
  addMethodChaining('greaterThan', greaterThan);
  addMethodChaining('lessThanEqual', lessThanEqual);
  addMethodChaining('greaterThanEqual', greaterThanEqual);
  addMethodChaining('and', and);
  addMethodChaining('or', or);
  addMethodChaining('not', not);
  addMethodChaining('xor', xor);
  addMethodChaining('bitAnd', bitAnd);
  addMethodChaining('bitNot', bitNot);
  addMethodChaining('bitOr', bitOr);
  addMethodChaining('bitXor', bitXor);
  addMethodChaining('shiftLeft', shiftLeft);
  addMethodChaining('shiftRight', shiftRight);
  var remainder = function remainder() {
    // @deprecated, r168

    console.warn('TSL.OperatorNode: .remainder() has been renamed to .modInt().');
    return modInt.apply(void 0, arguments);
  };
  addMethodChaining('remainder', remainder);

  /** @module MathNode **/

  /**
   * This node represents a variety of mathematical methods available in shaders.
   * They are divided into three categories:
   *
   * - Methods with one input like `sin`, `cos` or `normalize`.
   * - Methods with two inputs like `dot`, `cross` or `pow`.
   * - Methods with three inputs like `mix`, `clamp` or `smoothstep`.
   *
   * @augments TempNode
   */
  var MathNode = /*#__PURE__*/function (_TempNode7) {
    /**
     * Constructs a new math node.
     *
     * @param {String} method - The method name.
     * @param {Node} aNode - The first input.
     * @param {Node?} [bNode=null] - The second input.
     * @param {Node?} [cNode=null] - The third input.
     */
    function MathNode(method, aNode) {
      var _this20;
      var bNode = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
      var cNode = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
      (0, _classCallCheck2.default)(this, MathNode);
      _this20 = _callSuper(this, MathNode);

      /**
       * The method name.
       *
       * @type {String}
       */
      _this20.method = method;

      /**
       * The first input.
       *
       * @type {Node}
       */
      _this20.aNode = aNode;

      /**
       * The second input.
       *
       * @type {Node?}
       * @default null
       */
      _this20.bNode = bNode;

      /**
       * The third input.
       *
       * @type {Node?}
       * @default null
       */
      _this20.cNode = cNode;
      return _this20;
    }

    /**
     * The input type is inferred from the node types of the input nodes.
     *
     * @param {NodeBuilder} builder - The current node builder.
     * @return {String} The input type.
     */
    (0, _inherits2.default)(MathNode, _TempNode7);
    return (0, _createClass2.default)(MathNode, [{
      key: "getInputType",
      value: function getInputType(builder) {
        var aType = this.aNode.getNodeType(builder);
        var bType = this.bNode ? this.bNode.getNodeType(builder) : null;
        var cType = this.cNode ? this.cNode.getNodeType(builder) : null;
        var aLen = builder.isMatrix(aType) ? 0 : builder.getTypeLength(aType);
        var bLen = builder.isMatrix(bType) ? 0 : builder.getTypeLength(bType);
        var cLen = builder.isMatrix(cType) ? 0 : builder.getTypeLength(cType);
        if (aLen > bLen && aLen > cLen) {
          return aType;
        } else if (bLen > cLen) {
          return bType;
        } else if (cLen > aLen) {
          return cType;
        }
        return aType;
      }

      /**
       * The selected method as well as the input type determine the node type of this node.
       *
       * @param {NodeBuilder} builder - The current node builder.
       * @return {String} The node type.
       */
    }, {
      key: "getNodeType",
      value: function getNodeType(builder) {
        var method = this.method;
        if (method === MathNode.LENGTH || method === MathNode.DISTANCE || method === MathNode.DOT) {
          return 'float';
        } else if (method === MathNode.CROSS) {
          return 'vec3';
        } else if (method === MathNode.ALL) {
          return 'bool';
        } else if (method === MathNode.EQUALS) {
          return builder.changeComponentType(this.aNode.getNodeType(builder), 'bool');
        } else if (method === MathNode.MOD) {
          return this.aNode.getNodeType(builder);
        } else {
          return this.getInputType(builder);
        }
      }
    }, {
      key: "generate",
      value: function generate(builder, output) {
        var method = this.method;
        var type = this.getNodeType(builder);
        var inputType = this.getInputType(builder);
        var a = this.aNode;
        var b = this.bNode;
        var c = this.cNode;
        var coordinateSystem = builder.renderer.coordinateSystem;
        if (method === MathNode.TRANSFORM_DIRECTION) {
          // dir can be either a direction vector or a normal vector
          // upper-left 3x3 of matrix is assumed to be orthogonal

          var tA = a;
          var tB = b;
          if (builder.isMatrix(tA.getNodeType(builder))) {
            tB = vec4(vec3(tB), 0.0);
          } else {
            tA = vec4(vec3(tA), 0.0);
          }
          var mulNode = mul(tA, tB).xyz;
          return normalize(mulNode).build(builder, output);
        } else if (method === MathNode.NEGATE) {
          return builder.format('( - ' + a.build(builder, inputType) + ' )', type, output);
        } else if (method === MathNode.ONE_MINUS) {
          return sub(1.0, a).build(builder, output);
        } else if (method === MathNode.RECIPROCAL) {
          return div(1.0, a).build(builder, output);
        } else if (method === MathNode.DIFFERENCE) {
          return abs(sub(a, b)).build(builder, output);
        } else {
          var params = [];
          if (method === MathNode.CROSS || method === MathNode.MOD) {
            params.push(a.build(builder, type), b.build(builder, type));
          } else if (coordinateSystem === _$$_REQUIRE(_dependencyMap[1], "./three.core.js").WebGLCoordinateSystem && method === MathNode.STEP) {
            params.push(a.build(builder, builder.getTypeLength(a.getNodeType(builder)) === 1 ? 'float' : inputType), b.build(builder, inputType));
          } else if (coordinateSystem === _$$_REQUIRE(_dependencyMap[1], "./three.core.js").WebGLCoordinateSystem && (method === MathNode.MIN || method === MathNode.MAX) || method === MathNode.MOD) {
            params.push(a.build(builder, inputType), b.build(builder, builder.getTypeLength(b.getNodeType(builder)) === 1 ? 'float' : inputType));
          } else if (method === MathNode.REFRACT) {
            params.push(a.build(builder, inputType), b.build(builder, inputType), c.build(builder, 'float'));
          } else if (method === MathNode.MIX) {
            params.push(a.build(builder, inputType), b.build(builder, inputType), c.build(builder, builder.getTypeLength(c.getNodeType(builder)) === 1 ? 'float' : inputType));
          } else {
            if (coordinateSystem === _$$_REQUIRE(_dependencyMap[1], "./three.core.js").WebGPUCoordinateSystem && method === MathNode.ATAN && b !== null) {
              method = 'atan2';
            }
            params.push(a.build(builder, inputType));
            if (b !== null) params.push(b.build(builder, inputType));
            if (c !== null) params.push(c.build(builder, inputType));
          }
          return builder.format(`${builder.getMethod(method, type)}( ${params.join(', ')} )`, type, output);
        }
      }
    }, {
      key: "serialize",
      value: function serialize(data) {
        _superPropGet(MathNode, "serialize", this, 3)([data]);
        data.method = this.method;
      }
    }, {
      key: "deserialize",
      value: function deserialize(data) {
        _superPropGet(MathNode, "deserialize", this, 3)([data]);
        this.method = data.method;
      }
    }], [{
      key: "type",
      get: function get() {
        return 'MathNode';
      }
    }]);
  }(TempNode); // 1 input
  MathNode.ALL = 'all';
  MathNode.ANY = 'any';
  MathNode.RADIANS = 'radians';
  MathNode.DEGREES = 'degrees';
  MathNode.EXP = 'exp';
  MathNode.EXP2 = 'exp2';
  MathNode.LOG = 'log';
  MathNode.LOG2 = 'log2';
  MathNode.SQRT = 'sqrt';
  MathNode.INVERSE_SQRT = 'inversesqrt';
  MathNode.FLOOR = 'floor';
  MathNode.CEIL = 'ceil';
  MathNode.NORMALIZE = 'normalize';
  MathNode.FRACT = 'fract';
  MathNode.SIN = 'sin';
  MathNode.COS = 'cos';
  MathNode.TAN = 'tan';
  MathNode.ASIN = 'asin';
  MathNode.ACOS = 'acos';
  MathNode.ATAN = 'atan';
  MathNode.ABS = 'abs';
  MathNode.SIGN = 'sign';
  MathNode.LENGTH = 'length';
  MathNode.NEGATE = 'negate';
  MathNode.ONE_MINUS = 'oneMinus';
  MathNode.DFDX = 'dFdx';
  MathNode.DFDY = 'dFdy';
  MathNode.ROUND = 'round';
  MathNode.RECIPROCAL = 'reciprocal';
  MathNode.TRUNC = 'trunc';
  MathNode.FWIDTH = 'fwidth';
  MathNode.TRANSPOSE = 'transpose';

  // 2 inputs

  MathNode.BITCAST = 'bitcast';
  MathNode.EQUALS = 'equals';
  MathNode.MIN = 'min';
  MathNode.MAX = 'max';
  MathNode.MOD = 'mod';
  MathNode.STEP = 'step';
  MathNode.REFLECT = 'reflect';
  MathNode.DISTANCE = 'distance';
  MathNode.DIFFERENCE = 'difference';
  MathNode.DOT = 'dot';
  MathNode.CROSS = 'cross';
  MathNode.POW = 'pow';
  MathNode.TRANSFORM_DIRECTION = 'transformDirection';

  // 3 inputs

  MathNode.MIX = 'mix';
  MathNode.CLAMP = 'clamp';
  MathNode.REFRACT = 'refract';
  MathNode.SMOOTHSTEP = 'smoothstep';
  MathNode.FACEFORWARD = 'faceforward';

  // 1 inputs

  /**
   * A small value used to handle floating-point precision errors.
   *
   * @type {Node<float>}
   */
  var EPSILON = /*@__PURE__*/float(1e-6);

  /**
   * Represents infinity.
   *
   * @type {Node<float>}
   */
  var INFINITY = /*@__PURE__*/float(1e6);

  /**
   * Represents PI.
   *
   * @type {Node<float>}
   */
  var PI = /*@__PURE__*/float(Math.PI);

  /**
   * Represents PI * 2.
   *
   * @type {Node<float>}
   */
  var PI2 = /*@__PURE__*/float(Math.PI * 2);

  /**
   * Returns `true` if all components of `x` are `true`.
   *
   * @function
   * @param {Node | Number} x - The parameter.
   * @returns {Node<bool>}
   */
  var all = /*@__PURE__*/nodeProxy(MathNode, MathNode.ALL);

  /**
   * Returns `true` if any components of `x` are `true`.
   *
   * @function
   * @param {Node | Number} x - The parameter.
   * @returns {Node<bool>}
   */
  var any = /*@__PURE__*/nodeProxy(MathNode, MathNode.ANY);

  /**
   * Converts a quantity in degrees to radians.
   *
   * @function
   * @param {Node | Number} x - The input in degrees.
   * @returns {Node}
   */
  var radians = /*@__PURE__*/nodeProxy(MathNode, MathNode.RADIANS);

  /**
   * Convert a quantity in radians to degrees.
   *
   * @function
   * @param {Node | Number} x - The input in radians.
   * @returns {Node}
   */
  var degrees = /*@__PURE__*/nodeProxy(MathNode, MathNode.DEGREES);

  /**
   * Returns the natural exponentiation of the parameter.
   *
   * @function
   * @param {Node | Number} x - The parameter.
   * @returns {Node}
   */
  var exp = /*@__PURE__*/nodeProxy(MathNode, MathNode.EXP);

  /**
   * Returns 2 raised to the power of the parameter.
   *
   * @function
   * @param {Node | Number} x - The parameter.
   * @returns {Node}
   */
  var exp2 = /*@__PURE__*/nodeProxy(MathNode, MathNode.EXP2);

  /**
   * Returns the natural logarithm of the parameter.
   *
   * @function
   * @param {Node | Number} x - The parameter.
   * @returns {Node}
   */
  var log = /*@__PURE__*/nodeProxy(MathNode, MathNode.LOG);

  /**
   * Returns the base 2 logarithm of the parameter.
   *
   * @function
   * @param {Node | Number} x - The parameter.
   * @returns {Node}
   */
  var log2 = /*@__PURE__*/nodeProxy(MathNode, MathNode.LOG2);

  /**
   * Returns the square root of the parameter.
   *
   * @function
   * @param {Node | Number} x - The parameter.
   * @returns {Node}
   */
  var sqrt = /*@__PURE__*/nodeProxy(MathNode, MathNode.SQRT);

  /**
   * Returns the inverse of the square root of the parameter.
   *
   * @function
   * @param {Node | Number} x - The parameter.
   * @returns {Node}
   */
  var inverseSqrt = /*@__PURE__*/nodeProxy(MathNode, MathNode.INVERSE_SQRT);

  /**
   * Finds the nearest integer less than or equal to the parameter.
   *
   * @function
   * @param {Node | Number} x - The parameter.
   * @returns {Node}
   */
  var floor = /*@__PURE__*/nodeProxy(MathNode, MathNode.FLOOR);

  /**
   * Finds the nearest integer that is greater than or equal to the parameter.
   *
   * @function
   * @param {Node | Number} x - The parameter.
   * @returns {Node}
   */
  var ceil = /*@__PURE__*/nodeProxy(MathNode, MathNode.CEIL);

  /**
   * Calculates the unit vector in the same direction as the original vector.
   *
   * @function
   * @param {Node} x - The input vector.
   * @returns {Node}
   */
  var normalize = /*@__PURE__*/nodeProxy(MathNode, MathNode.NORMALIZE);

  /**
   * Computes the fractional part of the parameter.
   *
   * @function
   * @param {Node | Number} x - The parameter.
   * @returns {Node}
   */
  var fract = /*@__PURE__*/nodeProxy(MathNode, MathNode.FRACT);

  /**
   * Returns the sine of the parameter.
   *
   * @function
   * @param {Node | Number} x - The parameter.
   * @returns {Node}
   */
  var sin = /*@__PURE__*/nodeProxy(MathNode, MathNode.SIN);

  /**
   * Returns the cosine of the parameter.
   *
   * @function
   * @param {Node | Number} x - The parameter.
   * @returns {Node}
   */
  var cos = /*@__PURE__*/nodeProxy(MathNode, MathNode.COS);

  /**
   * Returns the tangent of the parameter.
   *
   * @function
   * @param {Node | Number} x - The parameter.
   * @returns {Node}
   */
  var tan = /*@__PURE__*/nodeProxy(MathNode, MathNode.TAN);

  /**
   * Returns the arcsine of the parameter.
   *
   * @function
   * @param {Node | Number} x - The parameter.
   * @returns {Node}
   */
  var asin = /*@__PURE__*/nodeProxy(MathNode, MathNode.ASIN);

  /**
   * Returns the arccosine of the parameter.
   *
   * @function
   * @param {Node | Number} x - The parameter.
   * @returns {Node}
   */
  var acos = /*@__PURE__*/nodeProxy(MathNode, MathNode.ACOS);

  /**
   * Returns the arc-tangent of the parameter.
   *
   * @function
   * @param {Node | Number} x - The parameter.
   * @returns {Node}
   */
  var atan = /*@__PURE__*/nodeProxy(MathNode, MathNode.ATAN);

  /**
   * Returns the absolute value of the parameter.
   *
   * @function
   * @param {Node | Number} x - The parameter.
   * @returns {Node}
   */
  var abs = /*@__PURE__*/nodeProxy(MathNode, MathNode.ABS);

  /**
   * Extracts the sign of the parameter.
   *
   * @function
   * @param {Node | Number} x - The parameter.
   * @returns {Node}
   */
  var sign = /*@__PURE__*/nodeProxy(MathNode, MathNode.SIGN);

  /**
   * Calculates the length of a vector.
   *
   * @function
   * @param {Node} x - The parameter.
   * @returns {Node<float>}
   */
  var length = /*@__PURE__*/nodeProxy(MathNode, MathNode.LENGTH);

  /**
   * Negates the value of the parameter (-x).
   *
   * @function
   * @param {Node | Number} x - The parameter.
   * @returns {Node}
   */
  var negate = /*@__PURE__*/nodeProxy(MathNode, MathNode.NEGATE);

  /**
   * Return `1` minus the parameter.
   *
   * @function
   * @param {Node | Number} x - The parameter.
   * @returns {Node}
   */
  var oneMinus = /*@__PURE__*/nodeProxy(MathNode, MathNode.ONE_MINUS);

  /**
   * Returns the partial derivative of the parameter with respect to x.
   *
   * @function
   * @param {Node | Number} x - The parameter.
   * @returns {Node}
   */
  var dFdx = /*@__PURE__*/nodeProxy(MathNode, MathNode.DFDX);

  /**
   * Returns the partial derivative of the parameter with respect to y.
   *
   * @function
   * @param {Node | Number} x - The parameter.
   * @returns {Node}
   */
  var dFdy = /*@__PURE__*/nodeProxy(MathNode, MathNode.DFDY);

  /**
   * Rounds the parameter to the nearest integer.
   *
   * @function
   * @param {Node | Number} x - The parameter.
   * @returns {Node}
   */
  var round = /*@__PURE__*/nodeProxy(MathNode, MathNode.ROUND);

  /**
   * Returns the reciprocal of the parameter `(1/x)`.
   *
   * @function
   * @param {Node | Number} x - The parameter.
   * @returns {Node}
   */
  var reciprocal = /*@__PURE__*/nodeProxy(MathNode, MathNode.RECIPROCAL);

  /**
   * Truncates the parameter, removing the fractional part.
   *
   * @function
   * @param {Node | Number} x - The parameter.
   * @returns {Node}
   */
  var trunc = /*@__PURE__*/nodeProxy(MathNode, MathNode.TRUNC);

  /**
   * Returns the sum of the absolute derivatives in x and y.
   *
   * @function
   * @param {Node | Number} x - The parameter.
   * @returns {Node}
   */
  var fwidth = /*@__PURE__*/nodeProxy(MathNode, MathNode.FWIDTH);

  /**
   * Returns the transpose of a matrix.
   *
   * @function
   * @param {Node<mat2|mat3|mat4>} x - The parameter.
   * @returns {Node}
   */
  var transpose = /*@__PURE__*/nodeProxy(MathNode, MathNode.TRANSPOSE);

  // 2 inputs

  /**
   * Reinterpret the bit representation of a value in one type as a value in another type.
   *
   * @function
   * @param {Node | Number} x - The parameter.
   * @param {String} y - The new type.
   * @returns {Node}
   */
  var bitcast = /*@__PURE__*/nodeProxy(MathNode, MathNode.BITCAST);

  /**
   * Returns `true` if `x` equals `y`.
   *
   * @function
   * @param {Node | Number} x - The first parameter.
   * @param {Node | Number} y - The second parameter.
   * @returns {Node<bool>}
   */
  var equals = /*@__PURE__*/nodeProxy(MathNode, MathNode.EQUALS);

  /**
   * Returns the lesser of two values.
   *
   * @function
   * @param {Node | Number} x - The y parameter.
   * @param {Node | Number} y - The x parameter.
   * @returns {Node}
   */
  var min$1 = /*@__PURE__*/nodeProxy(MathNode, MathNode.MIN);

  /**
   * Returns the greater of two values.
   *
   * @function
   * @param {Node | Number} x - The y parameter.
   * @param {Node | Number} y - The x parameter.
   * @returns {Node}
   */
  var max$1 = /*@__PURE__*/nodeProxy(MathNode, MathNode.MAX);

  /**
   * Computes the remainder of dividing the first node by the second one.
   *
   * @function
   * @param {Node | Number} x - The y parameter.
   * @param {Node | Number} y - The x parameter.
   * @returns {Node}
   */
  var mod = /*@__PURE__*/nodeProxy(MathNode, MathNode.MOD);

  /**
   * Generate a step function by comparing two values.
   *
   * @function
   * @param {Node | Number} x - The y parameter.
   * @param {Node | Number} y - The x parameter.
   * @returns {Node}
   */
  var step = /*@__PURE__*/nodeProxy(MathNode, MathNode.STEP);

  /**
   * Calculates the reflection direction for an incident vector.
   *
   * @function
   * @param {Node<vec2|vec3|vec4>} I - The incident vector.
   * @param {Node<vec2|vec3|vec4>} N - The normal vector.
   * @returns {Node<vec2|vec3|vec4>}
   */
  var reflect = /*@__PURE__*/nodeProxy(MathNode, MathNode.REFLECT);

  /**
   * Calculates the distance between two points.
   *
   * @function
   * @param {Node<vec2|vec3|vec4>} x - The first point.
   * @param {Node<vec2|vec3|vec4>} y - The second point.
   * @returns {Node<float>}
   */
  var distance = /*@__PURE__*/nodeProxy(MathNode, MathNode.DISTANCE);

  /**
   * Calculates the absolute difference between two values.
   *
   * @function
   * @param {Node | Number} x - The first parameter.
   * @param {Node | Number} y - The second parameter.
   * @returns {Node}
   */
  var difference = /*@__PURE__*/nodeProxy(MathNode, MathNode.DIFFERENCE);

  /**
   * Calculates the dot product of two vectors.
   *
   * @function
   * @param {Node<vec2|vec3|vec4>} x - The first vector.
   * @param {Node<vec2|vec3|vec4>} y - The second vector.
   * @returns {Node<float>}
   */
  var dot = /*@__PURE__*/nodeProxy(MathNode, MathNode.DOT);

  /**
   * Calculates the cross product of two vectors.
   *
   * @function
   * @param {Node<vec2|vec3|vec4>} x - The first vector.
   * @param {Node<vec2|vec3|vec4>} y - The second vector.
   * @returns {Node<vec2|vec3|vec4>}
   */
  var cross = /*@__PURE__*/nodeProxy(MathNode, MathNode.CROSS);

  /**
   * Return the value of the first parameter raised to the power of the second one.
   *
   * @function
   * @param {Node | Number} x - The first parameter.
   * @param {Node | Number} y - The second parameter.
   * @returns {Node}
   */
  var pow = /*@__PURE__*/nodeProxy(MathNode, MathNode.POW);

  /**
   * Returns the square of the parameter.
   *
   * @function
   * @param {Node | Number} x - The first parameter.
   * @returns {Node}
   */
  var pow2 = /*@__PURE__*/nodeProxy(MathNode, MathNode.POW, 2);

  /**
   * Returns the cube of the parameter.
   *
   * @function
   * @param {Node | Number} x - The first parameter.
   * @returns {Node}
   */
  var pow3 = /*@__PURE__*/nodeProxy(MathNode, MathNode.POW, 3);

  /**
   * Returns the fourth power of the parameter.
   *
   * @function
   * @param {Node | Number} x - The first parameter.
   * @returns {Node}
   */
  var pow4 = /*@__PURE__*/nodeProxy(MathNode, MathNode.POW, 4);

  /**
   * Transforms the direction of a vector by a matrix and then normalizes the result.
   *
   * @function
   * @param {Node<vec2|vec3|vec4>} direction - The direction vector.
   * @param {Node<mat2|mat3|mat4>} matrix - The transformation matrix.
   * @returns {Node}
   */
  var transformDirection = /*@__PURE__*/nodeProxy(MathNode, MathNode.TRANSFORM_DIRECTION);

  /**
   * Returns the cube root of a number.
   *
   * @function
   * @param {Node | Number} a - The first parameter.
   * @returns {Node}
   */
  var cbrt = function cbrt(a) {
    return mul(sign(a), pow(abs(a), 1.0 / 3.0));
  };

  /**
   * Calculate the squared length of a vector.
   *
   * @function
   * @param {Node<vec2|vec3|vec4>} a - The vector.
   * @returns {Node<float>}
   */
  var lengthSq = function lengthSq(a) {
    return dot(a, a);
  };

  /**
   * Linearly interpolates between two values.
   *
   * @function
   * @param {Node | Number} a - The first parameter.
   * @param {Node | Number} b - The second parameter.
   * @param {Node | Number} t - The interpolation value.
   * @returns {Node}
   */
  var mix = /*@__PURE__*/nodeProxy(MathNode, MathNode.MIX);

  /**
   * Constrains a value to lie between two further values.
   *
   * @function
   * @param {Node | Number} value - The value to constrain.
   * @param {Node | Number} [low=0] - The lower bound.
   * @param {Node | Number} [high=1] - The upper bound.
   * @returns {Node}
   */
  var clamp = function clamp(value) {
    var low = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var high = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
    return nodeObject(new MathNode(MathNode.CLAMP, nodeObject(value), nodeObject(low), nodeObject(high)));
  };

  /**
   * Constrains a value between `0` and `1`.
   *
   * @function
   * @param {Node | Number} value - The value to constrain.
   * @returns {Node}
   */
  var saturate = function saturate(value) {
    return clamp(value);
  };

  /**
   * Calculates the refraction direction for an incident vector.
   *
   * @function
   * @param {Node<vec2|vec3|vec4>} I - The incident vector.
   * @param {Node<vec2|vec3|vec4>} N - The normal vector.
   * @param {Node<float>} eta - The the ratio of indices of refraction.
   * @returns {Node<vec2|vec3|vec4>}
   */
  var refract = /*@__PURE__*/nodeProxy(MathNode, MathNode.REFRACT);

  /**
   * Performs a Hermite interpolation between two values.
   *
   * @function
   * @param {Node | Number} low - The value of the lower edge of the Hermite function.
   * @param {Node | Number} high - The value of the upper edge of the Hermite function.
   * @param {Node | Number} x - The source value for interpolation.
   * @returns {Node}
   */
  var smoothstep = /*@__PURE__*/nodeProxy(MathNode, MathNode.SMOOTHSTEP);

  /**
   * Returns a vector pointing in the same direction as another.
   *
   * @function
   * @param {Node<vec2|vec3|vec4>} N - The vector to orient.
   * @param {Node<vec2|vec3|vec4>} I - The incident vector.
   * @param {Node<vec2|vec3|vec4>} Nref - The reference vector.
   * @returns {Node<vec2|vec3|vec4>}
   */
  var faceForward = /*@__PURE__*/nodeProxy(MathNode, MathNode.FACEFORWARD);

  /**
   * Returns a random value for the given uv.
   *
   * @function
   * @param {Node<vec2>} uv - The uv node.
   * @returns {Node<float>}
   */
  var rand = /*@__PURE__*/Fn(function (_ref5) {
    var _ref6 = (0, _slicedToArray2.default)(_ref5, 1),
      uv = _ref6[0];
    var a = 12.9898,
      b = 78.233,
      c = 43758.5453;
    var dt = dot(uv.xy, vec2(a, b)),
      sn = mod(dt, PI);
    return fract(sin(sn).mul(c));
  });

  /**
   * Alias for `mix()` with a different parameter order.
   *
   * @function
   * @param {Node | Number} t - The interpolation value.
   * @param {Node | Number} e1 - The first parameter.
   * @param {Node | Number} e2 - The second parameter.
   * @returns {Node}
   */
  var mixElement = function mixElement(t, e1, e2) {
    return mix(e1, e2, t);
  };

  /**
   * Alias for `smoothstep()` with a different parameter order.
   *
   * @function
   * @param {Node | Number} x - The source value for interpolation.
   * @param {Node | Number} low - The value of the lower edge of the Hermite function.
   * @param {Node | Number} high - The value of the upper edge of the Hermite function.
   * @returns {Node}
   */
  var smoothstepElement = function smoothstepElement(x, low, high) {
    return smoothstep(low, high, x);
  };

  /**
   * Returns the arc-tangent of the quotient of its parameters.
   *
   * @function
   * @param {Node | Number} y - The y parameter.
   * @param {Node | Number} x - The x parameter.
   * @returns {Node}
   */
  var atan2 = function atan2(y, x) {
    // @deprecated, r172

    console.warn('THREE.TSL: "atan2" is overloaded. Use "atan" instead.');
    return atan(y, x);
  };

  // GLSL alias function

  var faceforward = faceForward;
  var inversesqrt = inverseSqrt;

  // Method chaining

  addMethodChaining('all', all);
  addMethodChaining('any', any);
  addMethodChaining('equals', equals);
  addMethodChaining('radians', radians);
  addMethodChaining('degrees', degrees);
  addMethodChaining('exp', exp);
  addMethodChaining('exp2', exp2);
  addMethodChaining('log', log);
  addMethodChaining('log2', log2);
  addMethodChaining('sqrt', sqrt);
  addMethodChaining('inverseSqrt', inverseSqrt);
  addMethodChaining('floor', floor);
  addMethodChaining('ceil', ceil);
  addMethodChaining('normalize', normalize);
  addMethodChaining('fract', fract);
  addMethodChaining('sin', sin);
  addMethodChaining('cos', cos);
  addMethodChaining('tan', tan);
  addMethodChaining('asin', asin);
  addMethodChaining('acos', acos);
  addMethodChaining('atan', atan);
  addMethodChaining('abs', abs);
  addMethodChaining('sign', sign);
  addMethodChaining('length', length);
  addMethodChaining('lengthSq', lengthSq);
  addMethodChaining('negate', negate);
  addMethodChaining('oneMinus', oneMinus);
  addMethodChaining('dFdx', dFdx);
  addMethodChaining('dFdy', dFdy);
  addMethodChaining('round', round);
  addMethodChaining('reciprocal', reciprocal);
  addMethodChaining('trunc', trunc);
  addMethodChaining('fwidth', fwidth);
  addMethodChaining('atan2', atan2);
  addMethodChaining('min', min$1);
  addMethodChaining('max', max$1);
  addMethodChaining('mod', mod);
  addMethodChaining('step', step);
  addMethodChaining('reflect', reflect);
  addMethodChaining('distance', distance);
  addMethodChaining('dot', dot);
  addMethodChaining('cross', cross);
  addMethodChaining('pow', pow);
  addMethodChaining('pow2', pow2);
  addMethodChaining('pow3', pow3);
  addMethodChaining('pow4', pow4);
  addMethodChaining('transformDirection', transformDirection);
  addMethodChaining('mix', mixElement);
  addMethodChaining('clamp', clamp);
  addMethodChaining('refract', refract);
  addMethodChaining('smoothstep', smoothstepElement);
  addMethodChaining('faceForward', faceForward);
  addMethodChaining('difference', difference);
  addMethodChaining('saturate', saturate);
  addMethodChaining('cbrt', cbrt);
  addMethodChaining('transpose', transpose);
  addMethodChaining('rand', rand);

  /** @module ConditionalNode **/

  /**
   * Represents a logical `if/else` statement. Can be used as an alternative
   * to the `If()`/`Else()` syntax.
   *
   * The corresponding TSL `select()` looks like so:
   * ```js
   * velocity = position.greaterThanEqual( limit ).select( velocity.negate(), velocity );
   * ```
   * The `select()` method is called in a chaining fashion on a condition. The parameter nodes of `select()`
   * determine the outcome of the entire statement.
   *
   * @augments Node
   */
  var ConditionalNode = /*#__PURE__*/function (_Node10) {
    /**
     * Constructs a new conditional node.
     *
     * @param {Node} condNode - The node that defines the condition.
     * @param {Node} ifNode - The node that is evaluate when the condition ends up `true`.
     * @param {Node?} [elseNode=null] - The node that is evaluate when the condition ends up `false`.
     */
    function ConditionalNode(condNode, ifNode) {
      var _this21;
      var elseNode = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
      (0, _classCallCheck2.default)(this, ConditionalNode);
      _this21 = _callSuper(this, ConditionalNode);

      /**
       * The node that defines the condition.
       *
       * @type {Node}
       */
      _this21.condNode = condNode;

      /**
       * The node that is evaluate when the condition ends up `true`.
       *
       * @type {Node}
       */
      _this21.ifNode = ifNode;

      /**
       * The node that is evaluate when the condition ends up `false`.
       *
       * @type {Node?}
       * @default null
       */
      _this21.elseNode = elseNode;
      return _this21;
    }

    /**
     * This method is overwritten since the node type is inferred from the if/else
     * nodes.
     *
     * @param {NodeBuilder} builder - The current node builder.
     * @return {String} The node type.
     */
    (0, _inherits2.default)(ConditionalNode, _Node10);
    return (0, _createClass2.default)(ConditionalNode, [{
      key: "getNodeType",
      value: function getNodeType(builder) {
        var _builder$getNodePrope2 = builder.getNodeProperties(this),
          ifNode = _builder$getNodePrope2.ifNode,
          elseNode = _builder$getNodePrope2.elseNode;
        if (ifNode === undefined) {
          // fallback setup

          this.setup(builder);
          return this.getNodeType(builder);
        }
        var ifType = ifNode.getNodeType(builder);
        if (elseNode !== null) {
          var elseType = elseNode.getNodeType(builder);
          if (builder.getTypeLength(elseType) > builder.getTypeLength(ifType)) {
            return elseType;
          }
        }
        return ifType;
      }
    }, {
      key: "setup",
      value: function setup(builder) {
        var condNode = this.condNode.cache();
        var ifNode = this.ifNode.cache();
        var elseNode = this.elseNode ? this.elseNode.cache() : null;

        //

        var currentNodeBlock = builder.context.nodeBlock;
        builder.getDataFromNode(ifNode).parentNodeBlock = currentNodeBlock;
        if (elseNode !== null) builder.getDataFromNode(elseNode).parentNodeBlock = currentNodeBlock;

        //

        var properties = builder.getNodeProperties(this);
        properties.condNode = condNode;
        properties.ifNode = ifNode.context({
          nodeBlock: ifNode
        });
        properties.elseNode = elseNode ? elseNode.context({
          nodeBlock: elseNode
        }) : null;
      }
    }, {
      key: "generate",
      value: function generate(builder, output) {
        var type = this.getNodeType(builder);
        var nodeData = builder.getDataFromNode(this);
        if (nodeData.nodeProperty !== undefined) {
          return nodeData.nodeProperty;
        }
        var _builder$getNodePrope3 = builder.getNodeProperties(this),
          condNode = _builder$getNodePrope3.condNode,
          ifNode = _builder$getNodePrope3.ifNode,
          elseNode = _builder$getNodePrope3.elseNode;
        var needsOutput = output !== 'void';
        var nodeProperty = needsOutput ? property(type).build(builder) : '';
        nodeData.nodeProperty = nodeProperty;
        var nodeSnippet = condNode.build(builder, 'bool');
        builder.addFlowCode(`\n${builder.tab}if ( ${nodeSnippet} ) {\n\n`).addFlowTab();
        var ifSnippet = ifNode.build(builder, type);
        if (ifSnippet) {
          if (needsOutput) {
            ifSnippet = nodeProperty + ' = ' + ifSnippet + ';';
          } else {
            ifSnippet = 'return ' + ifSnippet + ';';
          }
        }
        builder.removeFlowTab().addFlowCode(builder.tab + '\t' + ifSnippet + '\n\n' + builder.tab + '}');
        if (elseNode !== null) {
          builder.addFlowCode(' else {\n\n').addFlowTab();
          var elseSnippet = elseNode.build(builder, type);
          if (elseSnippet) {
            if (needsOutput) {
              elseSnippet = nodeProperty + ' = ' + elseSnippet + ';';
            } else {
              elseSnippet = 'return ' + elseSnippet + ';';
            }
          }
          builder.removeFlowTab().addFlowCode(builder.tab + '\t' + elseSnippet + '\n\n' + builder.tab + '}\n\n');
        } else {
          builder.addFlowCode('\n\n');
        }
        return builder.format(nodeProperty, type, output);
      }
    }], [{
      key: "type",
      get: function get() {
        return 'ConditionalNode';
      }
    }]);
  }(Node);
  /**
   * TSL function for creating a conditional node.
   *
   * @function
   * @param {Node} condNode - The node that defines the condition.
   * @param {Node} ifNode - The node that is evaluate when the condition ends up `true`.
   * @param {Node?} [elseNode=null] - The node that is evaluate when the condition ends up `false`.
   * @returns {ConditionalNode}
   */
  var select = /*@__PURE__*/nodeProxy(ConditionalNode);
  addMethodChaining('select', select);

  //

  var cond = function cond() {
    // @deprecated, r168

    console.warn('TSL.ConditionalNode: cond() has been renamed to select().');
    return select.apply(void 0, arguments);
  };
  addMethodChaining('cond', cond);

  /** @module ContextNode **/

  /**
   * This node can be used as a context management component for another node.
   * {@link NodeBuilder} performs its node building process in a specific context and
   * this node allows the modify the context. A typical use case is to overwrite `getUV()` e.g.:
   *
   * ```js
   *node.context( { getUV: () => customCoord } );
   *```
   * @augments Node
   */
  var ContextNode = exports.ContextNode = /*#__PURE__*/function (_Node11) {
    /**
     * Constructs a new context node.
     *
     * @param {Node} node - The node whose context should be modified.
     * @param {Object} [value={}] - The modified context data.
     */
    function ContextNode(node) {
      var _this22;
      var value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      (0, _classCallCheck2.default)(this, ContextNode);
      _this22 = _callSuper(this, ContextNode);

      /**
       * This flag can be used for type testing.
       *
       * @type {Boolean}
       * @readonly
       * @default true
       */
      _this22.isContextNode = true;

      /**
       * The node whose context should be modified.
       *
       * @type {Node}
       */
      _this22.node = node;

      /**
       * The modified context data.
       *
       * @type {Object}
       * @default {}
       */
      _this22.value = value;
      return _this22;
    }

    /**
     * This method is overwritten to ensure it returns the reference to {@link module:ContextNode~ContextNode#node}.
     *
     * @return {Node} A reference to {@link module:ContextNode~ContextNode#node}.
     */
    (0, _inherits2.default)(ContextNode, _Node11);
    return (0, _createClass2.default)(ContextNode, [{
      key: "getScope",
      value: function getScope() {
        return this.node.getScope();
      }

      /**
       * This method is overwritten to ensure it returns the type of {@link module:ContextNode~ContextNode#node}.
       *
       * @param {NodeBuilder} builder - The current node builder.
       * @return {String} The node type.
       */
    }, {
      key: "getNodeType",
      value: function getNodeType(builder) {
        return this.node.getNodeType(builder);
      }
    }, {
      key: "analyze",
      value: function analyze(builder) {
        this.node.build(builder);
      }
    }, {
      key: "setup",
      value: function setup(builder) {
        var previousContext = builder.getContext();
        builder.setContext(Object.assign({}, builder.context, this.value));
        var node = this.node.build(builder);
        builder.setContext(previousContext);
        return node;
      }
    }, {
      key: "generate",
      value: function generate(builder, output) {
        var previousContext = builder.getContext();
        builder.setContext(Object.assign({}, builder.context, this.value));
        var snippet = this.node.build(builder, output);
        builder.setContext(previousContext);
        return snippet;
      }
    }], [{
      key: "type",
      get: function get() {
        return 'ContextNode';
      }
    }]);
  }(Node);
  /**
   * TSL function for creating a context node.
   *
   * @function
   * @param {Node} node - The node whose context should be modified.
   * @param {Object} [value={}] - The modified context data.
   * @returns {ContextNode}
   */
  var context = /*@__PURE__*/nodeProxy(ContextNode);

  /**
   * TSL function for defining a label context value for a given node.
   *
   * @function
   * @param {Node} node - The node whose context should be modified.
   * @param {String} name - The name/label to set.
   * @returns {ContextNode}
   */
  var label = function label(node, name) {
    return context(node, {
      label: name
    });
  };
  addMethodChaining('context', context);
  addMethodChaining('label', label);

  /** @module VarNode **/

  /**
   * Class for representing shader variables as nodes. Variables are created from
   * existing nodes like the following:
   *
   * ```js
   * const depth = sampleDepth( uvNode ).toVar( 'depth' );
   * ```
   *
   * @augments Node
   */
  var VarNode = exports.VarNode = /*#__PURE__*/function (_Node12) {
    /**
     * Constructs a new variable node.
     *
     * @param {Node} node - The node for which a variable should be created.
     * @param {String?} name - The name of the variable in the shader.
     */
    function VarNode(node) {
      var _this23;
      var name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      (0, _classCallCheck2.default)(this, VarNode);
      _this23 = _callSuper(this, VarNode);

      /**
       * The node for which a variable should be created.
       *
       * @type {Node}
       */
      _this23.node = node;

      /**
       * The name of the variable in the shader. If no name is defined,
       * the node system auto-generates one.
       *
       * @type {String?}
       * @default null
       */
      _this23.name = name;

      /**
       * `VarNode` sets this property to `true` by default.
       *
       * @type {Boolean}
       * @default true
       */
      _this23.global = true;

      /**
       * This flag can be used for type testing.
       *
       * @type {Boolean}
       * @readonly
       * @default true
       */
      _this23.isVarNode = true;
      return _this23;
    }
    (0, _inherits2.default)(VarNode, _Node12);
    return (0, _createClass2.default)(VarNode, [{
      key: "getHash",
      value: function getHash(builder) {
        return this.name || _superPropGet(VarNode, "getHash", this, 3)([builder]);
      }
    }, {
      key: "getNodeType",
      value: function getNodeType(builder) {
        return this.node.getNodeType(builder);
      }
    }, {
      key: "generate",
      value: function generate(builder) {
        var node = this.node,
          name = this.name;
        var nodeVar = builder.getVarFromNode(this, name, builder.getVectorType(this.getNodeType(builder)));
        var propertyName = builder.getPropertyName(nodeVar);
        var snippet = node.build(builder, nodeVar.type);
        builder.addLineFlowCode(`${propertyName} = ${snippet}`, this);
        return propertyName;
      }
    }], [{
      key: "type",
      get: function get() {
        return 'VarNode';
      }
    }]);
  }(Node);
  /**
   * TSL function for creating a var node.
   *
   * @function
   * @param {Node} node - The node for which a variable should be created.
   * @param {String?} name - The name of the variable in the shader.
   * @returns {VarNode}
   */
  var createVar = /*@__PURE__*/nodeProxy(VarNode);
  addMethodChaining('toVar', function () {
    return createVar.apply(void 0, arguments).append();
  });

  // Deprecated

  var temp = function temp(node) {
    // @deprecated, r170

    console.warn('TSL: "temp" is deprecated. Use ".toVar()" instead.');
    return createVar(node);
  };
  addMethodChaining('temp', temp);

  /** @module VaryingNode **/

  /**
   * Class for representing shader varyings as nodes. Varyings are create from
   * existing nodes like the following:
   *
   * ```js
   * const positionLocal = positionGeometry.varying( 'vPositionLocal' );
   * ```
   *
   * @augments Node
   */
  var VaryingNode = exports.VaryingNode = /*#__PURE__*/function (_Node13) {
    /**
     * Constructs a new varying node.
     *
     * @param {Node} node - The node for which a varying should be created.
     * @param {String?} name - The name of the varying in the shader.
     */
    function VaryingNode(node) {
      var _this24;
      var name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      (0, _classCallCheck2.default)(this, VaryingNode);
      _this24 = _callSuper(this, VaryingNode);

      /**
       * The node for which a varying should be created.
       *
       * @type {Node}
       */
      _this24.node = node;

      /**
       * The name of the varying in the shader. If no name is defined,
       * the node system auto-generates one.
       *
       * @type {String?}
       * @default null
       */
      _this24.name = name;

      /**
       * This flag can be used for type testing.
       *
       * @type {Boolean}
       * @readonly
       * @default true
       */
      _this24.isVaryingNode = true;
      return _this24;
    }

    /**
     * The method is overwritten so it always returns `true`.
     *
     * @param {NodeBuilder} builder - The current node builder.
     * @return {Boolean} Whether this node is global or not.
     */
    (0, _inherits2.default)(VaryingNode, _Node13);
    return (0, _createClass2.default)(VaryingNode, [{
      key: "isGlobal",
      value: function isGlobal(/*builder*/
      ) {
        return true;
      }
    }, {
      key: "getHash",
      value: function getHash(builder) {
        return this.name || _superPropGet(VaryingNode, "getHash", this, 3)([builder]);
      }
    }, {
      key: "getNodeType",
      value: function getNodeType(builder) {
        // VaryingNode is auto type

        return this.node.getNodeType(builder);
      }

      /**
       * This method performs the setup of a varying node with the current node builder.
       *
       * @param {NodeBuilder} builder - The current node builder.
       * @return {NodeVarying} The node varying from the node builder.
       */
    }, {
      key: "setupVarying",
      value: function setupVarying(builder) {
        var properties = builder.getNodeProperties(this);
        var varying = properties.varying;
        if (varying === undefined) {
          var name = this.name;
          var type = this.getNodeType(builder);
          properties.varying = varying = builder.getVaryingFromNode(this, name, type);
          properties.node = this.node;
        }

        // this property can be used to check if the varying can be optimized for a variable
        varying.needsInterpolation || (varying.needsInterpolation = builder.shaderStage === 'fragment');
        return varying;
      }
    }, {
      key: "setup",
      value: function setup(builder) {
        this.setupVarying(builder);
      }
    }, {
      key: "analyze",
      value: function analyze(builder) {
        this.setupVarying(builder);
        return this.node.analyze(builder);
      }
    }, {
      key: "generate",
      value: function generate(builder) {
        var properties = builder.getNodeProperties(this);
        var varying = this.setupVarying(builder);
        var needsReassign = builder.shaderStage === 'fragment' && properties.reassignPosition === true && builder.context.needsPositionReassign;
        if (properties.propertyName === undefined || needsReassign) {
          var type = this.getNodeType(builder);
          var propertyName = builder.getPropertyName(varying, NodeShaderStage.VERTEX);

          // force node run in vertex stage
          builder.flowNodeFromShaderStage(NodeShaderStage.VERTEX, this.node, type, propertyName);
          properties.propertyName = propertyName;
          if (needsReassign) {
            // once reassign varying in fragment stage
            properties.reassignPosition = false;
          } else if (properties.reassignPosition === undefined && builder.context.isPositionNodeInput) {
            properties.reassignPosition = true;
          }
        }
        return builder.getPropertyName(varying);
      }
    }], [{
      key: "type",
      get: function get() {
        return 'VaryingNode';
      }
    }]);
  }(Node);
  /**
   * TSL function for creating a varying node.
   *
   * @function
   * @param {Node} node - The node for which a varying should be created.
   * @param {String?} name - The name of the varying in the shader.
   * @returns {VaryingNode}
   */
  var varying = /*@__PURE__*/nodeProxy(VaryingNode);

  /**
   * Computes a node in the vertex stage.
   *
   * @function
   * @param {Node} node - The node which should be executed in the vertex stage.
   * @returns {VaryingNode}
   */
  var vertexStage = function vertexStage(node) {
    return varying(node);
  };
  addMethodChaining('varying', varying);
  addMethodChaining('vertexStage', vertexStage);

  /** @module ColorSpaceFunctions **/

  /**
   * Converts the given color value from sRGB to linear-sRGB color space.
   *
   * @method
   * @param {Node<vec3>} color - The sRGB color.
   * @return {Node<vec3>} The linear-sRGB color.
   */
  var sRGBTransferEOTF = /*@__PURE__*/Fn(function (_ref7) {
    var _ref8 = (0, _slicedToArray2.default)(_ref7, 1),
      color = _ref8[0];
    var a = color.mul(0.9478672986).add(0.0521327014).pow(2.4);
    var b = color.mul(0.0773993808);
    var factor = color.lessThanEqual(0.04045);
    var rgbResult = mix(a, b, factor);
    return rgbResult;
  }).setLayout({
    name: 'sRGBTransferEOTF',
    type: 'vec3',
    inputs: [{
      name: 'color',
      type: 'vec3'
    }]
  });

  /**
   * Converts the given color value from linear-sRGB to sRGB color space.
   *
   * @method
   * @param {Node<vec3>} color - The linear-sRGB color.
   * @return {Node<vec3>} The sRGB color.
   */
  var sRGBTransferOETF = /*@__PURE__*/Fn(function (_ref9) {
    var _ref10 = (0, _slicedToArray2.default)(_ref9, 1),
      color = _ref10[0];
    var a = color.pow(0.41666).mul(1.055).sub(0.055);
    var b = color.mul(12.92);
    var factor = color.lessThanEqual(0.0031308);
    var rgbResult = mix(a, b, factor);
    return rgbResult;
  }).setLayout({
    name: 'sRGBTransferOETF',
    type: 'vec3',
    inputs: [{
      name: 'color',
      type: 'vec3'
    }]
  });

  /** @module ColorSpaceNode **/

  var WORKING_COLOR_SPACE = 'WorkingColorSpace';
  var OUTPUT_COLOR_SPACE = 'OutputColorSpace';

  /**
   * This node represents a color space conversion. Meaning it converts
   * a color value from a source to a target color space.
   *
   * @augments TempNode
   */
  var ColorSpaceNode = exports.ColorSpaceNode = /*#__PURE__*/function (_TempNode8) {
    /**
     * Constructs a new color space node.
     *
     * @param {Node} colorNode - Represents the color to convert.
     * @param {String} source - The source color space.
     * @param {String} target - The target color space.
     */
    function ColorSpaceNode(colorNode, source, target) {
      var _this25;
      (0, _classCallCheck2.default)(this, ColorSpaceNode);
      _this25 = _callSuper(this, ColorSpaceNode, ['vec4']);

      /**
       * Represents the color to convert.
       *
       * @type {Node}
       */
      _this25.colorNode = colorNode;

      /**
       * The source color space.
       *
       * @type {String}
       */
      _this25.source = source;

      /**
       * The target color space.
       *
       * @type {String}
       */
      _this25.target = target;
      return _this25;
    }

    /**
     * This method resolves the constants `WORKING_COLOR_SPACE` and
     * `OUTPUT_COLOR_SPACE` based on the current configuration of the
     * color management and renderer.
     *
     * @param {NodeBuilder} builder - The current node builder.
     * @param {String} colorSpace - The color space to resolve.
     * @return {String} The resolved color space.
     */
    (0, _inherits2.default)(ColorSpaceNode, _TempNode8);
    return (0, _createClass2.default)(ColorSpaceNode, [{
      key: "resolveColorSpace",
      value: function resolveColorSpace(builder, colorSpace) {
        if (colorSpace === WORKING_COLOR_SPACE) {
          return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").ColorManagement.workingColorSpace;
        } else if (colorSpace === OUTPUT_COLOR_SPACE) {
          return builder.context.outputColorSpace || builder.renderer.outputColorSpace;
        }
        return colorSpace;
      }
    }, {
      key: "setup",
      value: function setup(builder) {
        var colorNode = this.colorNode;
        var source = this.resolveColorSpace(builder, this.source);
        var target = this.resolveColorSpace(builder, this.target);
        var outputNode = colorNode;
        if (_$$_REQUIRE(_dependencyMap[1], "./three.core.js").ColorManagement.enabled === false || source === target || !source || !target) {
          return outputNode;
        }
        if (_$$_REQUIRE(_dependencyMap[1], "./three.core.js").ColorManagement.getTransfer(source) === _$$_REQUIRE(_dependencyMap[1], "./three.core.js").SRGBTransfer) {
          outputNode = vec4(sRGBTransferEOTF(outputNode.rgb), outputNode.a);
        }
        if (_$$_REQUIRE(_dependencyMap[1], "./three.core.js").ColorManagement.getPrimaries(source) !== _$$_REQUIRE(_dependencyMap[1], "./three.core.js").ColorManagement.getPrimaries(target)) {
          outputNode = vec4(mat3(_$$_REQUIRE(_dependencyMap[1], "./three.core.js").ColorManagement._getMatrix(new (_$$_REQUIRE(_dependencyMap[1], "./three.core.js").Matrix3)(), source, target)).mul(outputNode.rgb), outputNode.a);
        }
        if (_$$_REQUIRE(_dependencyMap[1], "./three.core.js").ColorManagement.getTransfer(target) === _$$_REQUIRE(_dependencyMap[1], "./three.core.js").SRGBTransfer) {
          outputNode = vec4(sRGBTransferOETF(outputNode.rgb), outputNode.a);
        }
        return outputNode;
      }
    }], [{
      key: "type",
      get: function get() {
        return 'ColorSpaceNode';
      }
    }]);
  }(TempNode);
  /**
   * TSL function for converting a given color node to the current output color space.
   *
   * @function
   * @param {Node} node - Represents the node to convert.
   * @returns {ColorSpaceNode}
   */
  var toOutputColorSpace = function toOutputColorSpace(node) {
    return nodeObject(new ColorSpaceNode(nodeObject(node), WORKING_COLOR_SPACE, OUTPUT_COLOR_SPACE));
  };

  /**
   * TSL function for converting a given color node to the current working color space.
   *
   * @function
   * @param {Node} node - Represents the node to convert.
   * @returns {ColorSpaceNode}
   */
  var toWorkingColorSpace = function toWorkingColorSpace(node) {
    return nodeObject(new ColorSpaceNode(nodeObject(node), OUTPUT_COLOR_SPACE, WORKING_COLOR_SPACE));
  };

  /**
   * TSL function for converting a given color node from the current working color space to the given color space.
   *
   * @function
   * @param {Node} node - Represents the node to convert.
   * @param {String} colorSpace - The target color space.
   * @returns {ColorSpaceNode}
   */
  var workingToColorSpace = function workingToColorSpace(node, colorSpace) {
    return nodeObject(new ColorSpaceNode(nodeObject(node), WORKING_COLOR_SPACE, colorSpace));
  };

  /**
   * TSL function for converting a given color node from the given color space to the current working color space.
   *
   * @function
   * @param {Node} node - Represents the node to convert.
   * @param {String} colorSpace - The source color space.
   * @returns {ColorSpaceNode}
   */
  var colorSpaceToWorking = function colorSpaceToWorking(node, colorSpace) {
    return nodeObject(new ColorSpaceNode(nodeObject(node), colorSpace, WORKING_COLOR_SPACE));
  };

  /**
   * TSL function for converting a given color node from one color space to another one.
   *
   * @function
   * @param {Node} node - Represents the node to convert.
   * @param {String} sourceColorSpace - The source color space.
   * @param {String} targetColorSpace - The target color space.
   * @returns {ColorSpaceNode}
   */
  var convertColorSpace = function convertColorSpace(node, sourceColorSpace, targetColorSpace) {
    return nodeObject(new ColorSpaceNode(nodeObject(node), sourceColorSpace, targetColorSpace));
  };
  addMethodChaining('toOutputColorSpace', toOutputColorSpace);
  addMethodChaining('toWorkingColorSpace', toWorkingColorSpace);
  addMethodChaining('workingToColorSpace', workingToColorSpace);
  addMethodChaining('colorSpaceToWorking', colorSpaceToWorking);

  // TODO: Avoid duplicated code and ues only ReferenceBaseNode or ReferenceNode

  /** @module ReferenceBaseNode **/

  /**
   * This class is only relevant if the referenced property is array-like.
   * In this case, `ReferenceElementNode` allows to refer to a specific
   * element inside the data structure via an index.
   *
   * @augments ArrayElementNode
   */
  var ReferenceElementNode$1 = /*#__PURE__*/function (_ArrayElementNode) {
    /**
     * Constructs a new reference element node.
     *
     * @param {Node?} referenceNode - The reference node.
     * @param {Node} indexNode - The index node that defines the element access.
     */
    function ReferenceElementNode(referenceNode, indexNode) {
      var _this26;
      (0, _classCallCheck2.default)(this, ReferenceElementNode);
      _this26 = _callSuper(this, ReferenceElementNode, [referenceNode, indexNode]);

      /**
       * Similar to {@link module:ReferenceBaseNode~ReferenceBaseNode#reference}, an additional
       * property references to the current node.
       *
       * @type {Node?}
       * @default null
       */
      _this26.referenceNode = referenceNode;

      /**
       * This flag can be used for type testing.
       *
       * @type {Boolean}
       * @readonly
       * @default true
       */
      _this26.isReferenceElementNode = true;
      return _this26;
    }

    /**
     * This method is overwritten since the node type is inferred from
     * the uniform type of the reference node.
     *
     * @param {NodeBuilder} builder - The current node builder.
     * @return {String} The node type.
     */
    (0, _inherits2.default)(ReferenceElementNode, _ArrayElementNode);
    return (0, _createClass2.default)(ReferenceElementNode, [{
      key: "getNodeType",
      value: function getNodeType() {
        return this.referenceNode.uniformType;
      }
    }, {
      key: "generate",
      value: function generate(builder) {
        var snippet = _superPropGet(ReferenceElementNode, "generate", this, 3)([builder]);
        var arrayType = this.referenceNode.getNodeType();
        var elementType = this.getNodeType();
        return builder.format(snippet, arrayType, elementType);
      }
    }], [{
      key: "type",
      get: function get() {
        return 'ReferenceElementNode';
      }
    }]);
  }(ArrayElementNode);

  /**
   * Base class for nodes which establishes a reference to a property of another object.
   * In this way, the value of the node is automatically linked to the value of
   * referenced object. Reference nodes internally represent the linked value
   * as a uniform.
   *
   * @augments Node
   */
  var ReferenceBaseNode = /*#__PURE__*/function (_Node14) {
    /**
     * Constructs a new reference base node.
     *
     * @param {String} property - The name of the property the node refers to.
     * @param {String} uniformType - The uniform type that should be used to represent the property value.
     * @param {Object?} [object=null] - The object the property belongs to.
     * @param {Number?} [count=null] - When the linked property is an array-like, this parameter defines its length.
     */
    function ReferenceBaseNode(property, uniformType) {
      var _this27;
      var object = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
      var count = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
      (0, _classCallCheck2.default)(this, ReferenceBaseNode);
      _this27 = _callSuper(this, ReferenceBaseNode);

      /**
       * The name of the property the node refers to.
       *
       * @type {String}
       */
      _this27.property = property;

      /**
       * The uniform type that should be used to represent the property value.
       *
       * @type {String}
       */
      _this27.uniformType = uniformType;

      /**
       * The object the property belongs to.
       *
       * @type {Object?}
       * @default null
       */
      _this27.object = object;

      /**
       * When the linked property is an array, this parameter defines its length.
       *
       * @type {Number?}
       * @default null
       */
      _this27.count = count;

      /**
       * The property name might have dots so nested properties can be referred.
       * The hierarchy of the names is stored inside this array.
       *
       * @type {Array<String>}
       */
      _this27.properties = property.split('.');

      /**
       * Points to the current referred object. This property exists next to {@link module:ReferenceNode~ReferenceNode#object}
       * since the final reference might be updated from calling code.
       *
       * @type {Object?}
       * @default null
       */
      _this27.reference = object;

      /**
       * The uniform node that holds the value of the reference node.
       *
       * @type {UniformNode}
       * @default null
       */
      _this27.node = null;

      /**
       * The uniform group of the internal uniform.
       *
       * @type {UniformGroupNode}
       * @default null
       */
      _this27.group = null;

      /**
       * Overwritten since reference nodes are updated per object.
       *
       * @type {String}
       * @default 'object'
       */
      _this27.updateType = NodeUpdateType.OBJECT;
      return _this27;
    }

    /**
     * Sets the uniform group for this reference node.
     *
     * @param {UniformGroupNode} group - The uniform group to set.
     * @return {ReferenceBaseNode} A reference to this node.
     */
    (0, _inherits2.default)(ReferenceBaseNode, _Node14);
    return (0, _createClass2.default)(ReferenceBaseNode, [{
      key: "setGroup",
      value: function setGroup(group) {
        this.group = group;
        return this;
      }

      /**
       * When the referred property is array-like, this method can be used
       * to access elements via an index node.
       *
       * @param {IndexNode} indexNode - indexNode.
       * @return {ReferenceElementNode} A reference to an element.
       */
    }, {
      key: "element",
      value: function element(indexNode) {
        return nodeObject(new ReferenceElementNode$1(this, nodeObject(indexNode)));
      }

      /**
       * Sets the node type which automatically defines the internal
       * uniform type.
       *
       * @param {String} uniformType - The type to set.
       */
    }, {
      key: "setNodeType",
      value: function setNodeType(uniformType) {
        var node = uniform(null, uniformType).getSelf();
        if (this.group !== null) {
          node.setGroup(this.group);
        }
        this.node = node;
      }

      /**
       * This method is overwritten since the node type is inferred from
       * the type of the reference node.
       *
       * @param {NodeBuilder} builder - The current node builder.
       * @return {String} The node type.
       */
    }, {
      key: "getNodeType",
      value: function getNodeType(builder) {
        if (this.node === null) {
          this.updateReference(builder);
          this.updateValue();
        }
        return this.node.getNodeType(builder);
      }

      /**
       * Returns the property value from the given referred object.
       *
       * @param {Object} [object=this.reference] - The object to retrieve the property value from.
       * @return {Any} The value.
       */
    }, {
      key: "getValueFromReference",
      value: function getValueFromReference() {
        var object = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.reference;
        var properties = this.properties;
        var value = object[properties[0]];
        for (var i = 1; i < properties.length; i++) {
          value = value[properties[i]];
        }
        return value;
      }

      /**
       * Allows to update the reference based on the given state. The state is only
       * evaluated {@link module:ReferenceBaseNode~ReferenceBaseNode#object} is not set.
       *
       * @param {(NodeFrame|NodeBuilder)} state - The current state.
       * @return {Object} The updated reference.
       */
    }, {
      key: "updateReference",
      value: function updateReference(state) {
        this.reference = this.object !== null ? this.object : state.object;
        return this.reference;
      }

      /**
       * The output of the reference node is the internal uniform node.
       *
       * @param {NodeBuilder} builder - The current node builder.
       * @return {UniformNode} The output node.
       */
    }, {
      key: "setup",
      value: function setup() {
        this.updateValue();
        return this.node;
      }

      /**
       * Overwritten to to update the internal uniform value.
       *
       * @param {NodeFrame} frame - A reference to the current node frame.
       */
    }, {
      key: "update",
      value: function update(/*frame*/
      ) {
        this.updateValue();
      }

      /**
       * Retrieves the value from the referred object property and uses it
       * to updated the internal uniform.
       */
    }, {
      key: "updateValue",
      value: function updateValue() {
        if (this.node === null) this.setNodeType(this.uniformType);
        var value = this.getValueFromReference();
        if (Array.isArray(value)) {
          this.node.array = value;
        } else {
          this.node.value = value;
        }
      }
    }], [{
      key: "type",
      get: function get() {
        return 'ReferenceBaseNode';
      }
    }]);
  }(Node);
  /**
   * TSL function for creating a reference base node.
   *
   * @function
   * @param {String} name - The name of the property the node refers to.
   * @param {String} type - The uniform type that should be used to represent the property value.
   * @param {Object} object - The object the property belongs to.
   * @returns {ReferenceBaseNode}
   */
  var reference$1 = function reference$1(name, type, object) {
    return nodeObject(new ReferenceBaseNode(name, type, object));
  };

  /** @module RendererReferenceNode **/

  /**
   * This node is a special type of reference node which is intended
   * for linking renderer properties with node values.
   * ```js
   * const exposureNode = rendererReference( 'toneMappingExposure', 'float', renderer );
   * ```
   * When changing `renderer.toneMappingExposure`, the node value of `exposureNode` will
   * automatically be updated.
   *
   * @augments ReferenceBaseNode
   */
  var RendererReferenceNode = exports.RendererReferenceNode = /*#__PURE__*/function (_ReferenceBaseNode) {
    /**
     * Constructs a new renderer reference node.
     *
     * @param {String} property - The name of the property the node refers to.
     * @param {String} inputType - The uniform type that should be used to represent the property value.
     * @param {Renderer?} [renderer=null] - The renderer the property belongs to. When no renderer is set,
     * the node refers to the renderer of the current state.
     */
    function RendererReferenceNode(property, inputType) {
      var _this28;
      var renderer = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
      (0, _classCallCheck2.default)(this, RendererReferenceNode);
      _this28 = _callSuper(this, RendererReferenceNode, [property, inputType, renderer]);

      /**
       * The renderer the property belongs to. When no renderer is set,
       * the node refers to the renderer of the current state.
       *
       * @type {Renderer?}
       * @default null
       */
      _this28.renderer = renderer;
      _this28.setGroup(renderGroup);
      return _this28;
    }

    /**
     * Updates the reference based on the given state. The state is only evaluated
     * {@link module:RendererReferenceNode~RendererReferenceNode#renderer} is not set.
     *
     * @param {(NodeFrame|NodeBuilder)} state - The current state.
     * @return {Object} The updated reference.
     */
    (0, _inherits2.default)(RendererReferenceNode, _ReferenceBaseNode);
    return (0, _createClass2.default)(RendererReferenceNode, [{
      key: "updateReference",
      value: function updateReference(state) {
        this.reference = this.renderer !== null ? this.renderer : state.renderer;
        return this.reference;
      }
    }], [{
      key: "type",
      get: function get() {
        return 'RendererReferenceNode';
      }
    }]);
  }(ReferenceBaseNode);
  /**
   * TSL function for creating a renderer reference node.
   *
   * @function
   * @param {String} name - The name of the property the node refers to.
   * @param {String} type - The uniform type that should be used to represent the property value.
   * @param {Renderer?} [renderer=null] - The renderer the property belongs to. When no renderer is set,
   * the node refers to the renderer of the current state.
   * @returns {RendererReferenceNode}
   */
  var rendererReference = function rendererReference(name, type) {
    var renderer = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
    return nodeObject(new RendererReferenceNode(name, type, renderer));
  };

  /** @module ToneMappingNode **/

  /**
   * This node represents a tone mapping operation.
   *
   * @augments TempNode
   */
  var ToneMappingNode = exports.ToneMappingNode = /*#__PURE__*/function (_TempNode9) {
    /**
     * Constructs a new tone mapping node.
     *
     * @param {Number} toneMapping - The tone mapping type.
     * @param {Node} exposureNode - The tone mapping exposure.
     * @param {Node} [colorNode=null] - The color node to process.
     */
    function ToneMappingNode(toneMapping) {
      var _this29;
      var exposureNode = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : toneMappingExposure;
      var colorNode = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
      (0, _classCallCheck2.default)(this, ToneMappingNode);
      _this29 = _callSuper(this, ToneMappingNode, ['vec3']);

      /**
       * The tone mapping type.
       *
       * @type {Number}
       */
      _this29.toneMapping = toneMapping;

      /**
       * The tone mapping exposure.
       *
       * @type {Node}
       * @default null
       */
      _this29.exposureNode = exposureNode;

      /**
       * Represents the color to process.
       *
       * @type {Node?}
       * @default null
       */
      _this29.colorNode = colorNode;
      return _this29;
    }

    /**
     * Overwrites the default `customCacheKey()` implementation by including the tone
     * mapping type into the cache key.
     *
     * @return {Number} The hash.
     */
    (0, _inherits2.default)(ToneMappingNode, _TempNode9);
    return (0, _createClass2.default)(ToneMappingNode, [{
      key: "customCacheKey",
      value: function customCacheKey() {
        return hash$1(this.toneMapping);
      }
    }, {
      key: "setup",
      value: function setup(builder) {
        var colorNode = this.colorNode || builder.context.color;
        var toneMapping = this.toneMapping;
        if (toneMapping === _$$_REQUIRE(_dependencyMap[1], "./three.core.js").NoToneMapping) return colorNode;
        var outputNode = null;
        var toneMappingFn = builder.renderer.library.getToneMappingFunction(toneMapping);
        if (toneMappingFn !== null) {
          outputNode = vec4(toneMappingFn(colorNode.rgb, this.exposureNode), colorNode.a);
        } else {
          console.error('ToneMappingNode: Unsupported Tone Mapping configuration.', toneMapping);
          outputNode = colorNode;
        }
        return outputNode;
      }
    }], [{
      key: "type",
      get: function get() {
        return 'ToneMappingNode';
      }
    }]);
  }(TempNode);
  /**
   * TSL function for creating a tone mapping node.
   *
   * @function
   * @param {Number} mapping - The tone mapping type.
   * @param {Node<float> | Number} exposure - The tone mapping exposure.
   * @param {Node<vec3> | Color} color - The color node to process.
   * @returns {ToneMappingNode<vec3>}
   */
  var toneMapping = function toneMapping(mapping, exposure, color) {
    return nodeObject(new ToneMappingNode(mapping, nodeObject(exposure), nodeObject(color)));
  };

  /**
   * TSL object that represents the global tone mapping exposure of the renderer.
   *
   * @type {RendererReferenceNode<vec3>}
   */
  var toneMappingExposure = /*@__PURE__*/rendererReference('toneMappingExposure', 'float');
  addMethodChaining('toneMapping', function (color, mapping, exposure) {
    return toneMapping(mapping, exposure, color);
  });

  /** @module BufferAttributeNode **/

  /**
   * In earlier `three.js` versions it was only possible to define attribute data
   * on geometry level. With `BufferAttributeNode`, it is also possible to do this
   * on the node level.
   * ```js
   * const geometry = new THREE.PlaneGeometry();
   * const positionAttribute = geometry.getAttribute( 'position' );
   *
   * const colors = [];
   * for ( let i = 0; i < position.count; i ++ ) {
   * 	colors.push( 1, 0, 0 );
   * }
   *
   * material.colorNode = bufferAttribute( new THREE.Float32BufferAttribute( colors, 3 ) );
   * ```
   * This new approach is especially interesting when geometry data are generated via
   * compute shaders. The below line converts a storage buffer into an attribute node.
   * ```js
   * material.positionNode = positionBuffer.toAttribute();
   * ```
   * @augments InputNode
   */
  var BufferAttributeNode = exports.BufferAttributeNode = /*#__PURE__*/function (_InputNode3) {
    /**
     * Constructs a new buffer attribute node.
     *
     * @param {BufferAttribute|InterleavedBuffer|TypedArray} value - The attribute data.
     * @param {String?} [bufferType=null] - The buffer type (e.g. `'vec3'`).
     * @param {Number} [bufferStride=0] - The buffer stride.
     * @param {Number} [bufferOffset=0] - The buffer offset.
     */
    function BufferAttributeNode(value) {
      var _this30;
      var bufferType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      var bufferStride = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      var bufferOffset = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
      (0, _classCallCheck2.default)(this, BufferAttributeNode);
      _this30 = _callSuper(this, BufferAttributeNode, [value, bufferType]);

      /**
       * This flag can be used for type testing.
       *
       * @type {Boolean}
       * @readonly
       * @default true
       */
      _this30.isBufferNode = true;

      /**
       * The buffer type (e.g. `'vec3'`).
       *
       * @type {String}
       * @default null
       */
      _this30.bufferType = bufferType;

      /**
       * The buffer stride.
       *
       * @type {Number}
       * @default 0
       */
      _this30.bufferStride = bufferStride;

      /**
       * The buffer offset.
       *
       * @type {Number}
       * @default 0
       */
      _this30.bufferOffset = bufferOffset;

      /**
       * The usage property. Set this to `THREE.DynamicDrawUsage` via `.setUsage()`,
       * if you are planning to update the attribute data per frame.
       *
       * @type {Number}
       * @default StaticDrawUsage
       */
      _this30.usage = _$$_REQUIRE(_dependencyMap[1], "./three.core.js").StaticDrawUsage;

      /**
       * Whether the attribute is instanced or not.
       *
       * @type {Boolean}
       * @default false
       */
      _this30.instanced = false;

      /**
       * A reference to the buffer attribute.
       *
       * @type {BufferAttribute?}
       * @default null
       */
      _this30.attribute = null;

      /**
       * `BufferAttributeNode` sets this property to `true` by default.
       *
       * @type {Boolean}
       * @default true
       */
      _this30.global = true;
      if (value && value.isBufferAttribute === true) {
        _this30.attribute = value;
        _this30.usage = value.usage;
        _this30.instanced = value.isInstancedBufferAttribute;
      }
      return _this30;
    }

    /**
     * This method is overwritten since the attribute data might be shared
     * and thus the hash should be shared as well.
     *
     * @param {NodeBuilder} builder - The current node builder.
     * @return {String} The hash.
     */
    (0, _inherits2.default)(BufferAttributeNode, _InputNode3);
    return (0, _createClass2.default)(BufferAttributeNode, [{
      key: "getHash",
      value: function getHash(builder) {
        if (this.bufferStride === 0 && this.bufferOffset === 0) {
          var bufferData = builder.globalCache.getData(this.value);
          if (bufferData === undefined) {
            bufferData = {
              node: this
            };
            builder.globalCache.setData(this.value, bufferData);
          }
          return bufferData.node.uuid;
        }
        return this.uuid;
      }

      /**
       * This method is overwritten since the node type is inferred from
       * the buffer attribute.
       *
       * @param {NodeBuilder} builder - The current node builder.
       * @return {String} The node type.
       */
    }, {
      key: "getNodeType",
      value: function getNodeType(builder) {
        if (this.bufferType === null) {
          this.bufferType = builder.getTypeFromAttribute(this.attribute);
        }
        return this.bufferType;
      }

      /**
       * Depending on which value was passed to the node, `setup()` behaves
       * differently. If no instance of `BufferAttribute` was passed, the method
       * creates an internal attribute and configures it respectively.
       *
       * @param {NodeBuilder} builder - The current node builder.
       */
    }, {
      key: "setup",
      value: function setup(builder) {
        if (this.attribute !== null) return;
        var type = this.getNodeType(builder);
        var array = this.value;
        var itemSize = builder.getTypeLength(type);
        var stride = this.bufferStride || itemSize;
        var offset = this.bufferOffset;
        var buffer = array.isInterleavedBuffer === true ? array : new (_$$_REQUIRE(_dependencyMap[1], "./three.core.js").InterleavedBuffer)(array, stride);
        var bufferAttribute = new (_$$_REQUIRE(_dependencyMap[1], "./three.core.js").InterleavedBufferAttribute)(buffer, itemSize, offset);
        buffer.setUsage(this.usage);
        this.attribute = bufferAttribute;
        this.attribute.isInstancedBufferAttribute = this.instanced; // @TODO: Add a possible: InstancedInterleavedBufferAttribute
      }

      /**
       * Generates the code snippet of the buffer attribute node.
       *
       * @param {NodeBuilder} builder - The current node builder.
       * @return {String} The generated code snippet.
       */
    }, {
      key: "generate",
      value: function generate(builder) {
        var nodeType = this.getNodeType(builder);
        var nodeAttribute = builder.getBufferAttributeFromNode(this, nodeType);
        var propertyName = builder.getPropertyName(nodeAttribute);
        var output = null;
        if (builder.shaderStage === 'vertex' || builder.shaderStage === 'compute') {
          this.name = propertyName;
          output = propertyName;
        } else {
          var nodeVarying = varying(this);
          output = nodeVarying.build(builder, nodeType);
        }
        return output;
      }

      /**
       * Overwrites the default implementation to return a fixed value `'bufferAttribute'`.
       *
       * @param {NodeBuilder} builder - The current node builder.
       * @return {String} The input type.
       */
    }, {
      key: "getInputType",
      value: function getInputType(/*builder*/
      ) {
        return 'bufferAttribute';
      }

      /**
       * Sets the `usage` property to the given value.
       *
       * @param {Number} value - The usage to set.
       * @return {BufferAttributeNode} A reference to this node.
       */
    }, {
      key: "setUsage",
      value: function setUsage(value) {
        this.usage = value;
        if (this.attribute && this.attribute.isBufferAttribute === true) {
          this.attribute.usage = value;
        }
        return this;
      }

      /**
       * Sets the `instanced` property to the given value.
       *
       * @param {Number} value - The value to set.
       * @return {BufferAttributeNode} A reference to this node.
       */
    }, {
      key: "setInstanced",
      value: function setInstanced(value) {
        this.instanced = value;
        return this;
      }
    }], [{
      key: "type",
      get: function get() {
        return 'BufferAttributeNode';
      }
    }]);
  }(InputNode);
  /**
   * TSL function for creating a buffer attribute node.
   *
   * @function
   * @param {BufferAttribute|InterleavedBuffer|TypedArray} array - The attribute data.
   * @param {String?} [type=null] - The buffer type (e.g. `'vec3'`).
   * @param {Number} [stride=0] - The buffer stride.
   * @param {Number} [offset=0] - The buffer offset.
   * @returns {BufferAttributeNode}
   */
  var bufferAttribute = function bufferAttribute(array) {
    var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    var stride = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
    var offset = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
    return nodeObject(new BufferAttributeNode(array, type, stride, offset));
  };

  /**
   * TSL function for creating a buffer attribute node but with dynamic draw usage.
   * Use this function if attribute data are updated per frame.
   *
   * @function
   * @param {BufferAttribute|InterleavedBuffer|TypedArray} array - The attribute data.
   * @param {String?} [type=null] - The buffer type (e.g. `'vec3'`).
   * @param {Number} [stride=0] - The buffer stride.
   * @param {Number} [offset=0] - The buffer offset.
   * @returns {BufferAttributeNode}
   */
  var dynamicBufferAttribute = function dynamicBufferAttribute(array) {
    var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    var stride = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
    var offset = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
    return bufferAttribute(array, type, stride, offset).setUsage(_$$_REQUIRE(_dependencyMap[1], "./three.core.js").DynamicDrawUsage);
  };

  /**
   * TSL function for creating a buffer attribute node but with enabled instancing
   *
   * @function
   * @param {BufferAttribute|InterleavedBuffer|TypedArray} array - The attribute data.
   * @param {String?} [type=null] - The buffer type (e.g. `'vec3'`).
   * @param {Number} [stride=0] - The buffer stride.
   * @param {Number} [offset=0] - The buffer offset.
   * @returns {BufferAttributeNode}
   */
  var instancedBufferAttribute = function instancedBufferAttribute(array) {
    var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    var stride = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
    var offset = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
    return bufferAttribute(array, type, stride, offset).setInstanced(true);
  };

  /**
   * TSL function for creating a buffer attribute node but with dynamic draw usage and enabled instancing
   *
   * @function
   * @param {BufferAttribute|InterleavedBuffer|TypedArray} array - The attribute data.
   * @param {String?} [type=null] - The buffer type (e.g. `'vec3'`).
   * @param {Number} [stride=0] - The buffer stride.
   * @param {Number} [offset=0] - The buffer offset.
   * @returns {BufferAttributeNode}
   */
  var instancedDynamicBufferAttribute = function instancedDynamicBufferAttribute(array) {
    var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    var stride = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
    var offset = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
    return dynamicBufferAttribute(array, type, stride, offset).setInstanced(true);
  };
  addMethodChaining('toAttribute', function (bufferNode) {
    return bufferAttribute(bufferNode.value);
  });

  /** @module ComputeNode **/

  /**
   * TODO
   *
   * @augments Node
   */
  var ComputeNode = exports.ComputeNode = /*#__PURE__*/function (_Node15) {
    /**
     * Constructs a new compute node.
     *
     * @param {Node} computeNode - TODO
     * @param {Number} count - TODO.
     * @param {Array<Number>} [workgroupSize=[64]] - TODO.
     */
    function ComputeNode(computeNode, count) {
      var _this31;
      var workgroupSize = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [64];
      (0, _classCallCheck2.default)(this, ComputeNode);
      _this31 = _callSuper(this, ComputeNode, ['void']);

      /**
       * This flag can be used for type testing.
       *
       * @type {Boolean}
       * @readonly
       * @default true
       */
      _this31.isComputeNode = true;

      /**
       * TODO
       *
       * @type {Node}
       */
      _this31.computeNode = computeNode;

      /**
       * TODO
       *
       * @type {Number}
       */
      _this31.count = count;

      /**
       * TODO
       *
       * @type {Array<Number>}
       * @default [64]
       */
      _this31.workgroupSize = workgroupSize;

      /**
       * TODO
       *
       * @type {Number}
       */
      _this31.dispatchCount = 0;

      /**
       * TODO
       *
       * @type {Number}
       */
      _this31.version = 1;

      /**
       * The name or label of the uniform.
       *
       * @type {String}
       * @default ''
       */
      _this31.name = '';

      /**
       * The `updateBeforeType` is set to `NodeUpdateType.OBJECT` since {@link ComputeNode#updateBefore}
       * is executed once per object by default.
       *
       * @type {String}
       * @default 'object'
       */
      _this31.updateBeforeType = NodeUpdateType.OBJECT;

      /**
       * TODO
       *
       * @type {Function}
       */
      _this31.onInitFunction = null;
      _this31.updateDispatchCount();
      return _this31;
    }

    /**
     * Executes the `dispose` event for this node.
     */
    (0, _inherits2.default)(ComputeNode, _Node15);
    return (0, _createClass2.default)(ComputeNode, [{
      key: "dispose",
      value: function dispose() {
        this.dispatchEvent({
          type: 'dispose'
        });
      }

      /**
       * Sets the {@link ComputeNode#name} property.
       *
       * @param {String} name - The name of the uniform.
       * @return {ComputeNode} A reference to this node.
       */
    }, {
      key: "label",
      value: function label(name) {
        this.name = name;
        return this;
      }

      /**
       * TODO
       */
    }, {
      key: "updateDispatchCount",
      value: function updateDispatchCount() {
        var count = this.count,
          workgroupSize = this.workgroupSize;
        var size = workgroupSize[0];
        for (var i = 1; i < workgroupSize.length; i++) size *= workgroupSize[i];
        this.dispatchCount = Math.ceil(count / size);
      }

      /**
       * TODO
       *
       * @param {Function} callback - TODO.
       * @return {ComputeNode} A reference to this node.
       */
    }, {
      key: "onInit",
      value: function onInit(callback) {
        this.onInitFunction = callback;
        return this;
      }

      /**
       * The method execute the compute for this node.
       *
       * @param {NodeFrame} frame - A reference to the current node frame.
       */
    }, {
      key: "updateBefore",
      value: function updateBefore(_ref11) {
        var renderer = _ref11.renderer;
        renderer.compute(this);
      }
    }, {
      key: "generate",
      value: function generate(builder) {
        var shaderStage = builder.shaderStage;
        if (shaderStage === 'compute') {
          var snippet = this.computeNode.build(builder, 'void');
          if (snippet !== '') {
            builder.addLineFlowCode(snippet, this);
          }
        }
      }
    }], [{
      key: "type",
      get: function get() {
        return 'ComputeNode';
      }
    }]);
  }(Node);
  /**
   * TSL function for creating a compute node.
   *
   * @function
   * @param {Node} node - TODO
   * @param {Number} count - TODO.
   * @param {Array<Number>} [workgroupSize=[64]] - TODO.
   * @returns {AtomicFunctionNode}
   */
  var compute = function compute(node, count, workgroupSize) {
    return nodeObject(new ComputeNode(nodeObject(node), count, workgroupSize));
  };
  addMethodChaining('compute', compute);

  /** @module CacheNode **/

  /**
   * This node can be used as a cache management component for another node.
   * Caching is in general used by default in {@link NodeBuilder} but this node
   * allows the usage of a shared parent cache during the build process.
   *
   * @augments Node
   */
  var CacheNode = exports.CacheNode = /*#__PURE__*/function (_Node16) {
    /**
     * Constructs a new cache node.
     *
     * @param {Node} node - The node that should be cached.
     * @param {Boolean} [parent=true] - Whether this node refers to a shared parent cache or not.
     */
    function CacheNode(node) {
      var _this32;
      var parent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
      (0, _classCallCheck2.default)(this, CacheNode);
      _this32 = _callSuper(this, CacheNode);

      /**
       * The node that should be cached.
       *
       * @type {Node}
       */
      _this32.node = node;

      /**
       * Whether this node refers to a shared parent cache or not.
       *
       * @type {Boolean}
       * @default true
       */
      _this32.parent = parent;

      /**
       * This flag can be used for type testing.
       *
       * @type {Boolean}
       * @readonly
       * @default true
       */
      _this32.isCacheNode = true;
      return _this32;
    }
    (0, _inherits2.default)(CacheNode, _Node16);
    return (0, _createClass2.default)(CacheNode, [{
      key: "getNodeType",
      value: function getNodeType(builder) {
        var previousCache = builder.getCache();
        var cache = builder.getCacheFromNode(this, this.parent);
        builder.setCache(cache);
        var nodeType = this.node.getNodeType(builder);
        builder.setCache(previousCache);
        return nodeType;
      }
    }, {
      key: "build",
      value: function build(builder) {
        var _this$node;
        var previousCache = builder.getCache();
        var cache = builder.getCacheFromNode(this, this.parent);
        builder.setCache(cache);
        for (var _len15 = arguments.length, params = new Array(_len15 > 1 ? _len15 - 1 : 0), _key15 = 1; _key15 < _len15; _key15++) {
          params[_key15 - 1] = arguments[_key15];
        }
        var data = (_this$node = this.node).build.apply(_this$node, [builder].concat(params));
        builder.setCache(previousCache);
        return data;
      }
    }], [{
      key: "type",
      get: function get() {
        return 'CacheNode';
      }
    }]);
  }(Node);
  /**
   * TSL function for creating a cache node.
   *
   * @function
   * @param {Node} node - The node that should be cached.
   * @param {Boolean} parent - Whether this node refers to a shared parent cache or not.
   * @returns {CacheNode}
   */
  var cache = function cache(node, parent) {
    return nodeObject(new CacheNode(nodeObject(node), parent));
  };
  addMethodChaining('cache', cache);

  /** @module BypassNode **/

  /**
   * The class generates the code of a given node but returns another node in the output.
   * This can be used to call a method or node that does not return a value, i.e.
   * type `void` on an input where returning a value is required. Example:
   *
   * ```js
   * material.colorNode = myColor.bypass( runVoidFn() )
   *```
   *
   * @augments Node
   */
  var BypassNode = exports.BypassNode = /*#__PURE__*/function (_Node17) {
    /**
     * Constructs a new bypass node.
     *
     * @param {Node} outputNode - The output node.
     * @param {Node} callNode - The call node.
     */
    function BypassNode(outputNode, callNode) {
      var _this33;
      (0, _classCallCheck2.default)(this, BypassNode);
      _this33 = _callSuper(this, BypassNode);

      /**
       * This flag can be used for type testing.
       *
       * @type {Boolean}
       * @readonly
       * @default true
       */
      _this33.isBypassNode = true;

      /**
       * The output node.
       *
       * @type {Node}
       */
      _this33.outputNode = outputNode;

      /**
       * The call node.
       *
       * @type {Node}
       */
      _this33.callNode = callNode;
      return _this33;
    }
    (0, _inherits2.default)(BypassNode, _Node17);
    return (0, _createClass2.default)(BypassNode, [{
      key: "getNodeType",
      value: function getNodeType(builder) {
        return this.outputNode.getNodeType(builder);
      }
    }, {
      key: "generate",
      value: function generate(builder) {
        var snippet = this.callNode.build(builder, 'void');
        if (snippet !== '') {
          builder.addLineFlowCode(snippet, this);
        }
        return this.outputNode.build(builder);
      }
    }], [{
      key: "type",
      get: function get() {
        return 'BypassNode';
      }
    }]);
  }(Node);
  /**
   * TSL function for creating a bypass node.
   *
   * @function
   * @param {Node} outputNode - The output node.
   * @param {Node} callNode - The call node.
   * @returns {BypassNode}
   */
  var bypass = /*@__PURE__*/nodeProxy(BypassNode);
  addMethodChaining('bypass', bypass);

  /** @module RemapNode **/

  /**
   * This node allows to remap a node value from one range into another. E.g a value of
   * `0.4` in the range `[ 0.3, 0.5 ]` should be remapped into the normalized range `[ 0, 1 ]`.
   * `RemapNode` takes care of that and converts the original value of `0.4` to `0.5`.
   *
   * @augments Node
   */
  var RemapNode = exports.RemapNode = /*#__PURE__*/function (_Node18) {
    /**
     * Constructs a new remap node.
     *
     * @param {Node} node - The node that should be remapped.
     * @param {Node} inLowNode - The source or current lower bound of the range.
     * @param {Node} inHighNode - The source or current upper bound of the range.
     * @param {Node} [outLowNode=float(0)] - The target lower bound of the range.
     * @param {Node} [outHighNode=float(1)] - The target upper bound of the range.
     */
    function RemapNode(node, inLowNode, inHighNode) {
      var _this34;
      var outLowNode = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : float(0);
      var outHighNode = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : float(1);
      (0, _classCallCheck2.default)(this, RemapNode);
      _this34 = _callSuper(this, RemapNode);

      /**
       * The node that should be remapped.
       *
       * @type {Node}
       */
      _this34.node = node;

      /**
       * The source or current lower bound of the range.
       *
       * @type {Node}
       */
      _this34.inLowNode = inLowNode;

      /**
       * The source or current upper bound of the range.
       *
       * @type {Node}
       */
      _this34.inHighNode = inHighNode;

      /**
       * The target lower bound of the range.
       *
       * @type {Node}
       * @default float(0)
       */
      _this34.outLowNode = outLowNode;

      /**
       * The target upper bound of the range.
       *
       * @type {Node}
       * @default float(1)
       */
      _this34.outHighNode = outHighNode;

      /**
       * Whether the node value should be clamped before
       * remapping it to the target range.
       *
       * @type {Boolean}
       * @default true
       */
      _this34.doClamp = true;
      return _this34;
    }
    (0, _inherits2.default)(RemapNode, _Node18);
    return (0, _createClass2.default)(RemapNode, [{
      key: "setup",
      value: function setup() {
        var node = this.node,
          inLowNode = this.inLowNode,
          inHighNode = this.inHighNode,
          outLowNode = this.outLowNode,
          outHighNode = this.outHighNode,
          doClamp = this.doClamp;
        var t = node.sub(inLowNode).div(inHighNode.sub(inLowNode));
        if (doClamp === true) t = t.clamp();
        return t.mul(outHighNode.sub(outLowNode)).add(outLowNode);
      }
    }], [{
      key: "type",
      get: function get() {
        return 'RemapNode';
      }
    }]);
  }(Node);
  /**
   * TSL function for creating a remap node.
   *
   * @function
   * @param {Node} node - The node that should be remapped.
   * @param {Node} inLowNode - The source or current lower bound of the range.
   * @param {Node} inHighNode - The source or current upper bound of the range.
   * @param {Node} [outLowNode=float(0)] - The target lower bound of the range.
   * @param {Node} [outHighNode=float(1)] - The target upper bound of the range.
   * @returns {RemapNode}
   */
  var remap = /*@__PURE__*/nodeProxy(RemapNode, null, null, {
    doClamp: false
  });

  /**
   * TSL function for creating a remap node, but with enabled clamping.
   *
   * @function
   * @param {Node} node - The node that should be remapped.
   * @param {Node} inLowNode - The source or current lower bound of the range.
   * @param {Node} inHighNode - The source or current upper bound of the range.
   * @param {Node} [outLowNode=float(0)] - The target lower bound of the range.
   * @param {Node} [outHighNode=float(1)] - The target upper bound of the range.
   * @returns {RemapNode}
   */
  var remapClamp = /*@__PURE__*/nodeProxy(RemapNode);
  addMethodChaining('remap', remap);
  addMethodChaining('remapClamp', remapClamp);

  /** @module ExpressionNode **/

  /**
   * This class can be used to implement basic expressions in shader code.
   * Basic examples for that are `return`, `continue` or `discard` statements.
   *
   * @augments Node
   */
  var ExpressionNode = exports.ExpressionNode = /*#__PURE__*/function (_Node19) {
    /**
     * Constructs a new expression node.
     *
     * @param {String} [snippet=''] - The native code snippet.
     * @param {String} [nodeType='void'] - The node type.
     */
    function ExpressionNode() {
      var _this35;
      var snippet = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
      var nodeType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'void';
      (0, _classCallCheck2.default)(this, ExpressionNode);
      _this35 = _callSuper(this, ExpressionNode, [nodeType]);

      /**
       * The native code snippet.
       *
       * @type {String}
       * @default ''
       */
      _this35.snippet = snippet;
      return _this35;
    }
    (0, _inherits2.default)(ExpressionNode, _Node19);
    return (0, _createClass2.default)(ExpressionNode, [{
      key: "generate",
      value: function generate(builder, output) {
        var type = this.getNodeType(builder);
        var snippet = this.snippet;
        if (type === 'void') {
          builder.addLineFlowCode(snippet, this);
        } else {
          return builder.format(`( ${snippet} )`, type, output);
        }
      }
    }], [{
      key: "type",
      get: function get() {
        return 'ExpressionNode';
      }
    }]);
  }(Node);
  /**
   * TSL function for creating an expression node.
   *
   * @function
   * @param {String} [snippet=''] - The native code snippet.
   * @param {String} [nodeType='void'] - The node type.
   * @returns {ExpressionNode}
   */
  var expression = /*@__PURE__*/nodeProxy(ExpressionNode);

  /** @module Discard **/

  /**
   * Represents a `discard` shader operation in TSL.
   *
   * @method
   * @param {ConditionalNode?} conditional - An optional conditional node. It allows to decide whether the discard should be executed or not.
   * @return {Node} The `discard` expression.
   */
  var Discard = function Discard(conditional) {
    return (conditional ? select(conditional, expression('discard')) : expression('discard')).append();
  };

  /**
   * Represents a `return` shader operation in TSL.
   *
   * @method
   * @return {ExpressionNode} The `return` expression.
   */
  var Return = function Return() {
    return expression('return').append();
  };
  addMethodChaining('discard', Discard);

  /** @module RenderOutputNode **/

  /**
   * Normally, tone mapping and color conversion happens automatically
   * before outputting pixel too the default (screen) framebuffer. In certain
   * post processing setups this happens to late because certain effects
   * require e.g. sRGB input. For such scenarios, `RenderOutputNode` can be used
   * to apply tone mapping and color space conversion at an arbitrary point
   * in the effect chain.
   *
   * When applying tone mapping and color space conversion manually with this node,
   * you have to set {@link PostProcessing#outputColorTransform} to `false`.
   *
   * ```js
   * const postProcessing = new PostProcessing( renderer );
   * postProcessing.outputColorTransform = false;
   *
   * const scenePass = pass( scene, camera );
   * const outputPass = renderOutput( scenePass );
   *
   * postProcessing.outputNode = outputPass;
   * ```
   *
   * @augments TempNode
   */
  var RenderOutputNode = exports.RenderOutputNode = /*#__PURE__*/function (_TempNode10) {
    /**
     * Constructs a new render output node.
     *
     * @param {Node} colorNode - The color node to process.
     * @param {Number} toneMapping - The tone mapping type.
     * @param {String} outputColorSpace - The output color space.
     */
    function RenderOutputNode(colorNode, toneMapping, outputColorSpace) {
      var _this36;
      (0, _classCallCheck2.default)(this, RenderOutputNode);
      _this36 = _callSuper(this, RenderOutputNode, ['vec4']);

      /**
       * The color node to process.
       *
       * @type {Node}
       */
      _this36.colorNode = colorNode;

      /**
       * The tone mapping type.
       *
       * @type {Number?}
       */
      _this36.toneMapping = toneMapping;

      /**
       * The output color space.
       *
       * @type {String?}
       */
      _this36.outputColorSpace = outputColorSpace;

      /**
       * This flag can be used for type testing.
       *
       * @type {Boolean}
       * @readonly
       * @default true
       */
      _this36.isRenderOutputNode = true;
      return _this36;
    }
    (0, _inherits2.default)(RenderOutputNode, _TempNode10);
    return (0, _createClass2.default)(RenderOutputNode, [{
      key: "setup",
      value: function setup(_ref12) {
        var context = _ref12.context;
        var outputNode = this.colorNode || context.color;

        // tone mapping

        var toneMapping = (this.toneMapping !== null ? this.toneMapping : context.toneMapping) || _$$_REQUIRE(_dependencyMap[1], "./three.core.js").NoToneMapping;
        var outputColorSpace = (this.outputColorSpace !== null ? this.outputColorSpace : context.outputColorSpace) || _$$_REQUIRE(_dependencyMap[1], "./three.core.js").NoColorSpace;
        if (toneMapping !== _$$_REQUIRE(_dependencyMap[1], "./three.core.js").NoToneMapping) {
          outputNode = outputNode.toneMapping(toneMapping);
        }

        // working to output color space

        if (outputColorSpace !== _$$_REQUIRE(_dependencyMap[1], "./three.core.js").NoColorSpace && outputColorSpace !== _$$_REQUIRE(_dependencyMap[1], "./three.core.js").ColorManagement.workingColorSpace) {
          outputNode = outputNode.workingToColorSpace(outputColorSpace);
        }
        return outputNode;
      }
    }], [{
      key: "type",
      get: function get() {
        return 'RenderOutputNode';
      }
    }]);
  }(TempNode);
  /**
   * TSL function for creating a posterize node.
   *
   * @function
   * @param {Node} color - The color node to process.
   * @param {Number?} [toneMapping=null] - The tone mapping type.
   * @param {String?} [outputColorSpace=null] - The output color space.
   * @returns {RenderOutputNode}
   */
  var renderOutput = function renderOutput(color) {
    var toneMapping = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    var outputColorSpace = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
    return nodeObject(new RenderOutputNode(nodeObject(color), toneMapping, outputColorSpace));
  };
  addMethodChaining('renderOutput', renderOutput);

  // Non-PURE exports list, side-effects are required here.
  // TSL Base Syntax

  function addNodeElement(name /*, nodeElement*/) {
    console.warn('THREE.TSLBase: AddNodeElement has been removed in favor of tree-shaking. Trying add', name);
  }

  /** @module AttributeNode **/

  /**
   * Base class for representing shader attributes as nodes.
   *
   * @augments Node
   */
  var AttributeNode = exports.AttributeNode = /*#__PURE__*/function (_Node20) {
    /**
     * Constructs a new attribute node.
     *
     * @param {String} attributeName - The name of the attribute.
     * @param {String?} nodeType - The node type.
     */
    function AttributeNode(attributeName) {
      var _this37;
      var nodeType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      (0, _classCallCheck2.default)(this, AttributeNode);
      _this37 = _callSuper(this, AttributeNode, [nodeType]);

      /**
       * `AttributeNode` sets this property to `true` by default.
       *
       * @type {Boolean}
       * @default true
       */
      _this37.global = true;
      _this37._attributeName = attributeName;
      return _this37;
    }
    (0, _inherits2.default)(AttributeNode, _Node20);
    return (0, _createClass2.default)(AttributeNode, [{
      key: "getHash",
      value: function getHash(builder) {
        return this.getAttributeName(builder);
      }
    }, {
      key: "getNodeType",
      value: function getNodeType(builder) {
        var nodeType = this.nodeType;
        if (nodeType === null) {
          var attributeName = this.getAttributeName(builder);
          if (builder.hasGeometryAttribute(attributeName)) {
            var _attribute3 = builder.geometry.getAttribute(attributeName);
            nodeType = builder.getTypeFromAttribute(_attribute3);
          } else {
            nodeType = 'float';
          }
        }
        return nodeType;
      }

      /**
       * Sets the attribute name to the given value. The method can be
       * overwritten in derived classes if the final name must be computed
       * analytically.
       *
       * @param {String} attributeName - The name of the attribute.
       * @return {AttributeNode} A reference to this node.
       */
    }, {
      key: "setAttributeName",
      value: function setAttributeName(attributeName) {
        this._attributeName = attributeName;
        return this;
      }

      /**
       * Returns the attribute name of this node. The method can be
       * overwritten in derived classes if the final name must be computed
       * analytically.
       *
       * @param {NodeBuilder} builder - The current node builder.
       * @return {String} The attribute name.
       */
    }, {
      key: "getAttributeName",
      value: function getAttributeName(/*builder*/
      ) {
        return this._attributeName;
      }
    }, {
      key: "generate",
      value: function generate(builder) {
        var attributeName = this.getAttributeName(builder);
        var nodeType = this.getNodeType(builder);
        var geometryAttribute = builder.hasGeometryAttribute(attributeName);
        if (geometryAttribute === true) {
          var _attribute4 = builder.geometry.getAttribute(attributeName);
          var attributeType = builder.getTypeFromAttribute(_attribute4);
          var nodeAttribute = builder.getAttribute(attributeName, attributeType);
          if (builder.shaderStage === 'vertex') {
            return builder.format(nodeAttribute.name, attributeType, nodeType);
          } else {
            var nodeVarying = varying(this);
            return nodeVarying.build(builder, nodeType);
          }
        } else {
          console.warn(`AttributeNode: Vertex attribute "${attributeName}" not found on geometry.`);
          return builder.generateConst(nodeType);
        }
      }
    }, {
      key: "serialize",
      value: function serialize(data) {
        _superPropGet(AttributeNode, "serialize", this, 3)([data]);
        data.global = this.global;
        data._attributeName = this._attributeName;
      }
    }, {
      key: "deserialize",
      value: function deserialize(data) {
        _superPropGet(AttributeNode, "deserialize", this, 3)([data]);
        this.global = data.global;
        this._attributeName = data._attributeName;
      }
    }], [{
      key: "type",
      get: function get() {
        return 'AttributeNode';
      }
    }]);
  }(Node);
  /**
   * TSL function for creating an attribute node.
   *
   * @function
   * @param {String} name - The name of the attribute.
   * @param {String?} nodeType - The node type.
   * @returns {AttributeNode}
   */
  var attribute = function attribute(name, nodeType) {
    return nodeObject(new AttributeNode(name, nodeType));
  };

  /** @module UV **/

  /**
   * TSL function for creating an uv attribute node with the given index.
   *
   * @function
   * @param {Number} [index=0] - The uv index.
   * @return {AttributeNode<vec2>} The uv attribute node.
   */
  var uv = function uv() {
    var index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    return attribute('uv' + (index > 0 ? index : ''), 'vec2');
  };

  /** @module TextureSizeNode **/

  /**
   * A node that represents the dimensions of a texture. The texture size is
   * retrieved in the shader via built-in shader functions like `textureDimensions()`
   * or `textureSize()`.
   *
   * @augments Node
   */
  var TextureSizeNode = exports.TextureSizeNode = /*#__PURE__*/function (_Node21) {
    /**
     * Constructs a new texture size node.
     *
     * @param {TextureNode} textureNode - A texture node which size should be retrieved.
     * @param {Node<int>?} [levelNode=null] - A level node which defines the requested mip.
     */
    function TextureSizeNode(textureNode) {
      var _this38;
      var levelNode = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      (0, _classCallCheck2.default)(this, TextureSizeNode);
      _this38 = _callSuper(this, TextureSizeNode, ['uvec2']);

      /**
       * This flag can be used for type testing.
       *
       * @type {Boolean}
       * @readonly
       * @default true
       */
      _this38.isTextureSizeNode = true;

      /**
       * A texture node which size should be retrieved.
       *
       * @type {TextureNode}
       */
      _this38.textureNode = textureNode;

      /**
       * A level node which defines the requested mip.
       *
       * @type {Node<int>}
       * @default null
       */
      _this38.levelNode = levelNode;
      return _this38;
    }
    (0, _inherits2.default)(TextureSizeNode, _Node21);
    return (0, _createClass2.default)(TextureSizeNode, [{
      key: "generate",
      value: function generate(builder, output) {
        var textureProperty = this.textureNode.build(builder, 'property');
        var level = this.levelNode === null ? '0' : this.levelNode.build(builder, 'int');
        return builder.format(`${builder.getMethod('textureDimensions')}( ${textureProperty}, ${level} )`, this.getNodeType(builder), output);
      }
    }], [{
      key: "type",
      get: function get() {
        return 'TextureSizeNode';
      }
    }]);
  }(Node);
  /**
   * TSL function for creating a texture size node.
   *
   * @function
   * @param {TextureNode} textureNode - A texture node which size should be retrieved.
   * @param {Node<int>?} [levelNode=null] - A level node which defines the requested mip.
   * @returns {TextureSizeNode}
   */
  var textureSize = /*@__PURE__*/nodeProxy(TextureSizeNode);

  /** @module MatcapUVNode **/

  /**
   * A special type of uniform node that computes the
   * maximum mipmap level for a given texture node.
   *
   * ```js
   * const level = maxMipLevel( textureNode );
   * ```
   *
   * @augments module:UniformNode~UniformNode
   */
  var MaxMipLevelNode = exports.MaxMipLevelNode = /*#__PURE__*/function (_UniformNode) {
    /**
     * Constructs a new max mip level node.
     *
     * @param {TextureNode} textureNode - The texture node to compute the max mip level for.
     */
    function MaxMipLevelNode(textureNode) {
      var _this39;
      (0, _classCallCheck2.default)(this, MaxMipLevelNode);
      _this39 = _callSuper(this, MaxMipLevelNode, [0]);

      /**
       * The texture node to compute the max mip level for.
       *
       * @private
       * @type {TextureNode}
       */
      _this39._textureNode = textureNode;

      /**
       * The `updateType` is set to `NodeUpdateType.FRAME` since the node updates
       * the texture once per frame in its {@link MaxMipLevelNode#update} method.
       *
       * @type {String}
       * @default 'frame'
       */
      _this39.updateType = NodeUpdateType.FRAME;
      return _this39;
    }

    /**
     * The texture node to compute the max mip level for.
     *
     * @readonly
     * @type {TextureNode}
     */
    (0, _inherits2.default)(MaxMipLevelNode, _UniformNode);
    return (0, _createClass2.default)(MaxMipLevelNode, [{
      key: "textureNode",
      get: function get() {
        return this._textureNode;
      }

      /**
       * The texture.
       *
       * @readonly
       * @type {Texture}
       */
    }, {
      key: "texture",
      get: function get() {
        return this._textureNode.value;
      }
    }, {
      key: "update",
      value: function update() {
        var texture = this.texture;
        var images = texture.images;
        var image = images && images.length > 0 ? images[0] && images[0].image || images[0] : texture.image;
        if (image && image.width !== undefined) {
          var width = image.width,
            height = image.height;
          this.value = Math.log2(Math.max(width, height));
        }
      }
    }], [{
      key: "type",
      get: function get() {
        return 'MaxMipLevelNode';
      }
    }]);
  }(UniformNode);
  /**
   * TSL function for creating a max mip level node.
   *
   * @function
   * @param {TextureNode} textureNode - The texture node to compute the max mip level for.
   * @returns {MaxMipLevelNode}
   */
  var maxMipLevel = /*@__PURE__*/nodeProxy(MaxMipLevelNode);

  /** @module TextureNode **/

  /**
   * This type of uniform node represents a 2D texture.
   *
   * @augments module:UniformNode~UniformNode
   */
  var TextureNode = exports.TextureNode = /*#__PURE__*/function (_UniformNode2) {
    /**
     * Constructs a new texture node.
     *
     * @param {Texture} value - The texture.
     * @param {Node<vec2|vec3>?} [uvNode=null] - The uv node.
     * @param {Node<int>?} [levelNode=null] - The level node.
     * @param {Node<float>?} [biasNode=null] - The bias node.
     */
    function TextureNode(value) {
      var _this40;
      var uvNode = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      var levelNode = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
      var biasNode = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
      (0, _classCallCheck2.default)(this, TextureNode);
      _this40 = _callSuper(this, TextureNode, [value]);

      /**
       * This flag can be used for type testing.
       *
       * @type {Boolean}
       * @readonly
       * @default true
       */
      _this40.isTextureNode = true;

      /**
       * Represents the texture coordinates.
       *
       * @type {Node<vec2|vec3>?}
       * @default null
       */
      _this40.uvNode = uvNode;

      /**
       * Represents the mip level that should be selected.
       *
       * @type {Node<int>?}
       * @default null
       */
      _this40.levelNode = levelNode;

      /**
       * Represents the bias to be applied during level-of-detail computation.
       *
       * @type {Node<float>?}
       * @default null
       */
      _this40.biasNode = biasNode;

      /**
       * Represents a reference value a texture sample is compared to.
       *
       * @type {Node<float>?}
       * @default null
       */
      _this40.compareNode = null;

      /**
       * When using texture arrays, the depth node defines the layer to select.
       *
       * @type {Node<int>?}
       * @default null
       */
      _this40.depthNode = null;

      /**
       * When defined, a texture is sampled using explicit gradients.
       *
       * @type {Array<Node<vec2>>?}
       * @default null
       */
      _this40.gradNode = null;

      /**
       * Whether texture values should be sampled or fetched.
       *
       * @type {Boolean}
       * @default true
       */
      _this40.sampler = true;

      /**
       * Whether the uv transformation matrix should be
       * automatically updated or not. Use `setUpdateMatrix()`
       * if you want to change the value of the property.
       *
       * @type {Boolean}
       * @default false
       */
      _this40.updateMatrix = false;

      /**
       * By default the `update()` method is not executed. `setUpdateMatrix()`
       * sets the value to `frame` when the uv transformation matrix should
       * automatically be updated.
       *
       * @type {String}
       * @default 'none'
       */
      _this40.updateType = NodeUpdateType.NONE;

      /**
       * The reference node.
       *
       * @type {Node?}
       * @default null
       */
      _this40.referenceNode = null;

      /**
       * The texture value is stored in a private property.
       *
       * @private
       * @type {Texture}
       */
      _this40._value = value;

      /**
       * The uniform node that represents the uv transformation matrix.
       *
       * @private
       * @type {UniformNode<mat3>?}
       */
      _this40._matrixUniform = null;
      _this40.setUpdateMatrix(uvNode === null);
      return _this40;
    }
    (0, _inherits2.default)(TextureNode, _UniformNode2);
    return (0, _createClass2.default)(TextureNode, [{
      key: "value",
      get:
      /**
       * The texture value.
       *
       * @type {Texture}
       */
      function get() {
        return this.referenceNode ? this.referenceNode.value : this._value;
      }

      /**
       * Overwritten since the uniform hash is defined by the texture's UUID.
       *
       * @param {NodeBuilder} builder - The current node builder.
       * @return {String} The uniform hash.
       */,
      set: function set(value) {
        if (this.referenceNode) {
          this.referenceNode.value = value;
        } else {
          this._value = value;
        }
      }
    }, {
      key: "getUniformHash",
      value: function getUniformHash(/*builder*/
      ) {
        return this.value.uuid;
      }

      /**
       * Overwritten since the node type is inferred from the texture type.
       *
       * @param {NodeBuilder} builder - The current node builder.
       * @return {String} The node type.
       */
    }, {
      key: "getNodeType",
      value: function getNodeType(/*builder*/
      ) {
        if (this.value.isDepthTexture === true) return 'float';
        if (this.value.type === _$$_REQUIRE(_dependencyMap[1], "./three.core.js").UnsignedIntType) {
          return 'uvec4';
        } else if (this.value.type === _$$_REQUIRE(_dependencyMap[1], "./three.core.js").IntType) {
          return 'ivec4';
        }
        return 'vec4';
      }

      /**
       * Overwrites the default implementation to return a fixed value `'texture'`.
       *
       * @param {NodeBuilder} builder - The current node builder.
       * @return {String} The input type.
       */
    }, {
      key: "getInputType",
      value: function getInputType(/*builder*/
      ) {
        return 'texture';
      }

      /**
       * Returns a default uvs based on the current texture's channel.
       *
       * @return {AttributeNode<vec2>} The default uvs.
       */
    }, {
      key: "getDefaultUV",
      value: function getDefaultUV() {
        return uv(this.value.channel);
      }

      /**
       * Overwritten to always return the texture reference of the node.
       *
       * @param {Any} state - This method can be invocated in different contexts so `state` can refer to any object type.
       * @return {Texture} The texture reference.
       */
    }, {
      key: "updateReference",
      value: function updateReference(/*state*/
      ) {
        return this.value;
      }

      /**
       * Transforms the given uv node with the texture transformation matrix.
       *
       * @param {Node} uvNode - The uv node to transform.
       * @return {Node} The transformed uv node.
       */
    }, {
      key: "getTransformedUV",
      value: function getTransformedUV(uvNode) {
        if (this._matrixUniform === null) this._matrixUniform = uniform(this.value.matrix);
        return this._matrixUniform.mul(vec3(uvNode, 1)).xy;
      }

      /**
       * Defines whether the uv transformation matrix should automatically be updated or not.
       *
       * @param {Boolean} value - The update toggle.
       * @return {TextureNode} A reference to this node.
       */
    }, {
      key: "setUpdateMatrix",
      value: function setUpdateMatrix(value) {
        this.updateMatrix = value;
        this.updateType = value ? NodeUpdateType.RENDER : NodeUpdateType.NONE;
        return this;
      }

      /**
       * Setups the uv node. Depending on the backend as well as texture's image and type, it might be necessary
       * to modify the uv node for correct sampling.
       *
       * @param {NodeBuilder} builder - The current node builder.
       * @param {Node} uvNode - The uv node to setup.
       * @return {Node} The updated uv node.
       */
    }, {
      key: "setupUV",
      value: function setupUV(builder, uvNode) {
        var texture = this.value;
        if (builder.isFlipY() && (texture.image instanceof ImageBitmap && texture.flipY === true || texture.isRenderTargetTexture === true || texture.isFramebufferTexture === true || texture.isDepthTexture === true)) {
          if (this.sampler) {
            uvNode = uvNode.flipY();
          } else {
            uvNode = uvNode.setY(int(textureSize(this, this.levelNode).y).sub(uvNode.y).sub(1));
          }
        }
        return uvNode;
      }

      /**
       * Setups texture node by preparing the internal nodes for code generation.
       *
       * @param {NodeBuilder} builder - The current node builder.
       */
    }, {
      key: "setup",
      value: function setup(builder) {
        var properties = builder.getNodeProperties(this);
        properties.referenceNode = this.referenceNode;

        //

        var texture = this.value;
        if (!texture || texture.isTexture !== true) {
          throw new Error('THREE.TSL: `texture( value )` function expects a valid instance of THREE.Texture().');
        }

        //

        var uvNode = this.uvNode;
        if ((uvNode === null || builder.context.forceUVContext === true) && builder.context.getUV) {
          uvNode = builder.context.getUV(this);
        }
        if (!uvNode) uvNode = this.getDefaultUV();
        if (this.updateMatrix === true) {
          uvNode = this.getTransformedUV(uvNode);
        }
        uvNode = this.setupUV(builder, uvNode);

        //

        var levelNode = this.levelNode;
        if (levelNode === null && builder.context.getTextureLevel) {
          levelNode = builder.context.getTextureLevel(this);
        }

        //

        properties.uvNode = uvNode;
        properties.levelNode = levelNode;
        properties.biasNode = this.biasNode;
        properties.compareNode = this.compareNode;
        properties.gradNode = this.gradNode;
        properties.depthNode = this.depthNode;
      }

      /**
       * Generates the uv code snippet.
       *
       * @param {NodeBuilder} builder - The current node builder.
       * @param {Node} uvNode - The uv node to generate code for.
       * @return {String} The generated code snippet.
       */
    }, {
      key: "generateUV",
      value: function generateUV(builder, uvNode) {
        return uvNode.build(builder, this.sampler === true ? 'vec2' : 'ivec2');
      }

      /**
       * Generates the snippet for the texture sampling.
       *
       * @param {NodeBuilder} builder - The current node builder.
       * @param {String} textureProperty - The texture property.
       * @param {String} uvSnippet - The uv snippet.
       * @param {String} levelSnippet - The level snippet.
       * @param {String} biasSnippet - The bias snippet.
       * @param {String} depthSnippet - The depth snippet.
       * @param {String} compareSnippet - The compare snippet.
       * @param {String} gradSnippet - The grad snippet.
       * @return {String} The generated code snippet.
       */
    }, {
      key: "generateSnippet",
      value: function generateSnippet(builder, textureProperty, uvSnippet, levelSnippet, biasSnippet, depthSnippet, compareSnippet, gradSnippet) {
        var texture = this.value;
        var snippet;
        if (levelSnippet) {
          snippet = builder.generateTextureLevel(texture, textureProperty, uvSnippet, levelSnippet, depthSnippet);
        } else if (biasSnippet) {
          snippet = builder.generateTextureBias(texture, textureProperty, uvSnippet, biasSnippet, depthSnippet);
        } else if (gradSnippet) {
          snippet = builder.generateTextureGrad(texture, textureProperty, uvSnippet, gradSnippet, depthSnippet);
        } else if (compareSnippet) {
          snippet = builder.generateTextureCompare(texture, textureProperty, uvSnippet, compareSnippet, depthSnippet);
        } else if (this.sampler === false) {
          snippet = builder.generateTextureLoad(texture, textureProperty, uvSnippet, depthSnippet);
        } else {
          snippet = builder.generateTexture(texture, textureProperty, uvSnippet, depthSnippet);
        }
        return snippet;
      }

      /**
       * Generates the code snippet of the texture node.
       *
       * @param {NodeBuilder} builder - The current node builder.
       * @param {String} output - The current output.
       * @return {String} The generated code snippet.
       */
    }, {
      key: "generate",
      value: function generate(builder, output) {
        var texture = this.value;
        var properties = builder.getNodeProperties(this);
        var textureProperty = _superPropGet(TextureNode, "generate", this, 3)([builder, 'property']);
        if (output === 'sampler') {
          return textureProperty + '_sampler';
        } else if (builder.isReference(output)) {
          return textureProperty;
        } else {
          var nodeData = builder.getDataFromNode(this);
          var propertyName = nodeData.propertyName;
          if (propertyName === undefined) {
            var uvNode = properties.uvNode,
              levelNode = properties.levelNode,
              biasNode = properties.biasNode,
              compareNode = properties.compareNode,
              depthNode = properties.depthNode,
              gradNode = properties.gradNode;
            var uvSnippet = this.generateUV(builder, uvNode);
            var levelSnippet = levelNode ? levelNode.build(builder, 'float') : null;
            var biasSnippet = biasNode ? biasNode.build(builder, 'float') : null;
            var depthSnippet = depthNode ? depthNode.build(builder, 'int') : null;
            var compareSnippet = compareNode ? compareNode.build(builder, 'float') : null;
            var gradSnippet = gradNode ? [gradNode[0].build(builder, 'vec2'), gradNode[1].build(builder, 'vec2')] : null;
            var nodeVar = builder.getVarFromNode(this);
            propertyName = builder.getPropertyName(nodeVar);
            var _snippet = this.generateSnippet(builder, textureProperty, uvSnippet, levelSnippet, biasSnippet, depthSnippet, compareSnippet, gradSnippet);
            builder.addLineFlowCode(`${propertyName} = ${_snippet}`, this);
            nodeData.snippet = _snippet;
            nodeData.propertyName = propertyName;
          }
          var snippet = propertyName;
          var nodeType = this.getNodeType(builder);
          if (builder.needsToWorkingColorSpace(texture)) {
            snippet = colorSpaceToWorking(expression(snippet, nodeType), texture.colorSpace).setup(builder).build(builder, nodeType);
          }
          return builder.format(snippet, nodeType, output);
        }
      }

      /**
       * Sets the sampler value.
       *
       * @param {Boolean} value - The sampler value to set.
       * @return {TextureNode} A reference to this texture node.
       */
    }, {
      key: "setSampler",
      value: function setSampler(value) {
        this.sampler = value;
        return this;
      }

      /**
       * Returns the sampler value.
       *
       * @return {Boolean} The sampler value.
       */
    }, {
      key: "getSampler",
      value: function getSampler() {
        return this.sampler;
      }

      // @TODO: Move to TSL
    }, {
      key: "uv",
      value: function uv(uvNode) {
        // @deprecated, r172

        console.warn('THREE.TextureNode: .uv() has been renamed. Use .sample() instead.');
        return this.sample(uvNode);
      }

      /**
       * Samples the texture with the given uv node.
       *
       * @param {Node} uvNode - The uv node.
       * @return {TextureNode} A texture node representing the texture sample.
       */
    }, {
      key: "sample",
      value: function sample(uvNode) {
        var textureNode = this.clone();
        textureNode.uvNode = nodeObject(uvNode);
        textureNode.referenceNode = this.getSelf();
        return nodeObject(textureNode);
      }

      /**
       * Samples a blurred version of the texture by defining an internal bias.
       *
       * @param {Node<float>} amountNode - How blurred the texture should be.
       * @return {TextureNode} A texture node representing the texture sample.
       */
    }, {
      key: "blur",
      value: function blur(amountNode) {
        var textureNode = this.clone();
        textureNode.biasNode = nodeObject(amountNode).mul(maxMipLevel(textureNode));
        textureNode.referenceNode = this.getSelf();
        return nodeObject(textureNode);
      }

      /**
       * Samples a specific mip of the texture.
       *
       * @param {Node<int>} levelNode - The mip level to sample.
       * @return {TextureNode} A texture node representing the texture sample.
       */
    }, {
      key: "level",
      value: function level(levelNode) {
        var textureNode = this.clone();
        textureNode.levelNode = nodeObject(levelNode);
        textureNode.referenceNode = this.getSelf();
        return nodeObject(textureNode);
      }

      /**
       * Returns the texture size of the requested level.
       *
       * @param {Node<int>} levelNode - The level to compute the size for.
       * @return {TextureSizeNode} The texture size.
       */
    }, {
      key: "size",
      value: function size(levelNode) {
        return textureSize(this, levelNode);
      }

      /**
       * Samples the texture with the given bias.
       *
       * @param {Node<float>} biasNode - The bias node.
       * @return {TextureNode} A texture node representing the texture sample.
       */
    }, {
      key: "bias",
      value: function bias(biasNode) {
        var textureNode = this.clone();
        textureNode.biasNode = nodeObject(biasNode);
        textureNode.referenceNode = this.getSelf();
        return nodeObject(textureNode);
      }

      /**
       * Samples the texture by executing a compare operation.
       *
       * @param {Node<float>} compareNode - The node that defines the compare value.
       * @return {TextureNode} A texture node representing the texture sample.
       */
    }, {
      key: "compare",
      value: function compare(compareNode) {
        var textureNode = this.clone();
        textureNode.compareNode = nodeObject(compareNode);
        textureNode.referenceNode = this.getSelf();
        return nodeObject(textureNode);
      }

      /**
       * Samples the texture using an explicit gradient.
       *
       * @param {Node<vec2>} gradNodeX - The gradX node.
       * @param {Node<vec2>} gradNodeY - The gradY node.
       * @return {TextureNode} A texture node representing the texture sample.
       */
    }, {
      key: "grad",
      value: function grad(gradNodeX, gradNodeY) {
        var textureNode = this.clone();
        textureNode.gradNode = [nodeObject(gradNodeX), nodeObject(gradNodeY)];
        textureNode.referenceNode = this.getSelf();
        return nodeObject(textureNode);
      }

      /**
       * Samples the texture by defining a depth node.
       *
       * @param {Node<int>} depthNode - The depth node.
       * @return {TextureNode} A texture node representing the texture sample.
       */
    }, {
      key: "depth",
      value: function depth(depthNode) {
        var textureNode = this.clone();
        textureNode.depthNode = nodeObject(depthNode);
        textureNode.referenceNode = this.getSelf();
        return nodeObject(textureNode);
      }

      // --
    }, {
      key: "serialize",
      value: function serialize(data) {
        _superPropGet(TextureNode, "serialize", this, 3)([data]);
        data.value = this.value.toJSON(data.meta).uuid;
        data.sampler = this.sampler;
        data.updateMatrix = this.updateMatrix;
        data.updateType = this.updateType;
      }
    }, {
      key: "deserialize",
      value: function deserialize(data) {
        _superPropGet(TextureNode, "deserialize", this, 3)([data]);
        this.value = data.meta.textures[data.value];
        this.sampler = data.sampler;
        this.updateMatrix = data.updateMatrix;
        this.updateType = data.updateType;
      }

      /**
       * The update is used to implement the update of the uv transformation matrix.
       */
    }, {
      key: "update",
      value: function update() {
        var texture = this.value;
        var matrixUniform = this._matrixUniform;
        if (matrixUniform !== null) matrixUniform.value = texture.matrix;
        if (texture.matrixAutoUpdate === true) {
          texture.updateMatrix();
        }
      }

      /**
       * Clones the texture node.
       *
       * @return {TextureNode} The cloned texture node.
       */
    }, {
      key: "clone",
      value: function clone() {
        var newNode = new this.constructor(this.value, this.uvNode, this.levelNode, this.biasNode);
        newNode.sampler = this.sampler;
        return newNode;
      }
    }], [{
      key: "type",
      get: function get() {
        return 'TextureNode';
      }
    }]);
  }(UniformNode);
  /**
   * TSL function for creating a texture node.
   *
   * @function
   * @param {Texture} value - The texture.
   * @param {Node<vec2|vec3>?} [uvNode=null] - The uv node.
   * @param {Node<int>?} [levelNode=null] - The level node.
   * @param {Node<float>?} [biasNode=null] - The bias node.
   * @returns {TextureNode}
   */
  var texture = /*@__PURE__*/nodeProxy(TextureNode);

  /**
   * TSL function for creating a texture node that fetches/loads texels without interpolation.
   *
   * @function
   * @param {Texture} value - The texture.
   * @param {Node<vec2|vec3>?} [uvNode=null] - The uv node.
   * @param {Node<int>?} [levelNode=null] - The level node.
   * @param {Node<float>?} [biasNode=null] - The bias node.
   * @returns {TextureNode}
   */
  var textureLoad = function textureLoad() {
    return texture.apply(void 0, arguments).setSampler(false);
  };

  //export const textureLevel = ( value, uv, level ) => texture( value, uv ).level( level );

  /**
   * Converts a texture or texture node to a sampler.
   *
   * @function
   * @param {TextureNode|Texture} aTexture - The texture or texture node to convert.
   * @returns {Node}
   */
  var sampler = function sampler(aTexture) {
    return (aTexture.isNode === true ? aTexture : texture(aTexture)).convert('sampler');
  };

  /** @module Camera **/

  /**
   * TSL object that represents the `near` value of the camera used for the current render.
   *
   * @type {UniformNode<float>}
   */
  var cameraNear = /*@__PURE__*/uniform('float').label('cameraNear').setGroup(renderGroup).onRenderUpdate(function (_ref13) {
    var camera = _ref13.camera;
    return camera.near;
  });

  /**
   * TSL object that represents the `far` value of the camera used for the current render.
   *
   * @type {UniformNode<float>}
   */
  var cameraFar = /*@__PURE__*/uniform('float').label('cameraFar').setGroup(renderGroup).onRenderUpdate(function (_ref14) {
    var camera = _ref14.camera;
    return camera.far;
  });

  /**
   * TSL object that represents the projection matrix of the camera used for the current render.
   *
   * @type {UniformNode<mat4>}
   */
  var cameraProjectionMatrix = /*@__PURE__*/uniform('mat4').label('cameraProjectionMatrix').setGroup(renderGroup).onRenderUpdate(function (_ref15) {
    var camera = _ref15.camera;
    return camera.projectionMatrix;
  });

  /**
   * TSL object that represents the inverse projection matrix of the camera used for the current render.
   *
   * @type {UniformNode<mat4>}
   */
  var cameraProjectionMatrixInverse = /*@__PURE__*/uniform('mat4').label('cameraProjectionMatrixInverse').setGroup(renderGroup).onRenderUpdate(function (_ref16) {
    var camera = _ref16.camera;
    return camera.projectionMatrixInverse;
  });

  /**
   * TSL object that represents the view matrix of the camera used for the current render.
   *
   * @type {UniformNode<mat4>}
   */
  var cameraViewMatrix = /*@__PURE__*/uniform('mat4').label('cameraViewMatrix').setGroup(renderGroup).onRenderUpdate(function (_ref17) {
    var camera = _ref17.camera;
    return camera.matrixWorldInverse;
  });

  /**
   * TSL object that represents the world matrix of the camera used for the current render.
   *
   * @type {UniformNode<mat4>}
   */
  var cameraWorldMatrix = /*@__PURE__*/uniform('mat4').label('cameraWorldMatrix').setGroup(renderGroup).onRenderUpdate(function (_ref18) {
    var camera = _ref18.camera;
    return camera.matrixWorld;
  });

  /**
   * TSL object that represents the normal matrix of the camera used for the current render.
   *
   * @type {UniformNode<mat3>}
   */
  var cameraNormalMatrix = /*@__PURE__*/uniform('mat3').label('cameraNormalMatrix').setGroup(renderGroup).onRenderUpdate(function (_ref19) {
    var camera = _ref19.camera;
    return camera.normalMatrix;
  });

  /**
   * TSL object that represents the position in world space of the camera used for the current render.
   *
   * @type {UniformNode<vec3>}
   */
  var cameraPosition = /*@__PURE__*/uniform(new (_$$_REQUIRE(_dependencyMap[1], "./three.core.js").Vector3)()).label('cameraPosition').setGroup(renderGroup).onRenderUpdate(function (_ref20, self) {
    var camera = _ref20.camera;
    return self.value.setFromMatrixPosition(camera.matrixWorld);
  });

  /** @module Object3DNode **/

  /**
   * This node can be used to access transformation related metrics of 3D objects.
   * Depending on the selected scope, a different metric is represented as a uniform
   * in the shader. The following scopes are supported:
   *
   * - `POSITION`: The object's position in world space.
   * - `VIEW_POSITION`: The object's position in view/camera space.
   * - `DIRECTION`: The object's direction in world space.
   * - `SCALE`: The object's scale in world space.
   * - `WORLD_MATRIX`: The object's matrix in world space.
   *
   * @augments Node
   */
  var Object3DNode = exports.Object3DNode = /*#__PURE__*/function (_Node22) {
    /**
     * Constructs a new object 3D node.
     *
     * @param {('position'|'viewPosition'|'direction'|'scale'|'worldMatrix')} scope - The node represents a different type of transformation depending on the scope.
     * @param {Object3D?} [object3d=null] - The 3D object.
     */
    function Object3DNode(scope) {
      var _this41;
      var object3d = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      (0, _classCallCheck2.default)(this, Object3DNode);
      _this41 = _callSuper(this, Object3DNode);

      /**
       * The node reports a different type of transformation depending on the scope.
       *
       * @type {('position'|'viewPosition'|'direction'|'scale'|'worldMatrix')}
       */
      _this41.scope = scope;

      /**
       * The 3D object.
       *
       * @type {Object3D?}
       * @default null
       */
      _this41.object3d = object3d;

      /**
       * Overwritten since this type of node is updated per object.
       *
       * @type {String}
       * @default 'object'
       */
      _this41.updateType = NodeUpdateType.OBJECT;

      /**
       * Holds the value of the node as a uniform.
       *
       * @private
       * @type {UniformNode}
       */
      _this41._uniformNode = new UniformNode(null);
      return _this41;
    }

    /**
     * Overwritten since the node type is inferred from the scope.
     *
     * @param {NodeBuilder} builder - The current node builder.
     * @return {String} The node type.
     */
    (0, _inherits2.default)(Object3DNode, _Node22);
    return (0, _createClass2.default)(Object3DNode, [{
      key: "getNodeType",
      value: function getNodeType() {
        var scope = this.scope;
        if (scope === Object3DNode.WORLD_MATRIX) {
          return 'mat4';
        } else if (scope === Object3DNode.POSITION || scope === Object3DNode.VIEW_POSITION || scope === Object3DNode.DIRECTION || scope === Object3DNode.SCALE) {
          return 'vec3';
        }
      }

      /**
       * Updates the uniform value depending on the scope.
       *
       * @param {NodeFrame} frame - The current node frame.
       */
    }, {
      key: "update",
      value: function update(frame) {
        var object = this.object3d;
        var uniformNode = this._uniformNode;
        var scope = this.scope;
        if (scope === Object3DNode.WORLD_MATRIX) {
          uniformNode.value = object.matrixWorld;
        } else if (scope === Object3DNode.POSITION) {
          uniformNode.value = uniformNode.value || new (_$$_REQUIRE(_dependencyMap[1], "./three.core.js").Vector3)();
          uniformNode.value.setFromMatrixPosition(object.matrixWorld);
        } else if (scope === Object3DNode.SCALE) {
          uniformNode.value = uniformNode.value || new (_$$_REQUIRE(_dependencyMap[1], "./three.core.js").Vector3)();
          uniformNode.value.setFromMatrixScale(object.matrixWorld);
        } else if (scope === Object3DNode.DIRECTION) {
          uniformNode.value = uniformNode.value || new (_$$_REQUIRE(_dependencyMap[1], "./three.core.js").Vector3)();
          object.getWorldDirection(uniformNode.value);
        } else if (scope === Object3DNode.VIEW_POSITION) {
          var camera = frame.camera;
          uniformNode.value = uniformNode.value || new (_$$_REQUIRE(_dependencyMap[1], "./three.core.js").Vector3)();
          uniformNode.value.setFromMatrixPosition(object.matrixWorld);
          uniformNode.value.applyMatrix4(camera.matrixWorldInverse);
        }
      }

      /**
       * Generates the code snippet of the uniform node. The node type of the uniform
       * node also depends on the selected scope.
       *
       * @param {NodeBuilder} builder - The current node builder.
       * @return {String} The generated code snippet.
       */
    }, {
      key: "generate",
      value: function generate(builder) {
        var scope = this.scope;
        if (scope === Object3DNode.WORLD_MATRIX) {
          this._uniformNode.nodeType = 'mat4';
        } else if (scope === Object3DNode.POSITION || scope === Object3DNode.VIEW_POSITION || scope === Object3DNode.DIRECTION || scope === Object3DNode.SCALE) {
          this._uniformNode.nodeType = 'vec3';
        }
        return this._uniformNode.build(builder);
      }
    }, {
      key: "serialize",
      value: function serialize(data) {
        _superPropGet(Object3DNode, "serialize", this, 3)([data]);
        data.scope = this.scope;
      }
    }, {
      key: "deserialize",
      value: function deserialize(data) {
        _superPropGet(Object3DNode, "deserialize", this, 3)([data]);
        this.scope = data.scope;
      }
    }], [{
      key: "type",
      get: function get() {
        return 'Object3DNode';
      }
    }]);
  }(Node);
  Object3DNode.WORLD_MATRIX = 'worldMatrix';
  Object3DNode.POSITION = 'position';
  Object3DNode.SCALE = 'scale';
  Object3DNode.VIEW_POSITION = 'viewPosition';
  Object3DNode.DIRECTION = 'direction';

  /**
   * TSL function for creating an object 3D node that represents the object's direction in world space.
   *
   * @function
   * @param {Object3D?} [object3d=null] - The 3D object.
   * @returns {Object3DNode<vec3>}
   */
  var objectDirection = /*@__PURE__*/nodeProxy(Object3DNode, Object3DNode.DIRECTION);

  /**
   * TSL function for creating an object 3D node that represents the object's world matrix.
   *
   * @function
   * @param {Object3D?} [object3d=null] - The 3D object.
   * @returns {Object3DNode<mat4>}
   */
  var objectWorldMatrix = /*@__PURE__*/nodeProxy(Object3DNode, Object3DNode.WORLD_MATRIX);

  /**
   * TSL function for creating an object 3D node that represents the object's position in world space.
   *
   * @function
   * @param {Object3D?} [object3d=null] - The 3D object.
   * @returns {Object3DNode<vec3>}
   */
  var objectPosition = /*@__PURE__*/nodeProxy(Object3DNode, Object3DNode.POSITION);

  /**
   * TSL function for creating an object 3D node that represents the object's scale in world space.
   *
   * @function
   * @param {Object3D?} [object3d=null] - The 3D object.
   * @returns {Object3DNode<vec3>}
   */
  var objectScale = /*@__PURE__*/nodeProxy(Object3DNode, Object3DNode.SCALE);

  /**
   * TSL function for creating an object 3D node that represents the object's position in view/camera space.
   *
   * @function
   * @param {Object3D?} [object3d=null] - The 3D object.
   * @returns {Object3DNode<vec3>}
   */
  var objectViewPosition = /*@__PURE__*/nodeProxy(Object3DNode, Object3DNode.VIEW_POSITION);

  /** @module ModelNode **/

  /**
   * This type of node is a specialized version of `Object3DNode`
   * with larger set of model related metrics. Unlike `Object3DNode`,
   * `ModelNode` extracts the reference to the 3D object from the
   * current node frame state.
   *
   * @augments module:Object3DNode~Object3DNode
   */
  var ModelNode = exports.ModelNode = /*#__PURE__*/function (_Object3DNode) {
    /**
     * Constructs a new object model node.
     *
     * @param {('position'|'viewPosition'|'direction'|'scale'|'worldMatrix')} scope - The node represents a different type of transformation depending on the scope.
     */
    function ModelNode(scope) {
      (0, _classCallCheck2.default)(this, ModelNode);
      return _callSuper(this, ModelNode, [scope]);
    }

    /**
     * Extracts the model reference from the frame state and then
     * updates the uniform value depending on the scope.
     *
     * @param {NodeFrame} frame - The current node frame.
     */
    (0, _inherits2.default)(ModelNode, _Object3DNode);
    return (0, _createClass2.default)(ModelNode, [{
      key: "update",
      value: function update(frame) {
        this.object3d = frame.object;
        _superPropGet(ModelNode, "update", this, 3)([frame]);
      }
    }], [{
      key: "type",
      get: function get() {
        return 'ModelNode';
      }
    }]);
  }(Object3DNode);
  /**
   * TSL object that represents the object's direction in world space.
   *
   * @type {ModelNode<vec3>}
   */
  var modelDirection = /*@__PURE__*/nodeImmutable(ModelNode, ModelNode.DIRECTION);

  /**
   * TSL object that represents the object's world matrix.
   *
   * @type {ModelNode<mat4>}
   */
  var modelWorldMatrix = /*@__PURE__*/nodeImmutable(ModelNode, ModelNode.WORLD_MATRIX);

  /**
   * TSL object that represents the object's position in world space.
   *
   * @type {ModelNode<vec3>}
   */
  var modelPosition = /*@__PURE__*/nodeImmutable(ModelNode, ModelNode.POSITION);

  /**
   * TSL object that represents the object's scale in world space.
   *
   * @type {ModelNode<vec3>}
   */
  var modelScale = /*@__PURE__*/nodeImmutable(ModelNode, ModelNode.SCALE);

  /**
   * TSL object that represents the object's position in view/camera space.
   *
   * @type {ModelNode<vec3>}
   */
  var modelViewPosition = /*@__PURE__*/nodeImmutable(ModelNode, ModelNode.VIEW_POSITION);

  /**
   * TSL object that represents the object's normal matrix.
   *
   * @type {UniformNode<mat3>}
   */
  var modelNormalMatrix = /*@__PURE__*/uniform(new (_$$_REQUIRE(_dependencyMap[1], "./three.core.js").Matrix3)()).onObjectUpdate(function (_ref21, self) {
    var object = _ref21.object;
    return self.value.getNormalMatrix(object.matrixWorld);
  });

  /**
   * TSL object that represents the object's inverse world matrix.
   *
   * @type {UniformNode<mat4>}
   */
  var modelWorldMatrixInverse = /*@__PURE__*/uniform(new (_$$_REQUIRE(_dependencyMap[1], "./three.core.js").Matrix4)()).onObjectUpdate(function (_ref22, self) {
    var object = _ref22.object;
    return self.value.copy(object.matrixWorld).invert();
  });

  /**
   * TSL object that represents the object's model view matrix.
   *
   * @type {Node<mat4>}
   */
  var modelViewMatrix = /*@__PURE__*/Fn(function (builder) {
    return builder.renderer.nodes.modelViewMatrix || mediumpModelViewMatrix;
  }).once()().toVar('modelViewMatrix');

  // GPU Precision

  /**
   * TSL object that represents the object's model view in `mediump` precision.
   *
   * @type {Node<mat4>}
   */
  var mediumpModelViewMatrix = /*@__PURE__*/cameraViewMatrix.mul(modelWorldMatrix);

  // CPU Precision

  /**
   * TSL object that represents the object's model view in `highp` precision
   * which is achieved by computing the matrix in JS and not in the shader.
   *
   * @type {Node<mat4>}
   */
  var highpModelViewMatrix = /*@__PURE__*/Fn(function (builder) {
    builder.context.isHighPrecisionModelViewMatrix = true;
    return uniform('mat4').onObjectUpdate(function (_ref23) {
      var object = _ref23.object,
        camera = _ref23.camera;
      return object.modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, object.matrixWorld);
    });
  }).once()().toVar('highpModelViewMatrix');

  /**
   * TSL object that represents the object's model normal view in `highp` precision
   * which is achieved by computing the matrix in JS and not in the shader.
   *
   * @type {Node<mat3>}
   */
  var highpModelNormalViewMatrix = /*@__PURE__*/Fn(function (builder) {
    var isHighPrecisionModelViewMatrix = builder.context.isHighPrecisionModelViewMatrix;
    return uniform('mat3').onObjectUpdate(function (_ref24) {
      var object = _ref24.object,
        camera = _ref24.camera;
      if (isHighPrecisionModelViewMatrix !== true) {
        object.modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse, object.matrixWorld);
      }
      return object.normalMatrix.getNormalMatrix(object.modelViewMatrix);
    });
  }).once()().toVar('highpModelNormalViewMatrix');

  /** @module Position **/

  /**
   * TSL object that represents the position attribute of the current rendered object.
   *
   * @type {AttributeNode<vec3>}
   */
  var positionGeometry = /*@__PURE__*/attribute('position', 'vec3');

  /**
   * TSL object that represents the vertex position in local space of the current rendered object.
   *
   * @type {AttributeNode<vec3>}
   */
  var positionLocal = /*@__PURE__*/positionGeometry.varying('positionLocal');

  /**
   * TSL object that represents the previous vertex position in local space of the current rendered object.
   * Used in context of {@link module:VelocityNode~VelocityNode} for rendering motion vectors.
   *
   * @type {AttributeNode<vec3>}
   */
  var positionPrevious = /*@__PURE__*/positionGeometry.varying('positionPrevious');

  /**
   * TSL object that represents the vertex position in world space of the current rendered object.
   *
   * @type {VaryingNode<vec3>}
   */
  var positionWorld = /*@__PURE__*/modelWorldMatrix.mul(positionLocal).xyz.varying('v_positionWorld').context({
    needsPositionReassign: true
  });

  /**
   * TSL object that represents the position world direction of the current rendered object.
   *
   * @type {Node<vec3>}
   */
  var positionWorldDirection = /*@__PURE__*/positionLocal.transformDirection(modelWorldMatrix).varying('v_positionWorldDirection').normalize().toVar('positionWorldDirection').context({
    needsPositionReassign: true
  });

  /**
   * TSL object that represents the vertex position in view space of the current rendered object.
   *
   * @type {VaryingNode<vec3>}
   */
  var positionView = /*@__PURE__*/Fn(function (builder) {
    return builder.context.setupPositionView();
  }, 'vec3').once()().varying('v_positionView').context({
    needsPositionReassign: true
  });

  /**
   * TSL object that represents the position view direction of the current rendered object.
   *
   * @type {VaryingNode<vec3>}
   */
  var positionViewDirection = /*@__PURE__*/positionView.negate().varying('v_positionViewDirection').normalize().toVar('positionViewDirection');

  /** @module FrontFacingNode **/

  /**
   * This node can be used to evaluate whether a primitive is front or back facing.
   *
   * @augments Node
   */
  var FrontFacingNode = exports.FrontFacingNode = /*#__PURE__*/function (_Node23) {
    /**
     * Constructs a new front facing node.
     */
    function FrontFacingNode() {
      var _this42;
      (0, _classCallCheck2.default)(this, FrontFacingNode);
      _this42 = _callSuper(this, FrontFacingNode, ['bool']);

      /**
       * This flag can be used for type testing.
       *
       * @type {Boolean}
       * @readonly
       * @default true
       */
      _this42.isFrontFacingNode = true;
      return _this42;
    }
    (0, _inherits2.default)(FrontFacingNode, _Node23);
    return (0, _createClass2.default)(FrontFacingNode, [{
      key: "generate",
      value: function generate(builder) {
        var renderer = builder.renderer,
          material = builder.material;
        if (renderer.coordinateSystem === _$$_REQUIRE(_dependencyMap[1], "./three.core.js").WebGLCoordinateSystem) {
          if (material.side === _$$_REQUIRE(_dependencyMap[1], "./three.core.js").BackSide) {
            return 'false';
          }
        }
        return builder.getFrontFacing();
      }
    }], [{
      key: "type",
      get: function get() {
        return 'FrontFacingNode';
      }
    }]);
  }(Node);
  /**
   * TSL object that represents whether a primitive is front or back facing
   *
   * @type {FrontFacingNode<bool>}
   */
  var frontFacing = /*@__PURE__*/nodeImmutable(FrontFacingNode);

  /**
   * TSL object that represents the front facing status as a number instead of a bool.
   * `1` means front facing, `-1` means back facing.
   *
   * @type {Node<float>}
   */
  var faceDirection = /*@__PURE__*/float(frontFacing).mul(2.0).sub(1.0);

  /** @module Normal **/

  /**
   * TSL object that represents the normal attribute of the current rendered object.
   *
   * @type {Node<vec3>}
   */
  var normalGeometry = /*@__PURE__*/attribute('normal', 'vec3');

  /**
   * TSL object that represents the vertex normal in local space of the current rendered object.
   *
   * @type {Node<vec3>}
   */
  var normalLocal = /*@__PURE__*/Fn(function (builder) {
    if (builder.geometry.hasAttribute('normal') === false) {
      console.warn('TSL.NormalNode: Vertex attribute "normal" not found on geometry.');
      return vec3(0, 1, 0);
    }
    return normalGeometry;
  }, 'vec3').once()().toVar('normalLocal');

  /**
   * TSL object that represents the flat vertex normal in view space of the current rendered object.
   *
   * @type {Node<vec3>}
   */
  var normalFlat = /*@__PURE__*/positionView.dFdx().cross(positionView.dFdy()).normalize().toVar('normalFlat');

  /**
   * TSL object that represents the vertex normal in view space of the current rendered object.
   *
   * @type {Node<vec3>}
   */
  var normalView = /*@__PURE__*/Fn(function (builder) {
    var node;
    if (builder.material.flatShading === true) {
      node = normalFlat;
    } else {
      node = varying(transformNormalToView(normalLocal), 'v_normalView').normalize();
    }
    return node;
  }, 'vec3').once()().toVar('normalView');

  /**
   * TSL object that represents the vertex normal in world space of the current rendered object.
   *
   * @type {Node<vec3>}
   */
  var normalWorld = /*@__PURE__*/varying(normalView.transformDirection(cameraViewMatrix), 'v_normalWorld').normalize().toVar('normalWorld');

  /**
   * TSL object that represents the transformed vertex normal in view space of the current rendered object.
   *
   * @type {Node<vec3>}
   */
  var transformedNormalView = /*@__PURE__*/Fn(function (builder) {
    return builder.context.setupNormal();
  }, 'vec3').once()().mul(faceDirection).toVar('transformedNormalView');

  /**
   * TSL object that represents the transformed vertex normal in world space of the current rendered object.
   *
   * @type {Node<vec3>}
   */
  var transformedNormalWorld = /*@__PURE__*/transformedNormalView.transformDirection(cameraViewMatrix).toVar('transformedNormalWorld');

  /**
   * TSL object that represents the transformed clearcoat vertex normal in view space of the current rendered object.
   *
   * @type {Node<vec3>}
   */
  var transformedClearcoatNormalView = /*@__PURE__*/Fn(function (builder) {
    return builder.context.setupClearcoatNormal();
  }, 'vec3').once()().mul(faceDirection).toVar('transformedClearcoatNormalView');

  /**
   * Transforms the normal with the given matrix.
   *
   * @function
   * @param {Node<vec3>} normal - The normal.
   * @param {Node<mat3>} [matrix=modelWorldMatrix] - The matrix.
   * @return {Node<vec3>} The transformed normal.
   */
  var transformNormal = /*@__PURE__*/Fn(function (_ref25) {
    var _ref26 = (0, _slicedToArray2.default)(_ref25, 2),
      normal = _ref26[0],
      _ref26$ = _ref26[1],
      matrix = _ref26$ === void 0 ? modelWorldMatrix : _ref26$;
    var m = mat3(matrix);
    var transformedNormal = normal.div(vec3(m[0].dot(m[0]), m[1].dot(m[1]), m[2].dot(m[2])));
    return m.mul(transformedNormal).xyz;
  });

  /**
   * Transforms the given normal from local to view space.
   *
   * @function
   * @param {Node<vec3>} normal - The normal.
   * @param {NodeBuilder} builder - The current node builder.
   * @return {Node<vec3>} The transformed normal.
   */
  var transformNormalToView = /*@__PURE__*/Fn(function (_ref27, builder) {
    var _ref28 = (0, _slicedToArray2.default)(_ref27, 1),
      normal = _ref28[0];
    var modelNormalViewMatrix = builder.renderer.nodes.modelNormalViewMatrix;
    if (modelNormalViewMatrix !== null) {
      return modelNormalViewMatrix.transformDirection(normal);
    }

    //

    var transformedNormal = modelNormalMatrix.mul(normal);
    return cameraViewMatrix.transformDirection(transformedNormal);
  });

  /** @module MaterialProperties **/

  /**
   * TSL object that represents the refraction ratio of the material used for rendering the current object.
   *
   * @type {UniformNode<float>}
   */
  var materialRefractionRatio = /*@__PURE__*/uniform(0).onReference(function (_ref29) {
    var material = _ref29.material;
    return material;
  }).onRenderUpdate(function (_ref30) {
    var material = _ref30.material;
    return material.refractionRatio;
  });

  /** @module ReflectVector **/

  /**
   * The reflect vector in view space.
   *
   * @type {Node<vec3>}
   */
  var reflectView = /*@__PURE__*/positionViewDirection.negate().reflect(transformedNormalView);

  /**
   * The refract vector in view space.
   *
   * @type {Node<vec3>}
   */
  var refractView = /*@__PURE__*/positionViewDirection.negate().refract(transformedNormalView, materialRefractionRatio);

  /**
   * Used for sampling cube maps when using cube reflection mapping.
   *
   * @type {Node<vec3>}
   */
  var reflectVector = /*@__PURE__*/reflectView.transformDirection(cameraViewMatrix).toVar('reflectVector');

  /**
   * Used for sampling cube maps when using cube refraction mapping.
   *
   * @type {Node<vec3>}
   */
  var refractVector = /*@__PURE__*/refractView.transformDirection(cameraViewMatrix).toVar('reflectVector');

  /** @module CubeTextureNode **/

  /**
   * This type of uniform node represents a cube texture.
   *
   * @augments module:TextureNode~TextureNode
   */
  var CubeTextureNode = exports.CubeTextureNode = /*#__PURE__*/function (_TextureNode) {
    /**
     * Constructs a new cube texture node.
     *
     * @param {CubeTexture} value - The cube texture.
     * @param {Node<vec3>?} [uvNode=null] - The uv node.
     * @param {Node<int>?} [levelNode=null] - The level node.
     * @param {Node<float>?} [biasNode=null] - The bias node.
     */
    function CubeTextureNode(value) {
      var _this43;
      var uvNode = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      var levelNode = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
      var biasNode = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
      (0, _classCallCheck2.default)(this, CubeTextureNode);
      _this43 = _callSuper(this, CubeTextureNode, [value, uvNode, levelNode, biasNode]);

      /**
       * This flag can be used for type testing.
       *
       * @type {Boolean}
       * @readonly
       * @default true
       */
      _this43.isCubeTextureNode = true;
      return _this43;
    }

    /**
     * Overwrites the default implementation to return a fixed value `'cubeTexture'`.
     *
     * @param {NodeBuilder} builder - The current node builder.
     * @return {String} The input type.
     */
    (0, _inherits2.default)(CubeTextureNode, _TextureNode);
    return (0, _createClass2.default)(CubeTextureNode, [{
      key: "getInputType",
      value: function getInputType(/*builder*/
      ) {
        return 'cubeTexture';
      }

      /**
       * Returns a default uvs based on the mapping type of the cube texture.
       *
       * @return {Node<vec3>} The default uv attribute.
       */
    }, {
      key: "getDefaultUV",
      value: function getDefaultUV() {
        var texture = this.value;
        if (texture.mapping === _$$_REQUIRE(_dependencyMap[1], "./three.core.js").CubeReflectionMapping) {
          return reflectVector;
        } else if (texture.mapping === _$$_REQUIRE(_dependencyMap[1], "./three.core.js").CubeRefractionMapping) {
          return refractVector;
        } else {
          console.error('THREE.CubeTextureNode: Mapping "%s" not supported.', texture.mapping);
          return vec3(0, 0, 0);
        }
      }

      /**
       * Overwritten with an empty implementation since the `updateMatrix` flag is ignored
       * for cube textures. The uv transformation matrix is not applied to cube textures.
       *
       * @param {Boolean} value - The update toggle.
       */
    }, {
      key: "setUpdateMatrix",
      value: function setUpdateMatrix(/*updateMatrix*/) {} // Ignore .updateMatrix for CubeTextureNode

      /**
       * Setups the uv node. Depending on the backend as well as the texture type, it might be necessary
       * to modify the uv node for correct sampling.
       *
       * @param {NodeBuilder} builder - The current node builder.
       * @param {Node} uvNode - The uv node to setup.
       * @return {Node} The updated uv node.
       */
    }, {
      key: "setupUV",
      value: function setupUV(builder, uvNode) {
        var texture = this.value;
        if (builder.renderer.coordinateSystem === _$$_REQUIRE(_dependencyMap[1], "./three.core.js").WebGPUCoordinateSystem || !texture.isRenderTargetTexture) {
          return vec3(uvNode.x.negate(), uvNode.yz);
        } else {
          return uvNode;
        }
      }

      /**
       * Generates the uv code snippet.
       *
       * @param {NodeBuilder} builder - The current node builder.
       * @param {Node} cubeUV - The uv node to generate code for.
       * @return {String} The generated code snippet.
       */
    }, {
      key: "generateUV",
      value: function generateUV(builder, cubeUV) {
        return cubeUV.build(builder, 'vec3');
      }
    }], [{
      key: "type",
      get: function get() {
        return 'CubeTextureNode';
      }
    }]);
  }(TextureNode);
  /**
   * TSL function for creating a cube texture node.
   *
   * @function
   * @param {CubeTexture} value - The cube texture.
   * @param {Node<vec3>?} [uvNode=null] - The uv node.
   * @param {Node<int>?} [levelNode=null] - The level node.
   * @param {Node<float>?} [biasNode=null] - The bias node.
   * @returns {CubeTextureNode}
   */
  var cubeTexture = /*@__PURE__*/nodeProxy(CubeTextureNode);

  /** @module BufferNode **/

  /**
   * A special type of uniform node which represents array-like data
   * as uniform buffers. The access usually happens via `element()`
   * which returns an instance of {@link ArrayElementNode}. For example:
   *
   * ```js
   * const bufferNode = buffer( array, 'mat4', count );
   * const matrixNode = bufferNode.element( index ); // access a matrix from the buffer
   * ```
   * In general, it is recommended to use the more managed {@link UniformArrayNode}
   * since it handles more input types and automatically cares about buffer paddings.
   *
   * @augments module:UniformNode~UniformNode
   */
  var BufferNode = exports.BufferNode = /*#__PURE__*/function (_UniformNode3) {
    /**
     * Constructs a new buffer node.
     *
     * @param {Array<Number>} value - Array-like buffer data.
     * @param {String} bufferType - The data type of the buffer.
     * @param {Number} [bufferCount=0] - The count of buffer elements.
     */
    function BufferNode(value, bufferType) {
      var _this44;
      var bufferCount = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      (0, _classCallCheck2.default)(this, BufferNode);
      _this44 = _callSuper(this, BufferNode, [value, bufferType]);

      /**
       * This flag can be used for type testing.
       *
       * @type {Boolean}
       * @readonly
       * @default true
       */
      _this44.isBufferNode = true;

      /**
       * The data type of the buffer.
       *
       * @type {String}
       */
      _this44.bufferType = bufferType;

      /**
       * The uniform node that holds the value of the reference node.
       *
       * @type {Number}
       * @default 0
       */
      _this44.bufferCount = bufferCount;
      return _this44;
    }

    /**
     * The data type of the buffer elements.
     *
     * @param {NodeBuilder} builder - The current node builder.
     * @return {String} The element type.
     */
    (0, _inherits2.default)(BufferNode, _UniformNode3);
    return (0, _createClass2.default)(BufferNode, [{
      key: "getElementType",
      value: function getElementType(builder) {
        return this.getNodeType(builder);
      }

      /**
       * Overwrites the default implementation to return a fixed value `'buffer'`.
       *
       * @param {NodeBuilder} builder - The current node builder.
       * @return {String} The input type.
       */
    }, {
      key: "getInputType",
      value: function getInputType(/*builder*/
      ) {
        return 'buffer';
      }
    }], [{
      key: "type",
      get: function get() {
        return 'BufferNode';
      }
    }]);
  }(UniformNode);
  /**
   * TSL function for creating a buffer node.
   *
   * @function
   * @param {Array} value - Array-like buffer data.
   * @param {String} type - The data type of a buffer element.
   * @param {Number} count - The count of buffer elements.
   * @returns {BufferNode}
   */
  var buffer = function buffer(value, type, count) {
    return nodeObject(new BufferNode(value, type, count));
  };

  /** @module UniformArrayNode **/

  /**
   * Represents the element access on uniform array nodes.
   *
   * @augments ArrayElementNode
   */
  var UniformArrayElementNode = /*#__PURE__*/function (_ArrayElementNode2) {
    /**
     * Constructs a new buffer node.
     *
     * @param {UniformArrayNode} uniformArrayNode - The uniform array node to access.
     * @param {IndexNode} indexNode - The index data that define the position of the accessed element in the array.
     */
    function UniformArrayElementNode(uniformArrayNode, indexNode) {
      var _this45;
      (0, _classCallCheck2.default)(this, UniformArrayElementNode);
      _this45 = _callSuper(this, UniformArrayElementNode, [uniformArrayNode, indexNode]);

      /**
       * This flag can be used for type testing.
       *
       * @type {Boolean}
       * @readonly
       * @default true
       */
      _this45.isArrayBufferElementNode = true;
      return _this45;
    }
    (0, _inherits2.default)(UniformArrayElementNode, _ArrayElementNode2);
    return (0, _createClass2.default)(UniformArrayElementNode, [{
      key: "generate",
      value: function generate(builder) {
        var snippet = _superPropGet(UniformArrayElementNode, "generate", this, 3)([builder]);
        var type = this.getNodeType();
        var paddedType = this.node.getPaddedType();
        return builder.format(snippet, paddedType, type);
      }
    }], [{
      key: "type",
      get: function get() {
        return 'UniformArrayElementNode';
      }
    }]);
  }(ArrayElementNode);
  /**
   * Similar to {@link module:BufferNode~BufferNode} this module represents array-like data as
   * uniform buffers. Unlike {@link module:BufferNode~BufferNode}, it can handle more common
   * data types in the array (e.g `three.js` primitives) and automatically
   * manage buffer padding. It should be the first choice when working with
   * uniforms buffers.
   * ```js
   * const tintColors = uniformArray( [
   * 	new Color( 1, 0, 0 ),
   * 	new Color( 0, 1, 0 ),
   * 	new Color( 0, 0, 1 )
   * ], 'color' );
   *
   * const redColor = tintColors.element( 0 );
   *
   * @augments module:BufferNode~BufferNode
   */
  var UniformArrayNode = exports.UniformArrayNode = /*#__PURE__*/function (_BufferNode) {
    /**
     * Constructs a new uniform array node.
     *
     * @param {Array<Any>} value - Array holding the buffer data.
     * @param {String?} [elementType=null] - The data type of a buffer element.
     */
    function UniformArrayNode(value) {
      var _this46;
      var elementType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      (0, _classCallCheck2.default)(this, UniformArrayNode);
      _this46 = _callSuper(this, UniformArrayNode, [null]);

      /**
       * Array holding the buffer data. Unlike {@link module:BufferNode~BufferNode}, the array can
       * hold number primitives as well as three.js objects like vectors, matrices
       * or colors.
       *
       * @type {Array<Any>}
       */
      _this46.array = value;

      /**
       * The data type of an array element.
       *
       * @type {String}
       */
      _this46.elementType = elementType === null ? getValueType(value[0]) : elementType;

      /**
       * The padded type. Uniform buffers must conform to a certain buffer layout
       * so a separate type is computed to ensure correct buffer size.
       *
       * @type {String}
       */
      _this46.paddedType = _this46.getPaddedType();

      /**
       * Overwritten since uniform array nodes are updated per render.
       *
       * @type {String}
       * @default 'render'
       */
      _this46.updateType = NodeUpdateType.RENDER;

      /**
       * This flag can be used for type testing.
       *
       * @type {Boolean}
       * @readonly
       * @default true
       */
      _this46.isArrayBufferNode = true;
      return _this46;
    }

    /**
     * This method is overwritten since the node type is inferred from the
     * {@link module:UniformArrayNode~UniformArrayNode#paddedType}.
     *
     * @param {NodeBuilder} builder - The current node builder.
     * @return {String} The node type.
     */
    (0, _inherits2.default)(UniformArrayNode, _BufferNode);
    return (0, _createClass2.default)(UniformArrayNode, [{
      key: "getNodeType",
      value: function getNodeType(/*builder*/
      ) {
        return this.paddedType;
      }

      /**
       * The data type of the array elements.
       *
       * @param {NodeBuilder} builder - The current node builder.
       * @return {String} The element type.
       */
    }, {
      key: "getElementType",
      value: function getElementType() {
        return this.elementType;
      }

      /**
       * Returns the padded type based on the element type.
       *
       * @return {String} The padded type.
       */
    }, {
      key: "getPaddedType",
      value: function getPaddedType() {
        var elementType = this.elementType;
        var paddedType = 'vec4';
        if (elementType === 'mat2') {
          paddedType = 'mat2';
        } else if (/mat/.test(elementType) === true) {
          paddedType = 'mat4';
        } else if (elementType.charAt(0) === 'i') {
          paddedType = 'ivec4';
        } else if (elementType.charAt(0) === 'u') {
          paddedType = 'uvec4';
        }
        return paddedType;
      }

      /**
       * The update makes sure to correctly transfer the data from the (complex) objects
       * in the array to the internal, correctly padded value buffer.
       *
       * @param {NodeFrame} frame - A reference to the current node frame.
       */
    }, {
      key: "update",
      value: function update(/*frame*/
      ) {
        var array = this.array,
          value = this.value;
        var elementType = this.elementType;
        if (elementType === 'float' || elementType === 'int' || elementType === 'uint') {
          for (var i = 0; i < array.length; i++) {
            var index = i * 4;
            value[index] = array[i];
          }
        } else if (elementType === 'color') {
          for (var _i2 = 0; _i2 < array.length; _i2++) {
            var _index = _i2 * 4;
            var vector = array[_i2];
            value[_index] = vector.r;
            value[_index + 1] = vector.g;
            value[_index + 2] = vector.b || 0;
            //value[ index + 3 ] = vector.a || 0;
          }
        } else if (elementType === 'mat2') {
          for (var _i3 = 0; _i3 < array.length; _i3++) {
            var _index2 = _i3 * 4;
            var matrix = array[_i3];
            value[_index2] = matrix.elements[0];
            value[_index2 + 1] = matrix.elements[1];
            value[_index2 + 2] = matrix.elements[2];
            value[_index2 + 3] = matrix.elements[3];
          }
        } else if (elementType === 'mat3') {
          for (var _i4 = 0; _i4 < array.length; _i4++) {
            var _index3 = _i4 * 16;
            var _matrix = array[_i4];
            value[_index3] = _matrix.elements[0];
            value[_index3 + 1] = _matrix.elements[1];
            value[_index3 + 2] = _matrix.elements[2];
            value[_index3 + 4] = _matrix.elements[3];
            value[_index3 + 5] = _matrix.elements[4];
            value[_index3 + 6] = _matrix.elements[5];
            value[_index3 + 8] = _matrix.elements[6];
            value[_index3 + 9] = _matrix.elements[7];
            value[_index3 + 10] = _matrix.elements[8];
            value[_index3 + 15] = 1;
          }
        } else if (elementType === 'mat4') {
          for (var _i5 = 0; _i5 < array.length; _i5++) {
            var _index4 = _i5 * 16;
            var _matrix2 = array[_i5];
            for (var _i6 = 0; _i6 < _matrix2.elements.length; _i6++) {
              value[_index4 + _i6] = _matrix2.elements[_i6];
            }
          }
        } else {
          for (var _i7 = 0; _i7 < array.length; _i7++) {
            var _index5 = _i7 * 4;
            var _vector = array[_i7];
            value[_index5] = _vector.x;
            value[_index5 + 1] = _vector.y;
            value[_index5 + 2] = _vector.z || 0;
            value[_index5 + 3] = _vector.w || 0;
          }
        }
      }

      /**
       * Implement the value buffer creation based on the array data.
       *
       * @param {NodeBuilder} builder - A reference to the current node builder.
       * @return {null}
       */
    }, {
      key: "setup",
      value: function setup(builder) {
        var length = this.array.length;
        var elementType = this.elementType;
        var arrayType = Float32Array;
        var paddedType = this.paddedType;
        var paddedElementLength = builder.getTypeLength(paddedType);
        if (elementType.charAt(0) === 'i') arrayType = Int32Array;
        if (elementType.charAt(0) === 'u') arrayType = Uint32Array;
        this.value = new arrayType(length * paddedElementLength);
        this.bufferCount = length;
        this.bufferType = paddedType;
        return _superPropGet(UniformArrayNode, "setup", this, 3)([builder]);
      }

      /**
       * Overwrites the default `element()` method to provide element access
       * based on {@link module:UniformArrayNode~UniformArrayNode}.
       *
       * @param {IndexNode} indexNode - The index node.
       * @return {UniformArrayElementNode}
       */
    }, {
      key: "element",
      value: function element(indexNode) {
        return nodeObject(new UniformArrayElementNode(this, nodeObject(indexNode)));
      }
    }], [{
      key: "type",
      get: function get() {
        return 'UniformArrayNode';
      }
    }]);
  }(BufferNode);
  /**
   * TSL function for creating an uniform array node.
   *
   * @function
   * @param {Array<Any>} values - Array-like data.
   * @param {String} nodeType - The data type of the array elements.
   * @returns {UniformArrayNode}
   */
  var uniformArray = function uniformArray(values, nodeType) {
    return nodeObject(new UniformArrayNode(values, nodeType));
  };

  //

  var uniforms = function uniforms(values, nodeType) {
    // @deprecated, r168

    console.warn('TSL.UniformArrayNode: uniforms() has been renamed to uniformArray().');
    return nodeObject(new UniformArrayNode(values, nodeType));
  };

  // TODO: Avoid duplicated code and ues only ReferenceBaseNode or ReferenceNode

  /** @module ReferenceNode **/

  /**
   * This class is only relevant if the referenced property is array-like.
   * In this case, `ReferenceElementNode` allows to refer to a specific
   * element inside the data structure via an index.
   *
   * @augments ArrayElementNode
   */
  var ReferenceElementNode = /*#__PURE__*/function (_ArrayElementNode3) {
    /**
     * Constructs a new reference element node.
     *
     * @param {Node?} referenceNode - The reference node.
     * @param {Node} indexNode - The index node that defines the element access.
     */
    function ReferenceElementNode(referenceNode, indexNode) {
      var _this47;
      (0, _classCallCheck2.default)(this, ReferenceElementNode);
      _this47 = _callSuper(this, ReferenceElementNode, [referenceNode, indexNode]);

      /**
       * Similar to {@link module:ReferenceNode~ReferenceNode#reference}, an additional
       * property references to the current node.
       *
       * @type {Node?}
       * @default null
       */
      _this47.referenceNode = referenceNode;

      /**
       * This flag can be used for type testing.
       *
       * @type {Boolean}
       * @readonly
       * @default true
       */
      _this47.isReferenceElementNode = true;
      return _this47;
    }

    /**
     * This method is overwritten since the node type is inferred from
     * the uniform type of the reference node.
     *
     * @param {NodeBuilder} builder - The current node builder.
     * @return {String} The node type.
     */
    (0, _inherits2.default)(ReferenceElementNode, _ArrayElementNode3);
    return (0, _createClass2.default)(ReferenceElementNode, [{
      key: "getNodeType",
      value: function getNodeType() {
        return this.referenceNode.uniformType;
      }
    }, {
      key: "generate",
      value: function generate(builder) {
        var snippet = _superPropGet(ReferenceElementNode, "generate", this, 3)([builder]);
        var arrayType = this.referenceNode.getNodeType();
        var elementType = this.getNodeType();
        return builder.format(snippet, arrayType, elementType);
      }
    }], [{
      key: "type",
      get: function get() {
        return 'ReferenceElementNode';
      }
    }]);
  }(ArrayElementNode);
  /**
   * This type of node establishes a reference to a property of another object.
   * In this way, the value of the node is automatically linked to the value of
   * referenced object. Reference nodes internally represent the linked value
   * as a uniform.
   *
   * @augments Node
   */
  var ReferenceNode = exports.ReferenceNode = /*#__PURE__*/function (_Node24) {
    /**
     * Constructs a new reference node.
     *
     * @param {String} property - The name of the property the node refers to.
     * @param {String} uniformType - The uniform type that should be used to represent the property value.
     * @param {Object?} [object=null] - The object the property belongs to.
     * @param {Number?} [count=null] - When the linked property is an array-like, this parameter defines its length.
     */
    function ReferenceNode(property, uniformType) {
      var _this48;
      var object = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
      var count = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
      (0, _classCallCheck2.default)(this, ReferenceNode);
      _this48 = _callSuper(this, ReferenceNode);

      /**
       * The name of the property the node refers to.
       *
       * @type {String}
       */
      _this48.property = property;

      /**
       * The uniform type that should be used to represent the property value.
       *
       * @type {String}
       */
      _this48.uniformType = uniformType;

      /**
       * The object the property belongs to.
       *
       * @type {Object?}
       * @default null
       */
      _this48.object = object;

      /**
       * When the linked property is an array, this parameter defines its length.
       *
       * @type {Number?}
       * @default null
       */
      _this48.count = count;

      /**
       * The property name might have dots so nested properties can be referred.
       * The hierarchy of the names is stored inside this array.
       *
       * @type {Array<String>}
       */
      _this48.properties = property.split('.');

      /**
       * Points to the current referred object. This property exists next to {@link module:ReferenceNode~ReferenceNode#object}
       * since the final reference might be updated from calling code.
       *
       * @type {Object?}
       * @default null
       */
      _this48.reference = object;

      /**
       * The uniform node that holds the value of the reference node.
       *
       * @type {UniformNode}
       * @default null
       */
      _this48.node = null;

      /**
       * The uniform group of the internal uniform.
       *
       * @type {UniformGroupNode}
       * @default null
       */
      _this48.group = null;

      /**
       * An optional label of the internal uniform node.
       *
       * @type {String?}
       * @default null
       */
      _this48.name = null;

      /**
       * Overwritten since reference nodes are updated per object.
       *
       * @type {String}
       * @default 'object'
       */
      _this48.updateType = NodeUpdateType.OBJECT;
      return _this48;
    }

    /**
     * When the referred property is array-like, this method can be used
     * to access elements via an index node.
     *
     * @param {IndexNode} indexNode - indexNode.
     * @return {ReferenceElementNode} A reference to an element.
     */
    (0, _inherits2.default)(ReferenceNode, _Node24);
    return (0, _createClass2.default)(ReferenceNode, [{
      key: "element",
      value: function element(indexNode) {
        return nodeObject(new ReferenceElementNode(this, nodeObject(indexNode)));
      }

      /**
       * Sets the uniform group for this reference node.
       *
       * @param {UniformGroupNode} group - The uniform group to set.
       * @return {ReferenceNode} A reference to this node.
       */
    }, {
      key: "setGroup",
      value: function setGroup(group) {
        this.group = group;
        return this;
      }

      /**
       * Sets the label for the internal uniform.
       *
       * @param {String} name - The label to set.
       * @return {ReferenceNode} A reference to this node.
       */
    }, {
      key: "label",
      value: function label(name) {
        this.name = name;
        return this;
      }

      /**
       * Sets the node type which automatically defines the internal
       * uniform type.
       *
       * @param {String} uniformType - The type to set.
       */
    }, {
      key: "setNodeType",
      value: function setNodeType(uniformType) {
        var node = null;
        if (this.count !== null) {
          node = buffer(null, uniformType, this.count);
        } else if (Array.isArray(this.getValueFromReference())) {
          node = uniformArray(null, uniformType);
        } else if (uniformType === 'texture') {
          node = texture(null);
        } else if (uniformType === 'cubeTexture') {
          node = cubeTexture(null);
        } else {
          node = uniform(null, uniformType);
        }
        if (this.group !== null) {
          node.setGroup(this.group);
        }
        if (this.name !== null) node.label(this.name);
        this.node = node.getSelf();
      }

      /**
       * This method is overwritten since the node type is inferred from
       * the type of the reference node.
       *
       * @param {NodeBuilder} builder - The current node builder.
       * @return {String} The node type.
       */
    }, {
      key: "getNodeType",
      value: function getNodeType(builder) {
        if (this.node === null) {
          this.updateReference(builder);
          this.updateValue();
        }
        return this.node.getNodeType(builder);
      }

      /**
       * Returns the property value from the given referred object.
       *
       * @param {Object} [object=this.reference] - The object to retrieve the property value from.
       * @return {Any} The value.
       */
    }, {
      key: "getValueFromReference",
      value: function getValueFromReference() {
        var object = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.reference;
        var properties = this.properties;
        var value = object[properties[0]];
        for (var i = 1; i < properties.length; i++) {
          value = value[properties[i]];
        }
        return value;
      }

      /**
       * Allows to update the reference based on the given state. The state is only
       * evaluated {@link module:ReferenceNode~ReferenceNode#object} is not set.
       *
       * @param {(NodeFrame|NodeBuilder)} state - The current state.
       * @return {Object} The updated reference.
       */
    }, {
      key: "updateReference",
      value: function updateReference(state) {
        this.reference = this.object !== null ? this.object : state.object;
        return this.reference;
      }

      /**
       * The output of the reference node is the internal uniform node.
       *
       * @param {NodeBuilder} builder - The current node builder.
       * @return {UniformNode} The output node.
       */
    }, {
      key: "setup",
      value: function setup(/* builder */
      ) {
        this.updateValue();
        return this.node;
      }

      /**
       * Overwritten to to update the internal uniform value.
       *
       * @param {NodeFrame} frame - A reference to the current node frame.
       */
    }, {
      key: "update",
      value: function update(/*frame*/
      ) {
        this.updateValue();
      }

      /**
       * Retrieves the value from the referred object property and uses it
       * to updated the internal uniform.
       */
    }, {
      key: "updateValue",
      value: function updateValue() {
        if (this.node === null) this.setNodeType(this.uniformType);
        var value = this.getValueFromReference();
        if (Array.isArray(value)) {
          this.node.array = value;
        } else {
          this.node.value = value;
        }
      }
    }], [{
      key: "type",
      get: function get() {
        return 'ReferenceNode';
      }
    }]);
  }(Node);
  /**
   * TSL function for creating a reference node.
   *
   * @function
   * @param {String} name - The name of the property the node refers to.
   * @param {String} type - The uniform type that should be used to represent the property value.
   * @param {Object} object - The object the property belongs to.
   * @returns {ReferenceNode}
   */
  var reference = function reference(name, type, object) {
    return nodeObject(new ReferenceNode(name, type, object));
  };

  /**
   * TSL function for creating a reference node. Use this function if you want need a reference
   * to an array-like property that should be represented as a uniform buffer.
   *
   * @function
   * @param {String} name - The name of the property the node refers to.
   * @param {String} type - The uniform type that should be used to represent the property value.
   * @param {Number} count - The number of value inside the array-like object.
   * @param {Object} object - An array-like object the property belongs to.
   * @returns {ReferenceNode}
   */
  var referenceBuffer = function referenceBuffer(name, type, count, object) {
    return nodeObject(new ReferenceNode(name, type, object, count));
  };

  /** @module MaterialReferenceNode **/

  /**
   * This node is a special type of reference node which is intended
   * for linking material properties with node values.
   * ```js
   * const opacityNode = materialReference( 'opacity', 'float', material );
   * ```
   * When changing `material.opacity`, the node value of `opacityNode` will
   * automatically be updated.
   *
   * @augments module:ReferenceNode~ReferenceNode
   */
  var MaterialReferenceNode = exports.MaterialReferenceNode = /*#__PURE__*/function (_ReferenceNode) {
    /**
     * Constructs a new material reference node.
     *
     * @param {String} property - The name of the property the node refers to.
     * @param {String} inputType - The uniform type that should be used to represent the property value.
     * @param {Material?} [material=null] - The material the property belongs to. When no material is set,
     * the node refers to the material of the current rendered object.
     */
    function MaterialReferenceNode(property, inputType) {
      var _this49;
      var material = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
      (0, _classCallCheck2.default)(this, MaterialReferenceNode);
      _this49 = _callSuper(this, MaterialReferenceNode, [property, inputType, material]);

      /**
       * The material the property belongs to. When no material is set,
       * the node refers to the material of the current rendered object.
       *
       * @type {Material?}
       * @default null
       */
      _this49.material = material;

      /**
       * This flag can be used for type testing.
       *
       * @type {Boolean}
       * @readonly
       * @default true
       */
      _this49.isMaterialReferenceNode = true;
      return _this49;
    }

    /**
     * Updates the reference based on the given state. The state is only evaluated
     * {@link module:MaterialReferenceNode~MaterialReferenceNode#material} is not set.
     *
     * @param {(NodeFrame|NodeBuilder)} state - The current state.
     * @return {Object} The updated reference.
     */
    (0, _inherits2.default)(MaterialReferenceNode, _ReferenceNode);
    return (0, _createClass2.default)(MaterialReferenceNode, [{
      key: "updateReference",
      value: function updateReference(state) {
        this.reference = this.material !== null ? this.material : state.material;
        return this.reference;
      }
    }], [{
      key: "type",
      get: function get() {
        return 'MaterialReferenceNode';
      }
    }]);
  }(ReferenceNode);
  /**
   * TSL function for creating a material reference node.
   *
   * @function
   * @param {String} name - The name of the property the node refers to.
   * @param {String} type - The uniform type that should be used to represent the property value.
   * @param {Material?} [material=null] - The material the property belongs to.
   * When no material is set, the node refers to the material of the current rendered object.
   * @returns {MaterialReferenceNode}
   */
  var materialReference = function materialReference(name, type) {
    var material = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
    return nodeObject(new MaterialReferenceNode(name, type, material));
  };

  /** @module Tangent **/

  /**
   * TSL object that represents the tangent attribute of the current rendered object.
   *
   * @type {Node<vec4>}
   */
  var tangentGeometry = /*@__PURE__*/Fn(function (builder) {
    if (builder.geometry.hasAttribute('tangent') === false) {
      builder.geometry.computeTangents();
    }
    return attribute('tangent', 'vec4');
  })();

  /**
   * TSL object that represents the vertex tangent in local space of the current rendered object.
   *
   * @type {Node<vec3>}
   */
  var tangentLocal = /*@__PURE__*/tangentGeometry.xyz.toVar('tangentLocal');

  /**
   * TSL object that represents the vertex tangent in view space of the current rendered object.
   *
   * @type {Node<vec3>}
   */
  var tangentView = /*@__PURE__*/modelViewMatrix.mul(vec4(tangentLocal, 0)).xyz.varying('v_tangentView').normalize().toVar('tangentView');

  /**
   * TSL object that represents the vertex tangent in world space of the current rendered object.
   *
   * @type {Node<vec3>}
   */
  var tangentWorld = /*@__PURE__*/tangentView.transformDirection(cameraViewMatrix).varying('v_tangentWorld').normalize().toVar('tangentWorld');

  /**
   * TSL object that represents the transformed vertex tangent in view space of the current rendered object.
   *
   * @type {Node<vec3>}
   */
  var transformedTangentView = /*@__PURE__*/tangentView.toVar('transformedTangentView');

  /**
   * TSL object that represents the transformed vertex tangent in world space of the current rendered object.
   *
   * @type {Node<vec3>}
   */
  var transformedTangentWorld = /*@__PURE__*/transformedTangentView.transformDirection(cameraViewMatrix).normalize().toVar('transformedTangentWorld');

  /** @module Bitangent **/

  var getBitangent = function getBitangent(crossNormalTangent) {
    return crossNormalTangent.mul(tangentGeometry.w).xyz;
  };

  /**
   * TSL object that represents the bitangent attribute of the current rendered object.
   *
   * @type {Node<vec3>}
   */
  var bitangentGeometry = /*@__PURE__*/varying(getBitangent(normalGeometry.cross(tangentGeometry)), 'v_bitangentGeometry').normalize().toVar('bitangentGeometry');

  /**
   * TSL object that represents the vertex bitangent in local space of the current rendered object.
   *
   * @type {Node<vec3>}
   */
  var bitangentLocal = /*@__PURE__*/varying(getBitangent(normalLocal.cross(tangentLocal)), 'v_bitangentLocal').normalize().toVar('bitangentLocal');

  /**
   * TSL object that represents the vertex bitangent in view space of the current rendered object.
   *
   * @type {Node<vec4>}
   */
  var bitangentView = /*@__PURE__*/varying(getBitangent(normalView.cross(tangentView)), 'v_bitangentView').normalize().toVar('bitangentView');

  /**
   * TSL object that represents the vertex bitangent in world space of the current rendered object.
   *
   * @type {Node<vec4>}
   */
  var bitangentWorld = /*@__PURE__*/varying(getBitangent(normalWorld.cross(tangentWorld)), 'v_bitangentWorld').normalize().toVar('bitangentWorld');

  /**
   * TSL object that represents the transformed vertex bitangent in view space of the current rendered object.
   *
   * @type {Node<vec4>}
   */
  var transformedBitangentView = /*@__PURE__*/getBitangent(transformedNormalView.cross(transformedTangentView)).normalize().toVar('transformedBitangentView');

  /**
   * TSL object that represents the transformed vertex bitangent in world space of the current rendered object.
   *
   * @type {Node<vec4>}
   */
  var transformedBitangentWorld = /*@__PURE__*/transformedBitangentView.transformDirection(cameraViewMatrix).normalize().toVar('transformedBitangentWorld');

  /** @module AccessorsUtils **/

  /**
   * TSL object that represents the TBN matrix in view space.
   *
   * @type {Node<mat3>}
   */
  var TBNViewMatrix = /*@__PURE__*/mat3(tangentView, bitangentView, normalView);

  /**
   * TSL object that represents the parallax direction.
   *
   * @type {Node<mat3>}
   */
  var parallaxDirection = /*@__PURE__*/positionViewDirection.mul(TBNViewMatrix) /*.normalize()*/;

  /**
   * TSL function for computing parallax uv coordinates.
   *
   * @function
   * @param {Node<vec2>} uv - A uv node.
   * @param {Node<vec2>} scale - A scale node.
   * @returns {Node<vec2>} Parallax uv coordinates.
   */
  var parallaxUV = function parallaxUV(uv, scale) {
    return uv.sub(parallaxDirection.mul(scale));
  };

  /**
   * TSL function for computing bent normals.
   *
   * @function
   * @returns {Node<vec3>} Bent normals.
   */
  var transformedBentNormalView = /*@__PURE__*/function () {
    // https://google.github.io/filament/Filament.md.html#lighting/imagebasedlights/anisotropy

    var bentNormal = anisotropyB.cross(positionViewDirection);
    bentNormal = bentNormal.cross(anisotropyB).normalize();
    bentNormal = mix(bentNormal, transformedNormalView, anisotropy.mul(roughness.oneMinus()).oneMinus().pow2().pow2()).normalize();
    return bentNormal;
  }();

  /** @module NormalMapNode **/

  // Normal Mapping Without Precomputed Tangents
  // http://www.thetenthplanet.de/archives/1180

  var perturbNormal2Arb = /*@__PURE__*/Fn(function (inputs) {
    var eye_pos = inputs.eye_pos,
      surf_norm = inputs.surf_norm,
      mapN = inputs.mapN,
      uv = inputs.uv;
    var q0 = eye_pos.dFdx();
    var q1 = eye_pos.dFdy();
    var st0 = uv.dFdx();
    var st1 = uv.dFdy();
    var N = surf_norm; // normalized

    var q1perp = q1.cross(N);
    var q0perp = N.cross(q0);
    var T = q1perp.mul(st0.x).add(q0perp.mul(st1.x));
    var B = q1perp.mul(st0.y).add(q0perp.mul(st1.y));
    var det = T.dot(T).max(B.dot(B));
    var scale = faceDirection.mul(det.inverseSqrt());
    return add(T.mul(mapN.x, scale), B.mul(mapN.y, scale), N.mul(mapN.z)).normalize();
  });

  /**
   * This class can be used for applying normals maps to materials.
   *
   * ```js
   * material.normalNode = normalMap( texture( normalTex ) );
   * ```
   *
   * @augments TempNode
   */
  var NormalMapNode = exports.NormalMapNode = /*#__PURE__*/function (_TempNode11) {
    /**
     * Constructs a new normal map node.
     *
     * @param {Node} node - Represents the normal map data.
     * @param {Node?} [scaleNode=null] - Controls the intensity of the effect.
     */
    function NormalMapNode(node) {
      var _this50;
      var scaleNode = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      (0, _classCallCheck2.default)(this, NormalMapNode);
      _this50 = _callSuper(this, NormalMapNode, ['vec3']);

      /**
       * Represents the normal map data.
       *
       * @type {Node}
       */
      _this50.node = node;

      /**
       * Controls the intensity of the effect.
       *
       * @type {Node?}
       * @default null
       */
      _this50.scaleNode = scaleNode;

      /**
       * The normal map type.
       *
       * @type {(TangentSpaceNormalMap|ObjectSpaceNormalMap)}
       * @default TangentSpaceNormalMap
       */
      _this50.normalMapType = _$$_REQUIRE(_dependencyMap[1], "./three.core.js").TangentSpaceNormalMap;
      return _this50;
    }
    (0, _inherits2.default)(NormalMapNode, _TempNode11);
    return (0, _createClass2.default)(NormalMapNode, [{
      key: "setup",
      value: function setup(builder) {
        var normalMapType = this.normalMapType,
          scaleNode = this.scaleNode;
        var normalMap = this.node.mul(2.0).sub(1.0);
        if (scaleNode !== null) {
          normalMap = vec3(normalMap.xy.mul(scaleNode), normalMap.z);
        }
        var outputNode = null;
        if (normalMapType === _$$_REQUIRE(_dependencyMap[1], "./three.core.js").ObjectSpaceNormalMap) {
          outputNode = transformNormalToView(normalMap);
        } else if (normalMapType === _$$_REQUIRE(_dependencyMap[1], "./three.core.js").TangentSpaceNormalMap) {
          var tangent = builder.hasGeometryAttribute('tangent');
          if (tangent === true) {
            outputNode = TBNViewMatrix.mul(normalMap).normalize();
          } else {
            outputNode = perturbNormal2Arb({
              eye_pos: positionView,
              surf_norm: normalView,
              mapN: normalMap,
              uv: uv()
            });
          }
        }
        return outputNode;
      }
    }], [{
      key: "type",
      get: function get() {
        return 'NormalMapNode';
      }
    }]);
  }(TempNode);
  /**
   * TSL function for creating a normal map node.
   *
   * @function
   * @param {Node} node - Represents the normal map data.
   * @param {Node?} [scaleNode=null] - Controls the intensity of the effect.
   * @returns {NormalMapNode}
   */
  var normalMap = /*@__PURE__*/nodeProxy(NormalMapNode);

  /** @module BumpMapNode **/

  // Bump Mapping Unparametrized Surfaces on the GPU by Morten S. Mikkelsen
  // https://mmikk.github.io/papers3d/mm_sfgrad_bump.pdf

  var dHdxy_fwd = Fn(function (_ref31) {
    var textureNode = _ref31.textureNode,
      bumpScale = _ref31.bumpScale;
    // It's used to preserve the same TextureNode instance
    var sampleTexture = function sampleTexture(callback) {
      return textureNode.cache().context({
        getUV: function getUV(texNode) {
          return callback(texNode.uvNode || uv());
        },
        forceUVContext: true
      });
    };
    var Hll = float(sampleTexture(function (uvNode) {
      return uvNode;
    }));
    return vec2(float(sampleTexture(function (uvNode) {
      return uvNode.add(uvNode.dFdx());
    })).sub(Hll), float(sampleTexture(function (uvNode) {
      return uvNode.add(uvNode.dFdy());
    })).sub(Hll)).mul(bumpScale);
  });

  // Evaluate the derivative of the height w.r.t. screen-space using forward differencing (listing 2)

  var perturbNormalArb = Fn(function (inputs) {
    var surf_pos = inputs.surf_pos,
      surf_norm = inputs.surf_norm,
      dHdxy = inputs.dHdxy;

    // normalize is done to ensure that the bump map looks the same regardless of the texture's scale
    var vSigmaX = surf_pos.dFdx().normalize();
    var vSigmaY = surf_pos.dFdy().normalize();
    var vN = surf_norm; // normalized

    var R1 = vSigmaY.cross(vN);
    var R2 = vN.cross(vSigmaX);
    var fDet = vSigmaX.dot(R1).mul(faceDirection);
    var vGrad = fDet.sign().mul(dHdxy.x.mul(R1).add(dHdxy.y.mul(R2)));
    return fDet.abs().mul(surf_norm).sub(vGrad).normalize();
  });

  /**
   * This class can be used for applying bump maps to materials.
   *
   * ```js
   * material.normalNode = bumpMap( texture( bumpTex ) );
   * ```
   *
   * @augments TempNode
   */
  var BumpMapNode = exports.BumpMapNode = /*#__PURE__*/function (_TempNode12) {
    /**
     * Constructs a new bump map node.
     *
     * @param {Node} textureNode - Represents the bump map data.
     * @param {Node?} [scaleNode=null] - Controls the intensity of the bump effect.
     */
    function BumpMapNode(textureNode) {
      var _this51;
      var scaleNode = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      (0, _classCallCheck2.default)(this, BumpMapNode);
      _this51 = _callSuper(this, BumpMapNode, ['vec3']);

      /**
       * Represents the bump map data.
       *
       * @type {Node}
       */
      _this51.textureNode = textureNode;

      /**
       * Controls the intensity of the bump effect.
       *
       * @type {Node?}
       * @default null
       */
      _this51.scaleNode = scaleNode;
      return _this51;
    }
    (0, _inherits2.default)(BumpMapNode, _TempNode12);
    return (0, _createClass2.default)(BumpMapNode, [{
      key: "setup",
      value: function setup() {
        var bumpScale = this.scaleNode !== null ? this.scaleNode : 1;
        var dHdxy = dHdxy_fwd({
          textureNode: this.textureNode,
          bumpScale: bumpScale
        });
        return perturbNormalArb({
          surf_pos: positionView,
          surf_norm: normalView,
          dHdxy: dHdxy
        });
      }
    }], [{
      key: "type",
      get: function get() {
        return 'BumpMapNode';
      }
    }]);
  }(TempNode);
  /**
   * TSL function for creating a bump map node.
   *
   * @function
   * @param {Node} textureNode - Represents the bump map data.
   * @param {Node?} [scaleNode=null] - Controls the intensity of the bump effect.
   * @returns {BumpMapNode}
   */
  var bumpMap = /*@__PURE__*/nodeProxy(BumpMapNode);

  /** @module MaterialNode **/

  var _propertyCache = new Map();

  /**
   * This class should simplify the node access to material properties.
   * It internal uses reference nodes to make sure  changes to material
   * properties are automatically reflected to predefined TSL objects
   * like e.g. `materialColor`.
   *
   * @augments Node
   */
  var MaterialNode = exports.MaterialNode = /*#__PURE__*/function (_Node25) {
    /**
     * Constructs a new material node.
     *
     * @param {String} scope - The scope defines what kind of material property is referred by the node.
     */
    function MaterialNode(scope) {
      var _this52;
      (0, _classCallCheck2.default)(this, MaterialNode);
      _this52 = _callSuper(this, MaterialNode);

      /**
       * The scope defines what material property is referred by the node.
       *
       * @type {String}
       */
      _this52.scope = scope;
      return _this52;
    }

    /**
     * Returns a cached reference node for the given property and type.
     *
     * @param {String} property - The name of the material property.
     * @param {String} type - The uniform type of the property.
     * @return {MaterialReferenceNode} A material reference node representing the property access.
     */
    (0, _inherits2.default)(MaterialNode, _Node25);
    return (0, _createClass2.default)(MaterialNode, [{
      key: "getCache",
      value: function getCache(property, type) {
        var node = _propertyCache.get(property);
        if (node === undefined) {
          node = materialReference(property, type);
          _propertyCache.set(property, node);
        }
        return node;
      }

      /**
       * Returns a float-typed material reference node for the given property name.
       *
       * @param {String} property - The name of the material property.
       * @return {MaterialReferenceNode<float>} A material reference node representing the property access.
       */
    }, {
      key: "getFloat",
      value: function getFloat(property) {
        return this.getCache(property, 'float');
      }

      /**
       * Returns a color-typed material reference node for the given property name.
       *
       * @param {String} property - The name of the material property.
       * @return {MaterialReferenceNode<color>} A material reference node representing the property access.
       */
    }, {
      key: "getColor",
      value: function getColor(property) {
        return this.getCache(property, 'color');
      }

      /**
       * Returns a texture-typed material reference node for the given property name.
       *
       * @param {String} property - The name of the material property.
       * @return {MaterialReferenceNode} A material reference node representing the property access.
       */
    }, {
      key: "getTexture",
      value: function getTexture(property) {
        return this.getCache(property === 'map' ? 'map' : property + 'Map', 'texture');
      }

      /**
       * The node setup is done depending on the selected scope. Multiple material properties
       * might be grouped into a single node composition if they logically belong together.
       *
       * @param {NodeBuilder} builder - The current node builder.
       * @return {Node} The node representing the selected scope.
       */
    }, {
      key: "setup",
      value: function setup(builder) {
        var material = builder.context.material;
        var scope = this.scope;
        var node = null;
        if (scope === MaterialNode.COLOR) {
          var colorNode = material.color !== undefined ? this.getColor(scope) : vec3();
          if (material.map && material.map.isTexture === true) {
            node = colorNode.mul(this.getTexture('map'));
          } else {
            node = colorNode;
          }
        } else if (scope === MaterialNode.OPACITY) {
          var opacityNode = this.getFloat(scope);
          if (material.alphaMap && material.alphaMap.isTexture === true) {
            node = opacityNode.mul(this.getTexture('alpha'));
          } else {
            node = opacityNode;
          }
        } else if (scope === MaterialNode.SPECULAR_STRENGTH) {
          if (material.specularMap && material.specularMap.isTexture === true) {
            node = this.getTexture('specular').r;
          } else {
            node = float(1);
          }
        } else if (scope === MaterialNode.SPECULAR_INTENSITY) {
          var specularIntensityNode = this.getFloat(scope);
          if (material.specularIntensityMap && material.specularIntensityMap.isTexture === true) {
            node = specularIntensityNode.mul(this.getTexture(scope).a);
          } else {
            node = specularIntensityNode;
          }
        } else if (scope === MaterialNode.SPECULAR_COLOR) {
          var specularColorNode = this.getColor(scope);
          if (material.specularColorMap && material.specularColorMap.isTexture === true) {
            node = specularColorNode.mul(this.getTexture(scope).rgb);
          } else {
            node = specularColorNode;
          }
        } else if (scope === MaterialNode.ROUGHNESS) {
          // TODO: cleanup similar branches

          var roughnessNode = this.getFloat(scope);
          if (material.roughnessMap && material.roughnessMap.isTexture === true) {
            node = roughnessNode.mul(this.getTexture(scope).g);
          } else {
            node = roughnessNode;
          }
        } else if (scope === MaterialNode.METALNESS) {
          var metalnessNode = this.getFloat(scope);
          if (material.metalnessMap && material.metalnessMap.isTexture === true) {
            node = metalnessNode.mul(this.getTexture(scope).b);
          } else {
            node = metalnessNode;
          }
        } else if (scope === MaterialNode.EMISSIVE) {
          var emissiveIntensityNode = this.getFloat('emissiveIntensity');
          var emissiveNode = this.getColor(scope).mul(emissiveIntensityNode);
          if (material.emissiveMap && material.emissiveMap.isTexture === true) {
            node = emissiveNode.mul(this.getTexture(scope));
          } else {
            node = emissiveNode;
          }
        } else if (scope === MaterialNode.NORMAL) {
          if (material.normalMap) {
            node = normalMap(this.getTexture('normal'), this.getCache('normalScale', 'vec2'));
            node.normalMapType = material.normalMapType;
          } else if (material.bumpMap) {
            node = bumpMap(this.getTexture('bump').r, this.getFloat('bumpScale'));
          } else {
            node = normalView;
          }
        } else if (scope === MaterialNode.CLEARCOAT) {
          var clearcoatNode = this.getFloat(scope);
          if (material.clearcoatMap && material.clearcoatMap.isTexture === true) {
            node = clearcoatNode.mul(this.getTexture(scope).r);
          } else {
            node = clearcoatNode;
          }
        } else if (scope === MaterialNode.CLEARCOAT_ROUGHNESS) {
          var clearcoatRoughnessNode = this.getFloat(scope);
          if (material.clearcoatRoughnessMap && material.clearcoatRoughnessMap.isTexture === true) {
            node = clearcoatRoughnessNode.mul(this.getTexture(scope).r);
          } else {
            node = clearcoatRoughnessNode;
          }
        } else if (scope === MaterialNode.CLEARCOAT_NORMAL) {
          if (material.clearcoatNormalMap) {
            node = normalMap(this.getTexture(scope), this.getCache(scope + 'Scale', 'vec2'));
          } else {
            node = normalView;
          }
        } else if (scope === MaterialNode.SHEEN) {
          var sheenNode = this.getColor('sheenColor').mul(this.getFloat('sheen')); // Move this mul() to CPU

          if (material.sheenColorMap && material.sheenColorMap.isTexture === true) {
            node = sheenNode.mul(this.getTexture('sheenColor').rgb);
          } else {
            node = sheenNode;
          }
        } else if (scope === MaterialNode.SHEEN_ROUGHNESS) {
          var sheenRoughnessNode = this.getFloat(scope);
          if (material.sheenRoughnessMap && material.sheenRoughnessMap.isTexture === true) {
            node = sheenRoughnessNode.mul(this.getTexture(scope).a);
          } else {
            node = sheenRoughnessNode;
          }
          node = node.clamp(0.07, 1.0);
        } else if (scope === MaterialNode.ANISOTROPY) {
          if (material.anisotropyMap && material.anisotropyMap.isTexture === true) {
            var anisotropyPolar = this.getTexture(scope);
            var anisotropyMat = mat2(materialAnisotropyVector.x, materialAnisotropyVector.y, materialAnisotropyVector.y.negate(), materialAnisotropyVector.x);
            node = anisotropyMat.mul(anisotropyPolar.rg.mul(2.0).sub(vec2(1.0)).normalize().mul(anisotropyPolar.b));
          } else {
            node = materialAnisotropyVector;
          }
        } else if (scope === MaterialNode.IRIDESCENCE_THICKNESS) {
          var iridescenceThicknessMaximum = reference('1', 'float', material.iridescenceThicknessRange);
          if (material.iridescenceThicknessMap) {
            var iridescenceThicknessMinimum = reference('0', 'float', material.iridescenceThicknessRange);
            node = iridescenceThicknessMaximum.sub(iridescenceThicknessMinimum).mul(this.getTexture(scope).g).add(iridescenceThicknessMinimum);
          } else {
            node = iridescenceThicknessMaximum;
          }
        } else if (scope === MaterialNode.TRANSMISSION) {
          var transmissionNode = this.getFloat(scope);
          if (material.transmissionMap) {
            node = transmissionNode.mul(this.getTexture(scope).r);
          } else {
            node = transmissionNode;
          }
        } else if (scope === MaterialNode.THICKNESS) {
          var thicknessNode = this.getFloat(scope);
          if (material.thicknessMap) {
            node = thicknessNode.mul(this.getTexture(scope).g);
          } else {
            node = thicknessNode;
          }
        } else if (scope === MaterialNode.IOR) {
          node = this.getFloat(scope);
        } else if (scope === MaterialNode.LIGHT_MAP) {
          node = this.getTexture(scope).rgb.mul(this.getFloat('lightMapIntensity'));
        } else if (scope === MaterialNode.AO) {
          node = this.getTexture(scope).r.sub(1.0).mul(this.getFloat('aoMapIntensity')).add(1.0);
        } else {
          var outputType = this.getNodeType(builder);
          node = this.getCache(scope, outputType);
        }
        return node;
      }
    }], [{
      key: "type",
      get: function get() {
        return 'MaterialNode';
      }
    }]);
  }(Node);
  MaterialNode.ALPHA_TEST = 'alphaTest';
  MaterialNode.COLOR = 'color';
  MaterialNode.OPACITY = 'opacity';
  MaterialNode.SHININESS = 'shininess';
  MaterialNode.SPECULAR = 'specular';
  MaterialNode.SPECULAR_STRENGTH = 'specularStrength';
  MaterialNode.SPECULAR_INTENSITY = 'specularIntensity';
  MaterialNode.SPECULAR_COLOR = 'specularColor';
  MaterialNode.REFLECTIVITY = 'reflectivity';
  MaterialNode.ROUGHNESS = 'roughness';
  MaterialNode.METALNESS = 'metalness';
  MaterialNode.NORMAL = 'normal';
  MaterialNode.CLEARCOAT = 'clearcoat';
  MaterialNode.CLEARCOAT_ROUGHNESS = 'clearcoatRoughness';
  MaterialNode.CLEARCOAT_NORMAL = 'clearcoatNormal';
  MaterialNode.EMISSIVE = 'emissive';
  MaterialNode.ROTATION = 'rotation';
  MaterialNode.SHEEN = 'sheen';
  MaterialNode.SHEEN_ROUGHNESS = 'sheenRoughness';
  MaterialNode.ANISOTROPY = 'anisotropy';
  MaterialNode.IRIDESCENCE = 'iridescence';
  MaterialNode.IRIDESCENCE_IOR = 'iridescenceIOR';
  MaterialNode.IRIDESCENCE_THICKNESS = 'iridescenceThickness';
  MaterialNode.IOR = 'ior';
  MaterialNode.TRANSMISSION = 'transmission';
  MaterialNode.THICKNESS = 'thickness';
  MaterialNode.ATTENUATION_DISTANCE = 'attenuationDistance';
  MaterialNode.ATTENUATION_COLOR = 'attenuationColor';
  MaterialNode.LINE_SCALE = 'scale';
  MaterialNode.LINE_DASH_SIZE = 'dashSize';
  MaterialNode.LINE_GAP_SIZE = 'gapSize';
  MaterialNode.LINE_WIDTH = 'linewidth';
  MaterialNode.LINE_DASH_OFFSET = 'dashOffset';
  MaterialNode.POINT_WIDTH = 'pointWidth';
  MaterialNode.DISPERSION = 'dispersion';
  MaterialNode.LIGHT_MAP = 'light';
  MaterialNode.AO = 'ao';

  /**
   * TSL object that represents alpha test of the current material.
   *
   * @type {Node<float>}
   */
  var materialAlphaTest = /*@__PURE__*/nodeImmutable(MaterialNode, MaterialNode.ALPHA_TEST);

  /**
   * TSL object that represents the diffuse color of the current material.
   * The value is composed via `color` * `map`.
   *
   * @type {Node<vec3>}
   */
  var materialColor = /*@__PURE__*/nodeImmutable(MaterialNode, MaterialNode.COLOR);

  /**
   * TSL object that represents the shininess of the current material.
   *
   * @type {Node<float>}
   */
  var materialShininess = /*@__PURE__*/nodeImmutable(MaterialNode, MaterialNode.SHININESS);

  /**
   * TSL object that represents the emissive color of the current material.
   * The value is composed via `emissive` * `emissiveIntensity` * `emissiveMap`.
   *
   * @type {Node<vec3>}
   */
  var materialEmissive = /*@__PURE__*/nodeImmutable(MaterialNode, MaterialNode.EMISSIVE);

  /**
   * TSL object that represents the opacity of the current material.
   * The value is composed via `opacity` * `alphaMap`.
   *
   * @type {Node<float>}
   */
  var materialOpacity = /*@__PURE__*/nodeImmutable(MaterialNode, MaterialNode.OPACITY);

  /**
   * TSL object that represents the specular of the current material.
   *
   * @type {Node<vec3>}
   */
  var materialSpecular = /*@__PURE__*/nodeImmutable(MaterialNode, MaterialNode.SPECULAR);

  /**
   * TSL object that represents the specular intensity of the current material.
   * The value is composed via `specularIntensity` * `specularMap.a`.
   *
   * @type {Node<float>}
   */
  var materialSpecularIntensity = /*@__PURE__*/nodeImmutable(MaterialNode, MaterialNode.SPECULAR_INTENSITY);

  /**
   * TSL object that represents the specular color of the current material.
   * The value is composed via `specularColor` * `specularMap.rgb`.
   *
   * @type {Node<vec3>}
   */
  var materialSpecularColor = /*@__PURE__*/nodeImmutable(MaterialNode, MaterialNode.SPECULAR_COLOR);

  /**
   * TSL object that represents the specular strength of the current material.
   * The value is composed via `specularMap.r`.
   *
   * @type {Node<float>}
   */
  var materialSpecularStrength = /*@__PURE__*/nodeImmutable(MaterialNode, MaterialNode.SPECULAR_STRENGTH);

  /**
   * TSL object that represents the reflectivity of the current material.
   *
   * @type {Node<float>}
   */
  var materialReflectivity = /*@__PURE__*/nodeImmutable(MaterialNode, MaterialNode.REFLECTIVITY);

  /**
   * TSL object that represents the roughness of the current material.
   * The value is composed via `roughness` * `roughnessMap.g`
   *
   * @type {Node<float>}
   */
  var materialRoughness = /*@__PURE__*/nodeImmutable(MaterialNode, MaterialNode.ROUGHNESS);

  /**
   * TSL object that represents the metalness of the current material.
   * The value is composed via `metalness` * `metalnessMap.b`
   *
   * @type {Node<float>}
   */
  var materialMetalness = /*@__PURE__*/nodeImmutable(MaterialNode, MaterialNode.METALNESS);

  /**
   * TSL object that represents the normal of the current material.
   * The value will be either `normalMap` * `normalScale`, `bumpMap` * `bumpScale` or `normalView`.
   *
   * @type {Node<vec3>}
   */
  var materialNormal = /*@__PURE__*/nodeImmutable(MaterialNode, MaterialNode.NORMAL).context({
    getUV: null
  });

  /**
   * TSL object that represents the clearcoat of the current material.
   * The value is composed via `clearcoat` * `clearcoatMap.r`
   *
   * @type {Node<float>}
   */
  var materialClearcoat = /*@__PURE__*/nodeImmutable(MaterialNode, MaterialNode.CLEARCOAT);

  /**
   * TSL object that represents the clearcoat roughness of the current material.
   * The value is composed via `clearcoatRoughness` * `clearcoatRoughnessMap.r`
   *
   * @type {Node<float>}
   */
  var materialClearcoatRoughness = /*@__PURE__*/nodeImmutable(MaterialNode, MaterialNode.CLEARCOAT_ROUGHNESS);

  /**
   * TSL object that represents the clearcoat normal of the current material.
   * The value will be either `clearcoatNormalMap` or `normalView`.
   *
   * @type {Node<vec3>}
   */
  var materialClearcoatNormal = /*@__PURE__*/nodeImmutable(MaterialNode, MaterialNode.CLEARCOAT_NORMAL).context({
    getUV: null
  });

  /**
   * TSL object that represents the rotation of the current sprite material.
   *
   * @type {Node<float>}
   */
  var materialRotation = /*@__PURE__*/nodeImmutable(MaterialNode, MaterialNode.ROTATION);

  /**
   * TSL object that represents the sheen color of the current material.
   * The value is composed via `sheen` * `sheenColor` * `sheenColorMap`.
   *
   * @type {Node<vec3>}
   */
  var materialSheen = /*@__PURE__*/nodeImmutable(MaterialNode, MaterialNode.SHEEN);

  /**
   * TSL object that represents the sheen roughness of the current material.
   * The value is composed via `sheenRoughness` * `sheenRoughnessMap.a` .
   *
   * @type {Node<float>}
   */
  var materialSheenRoughness = /*@__PURE__*/nodeImmutable(MaterialNode, MaterialNode.SHEEN_ROUGHNESS);

  /**
   * TSL object that represents the anisotropy of the current material.
   *
   * @type {Node<vec2>}
   */
  var materialAnisotropy = /*@__PURE__*/nodeImmutable(MaterialNode, MaterialNode.ANISOTROPY);

  /**
   * TSL object that represents the iridescence of the current material.
   *
   * @type {Node<float>}
   */
  var materialIridescence = /*@__PURE__*/nodeImmutable(MaterialNode, MaterialNode.IRIDESCENCE);

  /**
   * TSL object that represents the iridescence IOR of the current material.
   *
   * @type {Node<float>}
   */
  var materialIridescenceIOR = /*@__PURE__*/nodeImmutable(MaterialNode, MaterialNode.IRIDESCENCE_IOR);

  /**
   * TSL object that represents the iridescence thickness of the current material.
   *
   * @type {Node<float>}
   */
  var materialIridescenceThickness = /*@__PURE__*/nodeImmutable(MaterialNode, MaterialNode.IRIDESCENCE_THICKNESS);

  /**
   * TSL object that represents the transmission of the current material.
   * The value is composed via `transmission` * `transmissionMap.r`.
   *
   * @type {Node<float>}
   */
  var materialTransmission = /*@__PURE__*/nodeImmutable(MaterialNode, MaterialNode.TRANSMISSION);

  /**
   * TSL object that represents the thickness of the current material.
   * The value is composed via `thickness` * `thicknessMap.g`.
   *
   * @type {Node<float>}
   */
  var materialThickness = /*@__PURE__*/nodeImmutable(MaterialNode, MaterialNode.THICKNESS);

  /**
   * TSL object that represents the IOR of the current material.
   *
   * @type {Node<float>}
   */
  var materialIOR = /*@__PURE__*/nodeImmutable(MaterialNode, MaterialNode.IOR);

  /**
   * TSL object that represents the attenuation distance of the current material.
   *
   * @type {Node<float>}
   */
  var materialAttenuationDistance = /*@__PURE__*/nodeImmutable(MaterialNode, MaterialNode.ATTENUATION_DISTANCE);

  /**
   * TSL object that represents the attenuation color of the current material.
   *
   * @type {Node<vec3>}
   */
  var materialAttenuationColor = /*@__PURE__*/nodeImmutable(MaterialNode, MaterialNode.ATTENUATION_COLOR);

  /**
   * TSL object that represents the scale of the current dashed line material.
   *
   * @type {Node<float>}
   */
  var materialLineScale = /*@__PURE__*/nodeImmutable(MaterialNode, MaterialNode.LINE_SCALE);

  /**
   * TSL object that represents the dash size of the current dashed line material.
   *
   * @type {Node<float>}
   */
  var materialLineDashSize = /*@__PURE__*/nodeImmutable(MaterialNode, MaterialNode.LINE_DASH_SIZE);

  /**
   * TSL object that represents the gap size of the current dashed line material.
   *
   * @type {Node<float>}
   */
  var materialLineGapSize = /*@__PURE__*/nodeImmutable(MaterialNode, MaterialNode.LINE_GAP_SIZE);

  /**
   * TSL object that represents the line width of the current line material.
   *
   * @type {Node<float>}
   */
  var materialLineWidth = /*@__PURE__*/nodeImmutable(MaterialNode, MaterialNode.LINE_WIDTH);

  /**
   * TSL object that represents the dash offset of the current line material.
   *
   * @type {Node<float>}
   */
  var materialLineDashOffset = /*@__PURE__*/nodeImmutable(MaterialNode, MaterialNode.LINE_DASH_OFFSET);

  /**
   * TSL object that represents the point width of the current points material.
   *
   * @type {Node<float>}
   */
  var materialPointWidth = /*@__PURE__*/nodeImmutable(MaterialNode, MaterialNode.POINT_WIDTH);

  /**
   * TSL object that represents the dispersion of the current material.
   *
   * @type {Node<float>}
   */
  var materialDispersion = /*@__PURE__*/nodeImmutable(MaterialNode, MaterialNode.DISPERSION);

  /**
   * TSL object that represents the light map of the current material.
   * The value is composed via `lightMapIntensity` * `lightMap.rgb`.
   *
   * @type {Node<vec3>}
   */
  var materialLightMap = /*@__PURE__*/nodeImmutable(MaterialNode, MaterialNode.LIGHT_MAP);

  /**
   * TSL object that represents the ambient occlusion map of the current material.
   * The value is composed via `aoMap.r` - 1 * `aoMapIntensity` + 1.
   *
   * @type {Node<float>}
   */
  var materialAO = /*@__PURE__*/nodeImmutable(MaterialNode, MaterialNode.AO);

  /**
   * TSL object that represents the anisotropy vector of the current material.
   *
   * @type {Node<vec2>}
   */
  var materialAnisotropyVector = /*@__PURE__*/uniform(new (_$$_REQUIRE(_dependencyMap[1], "./three.core.js").Vector2)()).onReference(function (frame) {
    return frame.material;
  }).onRenderUpdate(function (_ref32) {
    var material = _ref32.material;
    this.value.set(material.anisotropy * Math.cos(material.anisotropyRotation), material.anisotropy * Math.sin(material.anisotropyRotation));
  });

  /** @module ModelViewProjectionNode **/

  /**
   * TSL object that represents the position in clip space after the model-view-projection transform of the current rendered object.
   *
   * @type {VaryingNode<vec4>}
   */
  var modelViewProjection = /*@__PURE__*/Fn(function (builder) {
    return builder.context.setupModelViewProjection();
  }, 'vec4').once()().varying('v_modelViewProjection');

  /** @module IndexNode **/

  /**
   * This class represents shader indices of different types. The following predefined node
   * objects cover frequent use cases:
   *
   * - `vertexIndex`: The index of a vertex within a mesh.
   * - `instanceIndex`: The index of either a mesh instance or an invocation of a compute shader.
   * - `drawIndex`: The index of a draw call.
   * - `invocationLocalIndex`: The index of a compute invocation within the scope of a workgroup load.
   * - `invocationSubgroupIndex`: The index of a compute invocation within the scope of a subgroup.
   * - `subgroupIndex`: The index of the subgroup the current compute invocation belongs to.
   *
   * @augments Node
   */
  var IndexNode = exports.IndexNode = /*#__PURE__*/function (_Node26) {
    /**
     * Constructs a new index node.
     *
     * @param {('vertex'|'instance'|'subgroup'|'invocationLocal'|'invocationSubgroup'|'draw')} scope - The scope of the index node.
     */
    function IndexNode(scope) {
      var _this53;
      (0, _classCallCheck2.default)(this, IndexNode);
      _this53 = _callSuper(this, IndexNode, ['uint']);

      /**
       * The scope of the index node.
       *
       * @type {String}
       */
      _this53.scope = scope;

      /**
       * This flag can be used for type testing.
       *
       * @type {Boolean}
       * @readonly
       * @default true
       */
      _this53.isIndexNode = true;
      return _this53;
    }
    (0, _inherits2.default)(IndexNode, _Node26);
    return (0, _createClass2.default)(IndexNode, [{
      key: "generate",
      value: function generate(builder) {
        var nodeType = this.getNodeType(builder);
        var scope = this.scope;
        var propertyName;
        if (scope === IndexNode.VERTEX) {
          propertyName = builder.getVertexIndex();
        } else if (scope === IndexNode.INSTANCE) {
          propertyName = builder.getInstanceIndex();
        } else if (scope === IndexNode.DRAW) {
          propertyName = builder.getDrawIndex();
        } else if (scope === IndexNode.INVOCATION_LOCAL) {
          propertyName = builder.getInvocationLocalIndex();
        } else if (scope === IndexNode.INVOCATION_SUBGROUP) {
          propertyName = builder.getInvocationSubgroupIndex();
        } else if (scope === IndexNode.SUBGROUP) {
          propertyName = builder.getSubgroupIndex();
        } else {
          throw new Error('THREE.IndexNode: Unknown scope: ' + scope);
        }
        var output;
        if (builder.shaderStage === 'vertex' || builder.shaderStage === 'compute') {
          output = propertyName;
        } else {
          var nodeVarying = varying(this);
          output = nodeVarying.build(builder, nodeType);
        }
        return output;
      }
    }], [{
      key: "type",
      get: function get() {
        return 'IndexNode';
      }
    }]);
  }(Node);
  IndexNode.VERTEX = 'vertex';
  IndexNode.INSTANCE = 'instance';
  IndexNode.SUBGROUP = 'subgroup';
  IndexNode.INVOCATION_LOCAL = 'invocationLocal';
  IndexNode.INVOCATION_SUBGROUP = 'invocationSubgroup';
  IndexNode.DRAW = 'draw';

  /**
   * TSL object that represents the index of a vertex within a mesh.
   *
   * @type {IndexNode}
   */
  var vertexIndex = /*@__PURE__*/nodeImmutable(IndexNode, IndexNode.VERTEX);

  /**
   * TSL object that represents the index of either a mesh instance or an invocation of a compute shader.
   *
   * @type {IndexNode}
   */
  var instanceIndex = /*@__PURE__*/nodeImmutable(IndexNode, IndexNode.INSTANCE);

  /**
   * TSL object that represents the index of the subgroup the current compute invocation belongs to.
   *
   * @type {IndexNode}
   */
  var subgroupIndex = /*@__PURE__*/nodeImmutable(IndexNode, IndexNode.SUBGROUP);

  /**
   * TSL object that represents the index of a compute invocation within the scope of a subgroup.
   *
   * @type {IndexNode}
   */
  var invocationSubgroupIndex = /*@__PURE__*/nodeImmutable(IndexNode, IndexNode.INVOCATION_SUBGROUP);

  /**
   * TSL object that represents the index of a compute invocation within the scope of a workgroup load.
   *
   * @type {IndexNode}
   */
  var invocationLocalIndex = /*@__PURE__*/nodeImmutable(IndexNode, IndexNode.INVOCATION_LOCAL);

  /**
   * TSL object that represents the index of a draw call.
   *
   * @type {IndexNode}
   */
  var drawIndex = /*@__PURE__*/nodeImmutable(IndexNode, IndexNode.DRAW);

  /** @module InstanceNode **/

  /**
   * This node implements the vertex shader logic which is required
   * when rendering 3D objects via instancing. The code makes sure
   * vertex positions, normals and colors can be modified via instanced
   * data.
   *
   * @augments Node
   */
  var InstanceNode = exports.InstanceNode = /*#__PURE__*/function (_Node27) {
    /**
     * Constructs a new instance node.
     *
     * @param {Number} count - The number of instances.
     * @param {InstancedBufferAttribute} instanceMatrix - Instanced buffer attribute representing the instance transformations.
     * @param {InstancedBufferAttribute} instanceColor - Instanced buffer attribute representing the instance colors.
     */
    function InstanceNode(count, instanceMatrix, instanceColor) {
      var _this54;
      (0, _classCallCheck2.default)(this, InstanceNode);
      _this54 = _callSuper(this, InstanceNode, ['void']);

      /**
       * The number of instances.
       *
       * @type {Number}
       */
      _this54.count = count;

      /**
       * Instanced buffer attribute representing the transformation of instances.
       *
       * @type {InstancedBufferAttribute}
       */
      _this54.instanceMatrix = instanceMatrix;

      /**
       * Instanced buffer attribute representing the color of instances.
       *
       * @type {InstancedBufferAttribute}
       */
      _this54.instanceColor = instanceColor;

      /**
       * The node that represents the instance matrix data.
       *
       * @type {Node}
       */
      _this54.instanceMatrixNode = null;

      /**
       * The node that represents the instance color data.
       *
       * @type {Node}
       */
      _this54.instanceColorNode = null;

      /**
       * The update type is set to `frame` since an update
       * of instanced buffer data must be checked per frame.
       *
       * @type {String}
       * @default 'frame'
       */
      _this54.updateType = NodeUpdateType.FRAME;

      /**
       * A reference to a buffer that is used by `instanceMatrixNode`.
       *
       * @type {InstancedInterleavedBuffer}
       */
      _this54.buffer = null;

      /**
       * A reference to a buffer that is used by `instanceColorNode`.
       *
       * @type {InstancedInterleavedBuffer}
       */
      _this54.bufferColor = null;
      return _this54;
    }

    /**
     * Setups the internal buffers and nodes and assigns the transformed vertex data
     * to predefined node variables for accumulation. That follows the same patterns
     * like with morph and skinning nodes.
     *
     * @param {NodeBuilder} builder - The current node builder.
     */
    (0, _inherits2.default)(InstanceNode, _Node27);
    return (0, _createClass2.default)(InstanceNode, [{
      key: "setup",
      value: function setup(builder) {
        var count = this.count,
          instanceMatrix = this.instanceMatrix,
          instanceColor = this.instanceColor;
        var instanceMatrixNode = this.instanceMatrixNode,
          instanceColorNode = this.instanceColorNode;
        if (instanceMatrixNode === null) {
          // Both WebGPU and WebGL backends have UBO max limited to 64kb. Matrix count number bigger than 1000 ( 16 * 4 * 1000 = 64kb ) will fallback to attribute.

          if (count <= 1000) {
            instanceMatrixNode = buffer(instanceMatrix.array, 'mat4', Math.max(count, 1)).element(instanceIndex);
          } else {
            var _buffer = new (_$$_REQUIRE(_dependencyMap[1], "./three.core.js").InstancedInterleavedBuffer)(instanceMatrix.array, 16, 1);
            this.buffer = _buffer;
            var bufferFn = instanceMatrix.usage === _$$_REQUIRE(_dependencyMap[1], "./three.core.js").DynamicDrawUsage ? instancedDynamicBufferAttribute : instancedBufferAttribute;
            var instanceBuffers = [
            // F.Signature -> bufferAttribute( array, type, stride, offset )
            bufferFn(_buffer, 'vec4', 16, 0), bufferFn(_buffer, 'vec4', 16, 4), bufferFn(_buffer, 'vec4', 16, 8), bufferFn(_buffer, 'vec4', 16, 12)];
            instanceMatrixNode = mat4.apply(void 0, instanceBuffers);
          }
          this.instanceMatrixNode = instanceMatrixNode;
        }
        if (instanceColor && instanceColorNode === null) {
          var _buffer2 = new (_$$_REQUIRE(_dependencyMap[1], "./three.core.js").InstancedBufferAttribute)(instanceColor.array, 3);
          var _bufferFn = instanceColor.usage === _$$_REQUIRE(_dependencyMap[1], "./three.core.js").DynamicDrawUsage ? instancedDynamicBufferAttribute : instancedBufferAttribute;
          this.bufferColor = _buffer2;
          instanceColorNode = vec3(_bufferFn(_buffer2, 'vec3', 3, 0));
          this.instanceColorNode = instanceColorNode;
        }

        // POSITION

        var instancePosition = instanceMatrixNode.mul(positionLocal).xyz;
        positionLocal.assign(instancePosition);

        // NORMAL

        if (builder.hasGeometryAttribute('normal')) {
          var instanceNormal = transformNormal(normalLocal, instanceMatrixNode);

          // ASSIGNS

          normalLocal.assign(instanceNormal);
        }

        // COLOR

        if (this.instanceColorNode !== null) {
          varyingProperty('vec3', 'vInstanceColor').assign(this.instanceColorNode);
        }
      }

      /**
       * Checks if the internal buffers required an update.
       *
       * @param {NodeFrame} frame - The current node frame.
       */
    }, {
      key: "update",
      value: function update(/*frame*/
      ) {
        if (this.instanceMatrix.usage !== _$$_REQUIRE(_dependencyMap[1], "./three.core.js").DynamicDrawUsage && this.buffer !== null && this.instanceMatrix.version !== this.buffer.version) {
          this.buffer.version = this.instanceMatrix.version;
        }
        if (this.instanceColor && this.instanceColor.usage !== _$$_REQUIRE(_dependencyMap[1], "./three.core.js").DynamicDrawUsage && this.bufferColor !== null && this.instanceColor.version !== this.bufferColor.version) {
          this.bufferColor.version = this.instanceColor.version;
        }
      }
    }], [{
      key: "type",
      get: function get() {
        return 'InstanceNode';
      }
    }]);
  }(Node);
  /**
   * TSL function for creating an instance node.
   *
   * @function
   * @param {Number} count - The number of instances.
   * @param {InstancedBufferAttribute} instanceMatrix - Instanced buffer attribute representing the instance transformations.
   * @param {InstancedBufferAttribute} instanceColor - Instanced buffer attribute representing the instance colors.
   * @returns {InstanceNode}
   */
  var instance = /*@__PURE__*/nodeProxy(InstanceNode);

  /** @module InstancedMeshNode **/

  /**
   * This is a special version of `InstanceNode` which requires the usage of {@link InstancedMesh}.
   * It allows an easier setup of the instance node.
   *
   * @augments module:InstanceNode~InstanceNode
   */
  var InstancedMeshNode = exports.InstancedMeshNode = /*#__PURE__*/function (_InstanceNode) {
    /**
     * Constructs a new instanced mesh node.
     *
     * @param {InstancedMesh} instancedMesh - The instanced mesh.
     */
    function InstancedMeshNode(instancedMesh) {
      var _this55;
      (0, _classCallCheck2.default)(this, InstancedMeshNode);
      var count = instancedMesh.count,
        instanceMatrix = instancedMesh.instanceMatrix,
        instanceColor = instancedMesh.instanceColor;
      _this55 = _callSuper(this, InstancedMeshNode, [count, instanceMatrix, instanceColor]);

      /**
       * A reference to the instanced mesh.
       *
       * @type {InstancedMesh}
       */
      _this55.instancedMesh = instancedMesh;
      return _this55;
    }
    (0, _inherits2.default)(InstancedMeshNode, _InstanceNode);
    return (0, _createClass2.default)(InstancedMeshNode, null, [{
      key: "type",
      get: function get() {
        return 'InstancedMeshNode';
      }
    }]);
  }(InstanceNode);
  /**
   * TSL function for creating an instanced mesh node.
   *
   * @function
   * @param {InstancedMesh} instancedMesh - The instancedMesh.
   * @returns {InstancedMeshNode}
   */
  var instancedMesh = /*@__PURE__*/nodeProxy(InstancedMeshNode);

  /** @module BatchNode **/

  /**
   * This node implements the vertex shader logic which is required
   * when rendering 3D objects via batching. `BatchNode` must be used
   * with instances of {@link BatchedMesh}.
   *
   * @augments Node
   */
  var BatchNode = exports.BatchNode = /*#__PURE__*/function (_Node28) {
    /**
     * Constructs a new batch node.
     *
     * @param {BatchedMesh} batchMesh - A reference to batched mesh.
     */
    function BatchNode(batchMesh) {
      var _this56;
      (0, _classCallCheck2.default)(this, BatchNode);
      _this56 = _callSuper(this, BatchNode, ['void']);

      /**
       * A reference to batched mesh.
       *
       * @type {BatchedMesh}
       */
      _this56.batchMesh = batchMesh;

      /**
       * The batching index node.
       *
       * @type {IndexNode?}
       * @default null
       */
      _this56.batchingIdNode = null;
      return _this56;
    }

    /**
     * Setups the internal buffers and nodes and assigns the transformed vertex data
     * to predefined node variables for accumulation. That follows the same patterns
     * like with morph and skinning nodes.
     *
     * @param {NodeBuilder} builder - The current node builder.
     */
    (0, _inherits2.default)(BatchNode, _Node28);
    return (0, _createClass2.default)(BatchNode, [{
      key: "setup",
      value: function setup(builder) {
        var _this57 = this;
        if (this.batchingIdNode === null) {
          if (builder.getDrawIndex() === null) {
            this.batchingIdNode = instanceIndex;
          } else {
            this.batchingIdNode = drawIndex;
          }
        }
        var getIndirectIndex = Fn(function (_ref33) {
          var _ref34 = (0, _slicedToArray2.default)(_ref33, 1),
            id = _ref34[0];
          var size = textureSize(textureLoad(_this57.batchMesh._indirectTexture), 0);
          var x = int(id).modInt(int(size));
          var y = int(id).div(int(size));
          return textureLoad(_this57.batchMesh._indirectTexture, ivec2(x, y)).x;
        }).setLayout({
          name: 'getIndirectIndex',
          type: 'uint',
          inputs: [{
            name: 'id',
            type: 'int'
          }]
        });
        var indirectId = getIndirectIndex(int(this.batchingIdNode));
        var matricesTexture = this.batchMesh._matricesTexture;
        var size = textureSize(textureLoad(matricesTexture), 0);
        var j = float(indirectId).mul(4).toInt().toVar();
        var x = j.modInt(size);
        var y = j.div(int(size));
        var batchingMatrix = mat4(textureLoad(matricesTexture, ivec2(x, y)), textureLoad(matricesTexture, ivec2(x.add(1), y)), textureLoad(matricesTexture, ivec2(x.add(2), y)), textureLoad(matricesTexture, ivec2(x.add(3), y)));
        var colorsTexture = this.batchMesh._colorsTexture;
        if (colorsTexture !== null) {
          var getBatchingColor = Fn(function (_ref35) {
            var _ref36 = (0, _slicedToArray2.default)(_ref35, 1),
              id = _ref36[0];
            var size = textureSize(textureLoad(colorsTexture), 0).x;
            var j = id;
            var x = j.modInt(size);
            var y = j.div(size);
            return textureLoad(colorsTexture, ivec2(x, y)).rgb;
          }).setLayout({
            name: 'getBatchingColor',
            type: 'vec3',
            inputs: [{
              name: 'id',
              type: 'int'
            }]
          });
          var _color = getBatchingColor(indirectId);
          varyingProperty('vec3', 'vBatchColor').assign(_color);
        }
        var bm = mat3(batchingMatrix);
        positionLocal.assign(batchingMatrix.mul(positionLocal));
        var transformedNormal = normalLocal.div(vec3(bm[0].dot(bm[0]), bm[1].dot(bm[1]), bm[2].dot(bm[2])));
        var batchingNormal = bm.mul(transformedNormal).xyz;
        normalLocal.assign(batchingNormal);
        if (builder.hasGeometryAttribute('tangent')) {
          tangentLocal.mulAssign(bm);
        }
      }
    }], [{
      key: "type",
      get: function get() {
        return 'BatchNode';
      }
    }]);
  }(Node);
  /**
   * TSL function for creating a batch node.
   *
   * @function
   * @param {BatchedMesh} batchMesh - A reference to batched mesh.
   * @returns {BatchNode}
   */
  var batch = /*@__PURE__*/nodeProxy(BatchNode);

  /** @module SkinningNode **/

  var _frameId = new WeakMap();

  /**
   * This node implements the vertex transformation shader logic which is required
   * for skinning/skeletal animation.
   *
   * @augments Node
   */
  var SkinningNode = exports.SkinningNode = /*#__PURE__*/function (_Node29) {
    /**
     * Constructs a new skinning node.
     *
     * @param {SkinnedMesh} skinnedMesh - The skinned mesh.
     * @param {Boolean} [useReference=false] - Whether to use reference nodes for internal skinned mesh related data or not.
     */
    function SkinningNode(skinnedMesh) {
      var _this58;
      var useReference = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      (0, _classCallCheck2.default)(this, SkinningNode);
      _this58 = _callSuper(this, SkinningNode, ['void']);

      /**
       * The skinned mesh.
       *
       * @type {SkinnedMesh}
       */
      _this58.skinnedMesh = skinnedMesh;

      /**
       * Whether to use reference nodes for internal skinned mesh related data or not.
       * TODO: Explain the purpose of the property.
       *
       * @type {Boolean}
       */
      _this58.useReference = useReference;

      /**
       * The update type overwritten since skinning nodes are updated per object.
       *
       * @type {String}
       */
      _this58.updateType = NodeUpdateType.OBJECT;

      //

      /**
       * The skin index attribute.
       *
       * @type {AttributeNode}
       */
      _this58.skinIndexNode = attribute('skinIndex', 'uvec4');

      /**
       * The skin weight attribute.
       *
       * @type {AttributeNode}
       */
      _this58.skinWeightNode = attribute('skinWeight', 'vec4');
      var bindMatrixNode, bindMatrixInverseNode, boneMatricesNode;
      if (useReference) {
        bindMatrixNode = reference('bindMatrix', 'mat4');
        bindMatrixInverseNode = reference('bindMatrixInverse', 'mat4');
        boneMatricesNode = referenceBuffer('skeleton.boneMatrices', 'mat4', skinnedMesh.skeleton.bones.length);
      } else {
        bindMatrixNode = uniform(skinnedMesh.bindMatrix, 'mat4');
        bindMatrixInverseNode = uniform(skinnedMesh.bindMatrixInverse, 'mat4');
        boneMatricesNode = buffer(skinnedMesh.skeleton.boneMatrices, 'mat4', skinnedMesh.skeleton.bones.length);
      }

      /**
       * The bind matrix node.
       *
       * @type {Node<mat4>}
       */
      _this58.bindMatrixNode = bindMatrixNode;

      /**
       * The bind matrix inverse node.
       *
       * @type {Node<mat4>}
       */
      _this58.bindMatrixInverseNode = bindMatrixInverseNode;

      /**
       * The bind matrices as a uniform buffer node.
       *
       * @type {Node}
       */
      _this58.boneMatricesNode = boneMatricesNode;

      /**
       * The previous bind matrices as a uniform buffer node.
       * Required for computing motion vectors.
       *
       * @type {Node?}
       * @default null
       */
      _this58.previousBoneMatricesNode = null;
      return _this58;
    }

    /**
     * Transforms the given vertex position via skinning.
     *
     * @param {Node} [boneMatrices=this.boneMatricesNode] - The bone matrices
     * @param {Node<vec3>} [position=positionLocal] - The vertex position in local space.
     * @return {Node<vec3>} The transformed vertex position.
     */
    (0, _inherits2.default)(SkinningNode, _Node29);
    return (0, _createClass2.default)(SkinningNode, [{
      key: "getSkinnedPosition",
      value: function getSkinnedPosition() {
        var boneMatrices = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.boneMatricesNode;
        var position = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : positionLocal;
        var skinIndexNode = this.skinIndexNode,
          skinWeightNode = this.skinWeightNode,
          bindMatrixNode = this.bindMatrixNode,
          bindMatrixInverseNode = this.bindMatrixInverseNode;
        var boneMatX = boneMatrices.element(skinIndexNode.x);
        var boneMatY = boneMatrices.element(skinIndexNode.y);
        var boneMatZ = boneMatrices.element(skinIndexNode.z);
        var boneMatW = boneMatrices.element(skinIndexNode.w);

        // POSITION

        var skinVertex = bindMatrixNode.mul(position);
        var skinned = add(boneMatX.mul(skinWeightNode.x).mul(skinVertex), boneMatY.mul(skinWeightNode.y).mul(skinVertex), boneMatZ.mul(skinWeightNode.z).mul(skinVertex), boneMatW.mul(skinWeightNode.w).mul(skinVertex));
        return bindMatrixInverseNode.mul(skinned).xyz;
      }

      /**
       * Transforms the given vertex normal via skinning.
       *
       * @param {Node} [boneMatrices=this.boneMatricesNode] - The bone matrices
       * @param {Node<vec3>} [normal=normalLocal] - The vertex normal in local space.
       * @return {Node<vec3>} The transformed vertex normal.
       */
    }, {
      key: "getSkinnedNormal",
      value: function getSkinnedNormal() {
        var boneMatrices = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.boneMatricesNode;
        var normal = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : normalLocal;
        var skinIndexNode = this.skinIndexNode,
          skinWeightNode = this.skinWeightNode,
          bindMatrixNode = this.bindMatrixNode,
          bindMatrixInverseNode = this.bindMatrixInverseNode;
        var boneMatX = boneMatrices.element(skinIndexNode.x);
        var boneMatY = boneMatrices.element(skinIndexNode.y);
        var boneMatZ = boneMatrices.element(skinIndexNode.z);
        var boneMatW = boneMatrices.element(skinIndexNode.w);

        // NORMAL

        var skinMatrix = add(skinWeightNode.x.mul(boneMatX), skinWeightNode.y.mul(boneMatY), skinWeightNode.z.mul(boneMatZ), skinWeightNode.w.mul(boneMatW));
        skinMatrix = bindMatrixInverseNode.mul(skinMatrix).mul(bindMatrixNode);
        return skinMatrix.transformDirection(normal).xyz;
      }

      /**
       * Transforms the given vertex normal via skinning.
       *
       * @param {NodeBuilder} builder - The current node builder.
       * @return {Node<vec3>} The skinned position from the previous frame.
       */
    }, {
      key: "getPreviousSkinnedPosition",
      value: function getPreviousSkinnedPosition(builder) {
        var skinnedMesh = builder.object;
        if (this.previousBoneMatricesNode === null) {
          skinnedMesh.skeleton.previousBoneMatrices = new Float32Array(skinnedMesh.skeleton.boneMatrices);
          this.previousBoneMatricesNode = referenceBuffer('skeleton.previousBoneMatrices', 'mat4', skinnedMesh.skeleton.bones.length);
        }
        return this.getSkinnedPosition(this.previousBoneMatricesNode, positionPrevious);
      }

      /**
       * Returns `true` if bone matrices from the previous frame are required.
       *
       * @param {NodeBuilder} builder - The current node builder.
       * @return {Boolean} Whether bone matrices from the previous frame are required or not.
       */
    }, {
      key: "needsPreviousBoneMatrices",
      value: function needsPreviousBoneMatrices(builder) {
        var mrt = builder.renderer.getMRT();
        return mrt && mrt.has('velocity') || getDataFromObject(builder.object).useVelocity === true;
      }

      /**
       * Setups the skinning node by assigning the transformed vertex data to predefined node variables.
       *
       * @param {NodeBuilder} builder - The current node builder.
       */
    }, {
      key: "setup",
      value: function setup(builder) {
        if (this.needsPreviousBoneMatrices(builder)) {
          positionPrevious.assign(this.getPreviousSkinnedPosition(builder));
        }
        var skinPosition = this.getSkinnedPosition();
        positionLocal.assign(skinPosition);
        if (builder.hasGeometryAttribute('normal')) {
          var skinNormal = this.getSkinnedNormal();
          normalLocal.assign(skinNormal);
          if (builder.hasGeometryAttribute('tangent')) {
            tangentLocal.assign(skinNormal);
          }
        }
      }

      /**
       * Generates the code snippet of the skinning node.
       *
       * @param {NodeBuilder} builder - The current node builder.
       * @param {String} output - The current output.
       * @return {String} The generated code snippet.
       */
    }, {
      key: "generate",
      value: function generate(builder, output) {
        if (output !== 'void') {
          return positionLocal.build(builder, output);
        }
      }

      /**
       * Updates the state of the skinned mesh by updating the skeleton once per frame.
       *
       * @param {NodeFrame} frame - The current node frame.
       */
    }, {
      key: "update",
      value: function update(frame) {
        var object = this.useReference ? frame.object : this.skinnedMesh;
        var skeleton = object.skeleton;
        if (_frameId.get(skeleton) === frame.frameId) return;
        _frameId.set(skeleton, frame.frameId);
        if (this.previousBoneMatricesNode !== null) skeleton.previousBoneMatrices.set(skeleton.boneMatrices);
        skeleton.update();
      }
    }], [{
      key: "type",
      get: function get() {
        return 'SkinningNode';
      }
    }]);
  }(Node);
  /**
   * TSL function for creating a skinning node.
   *
   * @function
   * @param {SkinnedMesh} skinnedMesh - The skinned mesh.
   * @returns {SkinningNode}
   */
  var skinning = function skinning(skinnedMesh) {
    return nodeObject(new SkinningNode(skinnedMesh));
  };

  /**
   * TSL function for creating a skinning node with reference usage.
   *
   * @function
   * @param {SkinnedMesh} skinnedMesh - The skinned mesh.
   * @returns {SkinningNode}
   */
  var skinningReference = function skinningReference(skinnedMesh) {
    return nodeObject(new SkinningNode(skinnedMesh, true));
  };

  /** @module LoopNode **/

  /**
   * This module offers a variety of ways to implement loops in TSL. In it's basic form it's:
   * ```js
   * Loop( count, ( { i } ) => {
   *
   * } );
   * ```
   * However, it is also possible to define a start and end ranges, data types and loop conditions:
   * ```js
   * Loop( { start: int( 0 ), end: int( 10 ), type: 'int', condition: '<' }, ( { i } ) => {
   *
   * } );
   *```
   * Nested loops can be defined in a compacted form:
   * ```js
   * Loop( 10, 5, ( { i, j } ) => {
   *
   * } );
   * ```
   * Loops that should run backwards can be defined like so:
   * ```js
   * Loop( { start: 10 }, () => {} );
   * ```
   * The module also provides `Break()` and `Continue()` TSL expression for loop control.
   * @augments Node
   */
  var LoopNode = exports.LoopNode = /*#__PURE__*/function (_Node30) {
    /**
     * Constructs a new loop node.
     *
     * @param {Array<Any>} params - Depending on the loop type, array holds different parameterization values for the loop.
     */
    function LoopNode() {
      var _this59;
      var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      (0, _classCallCheck2.default)(this, LoopNode);
      _this59 = _callSuper(this, LoopNode);
      _this59.params = params;
      return _this59;
    }

    /**
     * Returns a loop variable name based on an index. The pattern is
     * `0` = `i`, `1`= `j`, `2`= `k` and so on.
     *
     * @param {Number} index - The index.
     * @return {String} The loop variable name.
     */
    (0, _inherits2.default)(LoopNode, _Node30);
    return (0, _createClass2.default)(LoopNode, [{
      key: "getVarName",
      value: function getVarName(index) {
        return String.fromCharCode('i'.charCodeAt(0) + index);
      }

      /**
       * Returns properties about this node.
       *
       * @param {NodeBuilder} builder - The current node builder.
       * @return {Object} The node properties.
       */
    }, {
      key: "getProperties",
      value: function getProperties(builder) {
        var properties = builder.getNodeProperties(this);
        if (properties.stackNode !== undefined) return properties;

        //

        var inputs = {};
        for (var i = 0, l = this.params.length - 1; i < l; i++) {
          var param = this.params[i];
          var name = param.isNode !== true && param.name || this.getVarName(i);
          var type = param.isNode !== true && param.type || 'int';
          inputs[name] = expression(name, type);
        }
        var stack = builder.addStack(); // TODO: cache() it

        properties.returnsNode = this.params[this.params.length - 1](inputs, stack, builder);
        properties.stackNode = stack;
        builder.removeStack();
        return properties;
      }

      /**
       * This method is overwritten since the node type is inferred based on the loop configuration.
       *
       * @param {NodeBuilder} builder - The current node builder.
       * @return {String} The node type.
       */
    }, {
      key: "getNodeType",
      value: function getNodeType(builder) {
        var _this$getProperties = this.getProperties(builder),
          returnsNode = _this$getProperties.returnsNode;
        return returnsNode ? returnsNode.getNodeType(builder) : 'void';
      }
    }, {
      key: "setup",
      value: function setup(builder) {
        // setup properties

        this.getProperties(builder);
      }
    }, {
      key: "generate",
      value: function generate(builder) {
        var properties = this.getProperties(builder);
        var params = this.params;
        var stackNode = properties.stackNode;
        for (var i = 0, l = params.length - 1; i < l; i++) {
          var param = params[i];
          var start = null,
            end = null,
            name = null,
            type = null,
            condition = null,
            update = null;
          if (param.isNode) {
            type = 'int';
            name = this.getVarName(i);
            start = '0';
            end = param.build(builder, type);
            condition = '<';
          } else {
            type = param.type || 'int';
            name = param.name || this.getVarName(i);
            start = param.start;
            end = param.end;
            condition = param.condition;
            update = param.update;
            if (typeof start === 'number') start = builder.generateConst(type, start);else if (start && start.isNode) start = start.build(builder, type);
            if (typeof end === 'number') end = builder.generateConst(type, end);else if (end && end.isNode) end = end.build(builder, type);
            if (start !== undefined && end === undefined) {
              start = start + ' - 1';
              end = '0';
              condition = '>=';
            } else if (end !== undefined && start === undefined) {
              start = '0';
              condition = '<';
            }
            if (condition === undefined) {
              if (Number(start) > Number(end)) {
                condition = '>=';
              } else {
                condition = '<';
              }
            }
          }
          var internalParam = {
            start: start,
            end: end,
            condition: condition
          };

          //

          var startSnippet = internalParam.start;
          var endSnippet = internalParam.end;
          var declarationSnippet = '';
          var conditionalSnippet = '';
          var updateSnippet = '';
          if (!update) {
            if (type === 'int' || type === 'uint') {
              if (condition.includes('<')) update = '++';else update = '--';
            } else {
              if (condition.includes('<')) update = '+= 1.';else update = '-= 1.';
            }
          }
          declarationSnippet += builder.getVar(type, name) + ' = ' + startSnippet;
          conditionalSnippet += name + ' ' + condition + ' ' + endSnippet;
          updateSnippet += name + ' ' + update;
          var forSnippet = `for ( ${declarationSnippet}; ${conditionalSnippet}; ${updateSnippet} )`;
          builder.addFlowCode((i === 0 ? '\n' : '') + builder.tab + forSnippet + ' {\n\n').addFlowTab();
        }
        var stackSnippet = stackNode.build(builder, 'void');
        var returnsSnippet = properties.returnsNode ? properties.returnsNode.build(builder) : '';
        builder.removeFlowTab().addFlowCode('\n' + builder.tab + stackSnippet);
        for (var _i8 = 0, _l = this.params.length - 1; _i8 < _l; _i8++) {
          builder.addFlowCode((_i8 === 0 ? '' : builder.tab) + '}\n\n').removeFlowTab();
        }
        builder.addFlowTab();
        return returnsSnippet;
      }
    }], [{
      key: "type",
      get: function get() {
        return 'LoopNode';
      }
    }]);
  }(Node);
  /**
   * TSL function for creating a loop node.
   *
   * @function
   * @param {...Any} params - A list of parameters.
   * @returns {LoopNode}
   */
  var Loop = function Loop() {
    for (var _len16 = arguments.length, params = new Array(_len16), _key16 = 0; _key16 < _len16; _key16++) {
      params[_key16] = arguments[_key16];
    }
    return nodeObject(new LoopNode(nodeArray(params, 'int'))).append();
  };

  /**
   * TSL function for creating a `Continue()` expression.
   *
   * @function
   * @returns {ExpressionNode}
   */
  var Continue = function Continue() {
    return expression('continue').append();
  };

  /**
   * TSL function for creating a `Break()` expression.
   *
   * @function
   * @returns {ExpressionNode}
   */
  var Break = function Break() {
    return expression('break').append();
  };

  //

  var loop = function loop() {
    // @deprecated, r168

    console.warn('TSL.LoopNode: loop() has been renamed to Loop().');
    return Loop.apply(void 0, arguments);
  };

  /** @module MorphNode **/

  var _morphTextures = /*@__PURE__*/new WeakMap();
  var _morphVec4 = /*@__PURE__*/new (_$$_REQUIRE(_dependencyMap[1], "./three.core.js").Vector4)();
  var getMorph = /*@__PURE__*/Fn(function (_ref37) {
    var bufferMap = _ref37.bufferMap,
      influence = _ref37.influence,
      stride = _ref37.stride,
      width = _ref37.width,
      depth = _ref37.depth,
      offset = _ref37.offset;
    var texelIndex = int(vertexIndex).mul(stride).add(offset);
    var y = texelIndex.div(width);
    var x = texelIndex.sub(y.mul(width));
    var bufferAttrib = textureLoad(bufferMap, ivec2(x, y)).depth(depth);
    return bufferAttrib.mul(influence);
  });
  function getEntry(geometry) {
    var hasMorphPosition = geometry.morphAttributes.position !== undefined;
    var hasMorphNormals = geometry.morphAttributes.normal !== undefined;
    var hasMorphColors = geometry.morphAttributes.color !== undefined;

    // instead of using attributes, the WebGL 2 code path encodes morph targets
    // into an array of data textures. Each layer represents a single morph target.

    var morphAttribute = geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color;
    var morphTargetsCount = morphAttribute !== undefined ? morphAttribute.length : 0;
    var entry = _morphTextures.get(geometry);
    if (entry === undefined || entry.count !== morphTargetsCount) {
      if (entry !== undefined) entry.texture.dispose();
      var morphTargets = geometry.morphAttributes.position || [];
      var morphNormals = geometry.morphAttributes.normal || [];
      var morphColors = geometry.morphAttributes.color || [];
      var vertexDataCount = 0;
      if (hasMorphPosition === true) vertexDataCount = 1;
      if (hasMorphNormals === true) vertexDataCount = 2;
      if (hasMorphColors === true) vertexDataCount = 3;
      var width = geometry.attributes.position.count * vertexDataCount;
      var height = 1;
      var maxTextureSize = 4096; // @TODO: Use 'capabilities.maxTextureSize'

      if (width > maxTextureSize) {
        height = Math.ceil(width / maxTextureSize);
        width = maxTextureSize;
      }
      var _buffer3 = new Float32Array(width * height * 4 * morphTargetsCount);
      var bufferTexture = new (_$$_REQUIRE(_dependencyMap[1], "./three.core.js").DataArrayTexture)(_buffer3, width, height, morphTargetsCount);
      bufferTexture.type = _$$_REQUIRE(_dependencyMap[1], "./three.core.js").FloatType;
      bufferTexture.needsUpdate = true;

      // fill buffer

      var vertexDataStride = vertexDataCount * 4;
      for (var i = 0; i < morphTargetsCount; i++) {
        var morphTarget = morphTargets[i];
        var morphNormal = morphNormals[i];
        var morphColor = morphColors[i];
        var offset = width * height * 4 * i;
        for (var j = 0; j < morphTarget.count; j++) {
          var stride = j * vertexDataStride;
          if (hasMorphPosition === true) {
            _morphVec4.fromBufferAttribute(morphTarget, j);
            _buffer3[offset + stride + 0] = _morphVec4.x;
            _buffer3[offset + stride + 1] = _morphVec4.y;
            _buffer3[offset + stride + 2] = _morphVec4.z;
            _buffer3[offset + stride + 3] = 0;
          }
          if (hasMorphNormals === true) {
            _morphVec4.fromBufferAttribute(morphNormal, j);
            _buffer3[offset + stride + 4] = _morphVec4.x;
            _buffer3[offset + stride + 5] = _morphVec4.y;
            _buffer3[offset + stride + 6] = _morphVec4.z;
            _buffer3[offset + stride + 7] = 0;
          }
          if (hasMorphColors === true) {
            _morphVec4.fromBufferAttribute(morphColor, j);
            _buffer3[offset + stride + 8] = _morphVec4.x;
            _buffer3[offset + stride + 9] = _morphVec4.y;
            _buffer3[offset + stride + 10] = _morphVec4.z;
            _buffer3[offset + stride + 11] = morphColor.itemSize === 4 ? _morphVec4.w : 1;
          }
        }
      }
      entry = {
        count: morphTargetsCount,
        texture: bufferTexture,
        stride: vertexDataCount,
        size: new (_$$_REQUIRE(_dependencyMap[1], "./three.core.js").Vector2)(width, height)
      };
      _morphTextures.set(geometry, entry);
      function disposeTexture() {
        bufferTexture.dispose();
        _morphTextures.delete(geometry);
        geometry.removeEventListener('dispose', disposeTexture);
      }
      geometry.addEventListener('dispose', disposeTexture);
    }
    return entry;
  }

  /**
   * This node implements the vertex transformation shader logic which is required
   * for morph target animation.
   *
   * @augments Node
   */
  var MorphNode = exports.MorphNode = /*#__PURE__*/function (_Node31) {
    /**
     * Constructs a new morph node.
     *
     * @param {Mesh} mesh - The mesh holding the morph targets.
     */
    function MorphNode(mesh) {
      var _this60;
      (0, _classCallCheck2.default)(this, MorphNode);
      _this60 = _callSuper(this, MorphNode, ['void']);

      /**
       * The mesh holding the morph targets.
       *
       * @type {Mesh}
       */
      _this60.mesh = mesh;

      /**
       * A uniform node which represents the morph base influence value.
       *
       * @type {UniformNode<float>}
       */
      _this60.morphBaseInfluence = uniform(1);

      /**
       * The update type overwritten since morph nodes are updated per object.
       *
       * @type {String}
       */
      _this60.updateType = NodeUpdateType.OBJECT;
      return _this60;
    }

    /**
     * Setups the morph node by assigning the transformed vertex data to predefined node variables.
     *
     * @param {NodeBuilder} builder - The current node builder.
     */
    (0, _inherits2.default)(MorphNode, _Node31);
    return (0, _createClass2.default)(MorphNode, [{
      key: "setup",
      value: function setup(builder) {
        var _this61 = this;
        var geometry = builder.geometry;
        var hasMorphPosition = geometry.morphAttributes.position !== undefined;
        var hasMorphNormals = geometry.hasAttribute('normal') && geometry.morphAttributes.normal !== undefined;
        var morphAttribute = geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color;
        var morphTargetsCount = morphAttribute !== undefined ? morphAttribute.length : 0;

        // nodes

        var _getEntry = getEntry(geometry),
          bufferMap = _getEntry.texture,
          stride = _getEntry.stride,
          size = _getEntry.size;
        if (hasMorphPosition === true) positionLocal.mulAssign(this.morphBaseInfluence);
        if (hasMorphNormals === true) normalLocal.mulAssign(this.morphBaseInfluence);
        var width = int(size.width);
        Loop(morphTargetsCount, function (_ref38) {
          var i = _ref38.i;
          var influence = float(0).toVar();
          if (_this61.mesh.count > 1 && _this61.mesh.morphTexture !== null && _this61.mesh.morphTexture !== undefined) {
            influence.assign(textureLoad(_this61.mesh.morphTexture, ivec2(int(i).add(1), int(instanceIndex))).r);
          } else {
            influence.assign(reference('morphTargetInfluences', 'float').element(i).toVar());
          }
          if (hasMorphPosition === true) {
            positionLocal.addAssign(getMorph({
              bufferMap: bufferMap,
              influence: influence,
              stride: stride,
              width: width,
              depth: i,
              offset: int(0)
            }));
          }
          if (hasMorphNormals === true) {
            normalLocal.addAssign(getMorph({
              bufferMap: bufferMap,
              influence: influence,
              stride: stride,
              width: width,
              depth: i,
              offset: int(1)
            }));
          }
        });
      }

      /**
       * Updates the state of the morphed mesh by updating the base influence.
       *
       * @param {NodeFrame} frame - The current node frame.
       */
    }, {
      key: "update",
      value: function update(/*frame*/
      ) {
        var morphBaseInfluence = this.morphBaseInfluence;
        if (this.mesh.geometry.morphTargetsRelative) {
          morphBaseInfluence.value = 1;
        } else {
          morphBaseInfluence.value = 1 - this.mesh.morphTargetInfluences.reduce(function (a, b) {
            return a + b;
          }, 0);
        }
      }
    }], [{
      key: "type",
      get: function get() {
        return 'MorphNode';
      }
    }]);
  }(Node);
  /**
   * TSL function for creating a morph node.
   *
   * @function
   * @param {Mesh} mesh - The mesh holding the morph targets.
   * @returns {MorphNode}
   */
  var morphReference = /*@__PURE__*/nodeProxy(MorphNode);

  /**
   * Base class for lighting nodes.
   *
   * @augments Node
   */
  var LightingNode = exports.LightingNode = /*#__PURE__*/function (_Node32) {
    /**
     * Constructs a new lighting node.
     */
    function LightingNode() {
      var _this62;
      (0, _classCallCheck2.default)(this, LightingNode);
      _this62 = _callSuper(this, LightingNode, ['vec3']);

      /**
       * This flag can be used for type testing.
       *
       * @type {Boolean}
       * @readonly
       * @default true
       */
      _this62.isLightingNode = true;
      return _this62;
    }
    (0, _inherits2.default)(LightingNode, _Node32);
    return (0, _createClass2.default)(LightingNode, null, [{
      key: "type",
      get: function get() {
        return 'LightingNode';
      }
    }]);
  }(Node);
  /**
   * A generic class that can be used by nodes which contribute
   * ambient occlusion to the scene. E.g. an ambient occlusion map
   * node can be used as input for this module. Used in {@link NodeMaterial}.
   *
   * @augments LightingNode
   */
  var AONode = exports.AONode = /*#__PURE__*/function (_LightingNode) {
    /**
     * Constructs a new AO node.
     *
     * @param {Node<float>?} [aoNode=null] - The ambient occlusion node.
     */
    function AONode() {
      var _this63;
      var aoNode = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      (0, _classCallCheck2.default)(this, AONode);
      _this63 = _callSuper(this, AONode);

      /**
       * The ambient occlusion node.
       *
       * @type {Node<float>?}
       * @default null
       */
      _this63.aoNode = aoNode;
      return _this63;
    }
    (0, _inherits2.default)(AONode, _LightingNode);
    return (0, _createClass2.default)(AONode, [{
      key: "setup",
      value: function setup(builder) {
        builder.context.ambientOcclusion.mulAssign(this.aoNode);
      }
    }], [{
      key: "type",
      get: function get() {
        return 'AONode';
      }
    }]);
  }(LightingNode);
  /**
   * `LightingContextNode` represents an extension of the {@link module:ContextNode~ContextNode} module
   * by adding lighting specific context data. It represents the runtime context of
   * {@link LightsNode}.
   *
   * @augments ContextNode
   */
  var LightingContextNode = exports.LightingContextNode = /*#__PURE__*/function (_ContextNode) {
    /**
     * Constructs a new lighting context node.
     *
     * @param {LightsNode} node - The lights node.
     * @param {LightingModel?} [lightingModel=null] - The current lighting model.
     * @param {Node<vec3>?} [backdropNode=null] - A backdrop node.
     * @param {Node<float>?} [backdropAlphaNode=null] - A backdrop alpha node.
     */
    function LightingContextNode(node) {
      var _this64;
      var lightingModel = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      var backdropNode = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
      var backdropAlphaNode = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
      (0, _classCallCheck2.default)(this, LightingContextNode);
      _this64 = _callSuper(this, LightingContextNode, [node]);

      /**
       * The current lighting model.
       *
       * @type {LightingModel?}
       * @default null
       */
      _this64.lightingModel = lightingModel;

      /**
       * A backdrop node.
       *
       * @type {Node<vec3>?}
       * @default null
       */
      _this64.backdropNode = backdropNode;

      /**
       * A backdrop alpha node.
       *
       * @type {Node<float>?}
       * @default null
       */
      _this64.backdropAlphaNode = backdropAlphaNode;
      _this64._value = null;
      return _this64;
    }

    /**
     * Returns a lighting context object.
     *
     * @return {{
     * radiance: Node<vec3>,
     * irradiance: Node<vec3>,
     * iblIrradiance: Node<vec3>,
     * ambientOcclusion: Node<float>,
     * reflectedLight: {directDiffuse: Node<vec3>, directSpecular: Node<vec3>, indirectDiffuse: Node<vec3>, indirectSpecular: Node<vec3>},
     * backdrop: Node<vec3>,
     * backdropAlpha: Node<float>
     * }} The lighting context object.
     */
    (0, _inherits2.default)(LightingContextNode, _ContextNode);
    return (0, _createClass2.default)(LightingContextNode, [{
      key: "getContext",
      value: function getContext() {
        var backdropNode = this.backdropNode,
          backdropAlphaNode = this.backdropAlphaNode;
        var directDiffuse = vec3().toVar('directDiffuse'),
          directSpecular = vec3().toVar('directSpecular'),
          indirectDiffuse = vec3().toVar('indirectDiffuse'),
          indirectSpecular = vec3().toVar('indirectSpecular');
        var reflectedLight = {
          directDiffuse: directDiffuse,
          directSpecular: directSpecular,
          indirectDiffuse: indirectDiffuse,
          indirectSpecular: indirectSpecular
        };
        var context = {
          radiance: vec3().toVar('radiance'),
          irradiance: vec3().toVar('irradiance'),
          iblIrradiance: vec3().toVar('iblIrradiance'),
          ambientOcclusion: float(1).toVar('ambientOcclusion'),
          reflectedLight: reflectedLight,
          backdrop: backdropNode,
          backdropAlpha: backdropAlphaNode
        };
        return context;
      }
    }, {
      key: "setup",
      value: function setup(builder) {
        this.value = this._value || (this._value = this.getContext());
        this.value.lightingModel = this.lightingModel || builder.context.lightingModel;
        return _superPropGet(LightingContextNode, "setup", this, 3)([builder]);
      }
    }], [{
      key: "type",
      get: function get() {
        return 'LightingContextNode';
      }
    }]);
  }(ContextNode);
  var lightingContext = /*@__PURE__*/nodeProxy(LightingContextNode);

  /**
   * A generic class that can be used by nodes which contribute
   * irradiance to the scene. E.g. a light map node can be used
   * as input for this module. Used in {@link NodeMaterial}.
   *
   * @augments LightingNode
   */
  var IrradianceNode = exports.IrradianceNode = /*#__PURE__*/function (_LightingNode2) {
    /**
     * Constructs a new irradiance node.
     *
     * @param {Node<vec3>} node - A node contributing irradiance.
     */
    function IrradianceNode(node) {
      var _this65;
      (0, _classCallCheck2.default)(this, IrradianceNode);
      _this65 = _callSuper(this, IrradianceNode);

      /**
       * A node contributing irradiance.
       *
       * @type {Node<vec3>}
       */
      _this65.node = node;
      return _this65;
    }
    (0, _inherits2.default)(IrradianceNode, _LightingNode2);
    return (0, _createClass2.default)(IrradianceNode, [{
      key: "setup",
      value: function setup(builder) {
        builder.context.irradiance.addAssign(this.node);
      }
    }], [{
      key: "type",
      get: function get() {
        return 'IrradianceNode';
      }
    }]);
  }(LightingNode);
  /** @module ScreenNode **/
  var screenSizeVec, viewportVec;

  /**
   * This node provides a collection of screen related metrics.
   * Depending on {@link module:ScreenNode~ScreenNode#scope}, the nodes can represent
   * resolution or viewport data as well as fragment or uv coordinates.
   *
   * @augments Node
   */
  var ScreenNode = exports.ScreenNode = /*#__PURE__*/function (_Node33) {
    /**
     * Constructs a new screen node.
     *
     * @param {('coordinate'|'viewport'|'size'|'uv')} scope - The node's scope.
     */
    function ScreenNode(scope) {
      var _this66;
      (0, _classCallCheck2.default)(this, ScreenNode);
      _this66 = _callSuper(this, ScreenNode);

      /**
       * The node represents different metric depending on which scope is selected.
       *
       * - `ScreenNode.COORDINATE`: Window-relative coordinates of the current fragment according to WebGPU standards.
       * - `ScreenNode.VIEWPORT`: The current viewport defined as a four-dimensional vector.
       * - `ScreenNode.SIZE`: The dimensions of the current bound framebuffer.
       * - `ScreenNode.UV`: Normalized coordinates.
       *
       * @type {('coordinate'|'viewport'|'size'|'uv')}
       */
      _this66.scope = scope;

      /**
       * This flag can be used for type testing.
       *
       * @type {Boolean}
       * @readonly
       * @default true
       */
      _this66.isViewportNode = true;
      return _this66;
    }

    /**
     * This method is overwritten since the node type depends on the selected scope.
     *
     * @return {('vec2'|'vec4')} The node type.
     */
    (0, _inherits2.default)(ScreenNode, _Node33);
    return (0, _createClass2.default)(ScreenNode, [{
      key: "getNodeType",
      value: function getNodeType() {
        if (this.scope === ScreenNode.VIEWPORT) return 'vec4';else return 'vec2';
      }

      /**
       * This method is overwritten since the node's update type depends on the selected scope.
       *
       * @return {NodeUpdateType} The update type.
       */
    }, {
      key: "getUpdateType",
      value: function getUpdateType() {
        var updateType = NodeUpdateType.NONE;
        if (this.scope === ScreenNode.SIZE || this.scope === ScreenNode.VIEWPORT) {
          updateType = NodeUpdateType.RENDER;
        }
        this.updateType = updateType;
        return updateType;
      }

      /**
       * `ScreenNode` implements {@link Node#update} to retrieve viewport and size information
       * from the current renderer.
       *
       * @param {NodeFrame} frame - A reference to the current node frame.
       */
    }, {
      key: "update",
      value: function update(_ref39) {
        var renderer = _ref39.renderer;
        var renderTarget = renderer.getRenderTarget();
        if (this.scope === ScreenNode.VIEWPORT) {
          if (renderTarget !== null) {
            viewportVec.copy(renderTarget.viewport);
          } else {
            renderer.getViewport(viewportVec);
            viewportVec.multiplyScalar(renderer.getPixelRatio());
          }
        } else {
          if (renderTarget !== null) {
            screenSizeVec.width = renderTarget.width;
            screenSizeVec.height = renderTarget.height;
          } else {
            renderer.getDrawingBufferSize(screenSizeVec);
          }
        }
      }
    }, {
      key: "setup",
      value: function setup(/*builder*/
      ) {
        var scope = this.scope;
        var output = null;
        if (scope === ScreenNode.SIZE) {
          output = uniform(screenSizeVec || (screenSizeVec = new (_$$_REQUIRE(_dependencyMap[1], "./three.core.js").Vector2)()));
        } else if (scope === ScreenNode.VIEWPORT) {
          output = uniform(viewportVec || (viewportVec = new (_$$_REQUIRE(_dependencyMap[1], "./three.core.js").Vector4)()));
        } else {
          output = vec2(screenCoordinate.div(screenSize));
        }
        return output;
      }
    }, {
      key: "generate",
      value: function generate(builder) {
        if (this.scope === ScreenNode.COORDINATE) {
          var coord = builder.getFragCoord();
          if (builder.isFlipY()) {
            // follow webgpu standards

            var size = builder.getNodeProperties(screenSize).outputNode.build(builder);
            coord = `${builder.getType('vec2')}( ${coord}.x, ${size}.y - ${coord}.y )`;
          }
          return coord;
        }
        return _superPropGet(ScreenNode, "generate", this, 3)([builder]);
      }
    }], [{
      key: "type",
      get: function get() {
        return 'ScreenNode';
      }
    }]);
  }(Node);
  ScreenNode.COORDINATE = 'coordinate';
  ScreenNode.VIEWPORT = 'viewport';
  ScreenNode.SIZE = 'size';
  ScreenNode.UV = 'uv';

  // Screen

  /**
   * TSL object that represents normalized screen coordinates, unitless in `[0, 1]`.
   *
   * @type {ScreenNode<vec2>}
   */
  var screenUV = /*@__PURE__*/nodeImmutable(ScreenNode, ScreenNode.UV);

  /**
   * TSL object that represents the screen resolution in physical pixel units.
   *
   * @type {ScreenNode<vec2>}
   */
  var screenSize = /*@__PURE__*/nodeImmutable(ScreenNode, ScreenNode.SIZE);

  /**
   * TSL object that represents the current `x`/`y` pixel position on the screen in physical pixel units.
   *
   * @type {ScreenNode<vec2>}
   */
  var screenCoordinate = /*@__PURE__*/nodeImmutable(ScreenNode, ScreenNode.COORDINATE);

  // Viewport

  /**
   * TSL object that represents the viewport rectangle as `x`, `y`, `width` and `height` in physical pixel units.
   *
   * @type {ScreenNode<vec4>}
   */
  var viewport = /*@__PURE__*/nodeImmutable(ScreenNode, ScreenNode.VIEWPORT);

  /**
   * TSL object that represents the viewport resolution in physical pixel units.
   *
   * @type {ScreenNode<vec2>}
   */
  var viewportSize = viewport.zw;

  /**
   * TSL object that represents the current `x`/`y` pixel position on the viewport in physical pixel units.
   *
   * @type {ScreenNode<vec2>}
   */
  var viewportCoordinate = /*@__PURE__*/screenCoordinate.sub(viewport.xy);

  /**
   * TSL object that represents normalized viewport coordinates, unitless in `[0, 1]`.
   *
   * @type {ScreenNode<vec2>}
   */
  var viewportUV = /*@__PURE__*/viewportCoordinate.div(viewportSize);

  // Deprecated

  var viewportResolution = /*@__PURE__*/Fn(function () {
    // @deprecated, r169

    console.warn('TSL.ViewportNode: "viewportResolution" is deprecated. Use "screenSize" instead.');
    return screenSize;
  }, 'vec2').once()();
  var viewportTopLeft = /*@__PURE__*/Fn(function () {
    // @deprecated, r168

    console.warn('TSL.ViewportNode: "viewportTopLeft" is deprecated. Use "screenUV" instead.');
    return screenUV;
  }, 'vec2').once()();
  var viewportBottomLeft = /*@__PURE__*/Fn(function () {
    // @deprecated, r168

    console.warn('TSL.ViewportNode: "viewportBottomLeft" is deprecated. Use "screenUV.flipY()" instead.');
    return screenUV.flipY();
  }, 'vec2').once()();

  /** @module ViewportTextureNode **/

  var _size$4 = /*@__PURE__*/new (_$$_REQUIRE(_dependencyMap[1], "./three.core.js").Vector2)();

  /**
   * A special type of texture node which represents the data of the current viewport
   * as a texture. The module extracts data from the current bound framebuffer with
   * a copy operation so no extra render pass is required to produce the texture data
   * (which is good for performance). `ViewportTextureNode` can be used as an input for a
   * variety of effects like refractive or transmissive materials.
   *
   * @augments module:TextureNode~TextureNode
   */
  var ViewportTextureNode = exports.ViewportTextureNode = /*#__PURE__*/function (_TextureNode2) {
    /**
     * Constructs a new viewport texture node.
     *
     * @param {Node} [uvNode=screenUV] - The uv node.
     * @param {Node?} [levelNode=null] - The level node.
     * @param {Texture?} [framebufferTexture=null] - A framebuffer texture holding the viewport data. If not provided, a framebuffer texture is created automatically.
     */
    function ViewportTextureNode() {
      var _this67;
      var uvNode = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : screenUV;
      var levelNode = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      var framebufferTexture = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
      (0, _classCallCheck2.default)(this, ViewportTextureNode);
      if (framebufferTexture === null) {
        framebufferTexture = new (_$$_REQUIRE(_dependencyMap[1], "./three.core.js").FramebufferTexture)();
        framebufferTexture.minFilter = _$$_REQUIRE(_dependencyMap[1], "./three.core.js").LinearMipmapLinearFilter;
      }
      _this67 = _callSuper(this, ViewportTextureNode, [framebufferTexture, uvNode, levelNode]);

      /**
       * Whether to generate mipmaps or not.
       *
       * @type {Boolean}
       * @default false
       */
      _this67.generateMipmaps = false;

      /**
       * This flag can be used for type testing.
       *
       * @type {Boolean}
       * @readonly
       * @default true
       */
      _this67.isOutputTextureNode = true;

      /**
       * The `updateBeforeType` is set to `NodeUpdateType.FRAME` since the node renders the
       * scene once per frame in its {@link ViewportTextureNode#updateBefore} method.
       *
       * @type {String}
       * @default 'frame'
       */
      _this67.updateBeforeType = NodeUpdateType.FRAME;
      return _this67;
    }
    (0, _inherits2.default)(ViewportTextureNode, _TextureNode2);
    return (0, _createClass2.default)(ViewportTextureNode, [{
      key: "updateBefore",
      value: function updateBefore(frame) {
        var renderer = frame.renderer;
        renderer.getDrawingBufferSize(_size$4);

        //

        var framebufferTexture = this.value;
        if (framebufferTexture.image.width !== _size$4.width || framebufferTexture.image.height !== _size$4.height) {
          framebufferTexture.image.width = _size$4.width;
          framebufferTexture.image.height = _size$4.height;
          framebufferTexture.needsUpdate = true;
        }

        //

        var currentGenerateMipmaps = framebufferTexture.generateMipmaps;
        framebufferTexture.generateMipmaps = this.generateMipmaps;
        renderer.copyFramebufferToTexture(framebufferTexture);
        framebufferTexture.generateMipmaps = currentGenerateMipmaps;
      }
    }, {
      key: "clone",
      value: function clone() {
        var viewportTextureNode = new this.constructor(this.uvNode, this.levelNode, this.value);
        viewportTextureNode.generateMipmaps = this.generateMipmaps;
        return viewportTextureNode;
      }
    }], [{
      key: "type",
      get: function get() {
        return 'ViewportTextureNode';
      }
    }]);
  }(TextureNode);
  /**
   * TSL function for creating a viewport texture node.
   *
   * @function
   * @param {Node} [uvNode=screenUV] - The uv node.
   * @param {Node?} [levelNode=null] - The level node.
   * @param {Texture?} [framebufferTexture=null] - A framebuffer texture holding the viewport data. If not provided, a framebuffer texture is created automatically.
   * @returns {ViewportTextureNode}
   */
  var viewportTexture = /*@__PURE__*/nodeProxy(ViewportTextureNode);

  /**
   * TSL function for creating a viewport texture node with enabled mipmap generation.
   *
   * @function
   * @param {Node} [uvNode=screenUV] - The uv node.
   * @param {Node?} [levelNode=null] - The level node.
   * @param {Texture?} [framebufferTexture=null] - A framebuffer texture holding the viewport data. If not provided, a framebuffer texture is created automatically.
   * @returns {ViewportTextureNode}
   */
  var viewportMipTexture = /*@__PURE__*/nodeProxy(ViewportTextureNode, null, null, {
    generateMipmaps: true
  });

  /** @module ViewportDepthTextureNode **/

  var sharedDepthbuffer = null;

  /**
   * Represents the depth of the current viewport as a texture. This module
   * can be used in combination with viewport texture to achieve effects
   * that require depth evaluation.
   *
   * @augments module:ViewportTextureNode~ViewportTextureNode
   */
  var ViewportDepthTextureNode = exports.ViewportDepthTextureNode = /*#__PURE__*/function (_ViewportTextureNode) {
    /**
     * Constructs a new viewport depth texture node.
     *
     * @param {Node} [uvNode=screenUV] - The uv node.
     * @param {Node?} [levelNode=null] - The level node.
     */
    function ViewportDepthTextureNode() {
      var uvNode = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : screenUV;
      var levelNode = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      (0, _classCallCheck2.default)(this, ViewportDepthTextureNode);
      if (sharedDepthbuffer === null) {
        sharedDepthbuffer = new (_$$_REQUIRE(_dependencyMap[1], "./three.core.js").DepthTexture)();
      }
      return _callSuper(this, ViewportDepthTextureNode, [uvNode, levelNode, sharedDepthbuffer]);
    }
    (0, _inherits2.default)(ViewportDepthTextureNode, _ViewportTextureNode);
    return (0, _createClass2.default)(ViewportDepthTextureNode, null, [{
      key: "type",
      get: function get() {
        return 'ViewportDepthTextureNode';
      }
    }]);
  }(ViewportTextureNode);
  /**
   * TSL function for a viewport depth texture node.
   *
   * @function
   * @param {Node} [uvNode=screenUV] - The uv node.
   * @param {Node?} [levelNode=null] - The level node.
   * @returns {ViewportDepthTextureNode}
   */
  var viewportDepthTexture = /*@__PURE__*/nodeProxy(ViewportDepthTextureNode);

  /** @module ViewportDepthNode **/

  /**
   * This node offers a collection of features in context of the depth logic in the fragment shader.
   * Depending on {@link ViewportDepthNode#scope}, it can be used to define a depth value for the current
   * fragment or for depth evaluation purposes.
   *
   * @augments Node
   */
  var ViewportDepthNode = exports.ViewportDepthNode = /*#__PURE__*/function (_Node34) {
    /**
     * Constructs a new viewport depth node.
     *
     * @param {('depth'|'depthBase'|'linearDepth')} scope - The node's scope.
     * @param {Node?} [valueNode=null] - The value node.
     */
    function ViewportDepthNode(scope) {
      var _this68;
      var valueNode = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      (0, _classCallCheck2.default)(this, ViewportDepthNode);
      _this68 = _callSuper(this, ViewportDepthNode, ['float']);

      /**
       * The node behaves differently depending on which scope is selected.
       *
       * - `ViewportDepthNode.DEPTH_BASE`: Allows to define a value for the current fragment's depth.
       * - `ViewportDepthNode.DEPTH`: Represents the depth value for the current fragment (`valueNode` is ignored).
       * - `ViewportDepthNode.LINEAR_DEPTH`: Represents the linear (orthographic) depth value of the current fragment.
       * If a `valueNode` is set, the scope can be used to convert perspective depth data to linear data.
       *
       * @type {('depth'|'depthBase'|'linearDepth')}
       */
      _this68.scope = scope;

      /**
       * Can be used to define a custom depth value.
       * The property is ignored in the `ViewportDepthNode.DEPTH` scope.
       *
       * @type {Node?}
       * @default null
       */
      _this68.valueNode = valueNode;

      /**
       * This flag can be used for type testing.
       *
       * @type {Boolean}
       * @readonly
       * @default true
       */
      _this68.isViewportDepthNode = true;
      return _this68;
    }
    (0, _inherits2.default)(ViewportDepthNode, _Node34);
    return (0, _createClass2.default)(ViewportDepthNode, [{
      key: "generate",
      value: function generate(builder) {
        var scope = this.scope;
        if (scope === ViewportDepthNode.DEPTH_BASE) {
          return builder.getFragDepth();
        }
        return _superPropGet(ViewportDepthNode, "generate", this, 3)([builder]);
      }
    }, {
      key: "setup",
      value: function setup(_ref40) {
        var camera = _ref40.camera;
        var scope = this.scope;
        var value = this.valueNode;
        var node = null;
        if (scope === ViewportDepthNode.DEPTH_BASE) {
          if (value !== null) {
            node = depthBase().assign(value);
          }
        } else if (scope === ViewportDepthNode.DEPTH) {
          if (camera.isPerspectiveCamera) {
            node = viewZToPerspectiveDepth(positionView.z, cameraNear, cameraFar);
          } else {
            node = viewZToOrthographicDepth(positionView.z, cameraNear, cameraFar);
          }
        } else if (scope === ViewportDepthNode.LINEAR_DEPTH) {
          if (value !== null) {
            if (camera.isPerspectiveCamera) {
              var viewZ = perspectiveDepthToViewZ(value, cameraNear, cameraFar);
              node = viewZToOrthographicDepth(viewZ, cameraNear, cameraFar);
            } else {
              node = value;
            }
          } else {
            node = viewZToOrthographicDepth(positionView.z, cameraNear, cameraFar);
          }
        }
        return node;
      }
    }], [{
      key: "type",
      get: function get() {
        return 'ViewportDepthNode';
      }
    }]);
  }(Node);
  ViewportDepthNode.DEPTH_BASE = 'depthBase';
  ViewportDepthNode.DEPTH = 'depth';
  ViewportDepthNode.LINEAR_DEPTH = 'linearDepth';

  // NOTE: viewZ, the z-coordinate in camera space, is negative for points in front of the camera

  /**
   * TSL function for converting a viewZ value to an orthographic depth value.
   *
   * @function
   * @param {Node<float>} viewZ - The viewZ node.
   * @param {Node<float>} near - The camera's near value.
   * @param {Node<float>} far - The camera's far value.
   * @returns {Node<float>}
   */
  var viewZToOrthographicDepth = function viewZToOrthographicDepth(viewZ, near, far) {
    return viewZ.add(near).div(near.sub(far));
  };

  /**
   * TSL function for converting an orthographic depth value to a viewZ value.
   *
   * @function
   * @param {Node<float>} depth - The orthographic depth.
   * @param {Node<float>} near - The camera's near value.
   * @param {Node<float>} far - The camera's far value.
   * @returns {Node<float>}
   */
  var orthographicDepthToViewZ = function orthographicDepthToViewZ(depth, near, far) {
    return near.sub(far).mul(depth).sub(near);
  };

  /**
   * TSL function for converting a viewZ value to a perspective depth value.
   *
   * Note: {link https://twitter.com/gonnavis/status/1377183786949959682}.
   *
   * @function
   * @param {Node<float>} viewZ - The viewZ node.
   * @param {Node<float>} near - The camera's near value.
   * @param {Node<float>} far - The camera's far value.
   * @returns {Node<float>}
   */
  var viewZToPerspectiveDepth = function viewZToPerspectiveDepth(viewZ, near, far) {
    return near.add(viewZ).mul(far).div(far.sub(near).mul(viewZ));
  };

  /**
   * TSL function for converting a perspective depth value to a viewZ value.
   *
   * @function
   * @param {Node<float>} depth - The perspective depth.
   * @param {Node<float>} near - The camera's near value.
   * @param {Node<float>} far - The camera's far value.
   * @returns {Node<float>}
   */
  var perspectiveDepthToViewZ = function perspectiveDepthToViewZ(depth, near, far) {
    return near.mul(far).div(far.sub(near).mul(depth).sub(far));
  };

  /**
   * TSL function for converting a viewZ value to a logarithmic depth value.
   *
   * @function
   * @param {Node<float>} viewZ - The viewZ node.
   * @param {Node<float>} near - The camera's near value.
   * @param {Node<float>} far - The camera's far value.
   * @returns {Node<float>}
   */
  var viewZToLogarithmicDepth = function viewZToLogarithmicDepth(viewZ, near, far) {
    // NOTE: viewZ must be negative--see explanation at the end of this comment block.
    // The final logarithmic depth formula used here is adapted from one described in an
    // article by Thatcher Ulrich (see http://tulrich.com/geekstuff/log_depth_buffer.txt),
    // which was an improvement upon an earlier formula one described in an
    // Outerra article (https://outerra.blogspot.com/2009/08/logarithmic-z-buffer.html).
    // Ulrich's formula is the following:
    //     z = K * log( w / cameraNear ) / log( cameraFar / cameraNear )
    //     where K = 2^k - 1, and k is the number of bits in the depth buffer.
    // The Outerra variant ignored the camera near plane (it assumed it was 0) and instead
    // opted for a "C-constant" for resolution adjustment of objects near the camera.
    // Outerra states: "Notice that the 'C' variant doesnt use a near plane distance, it has it
    // set at 0" (quote from https://outerra.blogspot.com/2012/11/maximizing-depth-buffer-range-and.html).
    // Ulrich's variant has the benefit of constant relative precision over the whole near-far range.
    // It was debated here whether Outerra's "C-constant" or Ulrich's "near plane" variant should
    // be used, and ultimately Ulrich's "near plane" version was chosen.
    // Outerra eventually made another improvement to their original "C-constant" variant,
    // but it still does not incorporate the camera near plane (for this version,
    // see https://outerra.blogspot.com/2013/07/logarithmic-depth-buffer-optimizations.html).
    // Here we make 4 changes to Ulrich's formula:
    // 1. Clamp the camera near plane so we don't divide by 0.
    // 2. Use log2 instead of log to avoid an extra multiply (shaders implement log using log2).
    // 3. Assume K is 1 (K = maximum value in depth buffer; see Ulrich's formula above).
    // 4. To maintain consistency with the functions "viewZToOrthographicDepth" and "viewZToPerspectiveDepth",
    //    we modify the formula here to use 'viewZ' instead of 'w'. The other functions expect a negative viewZ,
    //    so we do the same here, hence the 'viewZ.negate()' call.
    // For visual representation of this depth curve, see https://www.desmos.com/calculator/uyqk0vex1u
    near = near.max(1e-6).toVar();
    var numerator = log2(viewZ.negate().div(near));
    var denominator = log2(far.div(near));
    return numerator.div(denominator);
  };

  /**
   * TSL function for converting a logarithmic depth value to a viewZ value.
   *
   * @function
   * @param {Node<float>} depth - The logarithmic depth.
   * @param {Node<float>} near - The camera's near value.
   * @param {Node<float>} far - The camera's far value.
   * @returns {Node<float>}
   */
  var logarithmicDepthToViewZ = function logarithmicDepthToViewZ(depth, near, far) {
    // NOTE: we add a 'negate()' call to the return value here to maintain consistency with
    // the functions "orthographicDepthToViewZ" and "perspectiveDepthToViewZ" (they return
    // a negative viewZ).
    var exponent = depth.mul(log(far.div(near)));
    return float(Math.E).pow(exponent).mul(near).negate();
  };

  /**
   * TSL function for defining a value for the current fragment's depth.
   *
   * @function
   * @param {Node<float>} value - The depth value to set.
   * @returns {ViewportDepthNode<float>}
   */
  var depthBase = /*@__PURE__*/nodeProxy(ViewportDepthNode, ViewportDepthNode.DEPTH_BASE);

  /**
   * TSL object that represents the depth value for the current fragment.
   *
   * @type {ViewportDepthNode}
   */
  var depth = /*@__PURE__*/nodeImmutable(ViewportDepthNode, ViewportDepthNode.DEPTH);

  /**
   * TSL function for converting a perspective depth value to linear depth.
   *
   * @function
   * @param {Node<float>} value - The perspective depth.
   * @returns {ViewportDepthNode<float>}
   */
  var linearDepth = /*@__PURE__*/nodeProxy(ViewportDepthNode, ViewportDepthNode.LINEAR_DEPTH);

  /**
   * TSL object that represents the linear (orthographic) depth value of the current fragment
   *
   * @type {ViewportDepthNode}
   */
  var viewportLinearDepth = /*@__PURE__*/linearDepth(viewportDepthTexture());
  depth.assign = function (value) {
    return depthBase(value);
  };

  /** @module BuiltinNode **/

  /**
   * The node allows to set values for built-in shader variables. That is
   * required for features like hardware-accelerated vertex clipping.
   *
   * @augments Node
   */
  var BuiltinNode = /*#__PURE__*/function (_Node35) {
    /**
     * Constructs a new builtin node.
     *
     * @param {String} name - The name of the built-in shader variable.
     */
    function BuiltinNode(name) {
      var _this69;
      (0, _classCallCheck2.default)(this, BuiltinNode);
      _this69 = _callSuper(this, BuiltinNode, ['float']);

      /**
       * The name of the built-in shader variable.
       *
       * @type {String}
       */
      _this69.name = name;

      /**
       * This flag can be used for type testing.
       *
       * @type {Boolean}
       * @readonly
       * @default true
       */
      _this69.isBuiltinNode = true;
      return _this69;
    }

    /**
     * Generates the code snippet of the builtin node.
     *
     * @param {NodeBuilder} builder - The current node builder.
     * @return {String} The generated code snippet.
     */
    (0, _inherits2.default)(BuiltinNode, _Node35);
    return (0, _createClass2.default)(BuiltinNode, [{
      key: "generate",
      value: function generate(/* builder */
      ) {
        return this.name;
      }
    }]);
  }(Node);
  /**
   * TSL function for creating a builtin node.
   *
   * @function
   * @param {String} name - The name of the built-in shader variable.
   * @returns {BuiltinNode}
   */
  var builtin = nodeProxy(BuiltinNode);

  /** @module ClippingNode **/

  /**
   * ```
   * This node is used in {@link NodeMaterial} to setup the clipping
   * which can happen hardware-accelerated (if supported) and optionally
   * use alpha-to-coverage for anti-aliasing clipped edges.
   * ```
   * @augments Node
   */
  var ClippingNode = /*#__PURE__*/function (_Node36) {
    /**
     * Constructs a new clipping node.
     *
     * @param {('default'|'hardware'|'alphaToCoverage')} [scope='default'] - The node's scope. Similar to other nodes,
     * the selected scope influences the behavior of the node and what type of code is generated.
     */
    function ClippingNode() {
      var _this70;
      var scope = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : ClippingNode.DEFAULT;
      (0, _classCallCheck2.default)(this, ClippingNode);
      _this70 = _callSuper(this, ClippingNode);

      /**
       * The node's scope. Similar to other nodes, the selected scope influences
       * the behavior of the node and what type of code is generated.
       *
       * @type {('default'|'hardware'|'alphaToCoverage')}
       */
      _this70.scope = scope;
      return _this70;
    }

    /**
     * Setups the node depending on the selected scope.
     *
     * @param {NodeBuilder} builder - The current node builder.
     * @return {Node} The result node.
     */
    (0, _inherits2.default)(ClippingNode, _Node36);
    return (0, _createClass2.default)(ClippingNode, [{
      key: "setup",
      value: function setup(builder) {
        _superPropGet(ClippingNode, "setup", this, 3)([builder]);
        var clippingContext = builder.clippingContext;
        var intersectionPlanes = clippingContext.intersectionPlanes,
          unionPlanes = clippingContext.unionPlanes;
        this.hardwareClipping = builder.material.hardwareClipping;
        if (this.scope === ClippingNode.ALPHA_TO_COVERAGE) {
          return this.setupAlphaToCoverage(intersectionPlanes, unionPlanes);
        } else if (this.scope === ClippingNode.HARDWARE) {
          return this.setupHardwareClipping(unionPlanes, builder);
        } else {
          return this.setupDefault(intersectionPlanes, unionPlanes);
        }
      }

      /**
       * Setups alpha to coverage.
       *
       * @param {Array<Vector4>} intersectionPlanes - The intersection planes.
       * @param {Array<Vector4>} unionPlanes - The union planes.
       * @return {Node} The result node.
       */
    }, {
      key: "setupAlphaToCoverage",
      value: function setupAlphaToCoverage(intersectionPlanes, unionPlanes) {
        var _this71 = this;
        return Fn(function () {
          var distanceToPlane = float().toVar('distanceToPlane');
          var distanceGradient = float().toVar('distanceToGradient');
          var clipOpacity = float(1).toVar('clipOpacity');
          var numUnionPlanes = unionPlanes.length;
          if (_this71.hardwareClipping === false && numUnionPlanes > 0) {
            var clippingPlanes = uniformArray(unionPlanes);
            Loop(numUnionPlanes, function (_ref41) {
              var i = _ref41.i;
              var plane = clippingPlanes.element(i);
              distanceToPlane.assign(positionView.dot(plane.xyz).negate().add(plane.w));
              distanceGradient.assign(distanceToPlane.fwidth().div(2.0));
              clipOpacity.mulAssign(smoothstep(distanceGradient.negate(), distanceGradient, distanceToPlane));
            });
          }
          var numIntersectionPlanes = intersectionPlanes.length;
          if (numIntersectionPlanes > 0) {
            var _clippingPlanes = uniformArray(intersectionPlanes);
            var intersectionClipOpacity = float(1).toVar('intersectionClipOpacity');
            Loop(numIntersectionPlanes, function (_ref42) {
              var i = _ref42.i;
              var plane = _clippingPlanes.element(i);
              distanceToPlane.assign(positionView.dot(plane.xyz).negate().add(plane.w));
              distanceGradient.assign(distanceToPlane.fwidth().div(2.0));
              intersectionClipOpacity.mulAssign(smoothstep(distanceGradient.negate(), distanceGradient, distanceToPlane).oneMinus());
            });
            clipOpacity.mulAssign(intersectionClipOpacity.oneMinus());
          }
          diffuseColor.a.mulAssign(clipOpacity);
          diffuseColor.a.equal(0.0).discard();
        })();
      }

      /**
       * Setups the default clipping.
       *
       * @param {Array<Vector4>} intersectionPlanes - The intersection planes.
       * @param {Array<Vector4>} unionPlanes - The union planes.
       * @return {Node} The result node.
       */
    }, {
      key: "setupDefault",
      value: function setupDefault(intersectionPlanes, unionPlanes) {
        var _this72 = this;
        return Fn(function () {
          var numUnionPlanes = unionPlanes.length;
          if (_this72.hardwareClipping === false && numUnionPlanes > 0) {
            var clippingPlanes = uniformArray(unionPlanes);
            Loop(numUnionPlanes, function (_ref43) {
              var i = _ref43.i;
              var plane = clippingPlanes.element(i);
              positionView.dot(plane.xyz).greaterThan(plane.w).discard();
            });
          }
          var numIntersectionPlanes = intersectionPlanes.length;
          if (numIntersectionPlanes > 0) {
            var _clippingPlanes2 = uniformArray(intersectionPlanes);
            var clipped = bool(true).toVar('clipped');
            Loop(numIntersectionPlanes, function (_ref44) {
              var i = _ref44.i;
              var plane = _clippingPlanes2.element(i);
              clipped.assign(positionView.dot(plane.xyz).greaterThan(plane.w).and(clipped));
            });
            clipped.discard();
          }
        })();
      }

      /**
       * Setups hardware clipping.
       *
       * @param {Array<Vector4>} unionPlanes - The union planes.
       * @param {NodeBuilder} builder - The current node builder.
       * @return {Node} The result node.
       */
    }, {
      key: "setupHardwareClipping",
      value: function setupHardwareClipping(unionPlanes, builder) {
        var numUnionPlanes = unionPlanes.length;
        builder.enableHardwareClipping(numUnionPlanes);
        return Fn(function () {
          var clippingPlanes = uniformArray(unionPlanes);
          var hw_clip_distances = builtin(builder.getClipDistance());
          Loop(numUnionPlanes, function (_ref45) {
            var i = _ref45.i;
            var plane = clippingPlanes.element(i);
            var distance = positionView.dot(plane.xyz).sub(plane.w).negate();
            hw_clip_distances.element(i).assign(distance);
          });
        })();
      }
    }], [{
      key: "type",
      get: function get() {
        return 'ClippingNode';
      }
    }]);
  }(Node);
  ClippingNode.ALPHA_TO_COVERAGE = 'alphaToCoverage';
  ClippingNode.DEFAULT = 'default';
  ClippingNode.HARDWARE = 'hardware';

  /**
   * TSL function for setting up the default clipping logic.
   *
   * @function
   * @returns {ClippingNode}
   */
  var clipping = function clipping() {
    return nodeObject(new ClippingNode());
  };

  /**
   * TSL function for setting up alpha to coverage.
   *
   * @function
   * @returns {ClippingNode}
   */
  var clippingAlpha = function clippingAlpha() {
    return nodeObject(new ClippingNode(ClippingNode.ALPHA_TO_COVERAGE));
  };

  /**
   * TSL function for setting up hardware-based clipping.
   *
   * @function
   * @returns {ClippingNode}
   */
  var hardwareClipping = function hardwareClipping() {
    return nodeObject(new ClippingNode(ClippingNode.HARDWARE));
  };

  // See: https://casual-effects.com/research/Wyman2017Hashed/index.html

  var ALPHA_HASH_SCALE = 0.05; // Derived from trials only, and may be changed.

  var hash2D = /*@__PURE__*/Fn(function (_ref46) {
    var _ref47 = (0, _slicedToArray2.default)(_ref46, 1),
      value = _ref47[0];
    return fract(mul(1.0e4, sin(mul(17.0, value.x).add(mul(0.1, value.y)))).mul(add(0.1, abs(sin(mul(13.0, value.y).add(value.x))))));
  });
  var hash3D = /*@__PURE__*/Fn(function (_ref48) {
    var _ref49 = (0, _slicedToArray2.default)(_ref48, 1),
      value = _ref49[0];
    return hash2D(vec2(hash2D(value.xy), value.z));
  });
  var getAlphaHashThreshold = /*@__PURE__*/Fn(function (_ref50) {
    var _ref51 = (0, _slicedToArray2.default)(_ref50, 1),
      position = _ref51[0];
    // Find the discretized derivatives of our coordinates
    var maxDeriv = max$1(length(dFdx(position.xyz)), length(dFdy(position.xyz)));
    var pixScale = float(1).div(float(ALPHA_HASH_SCALE).mul(maxDeriv)).toVar('pixScale');

    // Find two nearest log-discretized noise scales
    var pixScales = vec2(exp2(floor(log2(pixScale))), exp2(ceil(log2(pixScale))));

    // Compute alpha thresholds at our two noise scales
    var alpha = vec2(hash3D(floor(pixScales.x.mul(position.xyz))), hash3D(floor(pixScales.y.mul(position.xyz))));

    // Factor to interpolate lerp with
    var lerpFactor = fract(log2(pixScale));

    // Interpolate alpha threshold from noise at two scales
    var x = add(mul(lerpFactor.oneMinus(), alpha.x), mul(lerpFactor, alpha.y));

    // Pass into CDF to compute uniformly distrib threshold
    var a = min$1(lerpFactor, lerpFactor.oneMinus());
    var cases = vec3(x.mul(x).div(mul(2.0, a).mul(sub(1.0, a))), x.sub(mul(0.5, a)).div(sub(1.0, a)), sub(1.0, sub(1.0, x).mul(sub(1.0, x)).div(mul(2.0, a).mul(sub(1.0, a)))));

    // Find our final, uniformly distributed alpha threshold ()
    var threshold = x.lessThan(a.oneMinus()).select(x.lessThan(a).select(cases.x, cases.y), cases.z);

    // Avoids  == 0. Could also do  =1-
    return clamp(threshold, 1.0e-6, 1.0);
  }).setLayout({
    name: 'getAlphaHashThreshold',
    type: 'float',
    inputs: [{
      name: 'position',
      type: 'vec3'
    }]
  });

  /**
   * Base class for all node materials.
   *
   * @augments Material
   */
  var NodeMaterial = exports.NodeMaterial = /*#__PURE__*/function (_Material) {
    /**
     * Constructs a new node material.
     */
    function NodeMaterial() {
      var _this73;
      (0, _classCallCheck2.default)(this, NodeMaterial);
      _this73 = _callSuper(this, NodeMaterial);

      /**
       * This flag can be used for type testing.
       *
       * @type {Boolean}
       * @readonly
       * @default true
       */
      _this73.isNodeMaterial = true;

      /**
       * Whether this material is affected by fog or not.
       *
       * @type {Boolean}
       * @default true
       */
      _this73.fog = true;

      /**
       * Whether this material is affected by lights or not.
       *
       * @type {Boolean}
       * @default false
       */
      _this73.lights = false;

      /**
       * Whether this material uses hardware clipping or not.
       * This property is managed by the engine and should not be
       * modified by apps.
       *
       * @type {Boolean}
       * @default false
       */
      _this73.hardwareClipping = false;

      /**
       * Node materials which set their `lights` property to `true`
       * are affected by all lights of the scene. Sometimes selective
       * lighting is wanted which means only _some_ lights in the scene
       * affect a material. This can be achieved by creating an instance
       * of {@link module:LightsNode~LightsNode} with a list of selective
       * lights and assign the node to this property.
       *
       * ```js
       * const customLightsNode = lights( [ light1, light2 ] );
       * material.lightsNode = customLightsNode;
       * ```
       *
       * @type {LightsNode?}
       * @default null
       */
      _this73.lightsNode = null;

      /**
       * The environment of node materials can be defined by an environment
       * map assigned to the `envMap` property or by `Scene.environment`
       * if the node material is a PBR material. This node property allows to overwrite
       * the default behavior and define the environment with a custom node.
       *
       * ```js
       * material.envNode = pmremTexture( renderTarget.texture );
       * ```
       *
       * @type {Node<vec3>?}
       * @default null
       */
      _this73.envNode = null;

      /**
       * The lighting of node materials might be influenced by ambient occlusion.
       * The default AO is inferred from an ambient occlusion map assigned to `aoMap`
       * and the respective `aoMapIntensity`. This node property allows to overwrite
       * the default and define the ambient occlusion with a custom node instead.
       *
       * If you don't want to overwrite the diffuse color but modify the existing
       * values instead, use {@link module:MaterialNode.materialAO}.
       *
       * @type {Node<float>?}
       * @default null
       */
      _this73.aoNode = null;

      /**
       * The diffuse color of node materials is by default inferred from the
       * `color` and `map` properties. This node property allows to overwrite the default
       * and define the diffuse color with a node instead.
       *
       * ```js
       * material.colorNode = color( 0xff0000 ); // define red color
       * ```
       *
       * If you don't want to overwrite the diffuse color but modify the existing
       * values instead, use {@link module:MaterialNode.materialColor}.
       *
       * ```js
       * material.colorNode = materialColor.mul( color( 0xff0000 ) ); // give diffuse colors a red tint
       * ```
       *
       * @type {Node<vec3>?}
       * @default null
       */
      _this73.colorNode = null;

      /**
       * The normals of node materials are by default inferred from the `normalMap`/`normalScale`
       * or `bumpMap`/`bumpScale` properties. This node property allows to overwrite the default
       * and define the normals with a node instead.
       *
       * If you don't want to overwrite the normals but modify the existing values instead,
       * use {@link module:MaterialNode.materialNormal}.
       *
       * @type {Node<vec3>?}
       * @default null
       */
      _this73.normalNode = null;

      /**
       * The opacity of node materials is by default inferred from the `opacity`
       * and `alphaMap` properties. This node property allows to overwrite the default
       * and define the opacity with a node instead.
       *
       * If you don't want to overwrite the normals but modify the existing
       * value instead, use {@link module:MaterialNode.materialOpacity}.
       *
       * @type {Node<float>?}
       * @default null
       */
      _this73.opacityNode = null;

      /**
       * This node can be used to to implement a variety of filter-like effects. The idea is
       * to store the current rendering into a texture e.g. via `viewportSharedTexture()`, use it
       * to create an arbitrary effect and then assign the node composition to this property.
       * Everything behind the object using this material will now be affected by a filter.
       *
       * ```js
       * const material = new NodeMaterial()
       * material.transparent = true;
       *
       * // everything behind the object will be monochromatic
       * material.backdropNode = viewportSharedTexture().rgb.saturation( 0 );
       * ```
       *
       * Backdrop computations are part of the lighting so only lit materials can use this property.
       *
       * @type {Node<vec3>?}
       * @default null
       */
      _this73.backdropNode = null;

      /**
       * This node allows to modulate the influence of `backdropNode` to the outgoing light.
       *
       * @type {Node<float>?}
       * @default null
       */
      _this73.backdropAlphaNode = null;

      /**
       * The alpha test of node materials is by default inferred from the `alphaTest`
       * property. This node property allows to overwrite the default and define the
       * alpha test with a node instead.
       *
       * If you don't want to overwrite the alpha test but modify the existing
       * value instead, use {@link module:MaterialNode.materialAlphaTest}.
       *
       * @type {Node<float>?}
       * @default null
       */
      _this73.alphaTestNode = null;

      /**
       * The local vertex positions are computed based on multiple factors like the
       * attribute data, morphing or skinning. This node property allows to overwrite
       * the default and define local vertex positions with nodes instead.
       *
       * If you don't want to overwrite the vertex positions but modify the existing
       * values instead, use {@link module:Position.positionLocal}.
       *
       *```js
       * material.positionNode = positionLocal.add( displace );
       * ```
       *
       * @type {Node<vec3>?}
       * @default null
       */
      _this73.positionNode = null;

      /**
       * This node property is intended for logic which modifies geometry data once or per animation step.
       * Apps usually place such logic randomly in initialization routines or in the animation loop.
       * `geometryNode` is intended as a dedicated API so there is an intended spot where goemetry modiciations
       * can be implemented.
       *
       * The idea is to assign a `Fn` definition that holds the geometry modification logic. A typical example
       * would be a GPU based particle system that provides a node material for usage on app level. The particle
       * simulation would be implemented as compute shaders and managed inside a `Fn` function. This function is
       * eventually assigned to `geometryNode`.
       *
       * @type {Function}
       * @default null
       */
      _this73.geometryNode = null;

      /**
       * Allows to overwrite depth values in the fragment shader.
       *
       * @type {Node<float>?}
       * @default null
       */
      _this73.depthNode = null;

      /**
       * Allows to overwrite the position used for shadow map rendering which
       * is by default {@link module:Position.positionWorld}, the vertex position
       * in world space.
       *
       * @type {Node<float>?}
       * @default null
       */
      _this73.shadowPositionNode = null;

      /**
       * This node can be used to influence how an object using this node material
       * receive shadows.
       *
       * ```js
       * const totalShadows = float( 1 ).toVar();
       * material.receivedShadowNode = Fn( ( [ shadow ] ) => {
       * 	totalShadows.mulAssign( shadow );
       * 	//return float( 1 ); // bypass received shadows
       * 	return shadow.mix( color( 0xff0000 ), 1 ); // modify shadow color
       * } );
       *
       * @type {Node<vec4>?}
       * @default null
       */
      _this73.receivedShadowNode = null;

      /**
       * This node can be used to influence how an object using this node material
       * casts shadows. To apply a color to shadows, you can simply do:
       *
       * ```js
       * material.castShadowNode = vec4( 1, 0, 0, 1 );
       * ```
       *
       * Which can be nice to fake colored shadows of semi-transparent objects. It
       * is also common to use the property with `Fn` function so checks are performed
       * per fragment.
       *
       * ```js
       * materialCustomShadow.castShadowNode = Fn( () => {
       * 	hash( vertexIndex ).greaterThan( 0.5 ).discard();
       * 	return materialColor;
       * } )();
       *  ```
       *
       * @type {Node<vec4>?}
       * @default null
       */
      _this73.castShadowNode = null;

      /**
       * This node can be used to define the final output of the material.
       *
       * TODO: Explain the differences to `fragmentNode`.
       *
       * @type {Node<vec4>?}
       * @default null
       */
      _this73.outputNode = null;

      /**
       * MRT configuration is done on renderer or pass level. This node allows to
       * overwrite what values are written into MRT targets on material level. This
       * can be useful for implementing selective FX features that should only affect
       * specific objects.
       *
       * @type {MRTNode?}
       * @default null
       */
      _this73.mrtNode = null;

      /**
       * This node property can be used if you need complete freedom in implementing
       * the fragment shader. Assigning a node will replace the built-in material
       * logic used in the fragment stage.
       *
       * @type {Node<vec4>?}
       * @default null
       */
      _this73.fragmentNode = null;

      /**
       * This node property can be used if you need complete freedom in implementing
       * the vertex shader. Assigning a node will replace the built-in material logic
       * used in the vertex stage.
       *
       * @type {Node<vec4>?}
       * @default null
       */
      _this73.vertexNode = null;
      return _this73;
    }

    /**
     * Allows to define a custom cache key that influence the material key computation
     * for render objects.
     *
     * @return {String} The custom cache key.
     */
    (0, _inherits2.default)(NodeMaterial, _Material);
    return (0, _createClass2.default)(NodeMaterial, [{
      key: "type",
      get:
      /**
       * Represents the type of the node material.
       *
       * @type {String}
       */
      function get() {
        return this.constructor.type;
      },
      set: function set(_value) {/* */}
    }, {
      key: "customProgramCacheKey",
      value: function customProgramCacheKey() {
        return this.type + getCacheKey$1(this);
      }

      /**
       * Builds this material with the given node builder.
       *
       * @param {NodeBuilder} builder - The current node builder.
       */
    }, {
      key: "build",
      value: function build(builder) {
        this.setup(builder);
      }

      /**
       * Setups a node material observer with the given builder.
       *
       * @param {NodeBuilder} builder - The current node builder.
       * @return {NodeMaterialObserver} The node material observer.
       */
    }, {
      key: "setupObserver",
      value: function setupObserver(builder) {
        return new NodeMaterialObserver(builder);
      }

      /**
       * Setups the vertex and fragment stage of this node material.
       *
       * @param {NodeBuilder} builder - The current node builder.
       */
    }, {
      key: "setup",
      value: function setup(builder) {
        var _this74 = this;
        builder.context.setupNormal = function () {
          return _this74.setupNormal(builder);
        };
        builder.context.setupPositionView = function () {
          return _this74.setupPositionView(builder);
        };
        builder.context.setupModelViewProjection = function () {
          return _this74.setupModelViewProjection(builder);
        };
        var renderer = builder.renderer;
        var renderTarget = renderer.getRenderTarget();

        // < VERTEX STAGE >

        builder.addStack();
        var vertexNode = this.vertexNode || this.setupVertex(builder);
        builder.stack.outputNode = vertexNode;
        this.setupHardwareClipping(builder);
        if (this.geometryNode !== null) {
          builder.stack.outputNode = builder.stack.outputNode.bypass(this.geometryNode);
        }
        builder.addFlow('vertex', builder.removeStack());

        // < FRAGMENT STAGE >

        builder.addStack();
        var resultNode;
        var clippingNode = this.setupClipping(builder);
        if (this.depthWrite === true || this.depthTest === true) {
          // only write depth if depth buffer is configured

          if (renderTarget !== null) {
            if (renderTarget.depthBuffer === true) this.setupDepth(builder);
          } else {
            if (renderer.depth === true) this.setupDepth(builder);
          }
        }
        if (this.fragmentNode === null) {
          this.setupDiffuseColor(builder);
          this.setupVariants(builder);
          var outgoingLightNode = this.setupLighting(builder);
          if (clippingNode !== null) builder.stack.add(clippingNode);

          // force unsigned floats - useful for RenderTargets

          var basicOutput = vec4(outgoingLightNode, diffuseColor.a).max(0);
          resultNode = this.setupOutput(builder, basicOutput);

          // OUTPUT NODE

          output.assign(resultNode);

          //

          if (this.outputNode !== null) resultNode = this.outputNode;

          // MRT

          if (renderTarget !== null) {
            var _mrt = renderer.getMRT();
            var materialMRT = this.mrtNode;
            if (_mrt !== null) {
              resultNode = _mrt;
              if (materialMRT !== null) {
                resultNode = _mrt.merge(materialMRT);
              }
            } else if (materialMRT !== null) {
              resultNode = materialMRT;
            }
          }
        } else {
          var fragmentNode = this.fragmentNode;
          if (fragmentNode.isOutputStructNode !== true) {
            fragmentNode = vec4(fragmentNode);
          }
          resultNode = this.setupOutput(builder, fragmentNode);
        }
        builder.stack.outputNode = resultNode;
        builder.addFlow('fragment', builder.removeStack());

        // < MONITOR >

        builder.monitor = this.setupObserver(builder);
      }

      /**
       * Setups the clipping node.
       *
       * @param {NodeBuilder} builder - The current node builder.
       * @return {ClippingNode} The clipping node.
       */
    }, {
      key: "setupClipping",
      value: function setupClipping(builder) {
        if (builder.clippingContext === null) return null;
        var _builder$clippingCont = builder.clippingContext,
          unionPlanes = _builder$clippingCont.unionPlanes,
          intersectionPlanes = _builder$clippingCont.intersectionPlanes;
        var result = null;
        if (unionPlanes.length > 0 || intersectionPlanes.length > 0) {
          var samples = builder.renderer.samples;
          if (this.alphaToCoverage && samples > 1) {
            // to be added to flow when the color/alpha value has been determined
            result = clippingAlpha();
          } else {
            builder.stack.add(clipping());
          }
        }
        return result;
      }

      /**
       * Setups the hardware clipping if available on the current device.
       *
       * @param {NodeBuilder} builder - The current node builder.
       */
    }, {
      key: "setupHardwareClipping",
      value: function setupHardwareClipping(builder) {
        this.hardwareClipping = false;
        if (builder.clippingContext === null) return;
        var candidateCount = builder.clippingContext.unionPlanes.length;

        // 8 planes supported by WebGL ANGLE_clip_cull_distance and WebGPU clip-distances

        if (candidateCount > 0 && candidateCount <= 8 && builder.isAvailable('clipDistance')) {
          builder.stack.add(hardwareClipping());
          this.hardwareClipping = true;
        }
        return;
      }

      /**
       * Setups the depth of this material.
       *
       * @param {NodeBuilder} builder - The current node builder.
       */
    }, {
      key: "setupDepth",
      value: function setupDepth(builder) {
        var renderer = builder.renderer,
          camera = builder.camera;

        // Depth

        var depthNode = this.depthNode;
        if (depthNode === null) {
          var _mrt2 = renderer.getMRT();
          if (_mrt2 && _mrt2.has('depth')) {
            depthNode = _mrt2.get('depth');
          } else if (renderer.logarithmicDepthBuffer === true) {
            if (camera.isPerspectiveCamera) {
              depthNode = viewZToLogarithmicDepth(positionView.z, cameraNear, cameraFar);
            } else {
              depthNode = viewZToOrthographicDepth(positionView.z, cameraNear, cameraFar);
            }
          }
        }
        if (depthNode !== null) {
          depth.assign(depthNode).append();
        }
      }

      /**
       * Setups the position node in view space. This method exists
       * so derived node materials can modifiy the implementation e.g. sprite materials.
       *
       * @param {NodeBuilder} builder - The current node builder.
       * @return {Node<vec3>} The position in view space.
       */
    }, {
      key: "setupPositionView",
      value: function setupPositionView(/*builder*/
      ) {
        return modelViewMatrix.mul(positionLocal).xyz;
      }

      /**
       * Setups the position in clip space.
       *
       * @param {NodeBuilder} builder - The current node builder.
       * @return {Node<vec4>} The position in view space.
       */
    }, {
      key: "setupModelViewProjection",
      value: function setupModelViewProjection(/*builder*/
      ) {
        return cameraProjectionMatrix.mul(positionView);
      }

      /**
       * Setups the logic for the vertex stage.
       *
       * @param {NodeBuilder} builder - The current node builder.
       * @return {Node<vec4>} The position in clip space.
       */
    }, {
      key: "setupVertex",
      value: function setupVertex(builder) {
        builder.addStack();
        this.setupPosition(builder);
        builder.context.vertex = builder.removeStack();
        return modelViewProjection;
      }

      /**
       * Setups the computation of the position in local space.
       *
       * @param {NodeBuilder} builder - The current node builder.
       * @return {Node<vec3>} The position in local space.
       */
    }, {
      key: "setupPosition",
      value: function setupPosition(builder) {
        var object = builder.object,
          geometry = builder.geometry;
        if (geometry.morphAttributes.position || geometry.morphAttributes.normal || geometry.morphAttributes.color) {
          morphReference(object).append();
        }
        if (object.isSkinnedMesh === true) {
          skinningReference(object).append();
        }
        if (this.displacementMap) {
          var displacementMap = materialReference('displacementMap', 'texture');
          var displacementScale = materialReference('displacementScale', 'float');
          var displacementBias = materialReference('displacementBias', 'float');
          positionLocal.addAssign(normalLocal.normalize().mul(displacementMap.x.mul(displacementScale).add(displacementBias)));
        }
        if (object.isBatchedMesh) {
          batch(object).append();
        }
        if (object.isInstancedMesh && object.instanceMatrix && object.instanceMatrix.isInstancedBufferAttribute === true) {
          instancedMesh(object).append();
        }
        if (this.positionNode !== null) {
          positionLocal.assign(this.positionNode.context({
            isPositionNodeInput: true
          }));
        }
        return positionLocal;
      }

      /**
       * Setups the computation of the material's diffuse color.
       *
       * @param {NodeBuilder} builder - The current node builder.
       * @param {BufferGeometry} geometry - The geometry.
       */
    }, {
      key: "setupDiffuseColor",
      value: function setupDiffuseColor(_ref52) {
        var object = _ref52.object,
          geometry = _ref52.geometry;
        var colorNode = this.colorNode ? vec4(this.colorNode) : materialColor;

        // VERTEX COLORS

        if (this.vertexColors === true && geometry.hasAttribute('color')) {
          colorNode = vec4(colorNode.xyz.mul(attribute('color', 'vec3')), colorNode.a);
        }

        // Instanced colors

        if (object.instanceColor) {
          var instanceColor = varyingProperty('vec3', 'vInstanceColor');
          colorNode = instanceColor.mul(colorNode);
        }
        if (object.isBatchedMesh && object._colorsTexture) {
          var batchColor = varyingProperty('vec3', 'vBatchColor');
          colorNode = batchColor.mul(colorNode);
        }

        // COLOR

        diffuseColor.assign(colorNode);

        // OPACITY

        var opacityNode = this.opacityNode ? float(this.opacityNode) : materialOpacity;
        diffuseColor.a.assign(diffuseColor.a.mul(opacityNode));

        // ALPHA TEST

        if (this.alphaTestNode !== null || this.alphaTest > 0) {
          var alphaTestNode = this.alphaTestNode !== null ? float(this.alphaTestNode) : materialAlphaTest;
          diffuseColor.a.lessThanEqual(alphaTestNode).discard();
        }

        // ALPHA HASH

        if (this.alphaHash === true) {
          diffuseColor.a.lessThan(getAlphaHashThreshold(positionLocal)).discard();
        }
        if (this.transparent === false && this.blending === _$$_REQUIRE(_dependencyMap[1], "./three.core.js").NormalBlending && this.alphaToCoverage === false) {
          diffuseColor.a.assign(1.0);
        }
      }

      /**
       * Abstract interface method that can be implemented by derived materials
       * to setup material-specific node variables.
       *
       * @abstract
       * @param {NodeBuilder} builder - The current node builder.
       */
    }, {
      key: "setupVariants",
      value: function setupVariants(/*builder*/
      ) {

        // Interface function.
      }

      /**
       * Setups the outgoing light node variable
       *
       * @return {Node<vec3>} The outgoing light node.
       */
    }, {
      key: "setupOutgoingLight",
      value: function setupOutgoingLight() {
        return this.lights === true ? vec3(0) : diffuseColor.rgb;
      }

      /**
       * Setups the normal node from the material.
       *
       * @return {Node<vec3>} The normal node.
       */
    }, {
      key: "setupNormal",
      value: function setupNormal() {
        return this.normalNode ? vec3(this.normalNode) : materialNormal;
      }

      /**
       * Setups the environment node from the material.
       *
       * @param {NodeBuilder} builder - The current node builder.
       * @return {Node<vec4>} The environment node.
       */
    }, {
      key: "setupEnvironment",
      value: function setupEnvironment(/*builder*/
      ) {
        var node = null;
        if (this.envNode) {
          node = this.envNode;
        } else if (this.envMap) {
          node = this.envMap.isCubeTexture ? materialReference('envMap', 'cubeTexture') : materialReference('envMap', 'texture');
        }
        return node;
      }

      /**
       * Setups the light map node from the material.
       *
       * @param {NodeBuilder} builder - The current node builder.
       * @return {Node<vec3>} The light map node.
       */
    }, {
      key: "setupLightMap",
      value: function setupLightMap(builder) {
        var node = null;
        if (builder.material.lightMap) {
          node = new IrradianceNode(materialLightMap);
        }
        return node;
      }

      /**
       * Setups the lights node based on the scene, environment and material.
       *
       * @param {NodeBuilder} builder - The current node builder.
       * @return {LightsNode} The lights node.
       */
    }, {
      key: "setupLights",
      value: function setupLights(builder) {
        var materialLightsNode = [];

        //

        var envNode = this.setupEnvironment(builder);
        if (envNode && envNode.isLightingNode) {
          materialLightsNode.push(envNode);
        }
        var lightMapNode = this.setupLightMap(builder);
        if (lightMapNode && lightMapNode.isLightingNode) {
          materialLightsNode.push(lightMapNode);
        }
        if (this.aoNode !== null || builder.material.aoMap) {
          var aoNode = this.aoNode !== null ? this.aoNode : materialAO;
          materialLightsNode.push(new AONode(aoNode));
        }
        var lightsN = this.lightsNode || builder.lightsNode;
        if (materialLightsNode.length > 0) {
          lightsN = builder.renderer.lighting.createNode([].concat((0, _toConsumableArray2.default)(lightsN.getLights()), materialLightsNode));
        }
        return lightsN;
      }

      /**
       * This method should be implemented by most derived materials
       * since it defines the material's lighting model.
       *
       * @abstract
       * @param {NodeBuilder} builder - The current node builder.
       * @return {LightingModel} The lighting model.
       */
    }, {
      key: "setupLightingModel",
      value: function setupLightingModel(/*builder*/
      ) {

        // Interface function.
      }

      /**
       * Setups the outgoing light node.
       *
       * @param {NodeBuilder} builder - The current node builder.
       * @return {Node<vec3>} The outgoing light node.
       */
    }, {
      key: "setupLighting",
      value: function setupLighting(builder) {
        var material = builder.material;
        var backdropNode = this.backdropNode,
          backdropAlphaNode = this.backdropAlphaNode,
          emissiveNode = this.emissiveNode;

        // OUTGOING LIGHT

        var lights = this.lights === true || this.lightsNode !== null;
        var lightsNode = lights ? this.setupLights(builder) : null;
        var outgoingLightNode = this.setupOutgoingLight(builder);
        if (lightsNode && lightsNode.getScope().hasLights) {
          var lightingModel = this.setupLightingModel(builder);
          outgoingLightNode = lightingContext(lightsNode, lightingModel, backdropNode, backdropAlphaNode);
        } else if (backdropNode !== null) {
          outgoingLightNode = vec3(backdropAlphaNode !== null ? mix(outgoingLightNode, backdropNode, backdropAlphaNode) : backdropNode);
        }

        // EMISSIVE

        if (emissiveNode && emissiveNode.isNode === true || material.emissive && material.emissive.isColor === true) {
          emissive.assign(vec3(emissiveNode ? emissiveNode : materialEmissive));
          outgoingLightNode = outgoingLightNode.add(emissive);
        }
        return outgoingLightNode;
      }

      /**
       * Setups the output node.
       *
       * @param {NodeBuilder} builder - The current node builder.
       * @param {Node<vec4>} outputNode - The existing output node.
       * @return {Node<vec4>} The output node.
       */
    }, {
      key: "setupOutput",
      value: function setupOutput(builder, outputNode) {
        // FOG

        if (this.fog === true) {
          var fogNode = builder.fogNode;
          if (fogNode) {
            output.assign(outputNode);
            outputNode = vec4(fogNode);
          }
        }
        return outputNode;
      }

      /**
       * Most classic material types have a node pendant e.g. for `MeshBasicMaterial`
       * there is `MeshBasicNodeMaterial`. This utility method is intended for
       * defining all material properties of the classic type in the node type.
       *
       * @param {Material} material - The material to copy properties with their values to this node material.
       */
    }, {
      key: "setDefaultValues",
      value: function setDefaultValues(material) {
        // This approach is to reuse the native refreshUniforms*
        // and turn available the use of features like transmission and environment in core

        for (var _property8 in material) {
          var value = material[_property8];
          if (this[_property8] === undefined) {
            this[_property8] = value;
            if (value && value.clone) this[_property8] = value.clone();
          }
        }
        var descriptors = Object.getOwnPropertyDescriptors(material.constructor.prototype);
        for (var key in descriptors) {
          if (Object.getOwnPropertyDescriptor(this.constructor.prototype, key) === undefined && descriptors[key].get !== undefined) {
            Object.defineProperty(this.constructor.prototype, key, descriptors[key]);
          }
        }
      }

      /**
       * Serializes this material to JSON.
       *
       * @param {(Object|String)?} meta - The meta information for serialization.
       * @return {Object} The serialized node.
       */
    }, {
      key: "toJSON",
      value: function toJSON(meta) {
        var isRoot = meta === undefined || typeof meta === 'string';
        if (isRoot) {
          meta = {
            textures: {},
            images: {},
            nodes: {}
          };
        }
        var data = _$$_REQUIRE(_dependencyMap[1], "./three.core.js").Material.prototype.toJSON.call(this, meta);
        var nodeChildren = getNodeChildren(this);
        data.inputNodes = {};
        for (var _ref53 of nodeChildren) {
          var _property9 = _ref53.property;
          var childNode = _ref53.childNode;
          data.inputNodes[_property9] = childNode.toJSON(meta).uuid;
        }

        // TODO: Copied from Object3D.toJSON

        function extractFromCache(cache) {
          var values = [];
          for (var key in cache) {
            var _data2 = cache[key];
            delete _data2.metadata;
            values.push(_data2);
          }
          return values;
        }
        if (isRoot) {
          var textures = extractFromCache(meta.textures);
          var images = extractFromCache(meta.images);
          var nodes = extractFromCache(meta.nodes);
          if (textures.length > 0) data.textures = textures;
          if (images.length > 0) data.images = images;
          if (nodes.length > 0) data.nodes = nodes;
        }
        return data;
      }

      /**
       * Copies the properties of the given node material to this instance.
       *
       * @param {NodeMaterial} source - The material to copy.
       * @return {NodeMaterial} A reference to this node material.
       */
    }, {
      key: "copy",
      value: function copy(source) {
        this.lightsNode = source.lightsNode;
        this.envNode = source.envNode;
        this.colorNode = source.colorNode;
        this.normalNode = source.normalNode;
        this.opacityNode = source.opacityNode;
        this.backdropNode = source.backdropNode;
        this.backdropAlphaNode = source.backdropAlphaNode;
        this.alphaTestNode = source.alphaTestNode;
        this.positionNode = source.positionNode;
        this.geometryNode = source.geometryNode;
        this.depthNode = source.depthNode;
        this.shadowPositionNode = source.shadowPositionNode;
        this.receivedShadowNode = source.receivedShadowNode;
        this.castShadowNode = source.castShadowNode;
        this.outputNode = source.outputNode;
        this.mrtNode = source.mrtNode;
        this.fragmentNode = source.fragmentNode;
        this.vertexNode = source.vertexNode;
        return _superPropGet(NodeMaterial, "copy", this, 3)([source]);
      }
    }], [{
      key: "type",
      get: function get() {
        return 'NodeMaterial';
      }
    }]);
  }(_$$_REQUIRE(_dependencyMap[1], "./three.core.js").Material);
  var _defaultValues$e = /*@__PURE__*/new (_$$_REQUIRE(_dependencyMap[1], "./three.core.js").PointsMaterial)();

  /**
   * Unlike WebGL, WebGPU can render point primitives only with a size
   * of one pixel. This type node material can be used to mimic the WebGL
   * points rendering by rendering small planes via instancing.
   *
   * This material should be used with {@link InstancedPointsGeometry}.
   *
   * @augments NodeMaterial
   */
  var InstancedPointsNodeMaterial = exports.InstancedPointsNodeMaterial = /*#__PURE__*/function (_NodeMaterial) {
    /**
     * Constructs a new instanced points node material.
     *
     * @param {Object?} parameters - The configuration parameter.
     */
    function InstancedPointsNodeMaterial() {
      var _this75;
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      (0, _classCallCheck2.default)(this, InstancedPointsNodeMaterial);
      _this75 = _callSuper(this, InstancedPointsNodeMaterial);

      /**
       * This flag can be used for type testing.
       *
       * @type {Boolean}
       * @readonly
       * @default true
       */
      _this75.isInstancedPointsNodeMaterial = true;

      /**
       * Whether vertex colors should be used or not. If set to `true`,
       * each point instance can receive a custom color value.
       *
       * @type {Boolean}
       * @default false
       */
      _this75.useColor = parameters.vertexColors;

      /**
       * The points width in pixels.
       *
       * @type {Number}
       * @default 1
       */
      _this75.pointWidth = 1;

      /**
       * This node can be used to define the colors for each instance.
       *
       * @type {Node<vec3>?}
       * @default null
       */
      _this75.pointColorNode = null;

      /**
       * This node can be used to define the width for each point instance.
       *
       * @type {Node<float>?}
       * @default null
       */
      _this75.pointWidthNode = null;
      _this75._useAlphaToCoverage = true;
      _this75.setDefaultValues(_defaultValues$e);
      _this75.setValues(parameters);
      return _this75;
    }

    /**
     * Setups the vertex and fragment stage of this node material.
     *
     * @param {NodeBuilder} builder - The current node builder.
     */
    (0, _inherits2.default)(InstancedPointsNodeMaterial, _NodeMaterial);
    return (0, _createClass2.default)(InstancedPointsNodeMaterial, [{
      key: "setup",
      value: function setup(builder) {
        var _this76 = this;
        var renderer = builder.renderer;
        var useAlphaToCoverage = this._useAlphaToCoverage;
        var useColor = this.useColor;
        this.vertexNode = Fn(function () {
          var instancePosition = attribute('instancePosition').xyz;

          // camera space
          var mvPos = vec4(modelViewMatrix.mul(vec4(instancePosition, 1.0)));
          var aspect = viewport.z.div(viewport.w);

          // clip space
          var clipPos = cameraProjectionMatrix.mul(mvPos);

          // offset in ndc space
          var offset = positionGeometry.xy.toVar();
          offset.mulAssign(_this76.pointWidthNode ? _this76.pointWidthNode : materialPointWidth);
          offset.assign(offset.div(viewport.z));
          offset.y.assign(offset.y.mul(aspect));

          // back to clip space
          offset.assign(offset.mul(clipPos.w));

          //clipPos.xy += offset;
          clipPos.addAssign(vec4(offset, 0, 0));
          return clipPos;
        })();
        this.fragmentNode = Fn(function () {
          var alpha = float(1).toVar();
          var len2 = lengthSq(uv().mul(2).sub(1));
          if (useAlphaToCoverage && renderer.samples > 1) {
            var dlen = float(len2.fwidth()).toVar();
            alpha.assign(smoothstep(dlen.oneMinus(), dlen.add(1), len2).oneMinus());
          } else {
            len2.greaterThan(1.0).discard();
          }
          var pointColorNode;
          if (_this76.pointColorNode) {
            pointColorNode = _this76.pointColorNode;
          } else {
            if (useColor) {
              var instanceColor = attribute('instanceColor');
              pointColorNode = instanceColor.mul(materialColor);
            } else {
              pointColorNode = materialColor;
            }
          }
          alpha.mulAssign(materialOpacity);
          return vec4(pointColorNode, alpha);
        })();
        _superPropGet(InstancedPointsNodeMaterial, "setup", this, 3)([builder]);
      }

      /**
       * Whether alpha to coverage should be used or not.
       *
       * @type {Boolean}
       * @default true
       */
    }, {
      key: "alphaToCoverage",
      get: function get() {
        return this._useAlphaToCoverage;
      },
      set: function set(value) {
        if (this._useAlphaToCoverage !== value) {
          this._useAlphaToCoverage = value;
          this.needsUpdate = true;
        }
      }
    }], [{
      key: "type",
      get: function get() {
        return 'InstancedPointsNodeMaterial';
      }
    }]);
  }(NodeMaterial);
  var _defaultValues$d = /*@__PURE__*/new (_$$_REQUIRE(_dependencyMap[1], "./three.core.js").LineBasicMaterial)();

  /**
   * Node material version of `LineBasicMaterial`.
   *
   * @augments NodeMaterial
   */
  var LineBasicNodeMaterial = exports.LineBasicNodeMaterial = /*#__PURE__*/function (_NodeMaterial2) {
    /**
     * Constructs a new line basic node material.
     *
     * @param {Object?} parameters - The configuration parameter.
     */
    function LineBasicNodeMaterial(parameters) {
      var _this77;
      (0, _classCallCheck2.default)(this, LineBasicNodeMaterial);
      _this77 = _callSuper(this, LineBasicNodeMaterial);

      /**
       * This flag can be used for type testing.
       *
       * @type {Boolean}
       * @readonly
       * @default true
       */
      _this77.isLineBasicNodeMaterial = true;
      _this77.setDefaultValues(_defaultValues$d);
      _this77.setValues(parameters);
      return _this77;
    }
    (0, _inherits2.default)(LineBasicNodeMaterial, _NodeMaterial2);
    return (0, _createClass2.default)(LineBasicNodeMaterial, null, [{
      key: "type",
      get: function get() {
        return 'LineBasicNodeMaterial';
      }
    }]);
  }(NodeMaterial);
  var _defaultValues$c = /*@__PURE__*/new (_$$_REQUIRE(_dependencyMap[1], "./three.core.js").LineDashedMaterial)();

  /**
   * Node material version of `LineDashedMaterial`.
   *
   * @augments NodeMaterial
   */
  var LineDashedNodeMaterial = exports.LineDashedNodeMaterial = /*#__PURE__*/function (_NodeMaterial3) {
    /**
     * Constructs a new line dashed node material.
     *
     * @param {Object?} parameters - The configuration parameter.
     */
    function LineDashedNodeMaterial(parameters) {
      var _this78;
      (0, _classCallCheck2.default)(this, LineDashedNodeMaterial);
      _this78 = _callSuper(this, LineDashedNodeMaterial);

      /**
       * This flag can be used for type testing.
       *
       * @type {Boolean}
       * @readonly
       * @default true
       */
      _this78.isLineDashedNodeMaterial = true;
      _this78.setDefaultValues(_defaultValues$c);

      /**
       * The dash offset.
       *
       * @type {Number}
       * @default 0
       */
      _this78.dashOffset = 0;

      /**
       * The offset of dash materials is by default inferred from the `dashOffset`
       * property. This node property allows to overwrite the default
       * and define the offset with a node instead.
       *
       * If you don't want to overwrite the offset but modify the existing
       * value instead, use {@link module:MaterialNode.materialLineDashOffset}.
       *
       * @type {Node<float>?}
       * @default null
       */
      _this78.offsetNode = null;

      /**
       * The scale of dash materials is by default inferred from the `scale`
       * property. This node property allows to overwrite the default
       * and define the scale with a node instead.
       *
       * If you don't want to overwrite the scale but modify the existing
       * value instead, use {@link module:MaterialNode.materialLineScale}.
       *
       * @type {Node<float>?}
       * @default null
       */
      _this78.dashScaleNode = null;

      /**
       * The dash size of dash materials is by default inferred from the `dashSize`
       * property. This node property allows to overwrite the default
       * and define the dash size with a node instead.
       *
       * If you don't want to overwrite the dash size but modify the existing
       * value instead, use {@link module:MaterialNode.materialLineDashSize}.
       *
       * @type {Node<float>?}
       * @default null
       */
      _this78.dashSizeNode = null;

      /**
       * The gap size of dash materials is by default inferred from the `gapSize`
       * property. This node property allows to overwrite the default
       * and define the gap size with a node instead.
       *
       * If you don't want to overwrite the gap size but modify the existing
       * value instead, use {@link module:MaterialNode.materialLineGapSize}.
       *
       * @type {Node<float>?}
       * @default null
       */
      _this78.gapSizeNode = null;
      _this78.setValues(parameters);
      return _this78;
    }

    /**
     * Setups the dash specific node variables.
     *
     * @param {NodeBuilder} builder - The current node builder.
     */
    (0, _inherits2.default)(LineDashedNodeMaterial, _NodeMaterial3);
    return (0, _createClass2.default)(LineDashedNodeMaterial, [{
      key: "setupVariants",
      value: function setupVariants(/* builder */
      ) {
        var offsetNode = this.offsetNode ? float(this.offsetNode) : materialLineDashOffset;
        var dashScaleNode = this.dashScaleNode ? float(this.dashScaleNode) : materialLineScale;
        var dashSizeNode = this.dashSizeNode ? float(this.dashSizeNode) : materialLineDashSize;
        var gapSizeNode = this.gapSizeNode ? float(this.gapSizeNode) : materialLineGapSize;
        dashSize.assign(dashSizeNode);
        gapSize.assign(gapSizeNode);
        var vLineDistance = varying(attribute('lineDistance').mul(dashScaleNode));
        var vLineDistanceOffset = offsetNode ? vLineDistance.add(offsetNode) : vLineDistance;
        vLineDistanceOffset.mod(dashSize.add(gapSize)).greaterThan(dashSize).discard();
      }
    }], [{
      key: "type",
      get: function get() {
        return 'LineDashedNodeMaterial';
      }
    }]);
  }(NodeMaterial);
  /** @module ViewportSharedTextureNode **/
  var _sharedFramebuffer = null;

  /**
   * `ViewportTextureNode` creates an internal texture for each node instance. This module
   * shares a texture across all instances of `ViewportSharedTextureNode`. It should
   * be the first choice when using data of the default/screen framebuffer for performance reasons.
   *
   * @augments module:ViewportTextureNode~ViewportTextureNode
   */
  var ViewportSharedTextureNode = exports.ViewportSharedTextureNode = /*#__PURE__*/function (_ViewportTextureNode2) {
    /**
     * Constructs a new viewport shared texture node.
     *
     * @param {Node} [uvNode=screenUV] - The uv node.
     * @param {Node?} [levelNode=null] - The level node.
     */
    function ViewportSharedTextureNode() {
      var uvNode = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : screenUV;
      var levelNode = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      (0, _classCallCheck2.default)(this, ViewportSharedTextureNode);
      if (_sharedFramebuffer === null) {
        _sharedFramebuffer = new (_$$_REQUIRE(_dependencyMap[1], "./three.core.js").FramebufferTexture)();
      }
      return _callSuper(this, ViewportSharedTextureNode, [uvNode, levelNode, _sharedFramebuffer]);
    }
    (0, _inherits2.default)(ViewportSharedTextureNode, _ViewportTextureNode2);
    return (0, _createClass2.default)(ViewportSharedTextureNode, [{
      key: "updateReference",
      value: function updateReference() {
        return this;
      }
    }], [{
      key: "type",
      get: function get() {
        return 'ViewportSharedTextureNode';
      }
    }]);
  }(ViewportTextureNode);
  /**
   * TSL function for creating a shared viewport texture node.
   *
   * @function
   * @param {Node} [uvNode=screenUV] - The uv node.
   * @param {Node?} [levelNode=null] - The level node.
   * @returns {ViewportSharedTextureNode}
   */
  var viewportSharedTexture = /*@__PURE__*/nodeProxy(ViewportSharedTextureNode);
  var _defaultValues$b = /*@__PURE__*/new (_$$_REQUIRE(_dependencyMap[1], "./three.core.js").LineDashedMaterial)();

  /**
   * This node material can be used to render lines with a size larger than one
   * by representing them as instanced meshes.
   *
   * @augments NodeMaterial
   */
  var Line2NodeMaterial = exports.Line2NodeMaterial = /*#__PURE__*/function (_NodeMaterial4) {
    /**
     * Constructs a new node material for wide line rendering.
     *
     * @param {Object?} parameters - The configuration parameter.
     */
    function Line2NodeMaterial() {
      var _this79;
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      (0, _classCallCheck2.default)(this, Line2NodeMaterial);
      _this79 = _callSuper(this, Line2NodeMaterial);

      /**
       * This flag can be used for type testing.
       *
       * @type {Boolean}
       * @readonly
       * @default true
       */
      _this79.isLine2NodeMaterial = true;
      _this79.setDefaultValues(_defaultValues$b);

      /**
       * Whether vertex colors should be used or not.
       *
       * @type {Boolean}
       * @default false
       */
      _this79.useColor = parameters.vertexColors;

      /**
       * The dash offset.
       *
       * @type {Number}
       * @default 0
       */
      _this79.dashOffset = 0;

      /**
       * The line width.
       *
       * @type {Number}
       * @default 0
       */
      _this79.lineWidth = 1;

      /**
       * Defines the lines color.
       *
       * @type {Node<vec3>?}
       * @default null
       */
      _this79.lineColorNode = null;

      /**
       * Defines the offset.
       *
       * @type {Node<float>?}
       * @default null
       */
      _this79.offsetNode = null;

      /**
       * Defines the dash scale.
       *
       * @type {Node<float>?}
       * @default null
       */
      _this79.dashScaleNode = null;

      /**
       * Defines the dash size.
       *
       * @type {Node<float>?}
       * @default null
       */
      _this79.dashSizeNode = null;

      /**
       * Defines the gap size.
       *
       * @type {Node<float>?}
       * @default null
       */
      _this79.gapSizeNode = null;

      /**
       * Blending is set to `NoBlending` since transparency
       * is not supported, yet.
       *
       * @type {Number}
       * @default 0
       */
      _this79.blending = _$$_REQUIRE(_dependencyMap[1], "./three.core.js").NoBlending;
      _this79._useDash = parameters.dashed;
      _this79._useAlphaToCoverage = true;
      _this79._useWorldUnits = false;
      _this79.setValues(parameters);
      return _this79;
    }

    /**
     * Setups the vertex and fragment stage of this node material.
     *
     * @param {NodeBuilder} builder - The current node builder.
     */
    (0, _inherits2.default)(Line2NodeMaterial, _NodeMaterial4);
    return (0, _createClass2.default)(Line2NodeMaterial, [{
      key: "setup",
      value: function setup(builder) {
        var _this80 = this;
        var renderer = builder.renderer;
        var useAlphaToCoverage = this._useAlphaToCoverage;
        var useColor = this.useColor;
        var useDash = this._useDash;
        var useWorldUnits = this._useWorldUnits;
        var trimSegment = Fn(function (_ref54) {
          var start = _ref54.start,
            end = _ref54.end;
          var a = cameraProjectionMatrix.element(2).element(2); // 3nd entry in 3th column
          var b = cameraProjectionMatrix.element(3).element(2); // 3nd entry in 4th column
          var nearEstimate = b.mul(-0.5).div(a);
          var alpha = nearEstimate.sub(start.z).div(end.z.sub(start.z));
          return vec4(mix(start.xyz, end.xyz, alpha), end.w);
        }).setLayout({
          name: 'trimSegment',
          type: 'vec4',
          inputs: [{
            name: 'start',
            type: 'vec4'
          }, {
            name: 'end',
            type: 'vec4'
          }]
        });
        this.vertexNode = Fn(function () {
          var instanceStart = attribute('instanceStart');
          var instanceEnd = attribute('instanceEnd');

          // camera space

          var start = vec4(modelViewMatrix.mul(vec4(instanceStart, 1.0))).toVar('start');
          var end = vec4(modelViewMatrix.mul(vec4(instanceEnd, 1.0))).toVar('end');
          if (useDash) {
            var dashScaleNode = _this80.dashScaleNode ? float(_this80.dashScaleNode) : materialLineScale;
            var offsetNode = _this80.offsetNode ? float(_this80.offsetNode) : materialLineDashOffset;
            var instanceDistanceStart = attribute('instanceDistanceStart');
            var instanceDistanceEnd = attribute('instanceDistanceEnd');
            var lineDistance = positionGeometry.y.lessThan(0.5).select(dashScaleNode.mul(instanceDistanceStart), dashScaleNode.mul(instanceDistanceEnd));
            lineDistance = lineDistance.add(offsetNode);
            varyingProperty('float', 'lineDistance').assign(lineDistance);
          }
          if (useWorldUnits) {
            varyingProperty('vec3', 'worldStart').assign(start.xyz);
            varyingProperty('vec3', 'worldEnd').assign(end.xyz);
          }
          var aspect = viewport.z.div(viewport.w);

          // special case for perspective projection, and segments that terminate either in, or behind, the camera plane
          // clearly the gpu firmware has a way of addressing this issue when projecting into ndc space
          // but we need to perform ndc-space calculations in the shader, so we must address this issue directly
          // perhaps there is a more elegant solution -- WestLangley

          var perspective = cameraProjectionMatrix.element(2).element(3).equal(-1.0); // 4th entry in the 3rd column

          If(perspective, function () {
            If(start.z.lessThan(0.0).and(end.z.greaterThan(0.0)), function () {
              end.assign(trimSegment({
                start: start,
                end: end
              }));
            }).ElseIf(end.z.lessThan(0.0).and(start.z.greaterThanEqual(0.0)), function () {
              start.assign(trimSegment({
                start: end,
                end: start
              }));
            });
          });

          // clip space
          var clipStart = cameraProjectionMatrix.mul(start);
          var clipEnd = cameraProjectionMatrix.mul(end);

          // ndc space
          var ndcStart = clipStart.xyz.div(clipStart.w);
          var ndcEnd = clipEnd.xyz.div(clipEnd.w);

          // direction
          var dir = ndcEnd.xy.sub(ndcStart.xy).toVar();

          // account for clip-space aspect ratio
          dir.x.assign(dir.x.mul(aspect));
          dir.assign(dir.normalize());
          var clip = vec4().toVar();
          if (useWorldUnits) {
            // get the offset direction as perpendicular to the view vector

            var worldDir = end.xyz.sub(start.xyz).normalize();
            var tmpFwd = mix(start.xyz, end.xyz, 0.5).normalize();
            var worldUp = worldDir.cross(tmpFwd).normalize();
            var worldFwd = worldDir.cross(worldUp);
            var worldPos = varyingProperty('vec4', 'worldPos');
            worldPos.assign(positionGeometry.y.lessThan(0.5).select(start, end));

            // height offset
            var hw = materialLineWidth.mul(0.5);
            worldPos.addAssign(vec4(positionGeometry.x.lessThan(0.0).select(worldUp.mul(hw), worldUp.mul(hw).negate()), 0));

            // don't extend the line if we're rendering dashes because we
            // won't be rendering the endcaps
            if (!useDash) {
              // cap extension
              worldPos.addAssign(vec4(positionGeometry.y.lessThan(0.5).select(worldDir.mul(hw).negate(), worldDir.mul(hw)), 0));

              // add width to the box
              worldPos.addAssign(vec4(worldFwd.mul(hw), 0));

              // endcaps
              If(positionGeometry.y.greaterThan(1.0).or(positionGeometry.y.lessThan(0.0)), function () {
                worldPos.subAssign(vec4(worldFwd.mul(2.0).mul(hw), 0));
              });
            }

            // project the worldpos
            clip.assign(cameraProjectionMatrix.mul(worldPos));

            // shift the depth of the projected points so the line
            // segments overlap neatly
            var clipPose = vec3().toVar();
            clipPose.assign(positionGeometry.y.lessThan(0.5).select(ndcStart, ndcEnd));
            clip.z.assign(clipPose.z.mul(clip.w));
          } else {
            var offset = vec2(dir.y, dir.x.negate()).toVar('offset');

            // undo aspect ratio adjustment
            dir.x.assign(dir.x.div(aspect));
            offset.x.assign(offset.x.div(aspect));

            // sign flip
            offset.assign(positionGeometry.x.lessThan(0.0).select(offset.negate(), offset));

            // endcaps
            If(positionGeometry.y.lessThan(0.0), function () {
              offset.assign(offset.sub(dir));
            }).ElseIf(positionGeometry.y.greaterThan(1.0), function () {
              offset.assign(offset.add(dir));
            });

            // adjust for linewidth
            offset.assign(offset.mul(materialLineWidth));

            // adjust for clip-space to screen-space conversion // maybe resolution should be based on viewport ...
            offset.assign(offset.div(viewport.w));

            // select end
            clip.assign(positionGeometry.y.lessThan(0.5).select(clipStart, clipEnd));

            // back to clip space
            offset.assign(offset.mul(clip.w));
            clip.assign(clip.add(vec4(offset, 0, 0)));
          }
          return clip;
        })();
        var closestLineToLine = Fn(function (_ref55) {
          var p1 = _ref55.p1,
            p2 = _ref55.p2,
            p3 = _ref55.p3,
            p4 = _ref55.p4;
          var p13 = p1.sub(p3);
          var p43 = p4.sub(p3);
          var p21 = p2.sub(p1);
          var d1343 = p13.dot(p43);
          var d4321 = p43.dot(p21);
          var d1321 = p13.dot(p21);
          var d4343 = p43.dot(p43);
          var d2121 = p21.dot(p21);
          var denom = d2121.mul(d4343).sub(d4321.mul(d4321));
          var numer = d1343.mul(d4321).sub(d1321.mul(d4343));
          var mua = numer.div(denom).clamp();
          var mub = d1343.add(d4321.mul(mua)).div(d4343).clamp();
          return vec2(mua, mub);
        });
        this.colorNode = Fn(function () {
          var vUv = uv();
          if (useDash) {
            var dashSizeNode = _this80.dashSizeNode ? float(_this80.dashSizeNode) : materialLineDashSize;
            var gapSizeNode = _this80.gapSizeNode ? float(_this80.gapSizeNode) : materialLineGapSize;
            dashSize.assign(dashSizeNode);
            gapSize.assign(gapSizeNode);
            var vLineDistance = varyingProperty('float', 'lineDistance');
            vUv.y.lessThan(-1.0).or(vUv.y.greaterThan(1.0)).discard(); // discard endcaps
            vLineDistance.mod(dashSize.add(gapSize)).greaterThan(dashSize).discard(); // todo - FIX
          }
          var alpha = float(1).toVar('alpha');
          if (useWorldUnits) {
            var worldStart = varyingProperty('vec3', 'worldStart');
            var worldEnd = varyingProperty('vec3', 'worldEnd');

            // Find the closest points on the view ray and the line segment
            var rayEnd = varyingProperty('vec4', 'worldPos').xyz.normalize().mul(1e5);
            var lineDir = worldEnd.sub(worldStart);
            var params = closestLineToLine({
              p1: worldStart,
              p2: worldEnd,
              p3: vec3(0.0, 0.0, 0.0),
              p4: rayEnd
            });
            var p1 = worldStart.add(lineDir.mul(params.x));
            var p2 = rayEnd.mul(params.y);
            var delta = p1.sub(p2);
            var len = delta.length();
            var norm = len.div(materialLineWidth);
            if (!useDash) {
              if (useAlphaToCoverage && renderer.samples > 1) {
                var dnorm = norm.fwidth();
                alpha.assign(smoothstep(dnorm.negate().add(0.5), dnorm.add(0.5), norm).oneMinus());
              } else {
                norm.greaterThan(0.5).discard();
              }
            }
          } else {
            // round endcaps

            if (useAlphaToCoverage && renderer.samples > 1) {
              var a = vUv.x;
              var b = vUv.y.greaterThan(0.0).select(vUv.y.sub(1.0), vUv.y.add(1.0));
              var len2 = a.mul(a).add(b.mul(b));
              var dlen = float(len2.fwidth()).toVar('dlen');
              If(vUv.y.abs().greaterThan(1.0), function () {
                alpha.assign(smoothstep(dlen.oneMinus(), dlen.add(1), len2).oneMinus());
              });
            } else {
              If(vUv.y.abs().greaterThan(1.0), function () {
                var a = vUv.x;
                var b = vUv.y.greaterThan(0.0).select(vUv.y.sub(1.0), vUv.y.add(1.0));
                var len2 = a.mul(a).add(b.mul(b));
                len2.greaterThan(1.0).discard();
              });
            }
          }
          var lineColorNode;
          if (_this80.lineColorNode) {
            lineColorNode = _this80.lineColorNode;
          } else {
            if (useColor) {
              var instanceColorStart = attribute('instanceColorStart');
              var instanceColorEnd = attribute('instanceColorEnd');
              var instanceColor = positionGeometry.y.lessThan(0.5).select(instanceColorStart, instanceColorEnd);
              lineColorNode = instanceColor.mul(materialColor);
            } else {
              lineColorNode = materialColor;
            }
          }
          return vec4(lineColorNode, alpha);
        })();
        if (this.transparent) {
          var opacityNode = this.opacityNode ? float(this.opacityNode) : materialOpacity;
          this.outputNode = vec4(this.colorNode.rgb.mul(opacityNode).add(viewportSharedTexture().rgb.mul(opacityNode.oneMinus())), this.colorNode.a);
        }
        _superPropGet(Line2NodeMaterial, "setup", this, 3)([builder]);
      }

      /**
       * Whether the lines should sized in world units or not.
       * When set to `false` the unit is pixel.
       *
       * @type {Boolean}
       * @default false
       */
    }, {
      key: "worldUnits",
      get: function get() {
        return this._useWorldUnits;
      },
      set: function set(value) {
        if (this._useWorldUnits !== value) {
          this._useWorldUnits = value;
          this.needsUpdate = true;
        }
      }

      /**
       * Whether the lines should be dashed or not.
       *
       * @type {Boolean}
       * @default false
       */
    }, {
      key: "dashed",
      get: function get() {
        return this._useDash;
      },
      set: function set(value) {
        if (this._useDash !== value) {
          this._useDash = value;
          this.needsUpdate = true;
        }
      }

      /**
       * Whether alpha to coverage should be used or not.
       *
       * @type {Boolean}
       * @default true
       */
    }, {
      key: "alphaToCoverage",
      get: function get() {
        return this._useAlphaToCoverage;
      },
      set: function set(value) {
        if (this._useAlphaToCoverage !== value) {
          this._useAlphaToCoverage = value;
          this.needsUpdate = true;
        }
      }
    }], [{
      key: "type",
      get: function get() {
        return 'Line2NodeMaterial';
      }
    }]);
  }(NodeMaterial);
  /** @module Packing **/
  /**
   * Packs a direction vector into a color value.
   *
   * @method
   * @param {Node<vec3>} node - The direction to pack.
   * @return {Node<vec3>} The color.
   */
  var directionToColor = function directionToColor(node) {
    return nodeObject(node).mul(0.5).add(0.5);
  };

  /**
   * Unpacks a color value into a direction vector.
   *
   * @method
   * @param {Node<vec3>} node - The color to unpack.
   * @return {Node<vec3>} The direction.
   */
  var colorToDirection = function colorToDirection(node) {
    return nodeObject(node).mul(2.0).sub(1);
  };
  var _defaultValues$a = /*@__PURE__*/new (_$$_REQUIRE(_dependencyMap[1], "./three.core.js").MeshNormalMaterial)();

  /**
   * Node material version of `MeshNormalMaterial`.
   *
   * @augments NodeMaterial
   */
  var MeshNormalNodeMaterial = exports.MeshNormalNodeMaterial = /*#__PURE__*/function (_NodeMaterial5) {
    /**
     * Constructs a new mesh normal node material.
     *
     * @param {Object?} parameters - The configuration parameter.
     */
    function MeshNormalNodeMaterial(parameters) {
      var _this81;
      (0, _classCallCheck2.default)(this, MeshNormalNodeMaterial);
      _this81 = _callSuper(this, MeshNormalNodeMaterial);

      /**
       * This flag can be used for type testing.
       *
       * @type {Boolean}
       * @readonly
       * @default true
       */
      _this81.isMeshNormalNodeMaterial = true;
      _this81.setDefaultValues(_defaultValues$a);
      _this81.setValues(parameters);
      return _this81;
    }

    /**
     * Overwrites the default implementation by computing the diffuse color
     * based on the normal data.
     */
    (0, _inherits2.default)(MeshNormalNodeMaterial, _NodeMaterial5);
    return (0, _createClass2.default)(MeshNormalNodeMaterial, [{
      key: "setupDiffuseColor",
      value: function setupDiffuseColor() {
        var opacityNode = this.opacityNode ? float(this.opacityNode) : materialOpacity;
        diffuseColor.assign(vec4(directionToColor(transformedNormalView), opacityNode));
      }
    }], [{
      key: "type",
      get: function get() {
        return 'MeshNormalNodeMaterial';
      }
    }]);
  }(NodeMaterial);
  /** @module EquirectUVNode **/
  /**
   * Can be used to compute texture coordinates for projecting an
   * equirectangular texture onto a mesh for using it as the scene's
   * background.
   *
   * ```js
   * scene.backgroundNode = texture( equirectTexture, equirectUV() );
   * ```
   *
   * @augments TempNode
   */
  var EquirectUVNode = exports.EquirectUVNode = /*#__PURE__*/function (_TempNode13) {
    /**
     * Constructs a new equirect uv node.
     *
     * @param {Node<vec3>} [dirNode=positionWorldDirection] - A direction vector for sampling which is by default `positionWorldDirection`.
     */
    function EquirectUVNode() {
      var _this82;
      var dirNode = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : positionWorldDirection;
      (0, _classCallCheck2.default)(this, EquirectUVNode);
      _this82 = _callSuper(this, EquirectUVNode, ['vec2']);

      /**
       * A direction vector for sampling why is by default `positionWorldDirection`.
       *
       * @type {Node<vec3>}
       */
      _this82.dirNode = dirNode;
      return _this82;
    }
    (0, _inherits2.default)(EquirectUVNode, _TempNode13);
    return (0, _createClass2.default)(EquirectUVNode, [{
      key: "setup",
      value: function setup() {
        var dir = this.dirNode;
        var u = dir.z.atan(dir.x).mul(1 / (Math.PI * 2)).add(0.5);
        var v = dir.y.clamp(-1.0, 1.0).asin().mul(1 / Math.PI).add(0.5);
        return vec2(u, v);
      }
    }], [{
      key: "type",
      get: function get() {
        return 'EquirectUVNode';
      }
    }]);
  }(TempNode);
  /**
   * TSL function for creating an equirect uv node.
   *
   * @function
   * @param {Node<vec3>} [dirNode=positionWorldDirection] - A direction vector for sampling which is by default `positionWorldDirection`.
   * @returns {EquirectUVNode}
   */
  var equirectUV = /*@__PURE__*/nodeProxy(EquirectUVNode);

  // @TODO: Consider rename WebGLCubeRenderTarget to just CubeRenderTarget

  /**
   * This class represents a cube render target. It is a special version
   * of `WebGLCubeRenderTarget` which is compatible with `WebGPURenderer`.
   *
   * @augments WebGLCubeRenderTarget
   */
  var CubeRenderTarget = /*#__PURE__*/function (_WebGLCubeRenderTarge) {
    function CubeRenderTarget() {
      var _this83;
      var size = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      (0, _classCallCheck2.default)(this, CubeRenderTarget);
      _this83 = _callSuper(this, CubeRenderTarget, [size, options]);
      _this83.isCubeRenderTarget = true;
      return _this83;
    }

    /**
     * Converts the given equirectangular texture to a cube map.
     *
     * @param {Renderer} renderer - The renderer.
     * @param {Texture} texture - The equirectangular texture.
     * @return {CubeRenderTarget} A reference to this cube render target.
     */
    (0, _inherits2.default)(CubeRenderTarget, _WebGLCubeRenderTarge);
    return (0, _createClass2.default)(CubeRenderTarget, [{
      key: "fromEquirectangularTexture",
      value: function fromEquirectangularTexture(renderer, texture$1) {
        var currentMinFilter = texture$1.minFilter;
        var currentGenerateMipmaps = texture$1.generateMipmaps;
        texture$1.generateMipmaps = true;
        this.texture.type = texture$1.type;
        this.texture.colorSpace = texture$1.colorSpace;
        this.texture.generateMipmaps = texture$1.generateMipmaps;
        this.texture.minFilter = texture$1.minFilter;
        this.texture.magFilter = texture$1.magFilter;
        var geometry = new (_$$_REQUIRE(_dependencyMap[1], "./three.core.js").BoxGeometry)(5, 5, 5);
        var uvNode = equirectUV(positionWorldDirection);
        var material = new NodeMaterial();
        material.colorNode = texture(texture$1, uvNode, 0);
        material.side = _$$_REQUIRE(_dependencyMap[1], "./three.core.js").BackSide;
        material.blending = _$$_REQUIRE(_dependencyMap[1], "./three.core.js").NoBlending;
        var mesh = new (_$$_REQUIRE(_dependencyMap[1], "./three.core.js").Mesh)(geometry, material);
        var scene = new (_$$_REQUIRE(_dependencyMap[1], "./three.core.js").Scene)();
        scene.add(mesh);

        // Avoid blurred poles
        if (texture$1.minFilter === _$$_REQUIRE(_dependencyMap[1], "./three.core.js").LinearMipmapLinearFilter) texture$1.minFilter = _$$_REQUIRE(_dependencyMap[1], "./three.core.js").LinearFilter;
        var camera = new (_$$_REQUIRE(_dependencyMap[1], "./three.core.js").CubeCamera)(1, 10, this);
        var currentMRT = renderer.getMRT();
        renderer.setMRT(null);
        camera.update(renderer, scene);
        renderer.setMRT(currentMRT);
        texture$1.minFilter = currentMinFilter;
        texture$1.currentGenerateMipmaps = currentGenerateMipmaps;
        mesh.geometry.dispose();
        mesh.material.dispose();
        return this;
      }
    }]);
  }(_$$_REQUIRE(_dependencyMap[1], "./three.core.js").WebGLCubeRenderTarget);
  /** @module CubeMapNode **/
  var _cache$1 = new WeakMap();

  /**
   * This node can be used to automatically convert environment maps in the
   * equirectangular format into the cube map format.
   *
   * @augments TempNode
   */
  var CubeMapNode = /*#__PURE__*/function (_TempNode14) {
    /**
     * Constructs a new cube map node.
     *
     * @param {Node} envNode - The node representing the environment map.
     */
    function CubeMapNode(envNode) {
      var _this84;
      (0, _classCallCheck2.default)(this, CubeMapNode);
      _this84 = _callSuper(this, CubeMapNode, ['vec3']);

      /**
       * The node representing the environment map.
       *
       * @type {Node}
       */
      _this84.envNode = envNode;

      /**
       * A reference to the internal cube texture.
       *
       * @private
       * @type {CubeTexture}
       * @default null
       */
      _this84._cubeTexture = null;

      /**
       * A reference to the internal cube texture node.
       *
       * @private
       * @type {CubeTextureNode}
       */
      _this84._cubeTextureNode = cubeTexture();
      var defaultTexture = new (_$$_REQUIRE(_dependencyMap[1], "./three.core.js").CubeTexture)();
      defaultTexture.isRenderTargetTexture = true;

      /**
       * A default cube texture that acts as a placeholder.
       * It is used when the conversion from equirectangular to cube
       * map has not finished yet for a given texture.
       *
       * @private
       * @type {CubeTexture}
       */
      _this84._defaultTexture = defaultTexture;

      /**
       * The `updateBeforeType` is set to `NodeUpdateType.RENDER` since the node updates
       * the texture once per render in its {@link CubeMapNode#updateBefore} method.
       *
       * @type {String}
       * @default 'render'
       */
      _this84.updateBeforeType = NodeUpdateType.RENDER;
      return _this84;
    }
    (0, _inherits2.default)(CubeMapNode, _TempNode14);
    return (0, _createClass2.default)(CubeMapNode, [{
      key: "updateBefore",
      value: function updateBefore(frame) {
        var renderer = frame.renderer,
          material = frame.material;
        var envNode = this.envNode;
        if (envNode.isTextureNode || envNode.isMaterialReferenceNode) {
          var _texture = envNode.isTextureNode ? envNode.value : material[envNode.property];
          if (_texture && _texture.isTexture) {
            var mapping = _texture.mapping;
            if (mapping === _$$_REQUIRE(_dependencyMap[1], "./three.core.js").EquirectangularReflectionMapping || mapping === _$$_REQUIRE(_dependencyMap[1], "./three.core.js").EquirectangularRefractionMapping) {
              // check for converted cubemap map

              if (_cache$1.has(_texture)) {
                var cubeMap = _cache$1.get(_texture);
                mapTextureMapping(cubeMap, _texture.mapping);
                this._cubeTexture = cubeMap;
              } else {
                // create cube map from equirectangular map

                var image = _texture.image;
                if (isEquirectangularMapReady$1(image)) {
                  var renderTarget = new CubeRenderTarget(image.height);
                  renderTarget.fromEquirectangularTexture(renderer, _texture);
                  mapTextureMapping(renderTarget.texture, _texture.mapping);
                  this._cubeTexture = renderTarget.texture;
                  _cache$1.set(_texture, renderTarget.texture);
                  _texture.addEventListener('dispose', onTextureDispose);
                } else {
                  // default cube texture as fallback when equirectangular texture is not yet loaded

                  this._cubeTexture = this._defaultTexture;
                }
              }

              //

              this._cubeTextureNode.value = this._cubeTexture;
            } else {
              // envNode already refers to a cube map

              this._cubeTextureNode = this.envNode;
            }
          }
        }
      }
    }, {
      key: "setup",
      value: function setup(builder) {
        this.updateBefore(builder);
        return this._cubeTextureNode;
      }
    }], [{
      key: "type",
      get: function get() {
        return 'CubeMapNode';
      }
    }]);
  }(TempNode);
  /**
   * Returns true if the given equirectangular image has been fully loaded
   * and is ready for further processing.
   *
   * @private
   * @param {Image} image - The equirectangular image to check.
   * @return {Boolean} Whether the image is ready or not.
   */
  function isEquirectangularMapReady$1(image) {
    if (image === null || image === undefined) return false;
    return image.height > 0;
  }

  /**
   * This function is executed when `dispose()` is called on the equirectangular
   * texture. In this case, the generated cube map with its render target
   * is deleted as well.
   *
   * @private
   * @param {Object} event - The event object.
   */
  function onTextureDispose(event) {
    var texture = event.target;
    texture.removeEventListener('dispose', onTextureDispose);
    var renderTarget = _cache$1.get(texture);
    if (renderTarget !== undefined) {
      _cache$1.delete(texture);
      renderTarget.dispose();
    }
  }

  /**
   * This function makes sure the generated cube map uses the correct
   * texture mapping that corresponds to the equirectangular original.
   *
   * @private
   * @param {Texture} texture - The cube texture.
   * @param {Number} mapping - The original texture mapping.
   */
  function mapTextureMapping(texture, mapping) {
    if (mapping === _$$_REQUIRE(_dependencyMap[1], "./three.core.js").EquirectangularReflectionMapping) {
      texture.mapping = _$$_REQUIRE(_dependencyMap[1], "./three.core.js").CubeReflectionMapping;
    } else if (mapping === _$$_REQUIRE(_dependencyMap[1], "./three.core.js").EquirectangularRefractionMapping) {
      texture.mapping = _$$_REQUIRE(_dependencyMap[1], "./three.core.js").CubeRefractionMapping;
    }
  }

  /**
   * TSL function for creating a cube map node.
   *
   * @function
   * @param {Node} envNode - The node representing the environment map.
   * @returns {CubeMapNode}
   */
  var cubeMapNode = /*@__PURE__*/nodeProxy(CubeMapNode);

  /**
   * Represents a basic model for Image-based lighting (IBL). The environment
   * is defined via environment maps in the equirectangular or cube map format.
   * `BasicEnvironmentNode` is intended for non-PBR materials like {@link MeshBasicNodeMaterial}
   * or {@link MeshPhongNodeMaterial}.
   *
   * @augments LightingNode
   */
  var BasicEnvironmentNode = exports.BasicEnvironmentNode = /*#__PURE__*/function (_LightingNode3) {
    /**
     * Constructs a new basic environment node.
     *
     * @param {Node} [envNode=null] - A node representing the environment.
     */
    function BasicEnvironmentNode() {
      var _this85;
      var envNode = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      (0, _classCallCheck2.default)(this, BasicEnvironmentNode);
      _this85 = _callSuper(this, BasicEnvironmentNode);

      /**
       * A node representing the environment.
       *
       * @type {Node}
       * @default null
       */
      _this85.envNode = envNode;
      return _this85;
    }
    (0, _inherits2.default)(BasicEnvironmentNode, _LightingNode3);
    return (0, _createClass2.default)(BasicEnvironmentNode, [{
      key: "setup",
      value: function setup(builder) {
        // environment property is used in the finish() method of BasicLightingModel

        builder.context.environment = cubeMapNode(this.envNode);
      }
    }], [{
      key: "type",
      get: function get() {
        return 'BasicEnvironmentNode';
      }
    }]);
  }(LightingNode);
  /**
   * A specific version of {@link IrradianceNode} that is only relevant
   * for {@link MeshBasicNodeMaterial}. Since the material is unlit, it
   * requires a special scaling factor for the light map.
   *
   * @augments LightingNode
   */
  var BasicLightMapNode = /*#__PURE__*/function (_LightingNode4) {
    /**
     * Constructs a new basic light map node.
     *
     * @param {Node<vec3>?} [lightMapNode=null] - The light map node.
     */
    function BasicLightMapNode() {
      var _this86;
      var lightMapNode = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      (0, _classCallCheck2.default)(this, BasicLightMapNode);
      _this86 = _callSuper(this, BasicLightMapNode);

      /**
       * The light map node.
       *
       * @type {Node<vec3>?}
       */
      _this86.lightMapNode = lightMapNode;
      return _this86;
    }
    (0, _inherits2.default)(BasicLightMapNode, _LightingNode4);
    return (0, _createClass2.default)(BasicLightMapNode, [{
      key: "setup",
      value: function setup(builder) {
        // irradianceLightMap property is used in the indirectDiffuse() method of BasicLightingModel

        var RECIPROCAL_PI = float(1 / Math.PI);
        builder.context.irradianceLightMap = this.lightMapNode.mul(RECIPROCAL_PI);
      }
    }], [{
      key: "type",
      get: function get() {
        return 'BasicLightMapNode';
      }
    }]);
  }(LightingNode);
  /**
   * Abstract class for implementing lighting models. The module defines
   * multiple methods that concrete lighting models can implement. These
   * methods are executed at different points during the light evaluation
   * process.
   */
  var LightingModel = exports.LightingModel = /*#__PURE__*/function () {
    function LightingModel() {
      (0, _classCallCheck2.default)(this, LightingModel);
    }
    return (0, _createClass2.default)(LightingModel, [{
      key: "start",
      value:
      /**
       * This method is intended for setting up lighting model and context data
       * which are later used in the evaluation process.
       *
       * @abstract
       * @param {ContextNode} input - The current node context.
       * @param {StackNode} stack - The current stack.
       * @param {NodeBuilder} builder - The current node builder.
       */
      function start(/*input, stack, builder*/) {}

      /**
       * This method is intended for executing final tasks like final updates
       * to the outgoing light.
       *
       * @abstract
       * @param {ContextNode} input - The current node context.
       * @param {StackNode} stack - The current stack.
       * @param {NodeBuilder} builder - The current node builder.
       */
    }, {
      key: "finish",
      value: function finish(/*input, stack, builder*/) {}

      /**
       * This method is intended for implementing the direct light term and
       * executed during the build process of directional, point and spot light nodes.
       *
       * @abstract
       * @param {Object} input - The input data.
       * @param {StackNode} stack - The current stack.
       * @param {NodeBuilder} builder - The current node builder.
       */
    }, {
      key: "direct",
      value: function direct(/*input, stack, builder*/) {}

      /**
       * This method is intended for implementing the direct light term for
       * rect area light nodes.
       *
       * @abstract
       * @param {Object} input - The input data.
       * @param {StackNode} stack - The current stack.
       * @param {NodeBuilder} builder - The current node builder.
       */
    }, {
      key: "directRectArea",
      value: function directRectArea(/*input, stack, builder*/) {}

      /**
       * This method is intended for implementing the indirect light term.
       *
       * @abstract
       * @param {ContextNode} input - The current node context.
       * @param {StackNode} stack - The current stack.
       * @param {NodeBuilder} builder - The current node builder.
       */
    }, {
      key: "indirect",
      value: function indirect(/*input, stack, builder*/) {}

      /**
       * This method is intended for implementing the ambient occlusion term.
       * Unlike other methods, this method must be called manually by the lighting
       * model in its indirect term.
       *
       * @abstract
       * @param {ContextNode} input - The current node context.
       * @param {StackNode} stack - The current stack.
       * @param {NodeBuilder} builder - The current node builder.
       */
    }, {
      key: "ambientOcclusion",
      value: function ambientOcclusion(/*input, stack, builder*/) {}
    }]);
  }();
  /**
   * Represents the lighting model for unlit materials. The only light contribution
   * is baked indirect lighting modulated with ambient occlusion and the material's
   * diffuse color. Environment mapping is supported. Used in {@link MeshBasicNodeMaterial}.
   *
   * @augments LightingModel
   */
  var BasicLightingModel = /*#__PURE__*/function (_LightingModel) {
    /**
     * Constructs a new basic lighting model.
     */
    function BasicLightingModel() {
      (0, _classCallCheck2.default)(this, BasicLightingModel);
      return _callSuper(this, BasicLightingModel);
    }

    /**
     * Implements the baked indirect lighting with its modulation.
     *
     * @param {ContextNode} context - The current node context.
     * @param {StackNode} stack - The current stack.
     * @param {NodeBuilder} builder - The current node builder.
     */
    (0, _inherits2.default)(BasicLightingModel, _LightingModel);
    return (0, _createClass2.default)(BasicLightingModel, [{
      key: "indirect",
      value: function indirect(context, stack, builder) {
        var ambientOcclusion = context.ambientOcclusion;
        var reflectedLight = context.reflectedLight;
        var irradianceLightMap = builder.context.irradianceLightMap;
        reflectedLight.indirectDiffuse.assign(vec4(0.0));

        // accumulation (baked indirect lighting only)

        if (irradianceLightMap) {
          reflectedLight.indirectDiffuse.addAssign(irradianceLightMap);
        } else {
          reflectedLight.indirectDiffuse.addAssign(vec4(1.0, 1.0, 1.0, 0.0));
        }

        // modulation

        reflectedLight.indirectDiffuse.mulAssign(ambientOcclusion);
        reflectedLight.indirectDiffuse.mulAssign(diffuseColor.rgb);
      }

      /**
       * Implements the environment mapping.
       *
       * @param {ContextNode} context - The current node context.
       * @param {StackNode} stack - The current stack.
       * @param {NodeBuilder} builder - The current node builder.
       */
    }, {
      key: "finish",
      value: function finish(context, stack, builder) {
        var material = builder.material;
        var outgoingLight = context.outgoingLight;
        var envNode = builder.context.environment;
        if (envNode) {
          switch (material.combine) {
            case _$$_REQUIRE(_dependencyMap[1], "./three.core.js").MultiplyOperation:
              outgoingLight.rgb.assign(mix(outgoingLight.rgb, outgoingLight.rgb.mul(envNode.rgb), materialSpecularStrength.mul(materialReflectivity)));
              break;
            case _$$_REQUIRE(_dependencyMap[1], "./three.core.js").MixOperation:
              outgoingLight.rgb.assign(mix(outgoingLight.rgb, envNode.rgb, materialSpecularStrength.mul(materialReflectivity)));
              break;
            case _$$_REQUIRE(_dependencyMap[1], "./three.core.js").AddOperation:
              outgoingLight.rgb.addAssign(envNode.rgb.mul(materialSpecularStrength.mul(materialReflectivity)));
              break;
            default:
              console.warn('THREE.BasicLightingModel: Unsupported .combine value:', material.combine);
              break;
          }
        }
      }
    }]);
  }(LightingModel);
  var _defaultValues$9 = /*@__PURE__*/new (_$$_REQUIRE(_dependencyMap[1], "./three.core.js").MeshBasicMaterial)();

  /**
   * Node material version of `MeshBasicMaterial`.
   *
   * @augments NodeMaterial
   */
  var MeshBasicNodeMaterial = exports.MeshBasicNodeMaterial = /*#__PURE__*/function (_NodeMaterial6) {
    /**
     * Constructs a new mesh basic node material.
     *
     * @param {Object?} parameters - The configuration parameter.
     */
    function MeshBasicNodeMaterial(parameters) {
      var _this87;
      (0, _classCallCheck2.default)(this, MeshBasicNodeMaterial);
      _this87 = _callSuper(this, MeshBasicNodeMaterial);

      /**
       * This flag can be used for type testing.
       *
       * @type {Boolean}
       * @readonly
       * @default true
       */
      _this87.isMeshBasicNodeMaterial = true;

      /**
       * Although the basic material is by definition unlit, we set
       * this property to `true` since we use a lighting model to compute
       * the outgoing light of the fragment shader.
       *
       * @type {Boolean}
       * @default true
       */
      _this87.lights = true;
      _this87.setDefaultValues(_defaultValues$9);
      _this87.setValues(parameters);
      return _this87;
    }

    /**
     * Basic materials are not affected by normal and bump maps so we
     * return by default {@link module:Normal.normalView}.
     *
     * @return {Node<vec3>} The normal node.
     */
    (0, _inherits2.default)(MeshBasicNodeMaterial, _NodeMaterial6);
    return (0, _createClass2.default)(MeshBasicNodeMaterial, [{
      key: "setupNormal",
      value: function setupNormal() {
        return normalView; // see #28839
      }

      /**
       * Overwritten since this type of material uses {@link BasicEnvironmentNode}
       * to implement the default environment mapping.
       *
       * @param {NodeBuilder} builder - The current node builder.
       * @return {BasicEnvironmentNode<vec3>?} The environment node.
       */
    }, {
      key: "setupEnvironment",
      value: function setupEnvironment(builder) {
        var envNode = _superPropGet(MeshBasicNodeMaterial, "setupEnvironment", this, 3)([builder]);
        return envNode ? new BasicEnvironmentNode(envNode) : null;
      }

      /**
       * This method must be overwriten since light maps are evaluated
       * with a special scaling factor for basic materials.
       *
       * @param {NodeBuilder} builder - The current node builder.
       * @return {BasicLightMapNode<vec3>?} The light map node.
       */
    }, {
      key: "setupLightMap",
      value: function setupLightMap(builder) {
        var node = null;
        if (builder.material.lightMap) {
          node = new BasicLightMapNode(materialLightMap);
        }
        return node;
      }

      /**
       * The material overwrites this method because `lights` is set to `true` but
       * we still want to return the diffuse color as the outgoing light.
       *
       * @return {Node<vec3>} The outgoing light node.
       */
    }, {
      key: "setupOutgoingLight",
      value: function setupOutgoingLight() {
        return diffuseColor.rgb;
      }

      /**
       * Setups the lighting model.
       *
       * @return {BasicLightingModel} The lighting model.
       */
    }, {
      key: "setupLightingModel",
      value: function setupLightingModel() {
        return new BasicLightingModel();
      }
    }], [{
      key: "type",
      get: function get() {
        return 'MeshBasicNodeMaterial';
      }
    }]);
  }(NodeMaterial);
  var F_Schlick = /*@__PURE__*/Fn(function (_ref56) {
    var f0 = _ref56.f0,
      f90 = _ref56.f90,
      dotVH = _ref56.dotVH;
    // Original approximation by Christophe Schlick '94
    // float fresnel = pow( 1.0 - dotVH, 5.0 );

    // Optimized variant (presented by Epic at SIGGRAPH '13)
    // https://cdn2.unrealengine.com/Resources/files/2013SiggraphPresentationsNotes-26915738.pdf
    var fresnel = dotVH.mul(-5.55473).sub(6.98316).mul(dotVH).exp2();
    return f0.mul(fresnel.oneMinus()).add(f90.mul(fresnel));
  }); // validated

  var BRDF_Lambert = /*@__PURE__*/Fn(function (inputs) {
    return inputs.diffuseColor.mul(1 / Math.PI); // punctual light
  }); // validated

  var G_BlinnPhong_Implicit = function G_BlinnPhong_Implicit() {
    return float(0.25);
  };
  var D_BlinnPhong = /*@__PURE__*/Fn(function (_ref57) {
    var dotNH = _ref57.dotNH;
    return shininess.mul(float(0.5)).add(1.0).mul(float(1 / Math.PI)).mul(dotNH.pow(shininess));
  });
  var BRDF_BlinnPhong = /*@__PURE__*/Fn(function (_ref58) {
    var lightDirection = _ref58.lightDirection;
    var halfDir = lightDirection.add(positionViewDirection).normalize();
    var dotNH = transformedNormalView.dot(halfDir).clamp();
    var dotVH = positionViewDirection.dot(halfDir).clamp();
    var F = F_Schlick({
      f0: specularColor,
      f90: 1.0,
      dotVH: dotVH
    });
    var G = G_BlinnPhong_Implicit();
    var D = D_BlinnPhong({
      dotNH: dotNH
    });
    return F.mul(G).mul(D);
  });

  /**
   * Represents the lighting model for a phong material. Used in {@link MeshPhongNodeMaterial}.
   *
   * @augments BasicLightingModel
   */
  var PhongLightingModel = exports.PhongLightingModel = /*#__PURE__*/function (_BasicLightingModel) {
    /**
     * Constructs a new phong lighting model.
     *
     * @param {Boolean} [specular=true] - Whether specular is supported or not.
     */
    function PhongLightingModel() {
      var _this88;
      var specular = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
      (0, _classCallCheck2.default)(this, PhongLightingModel);
      _this88 = _callSuper(this, PhongLightingModel);

      /**
       * Whether specular is supported or not. Set this to `false` if you are
       * looking for a Lambert-like material meaning a material for non-shiny
       * surfaces, without specular highlights.
       *
       * @type {Boolean}
       * @default true
       */
      _this88.specular = specular;
      return _this88;
    }

    /**
     * Implements the direct lighting. The specular portion is optional an can be controlled
     * with the {@link PhongLightingModel#specular} flag.
     *
     * @param {Object} input - The input data.
     * @param {StackNode} stack - The current stack.
     * @param {NodeBuilder} builder - The current node builder.
     */
    (0, _inherits2.default)(PhongLightingModel, _BasicLightingModel);
    return (0, _createClass2.default)(PhongLightingModel, [{
      key: "direct",
      value: function direct(_ref59) {
        var lightDirection = _ref59.lightDirection,
          lightColor = _ref59.lightColor,
          reflectedLight = _ref59.reflectedLight;
        var dotNL = transformedNormalView.dot(lightDirection).clamp();
        var irradiance = dotNL.mul(lightColor);
        reflectedLight.directDiffuse.addAssign(irradiance.mul(BRDF_Lambert({
          diffuseColor: diffuseColor.rgb
        })));
        if (this.specular === true) {
          reflectedLight.directSpecular.addAssign(irradiance.mul(BRDF_BlinnPhong({
            lightDirection: lightDirection
          })).mul(materialSpecularStrength));
        }
      }

      /**
       * Implements the indirect lighting.
       *
       * @param {ContextNode} input - The current node context.
       * @param {StackNode} stack - The current stack.
       * @param {NodeBuilder} builder - The current node builder.
       */
    }, {
      key: "indirect",
      value: function indirect(_ref60) {
        var ambientOcclusion = _ref60.ambientOcclusion,
          irradiance = _ref60.irradiance,
          reflectedLight = _ref60.reflectedLight;
        reflectedLight.indirectDiffuse.addAssign(irradiance.mul(BRDF_Lambert({
          diffuseColor: diffuseColor
        })));
        reflectedLight.indirectDiffuse.mulAssign(ambientOcclusion);
      }
    }]);
  }(BasicLightingModel);
  var _defaultValues$8 = /*@__PURE__*/new (_$$_REQUIRE(_dependencyMap[1], "./three.core.js").MeshLambertMaterial)();

  /**
   * Node material version of `MeshLambertMaterial`.
   *
   * @augments NodeMaterial
   */
  var MeshLambertNodeMaterial = exports.MeshLambertNodeMaterial = /*#__PURE__*/function (_NodeMaterial7) {
    /**
     * Constructs a new mesh lambert node material.
     *
     * @param {Object?} parameters - The configuration parameter.
     */
    function MeshLambertNodeMaterial(parameters) {
      var _this89;
      (0, _classCallCheck2.default)(this, MeshLambertNodeMaterial);
      _this89 = _callSuper(this, MeshLambertNodeMaterial);

      /**
       * This flag can be used for type testing.
       *
       * @type {Boolean}
       * @readonly
       * @default true
       */
      _this89.isMeshLambertNodeMaterial = true;

      /**
       * Set to `true` because lambert materials react on lights.
       *
       * @type {Boolean}
       * @default true
       */
      _this89.lights = true;
      _this89.setDefaultValues(_defaultValues$8);
      _this89.setValues(parameters);
      return _this89;
    }

    /**
     * Overwritten since this type of material uses {@link BasicEnvironmentNode}
     * to implement the default environment mapping.
     *
     * @param {NodeBuilder} builder - The current node builder.
     * @return {BasicEnvironmentNode<vec3>?} The environment node.
     */
    (0, _inherits2.default)(MeshLambertNodeMaterial, _NodeMaterial7);
    return (0, _createClass2.default)(MeshLambertNodeMaterial, [{
      key: "setupEnvironment",
      value: function setupEnvironment(builder) {
        var envNode = _superPropGet(MeshLambertNodeMaterial, "setupEnvironment", this, 3)([builder]);
        return envNode ? new BasicEnvironmentNode(envNode) : null;
      }

      /**
       * Setups the lighting model.
       *
       * @return {PhongLightingModel} The lighting model.
       */
    }, {
      key: "setupLightingModel",
      value: function setupLightingModel(/*builder*/
      ) {
        return new PhongLightingModel(false); // ( specular ) -> force lambert
      }
    }], [{
      key: "type",
      get: function get() {
        return 'MeshLambertNodeMaterial';
      }
    }]);
  }(NodeMaterial);
  var _defaultValues$7 = /*@__PURE__*/new (_$$_REQUIRE(_dependencyMap[1], "./three.core.js").MeshPhongMaterial)();

  /**
   * Node material version of `MeshPhongMaterial`.
   *
   * @augments NodeMaterial
   */
  var MeshPhongNodeMaterial = exports.MeshPhongNodeMaterial = /*#__PURE__*/function (_NodeMaterial8) {
    /**
     * Constructs a new mesh lambert node material.
     *
     * @param {Object?} parameters - The configuration parameter.
     */
    function MeshPhongNodeMaterial(parameters) {
      var _this90;
      (0, _classCallCheck2.default)(this, MeshPhongNodeMaterial);
      _this90 = _callSuper(this, MeshPhongNodeMaterial);

      /**
       * This flag can be used for type testing.
       *
       * @type {Boolean}
       * @readonly
       * @default true
       */
      _this90.isMeshPhongNodeMaterial = true;

      /**
       * Set to `true` because phong materials react on lights.
       *
       * @type {Boolean}
       * @default true
       */
      _this90.lights = true;

      /**
       * The shininess of phong materials is by default inferred from the `shininess`
       * property. This node property allows to overwrite the default
       * and define the shininess with a node instead.
       *
       * If you don't want to overwrite the shininess but modify the existing
       * value instead, use {@link module:MaterialNode.materialShininess}.
       *
       * @type {Node<float>?}
       * @default null
       */
      _this90.shininessNode = null;

      /**
       * The specular color of phong materials is by default inferred from the
       * `specular` property. This node property allows to overwrite the default
       * and define the specular color with a node instead.
       *
       * If you don't want to overwrite the specular color but modify the existing
       * value instead, use {@link module:MaterialNode.materialSpecular}.
       *
       * @type {Node<vec3>?}
       * @default null
       */
      _this90.specularNode = null;
      _this90.setDefaultValues(_defaultValues$7);
      _this90.setValues(parameters);
      return _this90;
    }

    /**
     * Overwritten since this type of material uses {@link BasicEnvironmentNode}
     * to implement the default environment mapping.
     *
     * @param {NodeBuilder} builder - The current node builder.
     * @return {BasicEnvironmentNode<vec3>?} The environment node.
     */
    (0, _inherits2.default)(MeshPhongNodeMaterial, _NodeMaterial8);
    return (0, _createClass2.default)(MeshPhongNodeMaterial, [{
      key: "setupEnvironment",
      value: function setupEnvironment(builder) {
        var envNode = _superPropGet(MeshPhongNodeMaterial, "setupEnvironment", this, 3)([builder]);
        return envNode ? new BasicEnvironmentNode(envNode) : null;
      }

      /**
       * Setups the lighting model.
       *
       * @return {PhongLightingModel} The lighting model.
       */
    }, {
      key: "setupLightingModel",
      value: function setupLightingModel(/*builder*/
      ) {
        return new PhongLightingModel();
      }

      /**
       * Setups the phong specific node variables.
       *
       * @param {NodeBuilder} builder - The current node builder.
       */
    }, {
      key: "setupVariants",
      value: function setupVariants(/*builder*/
      ) {
        // SHININESS

        var shininessNode = (this.shininessNode ? float(this.shininessNode) : materialShininess).max(1e-4); // to prevent pow( 0.0, 0.0 )

        shininess.assign(shininessNode);

        // SPECULAR COLOR

        var specularNode = this.specularNode || materialSpecular;
        specularColor.assign(specularNode);
      }
    }, {
      key: "copy",
      value: function copy(source) {
        this.shininessNode = source.shininessNode;
        this.specularNode = source.specularNode;
        return _superPropGet(MeshPhongNodeMaterial, "copy", this, 3)([source]);
      }
    }], [{
      key: "type",
      get: function get() {
        return 'MeshPhongNodeMaterial';
      }
    }]);
  }(NodeMaterial);
  var getGeometryRoughness = /*@__PURE__*/Fn(function (builder) {
    if (builder.geometry.hasAttribute('normal') === false) {
      return float(0);
    }
    var dxy = normalView.dFdx().abs().max(normalView.dFdy().abs());
    var geometryRoughness = dxy.x.max(dxy.y).max(dxy.z);
    return geometryRoughness;
  });
  var getRoughness = /*@__PURE__*/Fn(function (inputs) {
    var roughness = inputs.roughness;
    var geometryRoughness = getGeometryRoughness();
    var roughnessFactor = roughness.max(0.0525); // 0.0525 corresponds to the base mip of a 256 cubemap.
    roughnessFactor = roughnessFactor.add(geometryRoughness);
    roughnessFactor = roughnessFactor.min(1.0);
    return roughnessFactor;
  });

  // Moving Frostbite to Physically Based Rendering 3.0 - page 12, listing 2
  // https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
  var V_GGX_SmithCorrelated = /*@__PURE__*/Fn(function (_ref61) {
    var alpha = _ref61.alpha,
      dotNL = _ref61.dotNL,
      dotNV = _ref61.dotNV;
    var a2 = alpha.pow2();
    var gv = dotNL.mul(a2.add(a2.oneMinus().mul(dotNV.pow2())).sqrt());
    var gl = dotNV.mul(a2.add(a2.oneMinus().mul(dotNL.pow2())).sqrt());
    return div(0.5, gv.add(gl).max(EPSILON));
  }).setLayout({
    name: 'V_GGX_SmithCorrelated',
    type: 'float',
    inputs: [{
      name: 'alpha',
      type: 'float'
    }, {
      name: 'dotNL',
      type: 'float'
    }, {
      name: 'dotNV',
      type: 'float'
    }]
  }); // validated

  // https://google.github.io/filament/Filament.md.html#materialsystem/anisotropicmodel/anisotropicspecularbrdf

  var V_GGX_SmithCorrelated_Anisotropic = /*@__PURE__*/Fn(function (_ref62) {
    var alphaT = _ref62.alphaT,
      alphaB = _ref62.alphaB,
      dotTV = _ref62.dotTV,
      dotBV = _ref62.dotBV,
      dotTL = _ref62.dotTL,
      dotBL = _ref62.dotBL,
      dotNV = _ref62.dotNV,
      dotNL = _ref62.dotNL;
    var gv = dotNL.mul(vec3(alphaT.mul(dotTV), alphaB.mul(dotBV), dotNV).length());
    var gl = dotNV.mul(vec3(alphaT.mul(dotTL), alphaB.mul(dotBL), dotNL).length());
    var v = div(0.5, gv.add(gl));
    return v.saturate();
  }).setLayout({
    name: 'V_GGX_SmithCorrelated_Anisotropic',
    type: 'float',
    inputs: [{
      name: 'alphaT',
      type: 'float',
      qualifier: 'in'
    }, {
      name: 'alphaB',
      type: 'float',
      qualifier: 'in'
    }, {
      name: 'dotTV',
      type: 'float',
      qualifier: 'in'
    }, {
      name: 'dotBV',
      type: 'float',
      qualifier: 'in'
    }, {
      name: 'dotTL',
      type: 'float',
      qualifier: 'in'
    }, {
      name: 'dotBL',
      type: 'float',
      qualifier: 'in'
    }, {
      name: 'dotNV',
      type: 'float',
      qualifier: 'in'
    }, {
      name: 'dotNL',
      type: 'float',
      qualifier: 'in'
    }]
  });

  // Microfacet Models for Refraction through Rough Surfaces - equation (33)
  // http://graphicrants.blogspot.com/2013/08/specular-brdf-reference.html
  // alpha is "roughness squared" in Disneys reparameterization
  var D_GGX = /*@__PURE__*/Fn(function (_ref63) {
    var alpha = _ref63.alpha,
      dotNH = _ref63.dotNH;
    var a2 = alpha.pow2();
    var denom = dotNH.pow2().mul(a2.oneMinus()).oneMinus(); // avoid alpha = 0 with dotNH = 1

    return a2.div(denom.pow2()).mul(1 / Math.PI);
  }).setLayout({
    name: 'D_GGX',
    type: 'float',
    inputs: [{
      name: 'alpha',
      type: 'float'
    }, {
      name: 'dotNH',
      type: 'float'
    }]
  }); // validated

  var RECIPROCAL_PI = /*@__PURE__*/float(1 / Math.PI);

  // https://google.github.io/filament/Filament.md.html#materialsystem/anisotropicmodel/anisotropicspecularbrdf

  var D_GGX_Anisotropic = /*@__PURE__*/Fn(function (_ref64) {
    var alphaT = _ref64.alphaT,
      alphaB = _ref64.alphaB,
      dotNH = _ref64.dotNH,
      dotTH = _ref64.dotTH,
      dotBH = _ref64.dotBH;
    var a2 = alphaT.mul(alphaB);
    var v = vec3(alphaB.mul(dotTH), alphaT.mul(dotBH), a2.mul(dotNH));
    var v2 = v.dot(v);
    var w2 = a2.div(v2);
    return RECIPROCAL_PI.mul(a2.mul(w2.pow2()));
  }).setLayout({
    name: 'D_GGX_Anisotropic',
    type: 'float',
    inputs: [{
      name: 'alphaT',
      type: 'float',
      qualifier: 'in'
    }, {
      name: 'alphaB',
      type: 'float',
      qualifier: 'in'
    }, {
      name: 'dotNH',
      type: 'float',
      qualifier: 'in'
    }, {
      name: 'dotTH',
      type: 'float',
      qualifier: 'in'
    }, {
      name: 'dotBH',
      type: 'float',
      qualifier: 'in'
    }]
  });

  // GGX Distribution, Schlick Fresnel, GGX_SmithCorrelated Visibility
  var BRDF_GGX = /*@__PURE__*/Fn(function (inputs) {
    var lightDirection = inputs.lightDirection,
      f0 = inputs.f0,
      f90 = inputs.f90,
      roughness = inputs.roughness,
      f = inputs.f,
      USE_IRIDESCENCE = inputs.USE_IRIDESCENCE,
      USE_ANISOTROPY = inputs.USE_ANISOTROPY;
    var normalView = inputs.normalView || transformedNormalView;
    var alpha = roughness.pow2(); // UE4's roughness

    var halfDir = lightDirection.add(positionViewDirection).normalize();
    var dotNL = normalView.dot(lightDirection).clamp();
    var dotNV = normalView.dot(positionViewDirection).clamp(); // @ TODO: Move to core dotNV
    var dotNH = normalView.dot(halfDir).clamp();
    var dotVH = positionViewDirection.dot(halfDir).clamp();
    var F = F_Schlick({
      f0: f0,
      f90: f90,
      dotVH: dotVH
    });
    var V, D;
    if (defined(USE_IRIDESCENCE)) {
      F = iridescence.mix(F, f);
    }
    if (defined(USE_ANISOTROPY)) {
      var dotTL = anisotropyT.dot(lightDirection);
      var dotTV = anisotropyT.dot(positionViewDirection);
      var dotTH = anisotropyT.dot(halfDir);
      var dotBL = anisotropyB.dot(lightDirection);
      var dotBV = anisotropyB.dot(positionViewDirection);
      var dotBH = anisotropyB.dot(halfDir);
      V = V_GGX_SmithCorrelated_Anisotropic({
        alphaT: alphaT,
        alphaB: alpha,
        dotTV: dotTV,
        dotBV: dotBV,
        dotTL: dotTL,
        dotBL: dotBL,
        dotNV: dotNV,
        dotNL: dotNL
      });
      D = D_GGX_Anisotropic({
        alphaT: alphaT,
        alphaB: alpha,
        dotNH: dotNH,
        dotTH: dotTH,
        dotBH: dotBH
      });
    } else {
      V = V_GGX_SmithCorrelated({
        alpha: alpha,
        dotNL: dotNL,
        dotNV: dotNV
      });
      D = D_GGX({
        alpha: alpha,
        dotNH: dotNH
      });
    }
    return F.mul(V).mul(D);
  }); // validated

  // Analytical approximation of the DFG LUT, one half of the
  // split-sum approximation used in indirect specular lighting.
  // via 'environmentBRDF' from "Physically Based Shading on Mobile"
  // https://www.unrealengine.com/blog/physically-based-shading-on-mobile
  var DFGApprox = /*@__PURE__*/Fn(function (_ref65) {
    var roughness = _ref65.roughness,
      dotNV = _ref65.dotNV;
    var c0 = vec4(-1, -0.0275, -0.572, 0.022);
    var c1 = vec4(1, 0.0425, 1.04, -0.04);
    var r = roughness.mul(c0).add(c1);
    var a004 = r.x.mul(r.x).min(dotNV.mul(-9.28).exp2()).mul(r.x).add(r.y);
    var fab = vec2(-1.04, 1.04).mul(a004).add(r.zw);
    return fab;
  }).setLayout({
    name: 'DFGApprox',
    type: 'vec2',
    inputs: [{
      name: 'roughness',
      type: 'float'
    }, {
      name: 'dotNV',
      type: 'vec3'
    }]
  });
  var EnvironmentBRDF = /*@__PURE__*/Fn(function (inputs) {
    var dotNV = inputs.dotNV,
      specularColor = inputs.specularColor,
      specularF90 = inputs.specularF90,
      roughness = inputs.roughness;
    var fab = DFGApprox({
      dotNV: dotNV,
      roughness: roughness
    });
    return specularColor.mul(fab.x).add(specularF90.mul(fab.y));
  });
  var Schlick_to_F0 = /*@__PURE__*/Fn(function (_ref66) {
    var f = _ref66.f,
      f90 = _ref66.f90,
      dotVH = _ref66.dotVH;
    var x = dotVH.oneMinus().saturate();
    var x2 = x.mul(x);
    var x5 = x.mul(x2, x2).clamp(0, .9999);
    return f.sub(vec3(f90).mul(x5)).div(x5.oneMinus());
  }).setLayout({
    name: 'Schlick_to_F0',
    type: 'vec3',
    inputs: [{
      name: 'f',
      type: 'vec3'
    }, {
      name: 'f90',
      type: 'float'
    }, {
      name: 'dotVH',
      type: 'float'
    }]
  });

  // https://github.com/google/filament/blob/master/shaders/src/brdf.fs
  var D_Charlie = /*@__PURE__*/Fn(function (_ref67) {
    var roughness = _ref67.roughness,
      dotNH = _ref67.dotNH;
    var alpha = roughness.pow2();

    // Estevez and Kulla 2017, "Production Friendly Microfacet Sheen BRDF"
    var invAlpha = float(1.0).div(alpha);
    var cos2h = dotNH.pow2();
    var sin2h = cos2h.oneMinus().max(0.0078125); // 2^(-14/2), so sin2h^2 > 0 in fp16

    return float(2.0).add(invAlpha).mul(sin2h.pow(invAlpha.mul(0.5))).div(2.0 * Math.PI);
  }).setLayout({
    name: 'D_Charlie',
    type: 'float',
    inputs: [{
      name: 'roughness',
      type: 'float'
    }, {
      name: 'dotNH',
      type: 'float'
    }]
  });

  // https://github.com/google/filament/blob/master/shaders/src/brdf.fs
  var V_Neubelt = /*@__PURE__*/Fn(function (_ref68) {
    var dotNV = _ref68.dotNV,
      dotNL = _ref68.dotNL;
    // Neubelt and Pettineo 2013, "Crafting a Next-gen Material Pipeline for The Order: 1886"
    return float(1.0).div(float(4.0).mul(dotNL.add(dotNV).sub(dotNL.mul(dotNV))));
  }).setLayout({
    name: 'V_Neubelt',
    type: 'float',
    inputs: [{
      name: 'dotNV',
      type: 'float'
    }, {
      name: 'dotNL',
      type: 'float'
    }]
  });
  var BRDF_Sheen = /*@__PURE__*/Fn(function (_ref69) {
    var lightDirection = _ref69.lightDirection;
    var halfDir = lightDirection.add(positionViewDirection).normalize();
    var dotNL = transformedNormalView.dot(lightDirection).clamp();
    var dotNV = transformedNormalView.dot(positionViewDirection).clamp();
    var dotNH = transformedNormalView.dot(halfDir).clamp();
    var D = D_Charlie({
      roughness: sheenRoughness,
      dotNH: dotNH
    });
    var V = V_Neubelt({
      dotNV: dotNV,
      dotNL: dotNL
    });
    return sheen.mul(D).mul(V);
  });

  // Rect Area Light

  // Real-Time Polygonal-Light Shading with Linearly Transformed Cosines
  // by Eric Heitz, Jonathan Dupuy, Stephen Hill and David Neubelt
  // code: https://github.com/selfshadow/ltc_code/

  var LTC_Uv = /*@__PURE__*/Fn(function (_ref70) {
    var N = _ref70.N,
      V = _ref70.V,
      roughness = _ref70.roughness;
    var LUT_SIZE = 64.0;
    var LUT_SCALE = (LUT_SIZE - 1.0) / LUT_SIZE;
    var LUT_BIAS = 0.5 / LUT_SIZE;
    var dotNV = N.dot(V).saturate();

    // texture parameterized by sqrt( GGX alpha ) and sqrt( 1 - cos( theta ) )
    var uv = vec2(roughness, dotNV.oneMinus().sqrt());
    uv.assign(uv.mul(LUT_SCALE).add(LUT_BIAS));
    return uv;
  }).setLayout({
    name: 'LTC_Uv',
    type: 'vec2',
    inputs: [{
      name: 'N',
      type: 'vec3'
    }, {
      name: 'V',
      type: 'vec3'
    }, {
      name: 'roughness',
      type: 'float'
    }]
  });
  var LTC_ClippedSphereFormFactor = /*@__PURE__*/Fn(function (_ref71) {
    var f = _ref71.f;
    // Real-Time Area Lighting: a Journey from Research to Production (p.102)
    // An approximation of the form factor of a horizon-clipped rectangle.

    var l = f.length();
    return max$1(l.mul(l).add(f.z).div(l.add(1.0)), 0);
  }).setLayout({
    name: 'LTC_ClippedSphereFormFactor',
    type: 'float',
    inputs: [{
      name: 'f',
      type: 'vec3'
    }]
  });
  var LTC_EdgeVectorFormFactor = /*@__PURE__*/Fn(function (_ref72) {
    var v1 = _ref72.v1,
      v2 = _ref72.v2;
    var x = v1.dot(v2);
    var y = x.abs().toVar();

    // rational polynomial approximation to theta / sin( theta ) / 2PI
    var a = y.mul(0.0145206).add(0.4965155).mul(y).add(0.8543985).toVar();
    var b = y.add(4.1616724).mul(y).add(3.4175940).toVar();
    var v = a.div(b);
    var theta_sintheta = x.greaterThan(0.0).select(v, max$1(x.mul(x).oneMinus(), 1e-7).inverseSqrt().mul(0.5).sub(v));
    return v1.cross(v2).mul(theta_sintheta);
  }).setLayout({
    name: 'LTC_EdgeVectorFormFactor',
    type: 'vec3',
    inputs: [{
      name: 'v1',
      type: 'vec3'
    }, {
      name: 'v2',
      type: 'vec3'
    }]
  });
  var LTC_Evaluate = /*@__PURE__*/Fn(function (_ref73) {
    var N = _ref73.N,
      V = _ref73.V,
      P = _ref73.P,
      mInv = _ref73.mInv,
      p0 = _ref73.p0,
      p1 = _ref73.p1,
      p2 = _ref73.p2,
      p3 = _ref73.p3;
    // bail if point is on back side of plane of light
    // assumes ccw winding order of light vertices
    var v1 = p1.sub(p0).toVar();
    var v2 = p3.sub(p0).toVar();
    var lightNormal = v1.cross(v2);
    var result = vec3().toVar();
    If(lightNormal.dot(P.sub(p0)).greaterThanEqual(0.0), function () {
      // construct orthonormal basis around N
      var T1 = V.sub(N.mul(V.dot(N))).normalize();
      var T2 = N.cross(T1).negate(); // negated from paper; possibly due to a different handedness of world coordinate system

      // compute transform
      var mat = mInv.mul(mat3(T1, T2, N).transpose()).toVar();

      // transform rect
      // & project rect onto sphere
      var coords0 = mat.mul(p0.sub(P)).normalize().toVar();
      var coords1 = mat.mul(p1.sub(P)).normalize().toVar();
      var coords2 = mat.mul(p2.sub(P)).normalize().toVar();
      var coords3 = mat.mul(p3.sub(P)).normalize().toVar();

      // calculate vector form factor
      var vectorFormFactor = vec3(0).toVar();
      vectorFormFactor.addAssign(LTC_EdgeVectorFormFactor({
        v1: coords0,
        v2: coords1
      }));
      vectorFormFactor.addAssign(LTC_EdgeVectorFormFactor({
        v1: coords1,
        v2: coords2
      }));
      vectorFormFactor.addAssign(LTC_EdgeVectorFormFactor({
        v1: coords2,
        v2: coords3
      }));
      vectorFormFactor.addAssign(LTC_EdgeVectorFormFactor({
        v1: coords3,
        v2: coords0
      }));

      // adjust for horizon clipping
      result.assign(vec3(LTC_ClippedSphereFormFactor({
        f: vectorFormFactor
      })));
    });
    return result;
  }).setLayout({
    name: 'LTC_Evaluate',
    type: 'vec3',
    inputs: [{
      name: 'N',
      type: 'vec3'
    }, {
      name: 'V',
      type: 'vec3'
    }, {
      name: 'P',
      type: 'vec3'
    }, {
      name: 'mInv',
      type: 'mat3'
    }, {
      name: 'p0',
      type: 'vec3'
    }, {
      name: 'p1',
      type: 'vec3'
    }, {
      name: 'p2',
      type: 'vec3'
    }, {
      name: 'p3',
      type: 'vec3'
    }]
  });

  /** @module TextureBicubic **/

  // Mipped Bicubic Texture Filtering by N8
  // https://www.shadertoy.com/view/Dl2SDW

  var bC = 1.0 / 6.0;
  var w0 = function w0(a) {
    return mul(bC, mul(a, mul(a, a.negate().add(3.0)).sub(3.0)).add(1.0));
  };
  var w1 = function w1(a) {
    return mul(bC, mul(a, mul(a, mul(3.0, a).sub(6.0))).add(4.0));
  };
  var w2 = function w2(a) {
    return mul(bC, mul(a, mul(a, mul(-3.0, a).add(3.0)).add(3.0)).add(1.0));
  };
  var w3 = function w3(a) {
    return mul(bC, pow(a, 3));
  };
  var g0 = function g0(a) {
    return w0(a).add(w1(a));
  };
  var g1 = function g1(a) {
    return w2(a).add(w3(a));
  };

  // h0 and h1 are the two offset functions
  var h0 = function h0(a) {
    return add(-1.0, w1(a).div(w0(a).add(w1(a))));
  };
  var h1 = function h1(a) {
    return add(1.0, w3(a).div(w2(a).add(w3(a))));
  };
  var bicubic = function bicubic(textureNode, texelSize, lod) {
    var uv = textureNode.uvNode;
    var uvScaled = mul(uv, texelSize.zw).add(0.5);
    var iuv = floor(uvScaled);
    var fuv = fract(uvScaled);
    var g0x = g0(fuv.x);
    var g1x = g1(fuv.x);
    var h0x = h0(fuv.x);
    var h1x = h1(fuv.x);
    var h0y = h0(fuv.y);
    var h1y = h1(fuv.y);
    var p0 = vec2(iuv.x.add(h0x), iuv.y.add(h0y)).sub(0.5).mul(texelSize.xy);
    var p1 = vec2(iuv.x.add(h1x), iuv.y.add(h0y)).sub(0.5).mul(texelSize.xy);
    var p2 = vec2(iuv.x.add(h0x), iuv.y.add(h1y)).sub(0.5).mul(texelSize.xy);
    var p3 = vec2(iuv.x.add(h1x), iuv.y.add(h1y)).sub(0.5).mul(texelSize.xy);
    var a = g0(fuv.y).mul(add(g0x.mul(textureNode.sample(p0).level(lod)), g1x.mul(textureNode.sample(p1).level(lod))));
    var b = g1(fuv.y).mul(add(g0x.mul(textureNode.sample(p2).level(lod)), g1x.mul(textureNode.sample(p3).level(lod))));
    return a.add(b);
  };

  /**
   * Applies mipped bicubic texture filtering to the given texture node.
   *
   * @method
   * @param {TextureNode} textureNode - The texture node that should be filtered.
   * @param {Node<float>} [lodNode=float(3)] - Defines the LOD to sample from.
   * @return {Node} The filtered texture sample.
   */
  var textureBicubic = /*@__PURE__*/Fn(function (_ref74) {
    var _ref75 = (0, _slicedToArray2.default)(_ref74, 2),
      textureNode = _ref75[0],
      _ref75$ = _ref75[1],
      lodNode = _ref75$ === void 0 ? float(3) : _ref75$;
    var fLodSize = vec2(textureNode.size(int(lodNode)));
    var cLodSize = vec2(textureNode.size(int(lodNode.add(1.0))));
    var fLodSizeInv = div(1.0, fLodSize);
    var cLodSizeInv = div(1.0, cLodSize);
    var fSample = bicubic(textureNode, vec4(fLodSizeInv, fLodSize), floor(lodNode));
    var cSample = bicubic(textureNode, vec4(cLodSizeInv, cLodSize), ceil(lodNode));
    return fract(lodNode).mix(fSample, cSample);
  });

  //
  // Transmission
  //

  var getVolumeTransmissionRay = /*@__PURE__*/Fn(function (_ref76) {
    var _ref77 = (0, _slicedToArray2.default)(_ref76, 5),
      n = _ref77[0],
      v = _ref77[1],
      thickness = _ref77[2],
      ior = _ref77[3],
      modelMatrix = _ref77[4];
    // Direction of refracted light.
    var refractionVector = vec3(refract(v.negate(), normalize(n), div(1.0, ior)));

    // Compute rotation-independent scaling of the model matrix.
    var modelScale = vec3(length(modelMatrix[0].xyz), length(modelMatrix[1].xyz), length(modelMatrix[2].xyz));

    // The thickness is specified in local space.
    return normalize(refractionVector).mul(thickness.mul(modelScale));
  }).setLayout({
    name: 'getVolumeTransmissionRay',
    type: 'vec3',
    inputs: [{
      name: 'n',
      type: 'vec3'
    }, {
      name: 'v',
      type: 'vec3'
    }, {
      name: 'thickness',
      type: 'float'
    }, {
      name: 'ior',
      type: 'float'
    }, {
      name: 'modelMatrix',
      type: 'mat4'
    }]
  });
  var applyIorToRoughness = /*@__PURE__*/Fn(function (_ref78) {
    var _ref79 = (0, _slicedToArray2.default)(_ref78, 2),
      roughness = _ref79[0],
      ior = _ref79[1];
    // Scale roughness with IOR so that an IOR of 1.0 results in no microfacet refraction and
    // an IOR of 1.5 results in the default amount of microfacet refraction.
    return roughness.mul(clamp(ior.mul(2.0).sub(2.0), 0.0, 1.0));
  }).setLayout({
    name: 'applyIorToRoughness',
    type: 'float',
    inputs: [{
      name: 'roughness',
      type: 'float'
    }, {
      name: 'ior',
      type: 'float'
    }]
  });
  var viewportBackSideTexture = /*@__PURE__*/viewportMipTexture();
  var viewportFrontSideTexture = /*@__PURE__*/viewportMipTexture();
  var getTransmissionSample = /*@__PURE__*/Fn(function (_ref80, _ref81) {
    var _ref82 = (0, _slicedToArray2.default)(_ref80, 3),
      fragCoord = _ref82[0],
      roughness = _ref82[1],
      ior = _ref82[2];
    var material = _ref81.material;
    var vTexture = material.side === _$$_REQUIRE(_dependencyMap[1], "./three.core.js").BackSide ? viewportBackSideTexture : viewportFrontSideTexture;
    var transmissionSample = vTexture.sample(fragCoord);
    //const transmissionSample = viewportMipTexture( fragCoord );

    var lod = log2(screenSize.x).mul(applyIorToRoughness(roughness, ior));
    return textureBicubic(transmissionSample, lod);
  });
  var volumeAttenuation = /*@__PURE__*/Fn(function (_ref83) {
    var _ref84 = (0, _slicedToArray2.default)(_ref83, 3),
      transmissionDistance = _ref84[0],
      attenuationColor = _ref84[1],
      attenuationDistance = _ref84[2];
    If(attenuationDistance.notEqual(0), function () {
      // Compute light attenuation using Beer's law.
      var attenuationCoefficient = log(attenuationColor).negate().div(attenuationDistance);
      var transmittance = exp(attenuationCoefficient.negate().mul(transmissionDistance));
      return transmittance;
    });

    // Attenuation distance is +, i.e. the transmitted color is not attenuated at all.
    return vec3(1.0);
  }).setLayout({
    name: 'volumeAttenuation',
    type: 'vec3',
    inputs: [{
      name: 'transmissionDistance',
      type: 'float'
    }, {
      name: 'attenuationColor',
      type: 'vec3'
    }, {
      name: 'attenuationDistance',
      type: 'float'
    }]
  });
  var getIBLVolumeRefraction = /*@__PURE__*/Fn(function (_ref85) {
    var _ref86 = (0, _slicedToArray2.default)(_ref85, 15),
      n = _ref86[0],
      v = _ref86[1],
      roughness = _ref86[2],
      diffuseColor = _ref86[3],
      specularColor = _ref86[4],
      specularF90 = _ref86[5],
      position = _ref86[6],
      modelMatrix = _ref86[7],
      viewMatrix = _ref86[8],
      projMatrix = _ref86[9],
      ior = _ref86[10],
      thickness = _ref86[11],
      attenuationColor = _ref86[12],
      attenuationDistance = _ref86[13],
      dispersion = _ref86[14];
    var transmittedLight, transmittance;
    if (dispersion) {
      transmittedLight = vec4().toVar();
      transmittance = vec3().toVar();
      var halfSpread = ior.sub(1.0).mul(dispersion.mul(0.025));
      var iors = vec3(ior.sub(halfSpread), ior, ior.add(halfSpread));
      Loop({
        start: 0,
        end: 3
      }, function (_ref87) {
        var i = _ref87.i;
        var ior = iors.element(i);
        var transmissionRay = getVolumeTransmissionRay(n, v, thickness, ior, modelMatrix);
        var refractedRayExit = position.add(transmissionRay);

        // Project refracted vector on the framebuffer, while mapping to normalized device coordinates.
        var ndcPos = projMatrix.mul(viewMatrix.mul(vec4(refractedRayExit, 1.0)));
        var refractionCoords = vec2(ndcPos.xy.div(ndcPos.w)).toVar();
        refractionCoords.addAssign(1.0);
        refractionCoords.divAssign(2.0);
        refractionCoords.assign(vec2(refractionCoords.x, refractionCoords.y.oneMinus())); // webgpu

        // Sample framebuffer to get pixel the refracted ray hits.
        var transmissionSample = getTransmissionSample(refractionCoords, roughness, ior);
        transmittedLight.element(i).assign(transmissionSample.element(i));
        transmittedLight.a.addAssign(transmissionSample.a);
        transmittance.element(i).assign(diffuseColor.element(i).mul(volumeAttenuation(length(transmissionRay), attenuationColor, attenuationDistance).element(i)));
      });
      transmittedLight.a.divAssign(3.0);
    } else {
      var transmissionRay = getVolumeTransmissionRay(n, v, thickness, ior, modelMatrix);
      var refractedRayExit = position.add(transmissionRay);

      // Project refracted vector on the framebuffer, while mapping to normalized device coordinates.
      var ndcPos = projMatrix.mul(viewMatrix.mul(vec4(refractedRayExit, 1.0)));
      var refractionCoords = vec2(ndcPos.xy.div(ndcPos.w)).toVar();
      refractionCoords.addAssign(1.0);
      refractionCoords.divAssign(2.0);
      refractionCoords.assign(vec2(refractionCoords.x, refractionCoords.y.oneMinus())); // webgpu

      // Sample framebuffer to get pixel the refracted ray hits.
      transmittedLight = getTransmissionSample(refractionCoords, roughness, ior);
      transmittance = diffuseColor.mul(volumeAttenuation(length(transmissionRay), attenuationColor, attenuationDistance));
    }
    var attenuatedColor = transmittance.rgb.mul(transmittedLight.rgb);
    var dotNV = n.dot(v).clamp();

    // Get the specular component.
    var F = vec3(EnvironmentBRDF({
      // n, v, specularColor, specularF90, roughness
      dotNV: dotNV,
      specularColor: specularColor,
      specularF90: specularF90,
      roughness: roughness
    }));

    // As less light is transmitted, the opacity should be increased. This simple approximation does a decent job
    // of modulating a CSS background, and has no effect when the buffer is opaque, due to a solid object or clear color.
    var transmittanceFactor = transmittance.r.add(transmittance.g, transmittance.b).div(3.0);
    return vec4(F.oneMinus().mul(attenuatedColor), transmittedLight.a.oneMinus().mul(transmittanceFactor).oneMinus());
  });

  //
  // Iridescence
  //

  // XYZ to linear-sRGB color space
  var XYZ_TO_REC709 = /*@__PURE__*/mat3(3.2404542, -0.9692660, 0.0556434, -1.5371385, 1.8760108, -0.2040259, -0.4985314, 0.0415560, 1.0572252);

  // Assume air interface for top
  // Note: We don't handle the case fresnel0 == 1
  var Fresnel0ToIor = function Fresnel0ToIor(fresnel0) {
    var sqrtF0 = fresnel0.sqrt();
    return vec3(1.0).add(sqrtF0).div(vec3(1.0).sub(sqrtF0));
  };

  // ior is a value between 1.0 and 3.0. 1.0 is air interface
  var IorToFresnel0 = function IorToFresnel0(transmittedIor, incidentIor) {
    return transmittedIor.sub(incidentIor).div(transmittedIor.add(incidentIor)).pow2();
  };

  // Fresnel equations for dielectric/dielectric interfaces.
  // Ref: https://belcour.github.io/blog/research/2017/05/01/brdf-thin-film.html
  // Evaluation XYZ sensitivity curves in Fourier space
  var evalSensitivity = function evalSensitivity(OPD, shift) {
    var phase = OPD.mul(2.0 * Math.PI * 1.0e-9);
    var val = vec3(5.4856e-13, 4.4201e-13, 5.2481e-13);
    var pos = vec3(1.6810e+06, 1.7953e+06, 2.2084e+06);
    var VAR = vec3(4.3278e+09, 9.3046e+09, 6.6121e+09);
    var x = float(9.7470e-14 * Math.sqrt(2.0 * Math.PI * 4.5282e+09)).mul(phase.mul(2.2399e+06).add(shift.x).cos()).mul(phase.pow2().mul(-4.5282e+09).exp());
    var xyz = val.mul(VAR.mul(2.0 * Math.PI).sqrt()).mul(pos.mul(phase).add(shift).cos()).mul(phase.pow2().negate().mul(VAR).exp());
    xyz = vec3(xyz.x.add(x), xyz.y, xyz.z).div(1.0685e-7);
    var rgb = XYZ_TO_REC709.mul(xyz);
    return rgb;
  };
  var evalIridescence = /*@__PURE__*/Fn(function (_ref88) {
    var outsideIOR = _ref88.outsideIOR,
      eta2 = _ref88.eta2,
      cosTheta1 = _ref88.cosTheta1,
      thinFilmThickness = _ref88.thinFilmThickness,
      baseF0 = _ref88.baseF0;
    // Force iridescenceIOR -> outsideIOR when thinFilmThickness -> 0.0
    var iridescenceIOR = mix(outsideIOR, eta2, smoothstep(0.0, 0.03, thinFilmThickness));
    // Evaluate the cosTheta on the base layer (Snell law)
    var sinTheta2Sq = outsideIOR.div(iridescenceIOR).pow2().mul(cosTheta1.pow2().oneMinus());

    // Handle TIR:
    var cosTheta2Sq = sinTheta2Sq.oneMinus();
    If(cosTheta2Sq.lessThan(0), function () {
      return vec3(1.0);
    });
    var cosTheta2 = cosTheta2Sq.sqrt();

    // First interface
    var R0 = IorToFresnel0(iridescenceIOR, outsideIOR);
    var R12 = F_Schlick({
      f0: R0,
      f90: 1.0,
      dotVH: cosTheta1
    });
    //const R21 = R12;
    var T121 = R12.oneMinus();
    var phi12 = iridescenceIOR.lessThan(outsideIOR).select(Math.PI, 0.0);
    var phi21 = float(Math.PI).sub(phi12);

    // Second interface
    var baseIOR = Fresnel0ToIor(baseF0.clamp(0.0, 0.9999)); // guard against 1.0
    var R1 = IorToFresnel0(baseIOR, iridescenceIOR.toVec3());
    var R23 = F_Schlick({
      f0: R1,
      f90: 1.0,
      dotVH: cosTheta2
    });
    var phi23 = vec3(baseIOR.x.lessThan(iridescenceIOR).select(Math.PI, 0.0), baseIOR.y.lessThan(iridescenceIOR).select(Math.PI, 0.0), baseIOR.z.lessThan(iridescenceIOR).select(Math.PI, 0.0));

    // Phase shift
    var OPD = iridescenceIOR.mul(thinFilmThickness, cosTheta2, 2.0);
    var phi = vec3(phi21).add(phi23);

    // Compound terms
    var R123 = R12.mul(R23).clamp(1e-5, 0.9999);
    var r123 = R123.sqrt();
    var Rs = T121.pow2().mul(R23).div(vec3(1.0).sub(R123));

    // Reflectance term for m = 0 (DC term amplitude)
    var C0 = R12.add(Rs);
    var I = C0.toVar();

    // Reflectance term for m > 0 (pairs of diracs)
    var Cm = Rs.sub(T121).toVar();
    Loop({
      start: 1,
      end: 2,
      condition: '<=',
      name: 'm'
    }, function (_ref89) {
      var m = _ref89.m;
      Cm.mulAssign(r123);
      var Sm = evalSensitivity(float(m).mul(OPD), float(m).mul(phi)).mul(2.0);
      I.addAssign(Cm.mul(Sm));
    });

    // Since out of gamut colors might be produced, negative color values are clamped to 0.
    return I.max(vec3(0.0));
  }).setLayout({
    name: 'evalIridescence',
    type: 'vec3',
    inputs: [{
      name: 'outsideIOR',
      type: 'float'
    }, {
      name: 'eta2',
      type: 'float'
    }, {
      name: 'cosTheta1',
      type: 'float'
    }, {
      name: 'thinFilmThickness',
      type: 'float'
    }, {
      name: 'baseF0',
      type: 'vec3'
    }]
  });

  //
  //	Sheen
  //

  // This is a curve-fit approximation to the "Charlie sheen" BRDF integrated over the hemisphere from
  // Estevez and Kulla 2017, "Production Friendly Microfacet Sheen BRDF". The analysis can be found
  // in the Sheen section of https://drive.google.com/file/d/1T0D1VSyR4AllqIJTQAraEIzjlb5h4FKH/view?usp=sharing
  var IBLSheenBRDF = /*@__PURE__*/Fn(function (_ref90) {
    var normal = _ref90.normal,
      viewDir = _ref90.viewDir,
      roughness = _ref90.roughness;
    var dotNV = normal.dot(viewDir).saturate();
    var r2 = roughness.pow2();
    var a = select(roughness.lessThan(0.25), float(-339.2).mul(r2).add(float(161.4).mul(roughness)).sub(25.9), float(-8.48).mul(r2).add(float(14.3).mul(roughness)).sub(9.95));
    var b = select(roughness.lessThan(0.25), float(44.0).mul(r2).sub(float(23.7).mul(roughness)).add(3.26), float(1.97).mul(r2).sub(float(3.27).mul(roughness)).add(0.72));
    var DG = select(roughness.lessThan(0.25), 0.0, float(0.1).mul(roughness).sub(0.025)).add(a.mul(dotNV).add(b).exp());
    return DG.mul(1.0 / Math.PI).saturate();
  });
  var clearcoatF0 = vec3(0.04);
  var clearcoatF90 = float(1);

  /**
   * Represents the lighting model for a PBR material.
   *
   * @augments LightingModel
   */
  var PhysicalLightingModel = exports.PhysicalLightingModel = /*#__PURE__*/function (_LightingModel2) {
    /**
     * Constructs a new physical lighting model.
     *
     * @param {Boolean} [clearcoat=false] - Whether clearcoat is supported or not.
     * @param {Boolean} [sheen=false] - Whether sheen is supported or not.
     * @param {Boolean} [iridescence=false] - Whether iridescence is supported or not.
     * @param {Boolean} [anisotropy=false] - Whether anisotropy is supported or not.
     * @param {Boolean} [transmission=false] - Whether transmission is supported or not.
     * @param {Boolean} [dispersion=false] - Whether dispersion is supported or not.
     */
    function PhysicalLightingModel() {
      var _this91;
      var clearcoat = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      var sheen = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      var iridescence = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      var anisotropy = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
      var transmission = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
      var dispersion = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;
      (0, _classCallCheck2.default)(this, PhysicalLightingModel);
      _this91 = _callSuper(this, PhysicalLightingModel);

      /**
       * Whether clearcoat is supported or not.
       *
       * @type {Boolean}
       * @default false
       */
      _this91.clearcoat = clearcoat;

      /**
       * Whether sheen is supported or not.
       *
       * @type {Boolean}
       * @default false
       */
      _this91.sheen = sheen;

      /**
       * Whether iridescence is supported or not.
       *
       * @type {Boolean}
       * @default false
       */
      _this91.iridescence = iridescence;

      /**
       * Whether anisotropy is supported or not.
       *
       * @type {Boolean}
       * @default false
       */
      _this91.anisotropy = anisotropy;

      /**
       * Whether transmission is supported or not.
       *
       * @type {Boolean}
       * @default false
       */
      _this91.transmission = transmission;

      /**
       * Whether dispersion is supported or not.
       *
       * @type {Boolean}
       * @default false
       */
      _this91.dispersion = dispersion;

      /**
       * The clear coat radiance.
       *
       * @type {Node?}
       * @default null
       */
      _this91.clearcoatRadiance = null;

      /**
       * The clear coat specular direct.
       *
       * @type {Node?}
       * @default null
       */
      _this91.clearcoatSpecularDirect = null;

      /**
       * The clear coat specular indirect.
       *
       * @type {Node?}
       * @default null
       */
      _this91.clearcoatSpecularIndirect = null;

      /**
       * The sheen specular direct.
       *
       * @type {Node?}
       * @default null
       */
      _this91.sheenSpecularDirect = null;

      /**
       * The sheen specular indirect.
       *
       * @type {Node?}
       * @default null
       */
      _this91.sheenSpecularIndirect = null;

      /**
       * The iridescence Fresnel.
       *
       * @type {Node?}
       * @default null
       */
      _this91.iridescenceFresnel = null;

      /**
       * The iridescence F0.
       *
       * @type {Node?}
       * @default null
       */
      _this91.iridescenceF0 = null;
      return _this91;
    }

    /**
     * Depending on what features are requested, the method prepares certain node variables
     * which are later used for lighting computations.
     *
     * @param {ContextNode} context - The current node context.
     */
    (0, _inherits2.default)(PhysicalLightingModel, _LightingModel2);
    return (0, _createClass2.default)(PhysicalLightingModel, [{
      key: "start",
      value: function start(context) {
        if (this.clearcoat === true) {
          this.clearcoatRadiance = vec3().toVar('clearcoatRadiance');
          this.clearcoatSpecularDirect = vec3().toVar('clearcoatSpecularDirect');
          this.clearcoatSpecularIndirect = vec3().toVar('clearcoatSpecularIndirect');
        }
        if (this.sheen === true) {
          this.sheenSpecularDirect = vec3().toVar('sheenSpecularDirect');
          this.sheenSpecularIndirect = vec3().toVar('sheenSpecularIndirect');
        }
        if (this.iridescence === true) {
          var dotNVi = transformedNormalView.dot(positionViewDirection).clamp();
          this.iridescenceFresnel = evalIridescence({
            outsideIOR: float(1.0),
            eta2: iridescenceIOR,
            cosTheta1: dotNVi,
            thinFilmThickness: iridescenceThickness,
            baseF0: specularColor
          });
          this.iridescenceF0 = Schlick_to_F0({
            f: this.iridescenceFresnel,
            f90: 1.0,
            dotVH: dotNVi
          });
        }
        if (this.transmission === true) {
          var position = positionWorld;
          var v = cameraPosition.sub(positionWorld).normalize(); // TODO: Create Node for this, same issue in MaterialX
          var n = transformedNormalWorld;
          context.backdrop = getIBLVolumeRefraction(n, v, roughness, diffuseColor, specularColor, specularF90,
          // specularF90
          position,
          // positionWorld
          modelWorldMatrix,
          // modelMatrix
          cameraViewMatrix,
          // viewMatrix
          cameraProjectionMatrix,
          // projMatrix
          ior, thickness, attenuationColor, attenuationDistance, this.dispersion ? dispersion : null);
          context.backdropAlpha = transmission;
          diffuseColor.a.mulAssign(mix(1, context.backdrop.a, transmission));
        }
      }

      // Fdez-Agera's "Multiple-Scattering Microfacet Model for Real-Time Image Based Lighting"
      // Approximates multi-scattering in order to preserve energy.
      // http://www.jcgt.org/published/0008/01/03/
    }, {
      key: "computeMultiscattering",
      value: function computeMultiscattering(singleScatter, multiScatter, specularF90) {
        var dotNV = transformedNormalView.dot(positionViewDirection).clamp(); // @ TODO: Move to core dotNV

        var fab = DFGApprox({
          roughness: roughness,
          dotNV: dotNV
        });
        var Fr = this.iridescenceF0 ? iridescence.mix(specularColor, this.iridescenceF0) : specularColor;
        var FssEss = Fr.mul(fab.x).add(specularF90.mul(fab.y));
        var Ess = fab.x.add(fab.y);
        var Ems = Ess.oneMinus();
        var Favg = specularColor.add(specularColor.oneMinus().mul(0.047619)); // 1/21
        var Fms = FssEss.mul(Favg).div(Ems.mul(Favg).oneMinus());
        singleScatter.addAssign(FssEss);
        multiScatter.addAssign(Fms.mul(Ems));
      }

      /**
       * Implements the direct light.
       *
       * @param {Object} input - The input data.
       * @param {StackNode} stack - The current stack.
       * @param {NodeBuilder} builder - The current node builder.
       */
    }, {
      key: "direct",
      value: function direct(_ref91) {
        var lightDirection = _ref91.lightDirection,
          lightColor = _ref91.lightColor,
          reflectedLight = _ref91.reflectedLight;
        var dotNL = transformedNormalView.dot(lightDirection).clamp();
        var irradiance = dotNL.mul(lightColor);
        if (this.sheen === true) {
          this.sheenSpecularDirect.addAssign(irradiance.mul(BRDF_Sheen({
            lightDirection: lightDirection
          })));
        }
        if (this.clearcoat === true) {
          var dotNLcc = transformedClearcoatNormalView.dot(lightDirection).clamp();
          var ccIrradiance = dotNLcc.mul(lightColor);
          this.clearcoatSpecularDirect.addAssign(ccIrradiance.mul(BRDF_GGX({
            lightDirection: lightDirection,
            f0: clearcoatF0,
            f90: clearcoatF90,
            roughness: clearcoatRoughness,
            normalView: transformedClearcoatNormalView
          })));
        }
        reflectedLight.directDiffuse.addAssign(irradiance.mul(BRDF_Lambert({
          diffuseColor: diffuseColor.rgb
        })));
        reflectedLight.directSpecular.addAssign(irradiance.mul(BRDF_GGX({
          lightDirection: lightDirection,
          f0: specularColor,
          f90: 1,
          roughness: roughness,
          iridescence: this.iridescence,
          f: this.iridescenceFresnel,
          USE_IRIDESCENCE: this.iridescence,
          USE_ANISOTROPY: this.anisotropy
        })));
      }

      /**
       * This method is intended for implementing the direct light term for
       * rect area light nodes.
       *
       * @param {Object} input - The input data.
       * @param {StackNode} stack - The current stack.
       * @param {NodeBuilder} builder - The current node builder.
       */
    }, {
      key: "directRectArea",
      value: function directRectArea(_ref92) {
        var lightColor = _ref92.lightColor,
          lightPosition = _ref92.lightPosition,
          halfWidth = _ref92.halfWidth,
          halfHeight = _ref92.halfHeight,
          reflectedLight = _ref92.reflectedLight,
          ltc_1 = _ref92.ltc_1,
          ltc_2 = _ref92.ltc_2;
        var p0 = lightPosition.add(halfWidth).sub(halfHeight); // counterclockwise; light shines in local neg z direction
        var p1 = lightPosition.sub(halfWidth).sub(halfHeight);
        var p2 = lightPosition.sub(halfWidth).add(halfHeight);
        var p3 = lightPosition.add(halfWidth).add(halfHeight);
        var N = transformedNormalView;
        var V = positionViewDirection;
        var P = positionView.toVar();
        var uv = LTC_Uv({
          N: N,
          V: V,
          roughness: roughness
        });
        var t1 = ltc_1.sample(uv).toVar();
        var t2 = ltc_2.sample(uv).toVar();
        var mInv = mat3(vec3(t1.x, 0, t1.y), vec3(0, 1, 0), vec3(t1.z, 0, t1.w)).toVar();

        // LTC Fresnel Approximation by Stephen Hill
        // http://blog.selfshadow.com/publications/s2016-advances/s2016_ltc_fresnel.pdf
        var fresnel = specularColor.mul(t2.x).add(specularColor.oneMinus().mul(t2.y)).toVar();
        reflectedLight.directSpecular.addAssign(lightColor.mul(fresnel).mul(LTC_Evaluate({
          N: N,
          V: V,
          P: P,
          mInv: mInv,
          p0: p0,
          p1: p1,
          p2: p2,
          p3: p3
        })));
        reflectedLight.directDiffuse.addAssign(lightColor.mul(diffuseColor).mul(LTC_Evaluate({
          N: N,
          V: V,
          P: P,
          mInv: mat3(1, 0, 0, 0, 1, 0, 0, 0, 1),
          p0: p0,
          p1: p1,
          p2: p2,
          p3: p3
        })));
      }

      /**
       * Implements the indirect lighting.
       *
       * @param {ContextNode} context - The current node context.
       * @param {StackNode} stack - The current stack.
       * @param {NodeBuilder} builder - The current node builder.
       */
    }, {
      key: "indirect",
      value: function indirect(context, stack, builder) {
        this.indirectDiffuse(context, stack, builder);
        this.indirectSpecular(context, stack, builder);
        this.ambientOcclusion(context, stack, builder);
      }

      /**
       * Implements the indirect diffuse term.
       *
       * @param {ContextNode} input - The current node context.
       * @param {StackNode} stack - The current stack.
       * @param {NodeBuilder} builder - The current node builder.
       */
    }, {
      key: "indirectDiffuse",
      value: function indirectDiffuse(_ref93) {
        var irradiance = _ref93.irradiance,
          reflectedLight = _ref93.reflectedLight;
        reflectedLight.indirectDiffuse.addAssign(irradiance.mul(BRDF_Lambert({
          diffuseColor: diffuseColor
        })));
      }

      /**
       * Implements the indirect specular term.
       *
       * @param {ContextNode} input - The current node context.
       * @param {StackNode} stack - The current stack.
       * @param {NodeBuilder} builder - The current node builder.
       */
    }, {
      key: "indirectSpecular",
      value: function indirectSpecular(_ref94) {
        var radiance = _ref94.radiance,
          iblIrradiance = _ref94.iblIrradiance,
          reflectedLight = _ref94.reflectedLight;
        if (this.sheen === true) {
          this.sheenSpecularIndirect.addAssign(iblIrradiance.mul(sheen, IBLSheenBRDF({
            normal: transformedNormalView,
            viewDir: positionViewDirection,
            roughness: sheenRoughness
          })));
        }
        if (this.clearcoat === true) {
          var dotNVcc = transformedClearcoatNormalView.dot(positionViewDirection).clamp();
          var clearcoatEnv = EnvironmentBRDF({
            dotNV: dotNVcc,
            specularColor: clearcoatF0,
            specularF90: clearcoatF90,
            roughness: clearcoatRoughness
          });
          this.clearcoatSpecularIndirect.addAssign(this.clearcoatRadiance.mul(clearcoatEnv));
        }

        // Both indirect specular and indirect diffuse light accumulate here

        var singleScattering = vec3().toVar('singleScattering');
        var multiScattering = vec3().toVar('multiScattering');
        var cosineWeightedIrradiance = iblIrradiance.mul(1 / Math.PI);
        this.computeMultiscattering(singleScattering, multiScattering, specularF90);
        var totalScattering = singleScattering.add(multiScattering);
        var diffuse = diffuseColor.mul(totalScattering.r.max(totalScattering.g).max(totalScattering.b).oneMinus());
        reflectedLight.indirectSpecular.addAssign(radiance.mul(singleScattering));
        reflectedLight.indirectSpecular.addAssign(multiScattering.mul(cosineWeightedIrradiance));
        reflectedLight.indirectDiffuse.addAssign(diffuse.mul(cosineWeightedIrradiance));
      }

      /**
       * Implements the ambient occlusion term.
       *
       * @param {ContextNode} input - The current node context.
       * @param {StackNode} stack - The current stack.
       * @param {NodeBuilder} builder - The current node builder.
       */
    }, {
      key: "ambientOcclusion",
      value: function ambientOcclusion(_ref95) {
        var _ambientOcclusion = _ref95.ambientOcclusion,
          reflectedLight = _ref95.reflectedLight;
        var dotNV = transformedNormalView.dot(positionViewDirection).clamp(); // @ TODO: Move to core dotNV

        var aoNV = dotNV.add(_ambientOcclusion);
        var aoExp = roughness.mul(-16.0).oneMinus().negate().exp2();
        var aoNode = _ambientOcclusion.sub(aoNV.pow(aoExp).oneMinus()).clamp();
        if (this.clearcoat === true) {
          this.clearcoatSpecularIndirect.mulAssign(_ambientOcclusion);
        }
        if (this.sheen === true) {
          this.sheenSpecularIndirect.mulAssign(_ambientOcclusion);
        }
        reflectedLight.indirectDiffuse.mulAssign(_ambientOcclusion);
        reflectedLight.indirectSpecular.mulAssign(aoNode);
      }

      /**
       * Used for final lighting accumulations depending on the requested features.
       *
       * @param {ContextNode} context - The current node context.
       * @param {StackNode} stack - The current stack.
       * @param {NodeBuilder} builder - The current node builder.
       */
    }, {
      key: "finish",
      value: function finish(context) {
        var outgoingLight = context.outgoingLight;
        if (this.clearcoat === true) {
          var dotNVcc = transformedClearcoatNormalView.dot(positionViewDirection).clamp();
          var Fcc = F_Schlick({
            dotVH: dotNVcc,
            f0: clearcoatF0,
            f90: clearcoatF90
          });
          var clearcoatLight = outgoingLight.mul(clearcoat.mul(Fcc).oneMinus()).add(this.clearcoatSpecularDirect.add(this.clearcoatSpecularIndirect).mul(clearcoat));
          outgoingLight.assign(clearcoatLight);
        }
        if (this.sheen === true) {
          var sheenEnergyComp = sheen.r.max(sheen.g).max(sheen.b).mul(0.157).oneMinus();
          var sheenLight = outgoingLight.mul(sheenEnergyComp).add(this.sheenSpecularDirect, this.sheenSpecularIndirect);
          outgoingLight.assign(sheenLight);
        }
      }
    }]);
  }(LightingModel); // These defines must match with PMREMGenerator
  var cubeUV_r0 = /*@__PURE__*/float(1.0);
  var cubeUV_m0 = /*@__PURE__*/float(-2.0);
  var cubeUV_r1 = /*@__PURE__*/float(0.8);
  var cubeUV_m1 = /*@__PURE__*/float(-1.0);
  var cubeUV_r4 = /*@__PURE__*/float(0.4);
  var cubeUV_m4 = /*@__PURE__*/float(2.0);
  var cubeUV_r5 = /*@__PURE__*/float(0.305);
  var cubeUV_m5 = /*@__PURE__*/float(3.0);
  var cubeUV_r6 = /*@__PURE__*/float(0.21);
  var cubeUV_m6 = /*@__PURE__*/float(4.0);
  var cubeUV_minMipLevel = /*@__PURE__*/float(4.0);
  var cubeUV_minTileSize = /*@__PURE__*/float(16.0);

  // These shader functions convert between the UV coordinates of a single face of
  // a cubemap, the 0-5 integer index of a cube face, and the direction vector for
  // sampling a textureCube (not generally normalized ).

  var getFace = /*@__PURE__*/Fn(function (_ref96) {
    var _ref97 = (0, _slicedToArray2.default)(_ref96, 1),
      direction = _ref97[0];
    var absDirection = vec3(abs(direction)).toVar();
    var face = float(-1.0).toVar();
    If(absDirection.x.greaterThan(absDirection.z), function () {
      If(absDirection.x.greaterThan(absDirection.y), function () {
        face.assign(select(direction.x.greaterThan(0.0), 0.0, 3.0));
      }).Else(function () {
        face.assign(select(direction.y.greaterThan(0.0), 1.0, 4.0));
      });
    }).Else(function () {
      If(absDirection.z.greaterThan(absDirection.y), function () {
        face.assign(select(direction.z.greaterThan(0.0), 2.0, 5.0));
      }).Else(function () {
        face.assign(select(direction.y.greaterThan(0.0), 1.0, 4.0));
      });
    });
    return face;
  }).setLayout({
    name: 'getFace',
    type: 'float',
    inputs: [{
      name: 'direction',
      type: 'vec3'
    }]
  });

  // RH coordinate system; PMREM face-indexing convention
  var getUV = /*@__PURE__*/Fn(function (_ref98) {
    var _ref99 = (0, _slicedToArray2.default)(_ref98, 2),
      direction = _ref99[0],
      face = _ref99[1];
    var uv = vec2().toVar();
    If(face.equal(0.0), function () {
      uv.assign(vec2(direction.z, direction.y).div(abs(direction.x))); // pos x
    }).ElseIf(face.equal(1.0), function () {
      uv.assign(vec2(direction.x.negate(), direction.z.negate()).div(abs(direction.y))); // pos y
    }).ElseIf(face.equal(2.0), function () {
      uv.assign(vec2(direction.x.negate(), direction.y).div(abs(direction.z))); // pos z
    }).ElseIf(face.equal(3.0), function () {
      uv.assign(vec2(direction.z.negate(), direction.y).div(abs(direction.x))); // neg x
    }).ElseIf(face.equal(4.0), function () {
      uv.assign(vec2(direction.x.negate(), direction.z).div(abs(direction.y))); // neg y
    }).Else(function () {
      uv.assign(vec2(direction.x, direction.y).div(abs(direction.z))); // neg z
    });
    return mul(0.5, uv.add(1.0));
  }).setLayout({
    name: 'getUV',
    type: 'vec2',
    inputs: [{
      name: 'direction',
      type: 'vec3'
    }, {
      name: 'face',
      type: 'float'
    }]
  });
  var roughnessToMip = /*@__PURE__*/Fn(function (_ref100) {
    var _ref101 = (0, _slicedToArray2.default)(_ref100, 1),
      roughness = _ref101[0];
    var mip = float(0.0).toVar();
    If(roughness.greaterThanEqual(cubeUV_r1), function () {
      mip.assign(cubeUV_r0.sub(roughness).mul(cubeUV_m1.sub(cubeUV_m0)).div(cubeUV_r0.sub(cubeUV_r1)).add(cubeUV_m0));
    }).ElseIf(roughness.greaterThanEqual(cubeUV_r4), function () {
      mip.assign(cubeUV_r1.sub(roughness).mul(cubeUV_m4.sub(cubeUV_m1)).div(cubeUV_r1.sub(cubeUV_r4)).add(cubeUV_m1));
    }).ElseIf(roughness.greaterThanEqual(cubeUV_r5), function () {
      mip.assign(cubeUV_r4.sub(roughness).mul(cubeUV_m5.sub(cubeUV_m4)).div(cubeUV_r4.sub(cubeUV_r5)).add(cubeUV_m4));
    }).ElseIf(roughness.greaterThanEqual(cubeUV_r6), function () {
      mip.assign(cubeUV_r5.sub(roughness).mul(cubeUV_m6.sub(cubeUV_m5)).div(cubeUV_r5.sub(cubeUV_r6)).add(cubeUV_m5));
    }).Else(function () {
      mip.assign(float(-2.0).mul(log2(mul(1.16, roughness)))); // 1.16 = 1.79^0.25
    });
    return mip;
  }).setLayout({
    name: 'roughnessToMip',
    type: 'float',
    inputs: [{
      name: 'roughness',
      type: 'float'
    }]
  });

  // RH coordinate system; PMREM face-indexing convention
  var getDirection = /*@__PURE__*/Fn(function (_ref102) {
    var _ref103 = (0, _slicedToArray2.default)(_ref102, 2),
      uv_immutable = _ref103[0],
      face = _ref103[1];
    var uv = uv_immutable.toVar();
    uv.assign(mul(2.0, uv).sub(1.0));
    var direction = vec3(uv, 1.0).toVar();
    If(face.equal(0.0), function () {
      direction.assign(direction.zyx); // ( 1, v, u ) pos x
    }).ElseIf(face.equal(1.0), function () {
      direction.assign(direction.xzy);
      direction.xz.mulAssign(-1.0); // ( -u, 1, -v ) pos y
    }).ElseIf(face.equal(2.0), function () {
      direction.x.mulAssign(-1.0); // ( -u, v, 1 ) pos z
    }).ElseIf(face.equal(3.0), function () {
      direction.assign(direction.zyx);
      direction.xz.mulAssign(-1.0); // ( -1, v, -u ) neg x
    }).ElseIf(face.equal(4.0), function () {
      direction.assign(direction.xzy);
      direction.xy.mulAssign(-1.0); // ( -u, -1, v ) neg y
    }).ElseIf(face.equal(5.0), function () {
      direction.z.mulAssign(-1.0); // ( u, v, -1 ) neg zS
    });
    return direction;
  }).setLayout({
    name: 'getDirection',
    type: 'vec3',
    inputs: [{
      name: 'uv',
      type: 'vec2'
    }, {
      name: 'face',
      type: 'float'
    }]
  });

  //

  var textureCubeUV = /*@__PURE__*/Fn(function (_ref104) {
    var _ref105 = (0, _slicedToArray2.default)(_ref104, 6),
      envMap = _ref105[0],
      sampleDir_immutable = _ref105[1],
      roughness_immutable = _ref105[2],
      CUBEUV_TEXEL_WIDTH = _ref105[3],
      CUBEUV_TEXEL_HEIGHT = _ref105[4],
      CUBEUV_MAX_MIP = _ref105[5];
    var roughness = float(roughness_immutable);
    var sampleDir = vec3(sampleDir_immutable);
    var mip = clamp(roughnessToMip(roughness), cubeUV_m0, CUBEUV_MAX_MIP);
    var mipF = fract(mip);
    var mipInt = floor(mip);
    var color0 = vec3(bilinearCubeUV(envMap, sampleDir, mipInt, CUBEUV_TEXEL_WIDTH, CUBEUV_TEXEL_HEIGHT, CUBEUV_MAX_MIP)).toVar();
    If(mipF.notEqual(0.0), function () {
      var color1 = vec3(bilinearCubeUV(envMap, sampleDir, mipInt.add(1.0), CUBEUV_TEXEL_WIDTH, CUBEUV_TEXEL_HEIGHT, CUBEUV_MAX_MIP)).toVar();
      color0.assign(mix(color0, color1, mipF));
    });
    return color0;
  });
  var bilinearCubeUV = /*@__PURE__*/Fn(function (_ref106) {
    var _ref107 = (0, _slicedToArray2.default)(_ref106, 6),
      envMap = _ref107[0],
      direction_immutable = _ref107[1],
      mipInt_immutable = _ref107[2],
      CUBEUV_TEXEL_WIDTH = _ref107[3],
      CUBEUV_TEXEL_HEIGHT = _ref107[4],
      CUBEUV_MAX_MIP = _ref107[5];
    var mipInt = float(mipInt_immutable).toVar();
    var direction = vec3(direction_immutable);
    var face = float(getFace(direction)).toVar();
    var filterInt = float(max$1(cubeUV_minMipLevel.sub(mipInt), 0.0)).toVar();
    mipInt.assign(max$1(mipInt, cubeUV_minMipLevel));
    var faceSize = float(exp2(mipInt)).toVar();
    var uv = vec2(getUV(direction, face).mul(faceSize.sub(2.0)).add(1.0)).toVar();
    If(face.greaterThan(2.0), function () {
      uv.y.addAssign(faceSize);
      face.subAssign(3.0);
    });
    uv.x.addAssign(face.mul(faceSize));
    uv.x.addAssign(filterInt.mul(mul(3.0, cubeUV_minTileSize)));
    uv.y.addAssign(mul(4.0, exp2(CUBEUV_MAX_MIP).sub(faceSize)));
    uv.x.mulAssign(CUBEUV_TEXEL_WIDTH);
    uv.y.mulAssign(CUBEUV_TEXEL_HEIGHT);
    return envMap.sample(uv).grad(vec2(), vec2()); // disable anisotropic filtering
  });
  var getSample = /*@__PURE__*/Fn(function (_ref108) {
    var envMap = _ref108.envMap,
      mipInt = _ref108.mipInt,
      outputDirection = _ref108.outputDirection,
      theta = _ref108.theta,
      axis = _ref108.axis,
      CUBEUV_TEXEL_WIDTH = _ref108.CUBEUV_TEXEL_WIDTH,
      CUBEUV_TEXEL_HEIGHT = _ref108.CUBEUV_TEXEL_HEIGHT,
      CUBEUV_MAX_MIP = _ref108.CUBEUV_MAX_MIP;
    var cosTheta = cos(theta);

    // Rodrigues' axis-angle rotation
    var sampleDirection = outputDirection.mul(cosTheta).add(axis.cross(outputDirection).mul(sin(theta))).add(axis.mul(axis.dot(outputDirection).mul(cosTheta.oneMinus())));
    return bilinearCubeUV(envMap, sampleDirection, mipInt, CUBEUV_TEXEL_WIDTH, CUBEUV_TEXEL_HEIGHT, CUBEUV_MAX_MIP);
  });
  var blur = /*@__PURE__*/Fn(function (_ref109) {
    var n = _ref109.n,
      latitudinal = _ref109.latitudinal,
      poleAxis = _ref109.poleAxis,
      outputDirection = _ref109.outputDirection,
      weights = _ref109.weights,
      samples = _ref109.samples,
      dTheta = _ref109.dTheta,
      mipInt = _ref109.mipInt,
      envMap = _ref109.envMap,
      CUBEUV_TEXEL_WIDTH = _ref109.CUBEUV_TEXEL_WIDTH,
      CUBEUV_TEXEL_HEIGHT = _ref109.CUBEUV_TEXEL_HEIGHT,
      CUBEUV_MAX_MIP = _ref109.CUBEUV_MAX_MIP;
    var axis = vec3(select(latitudinal, poleAxis, cross(poleAxis, outputDirection))).toVar();
    If(all(axis.equals(vec3(0.0))), function () {
      axis.assign(vec3(outputDirection.z, 0.0, outputDirection.x.negate()));
    });
    axis.assign(normalize(axis));
    var gl_FragColor = vec3().toVar();
    gl_FragColor.addAssign(weights.element(int(0)).mul(getSample({
      theta: 0.0,
      axis: axis,
      outputDirection: outputDirection,
      mipInt: mipInt,
      envMap: envMap,
      CUBEUV_TEXEL_WIDTH: CUBEUV_TEXEL_WIDTH,
      CUBEUV_TEXEL_HEIGHT: CUBEUV_TEXEL_HEIGHT,
      CUBEUV_MAX_MIP: CUBEUV_MAX_MIP
    })));
    Loop({
      start: int(1),
      end: n
    }, function (_ref110) {
      var i = _ref110.i;
      If(i.greaterThanEqual(samples), function () {
        Break();
      });
      var theta = float(dTheta.mul(float(i))).toVar();
      gl_FragColor.addAssign(weights.element(i).mul(getSample({
        theta: theta.mul(-1.0),
        axis: axis,
        outputDirection: outputDirection,
        mipInt: mipInt,
        envMap: envMap,
        CUBEUV_TEXEL_WIDTH: CUBEUV_TEXEL_WIDTH,
        CUBEUV_TEXEL_HEIGHT: CUBEUV_TEXEL_HEIGHT,
        CUBEUV_MAX_MIP: CUBEUV_MAX_MIP
      })));
      gl_FragColor.addAssign(weights.element(i).mul(getSample({
        theta: theta,
        axis: axis,
        outputDirection: outputDirection,
        mipInt: mipInt,
        envMap: envMap,
        CUBEUV_TEXEL_WIDTH: CUBEUV_TEXEL_WIDTH,
        CUBEUV_TEXEL_HEIGHT: CUBEUV_TEXEL_HEIGHT,
        CUBEUV_MAX_MIP: CUBEUV_MAX_MIP
      })));
    });
    return vec4(gl_FragColor, 1);
  });

  /** @module PMREMNode **/

  var _generator = null;
  var _cache = new WeakMap();

  /**
   * Generates the cubeUV size based on the given image height.
   *
   * @private
   * @param {Number} imageHeight - The image height.
   * @return {{texelWidth: Number,texelHeight: Number, maxMip: Number}} The result object.
   */
  function _generateCubeUVSize(imageHeight) {
    var maxMip = Math.log2(imageHeight) - 2;
    var texelHeight = 1.0 / imageHeight;
    var texelWidth = 1.0 / (3 * Math.max(Math.pow(2, maxMip), 7 * 16));
    return {
      texelWidth: texelWidth,
      texelHeight: texelHeight,
      maxMip: maxMip
    };
  }

  /**
   * Generates a PMREM from the given texture .
   *
   * @private
   * @param {Texture} texture - The texture to create the PMREM for.
   * @return {Texture} The PMREM.
   */
  function _getPMREMFromTexture(texture) {
    var cacheTexture = _cache.get(texture);
    var pmremVersion = cacheTexture !== undefined ? cacheTexture.pmremVersion : -1;
    if (pmremVersion !== texture.pmremVersion) {
      var image = texture.image;
      if (texture.isCubeTexture) {
        if (isCubeMapReady(image)) {
          cacheTexture = _generator.fromCubemap(texture, cacheTexture);
        } else {
          return null;
        }
      } else {
        if (isEquirectangularMapReady(image)) {
          cacheTexture = _generator.fromEquirectangular(texture, cacheTexture);
        } else {
          return null;
        }
      }
      cacheTexture.pmremVersion = texture.pmremVersion;
      _cache.set(texture, cacheTexture);
    }
    return cacheTexture.texture;
  }

  /**
   * This node represents a PMREM which is a special type of preprocessed
   * environment map intended for PBR materials.
   *
   * ```js
   * const material = new MeshStandardNodeMaterial();
   * material.envNode = pmremTexture( envMap );
   * ```
   *
   * @augments TempNode
   */
  var PMREMNode = exports.PMREMNode = /*#__PURE__*/function (_TempNode15) {
    /**
     * Constructs a new function overloading node.
     *
     * @param {Texture} value - The input texture.
     * @param {Node<vec2>} [uvNode=null] - The uv node.
     * @param {Node<float>} [levelNode=null] - The level node.
     */
    function PMREMNode(value) {
      var _this92;
      var uvNode = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      var levelNode = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
      (0, _classCallCheck2.default)(this, PMREMNode);
      _this92 = _callSuper(this, PMREMNode, ['vec3']);

      /**
       * Reference to the input texture.
       *
       * @private
       * @type {Texture}
       */
      _this92._value = value;

      /**
       * Reference to the generated PMREM.
       *
       * @private
       * @type {Texture | null}
       * @default null
       */
      _this92._pmrem = null;

      /**
       *  The uv node.
       *
       * @type {Node<vec2>}
       */
      _this92.uvNode = uvNode;

      /**
       *  The level node.
       *
       * @type {Node<float>}
       */
      _this92.levelNode = levelNode;

      /**
       * Reference to a PMREM generator.
       *
       * @private
       * @type {PMREMGenerator}
       * @default null
       */
      _this92._generator = null;
      var defaultTexture = new (_$$_REQUIRE(_dependencyMap[1], "./three.core.js").Texture)();
      defaultTexture.isRenderTargetTexture = true;

      /**
       * The texture node holding the generated PMREM.
       *
       * @private
       * @type {TextureNode}
       */
      _this92._texture = texture(defaultTexture);

      /**
       * A uniform representing the PMREM's width.
       *
       * @private
       * @type {UniformNode<float>}
       */
      _this92._width = uniform(0);

      /**
       * A uniform representing the PMREM's height.
       *
       * @private
       * @type {UniformNode<float>}
       */
      _this92._height = uniform(0);

      /**
       * A uniform representing the PMREM's max Mip.
       *
       * @private
       * @type {UniformNode<float>}
       */
      _this92._maxMip = uniform(0);

      /**
       * The `updateBeforeType` is set to `NodeUpdateType.RENDER`.
       *
       * @type {String}
       * @default 'render'
       */
      _this92.updateBeforeType = NodeUpdateType.RENDER;
      return _this92;
    }
    (0, _inherits2.default)(PMREMNode, _TempNode15);
    return (0, _createClass2.default)(PMREMNode, [{
      key: "value",
      get:
      /**
       * The node's texture value.
       *
       * @type {Texture}
       */
      function get() {
        return this._value;
      }

      /**
       * Uses the given PMREM texture to update internal values.
       *
       * @param {Texture} texture - The PMREM texture.
       */,
      set: function set(value) {
        this._value = value;
        this._pmrem = null;
      }
    }, {
      key: "updateFromTexture",
      value: function updateFromTexture(texture) {
        var cubeUVSize = _generateCubeUVSize(texture.image.height);
        this._texture.value = texture;
        this._width.value = cubeUVSize.texelWidth;
        this._height.value = cubeUVSize.texelHeight;
        this._maxMip.value = cubeUVSize.maxMip;
      }
    }, {
      key: "updateBefore",
      value: function updateBefore() {
        var pmrem = this._pmrem;
        var pmremVersion = pmrem ? pmrem.pmremVersion : -1;
        var texture = this._value;
        if (pmremVersion !== texture.pmremVersion) {
          if (texture.isPMREMTexture === true) {
            pmrem = texture;
          } else {
            pmrem = _getPMREMFromTexture(texture);
          }
          if (pmrem !== null) {
            this._pmrem = pmrem;
            this.updateFromTexture(pmrem);
          }
        }
      }
    }, {
      key: "setup",
      value: function setup(builder) {
        if (_generator === null) {
          _generator = builder.createPMREMGenerator();
        }

        //

        this.updateBefore(builder);

        //

        var uvNode = this.uvNode;
        if (uvNode === null && builder.context.getUV) {
          uvNode = builder.context.getUV(this);
        }

        //

        var texture = this.value;
        if (builder.renderer.coordinateSystem === _$$_REQUIRE(_dependencyMap[1], "./three.core.js").WebGLCoordinateSystem && texture.isPMREMTexture !== true && texture.isRenderTargetTexture === true) {
          uvNode = vec3(uvNode.x.negate(), uvNode.yz);
        }
        uvNode = vec3(uvNode.x, uvNode.y.negate(), uvNode.z);

        //

        var levelNode = this.levelNode;
        if (levelNode === null && builder.context.getTextureLevel) {
          levelNode = builder.context.getTextureLevel(this);
        }

        //

        return textureCubeUV(this._texture, uvNode, levelNode, this._width, this._height, this._maxMip);
      }
    }], [{
      key: "type",
      get: function get() {
        return 'PMREMNode';
      }
    }]);
  }(TempNode);
  /**
   * Returns `true` if the given cube map image has been fully loaded.
   *
   * @private
   * @param {Array<(Image|Object)>} image - The cube map image.
   * @return {Boolean} Whether the given cube map is ready or not.
   */
  function isCubeMapReady(image) {
    if (image === null || image === undefined) return false;
    var count = 0;
    var length = 6;
    for (var i = 0; i < length; i++) {
      if (image[i] !== undefined) count++;
    }
    return count === length;
  }

  /**
   * Returns `true` if the given equirectangular image has been fully loaded.
   *
   * @private
   * @param {(Image|Object)} image - The equirectangular image.
   * @return {Boolean} Whether the given cube map is ready or not.
   */
  function isEquirectangularMapReady(image) {
    if (image === null || image === undefined) return false;
    return image.height > 0;
  }

  /**
   * TSL function for creating a PMREM node.
   *
   * @function
   * @param {Texture} value - The input texture.
   * @param {Node<vec2>} [uvNode=null] - The uv node.
   * @param {Node<float>} [levelNode=null] - The level node.
   * @returns {PMREMNode}
   */
  var pmremTexture = /*@__PURE__*/nodeProxy(PMREMNode);
  var _envNodeCache = new WeakMap();

  /**
   * Represents a physical model for Image-based lighting (IBL). The environment
   * is defined via environment maps in the equirectangular, cube map or cubeUV (PMREM) format.
   * `EnvironmentNode` is intended for PBR materials like {@link MeshStandardNodeMaterial}.
   *
   * @augments LightingNode
   */
  var EnvironmentNode = exports.EnvironmentNode = /*#__PURE__*/function (_LightingNode5) {
    /**
     * Constructs a new environment node.
     *
     * @param {Node} [envNode=null] - A node representing the environment.
     */
    function EnvironmentNode() {
      var _this93;
      var envNode = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      (0, _classCallCheck2.default)(this, EnvironmentNode);
      _this93 = _callSuper(this, EnvironmentNode);

      /**
       * A node representing the environment.
       *
       * @type {Node?}
       * @default null
       */
      _this93.envNode = envNode;
      return _this93;
    }
    (0, _inherits2.default)(EnvironmentNode, _LightingNode5);
    return (0, _createClass2.default)(EnvironmentNode, [{
      key: "setup",
      value: function setup(builder) {
        var material = builder.material;
        var envNode = this.envNode;
        if (envNode.isTextureNode || envNode.isMaterialReferenceNode) {
          var value = envNode.isTextureNode ? envNode.value : material[envNode.property];
          var cacheEnvNode = _envNodeCache.get(value);
          if (cacheEnvNode === undefined) {
            cacheEnvNode = pmremTexture(value);
            _envNodeCache.set(value, cacheEnvNode);
          }
          envNode = cacheEnvNode;
        }

        //

        var envMap = material.envMap;
        var intensity = envMap ? reference('envMapIntensity', 'float', builder.material) : reference('environmentIntensity', 'float', builder.scene); // @TODO: Add materialEnvIntensity in MaterialNode

        var useAnisotropy = material.useAnisotropy === true || material.anisotropy > 0;
        var radianceNormalView = useAnisotropy ? transformedBentNormalView : transformedNormalView;
        var radiance = envNode.context(createRadianceContext(roughness, radianceNormalView)).mul(intensity);
        var irradiance = envNode.context(createIrradianceContext(transformedNormalWorld)).mul(Math.PI).mul(intensity);
        var isolateRadiance = cache(radiance);
        var isolateIrradiance = cache(irradiance);

        //

        builder.context.radiance.addAssign(isolateRadiance);
        builder.context.iblIrradiance.addAssign(isolateIrradiance);

        //

        var clearcoatRadiance = builder.context.lightingModel.clearcoatRadiance;
        if (clearcoatRadiance) {
          var clearcoatRadianceContext = envNode.context(createRadianceContext(clearcoatRoughness, transformedClearcoatNormalView)).mul(intensity);
          var isolateClearcoatRadiance = cache(clearcoatRadianceContext);
          clearcoatRadiance.addAssign(isolateClearcoatRadiance);
        }
      }
    }], [{
      key: "type",
      get: function get() {
        return 'EnvironmentNode';
      }
    }]);
  }(LightingNode);
  var createRadianceContext = function createRadianceContext(roughnessNode, normalViewNode) {
    var reflectVec = null;
    return {
      getUV: function getUV() {
        if (reflectVec === null) {
          reflectVec = positionViewDirection.negate().reflect(normalViewNode);

          // Mixing the reflection with the normal is more accurate and keeps rough objects from gathering light from behind their tangent plane.
          reflectVec = roughnessNode.mul(roughnessNode).mix(reflectVec, normalViewNode).normalize();
          reflectVec = reflectVec.transformDirection(cameraViewMatrix);
        }
        return reflectVec;
      },
      getTextureLevel: function getTextureLevel() {
        return roughnessNode;
      }
    };
  };
  var createIrradianceContext = function createIrradianceContext(normalWorldNode) {
    return {
      getUV: function getUV() {
        return normalWorldNode;
      },
      getTextureLevel: function getTextureLevel() {
        return float(1.0);
      }
    };
  };
  var _defaultValues$6 = /*@__PURE__*/new (_$$_REQUIRE(_dependencyMap[1], "./three.core.js").MeshStandardMaterial)();

  /**
   * Node material version of `MeshStandardMaterial`.
   *
   * @augments NodeMaterial
   */
  var MeshStandardNodeMaterial = exports.MeshStandardNodeMaterial = /*#__PURE__*/function (_NodeMaterial9) {
    /**
     * Constructs a new mesh standard node material.
     *
     * @param {Object?} parameters - The configuration parameter.
     */
    function MeshStandardNodeMaterial(parameters) {
      var _this94;
      (0, _classCallCheck2.default)(this, MeshStandardNodeMaterial);
      _this94 = _callSuper(this, MeshStandardNodeMaterial);

      /**
       * This flag can be used for type testing.
       *
       * @type {Boolean}
       * @readonly
       * @default true
       */
      _this94.isMeshStandardNodeMaterial = true;

      /**
       * Set to `true` because standard materials react on lights.
       *
       * @type {Boolean}
       * @default true
       */
      _this94.lights = true;

      /**
       * The emissive color of standard materials is by default inferred from the `emissive`,
       * `emissiveIntensity` and `emissiveMap` properties. This node property allows to
       * overwrite the default and define the emissive color with a node instead.
       *
       * If you don't want to overwrite the emissive color but modify the existing
       * value instead, use {@link module:MaterialNode.materialEmissive}.
       *
       * @type {Node<vec3>?}
       * @default null
       */
      _this94.emissiveNode = null;

      /**
       * The metalness of standard materials is by default inferred from the `metalness`,
       * and `metalnessMap` properties. This node property allows to
       * overwrite the default and define the metalness with a node instead.
       *
       * If you don't want to overwrite the metalness but modify the existing
       * value instead, use {@link module:MaterialNode.materialMetalness}.
       *
       * @type {Node<float>?}
       * @default null
       */
      _this94.metalnessNode = null;

      /**
       * The roughness of standard materials is by default inferred from the `roughness`,
       * and `roughnessMap` properties. This node property allows to
       * overwrite the default and define the roughness with a node instead.
       *
       * If you don't want to overwrite the roughness but modify the existing
       * value instead, use {@link module:MaterialNode.materialRoughness}.
       *
       * @type {Node<float>?}
       * @default null
       */
      _this94.roughnessNode = null;
      _this94.setDefaultValues(_defaultValues$6);
      _this94.setValues(parameters);
      return _this94;
    }

    /**
     * Overwritten since this type of material uses {@link EnvironmentNode}
     * to implement the PBR (PMREM based) environment mapping. Besides, the
     * method honors `Scene.environment`.
     *
     * @param {NodeBuilder} builder - The current node builder.
     * @return {EnvironmentNode<vec3>?} The environment node.
     */
    (0, _inherits2.default)(MeshStandardNodeMaterial, _NodeMaterial9);
    return (0, _createClass2.default)(MeshStandardNodeMaterial, [{
      key: "setupEnvironment",
      value: function setupEnvironment(builder) {
        var envNode = _superPropGet(MeshStandardNodeMaterial, "setupEnvironment", this, 3)([builder]);
        if (envNode === null && builder.environmentNode) {
          envNode = builder.environmentNode;
        }
        return envNode ? new EnvironmentNode(envNode) : null;
      }

      /**
       * Setups the lighting model.
       *
       * @return {PhysicalLightingModel} The lighting model.
       */
    }, {
      key: "setupLightingModel",
      value: function setupLightingModel(/*builder*/
      ) {
        return new PhysicalLightingModel();
      }

      /**
       * Setups the specular related node variables.
       */
    }, {
      key: "setupSpecular",
      value: function setupSpecular() {
        var specularColorNode = mix(vec3(0.04), diffuseColor.rgb, metalness);
        specularColor.assign(specularColorNode);
        specularF90.assign(1.0);
      }

      /**
       * Setups the standard specific node variables.
       *
       * @param {NodeBuilder} builder - The current node builder.
       */
    }, {
      key: "setupVariants",
      value: function setupVariants() {
        // METALNESS

        var metalnessNode = this.metalnessNode ? float(this.metalnessNode) : materialMetalness;
        metalness.assign(metalnessNode);

        // ROUGHNESS

        var roughnessNode = this.roughnessNode ? float(this.roughnessNode) : materialRoughness;
        roughnessNode = getRoughness({
          roughness: roughnessNode
        });
        roughness.assign(roughnessNode);

        // SPECULAR COLOR

        this.setupSpecular();

        // DIFFUSE COLOR

        diffuseColor.assign(vec4(diffuseColor.rgb.mul(metalnessNode.oneMinus()), diffuseColor.a));
      }
    }, {
      key: "copy",
      value: function copy(source) {
        this.emissiveNode = source.emissiveNode;
        this.metalnessNode = source.metalnessNode;
        this.roughnessNode = source.roughnessNode;
        return _superPropGet(MeshStandardNodeMaterial, "copy", this, 3)([source]);
      }
    }], [{
      key: "type",
      get: function get() {
        return 'MeshStandardNodeMaterial';
      }
    }]);
  }(NodeMaterial);
  var _defaultValues$5 = /*@__PURE__*/new (_$$_REQUIRE(_dependencyMap[1], "./three.core.js").MeshPhysicalMaterial)();

  /**
   * Node material version of `MeshPhysicalMaterial`.
   *
   * @augments MeshStandardNodeMaterial
   */
  var MeshPhysicalNodeMaterial = exports.MeshPhysicalNodeMaterial = /*#__PURE__*/function (_MeshStandardNodeMate) {
    /**
     * Constructs a new mesh physical node material.
     *
     * @param {Object?} parameters - The configuration parameter.
     */
    function MeshPhysicalNodeMaterial(parameters) {
      var _this95;
      (0, _classCallCheck2.default)(this, MeshPhysicalNodeMaterial);
      _this95 = _callSuper(this, MeshPhysicalNodeMaterial);

      /**
       * This flag can be used for type testing.
       *
       * @type {Boolean}
       * @readonly
       * @default true
       */
      _this95.isMeshPhysicalNodeMaterial = true;

      /**
       * The clearcoat of physical materials is by default inferred from the `clearcoat`
       * and `clearcoatMap` properties. This node property allows to overwrite the default
       * and define the clearcoat with a node instead.
       *
       * If you don't want to overwrite the clearcoat but modify the existing
       * value instead, use {@link module:MaterialNode.materialClearcoat}.
       *
       * @type {Node<float>?}
       * @default null
       */
      _this95.clearcoatNode = null;

      /**
       * The clearcoat roughness of physical materials is by default inferred from the `clearcoatRoughness`
       * and `clearcoatRoughnessMap` properties. This node property allows to overwrite the default
       * and define the clearcoat roughness with a node instead.
       *
       * If you don't want to overwrite the clearcoat roughness but modify the existing
       * value instead, use {@link module:MaterialNode.materialClearcoatRoughness}.
       *
       * @type {Node<float>?}
       * @default null
       */
      _this95.clearcoatRoughnessNode = null;

      /**
       * The clearcoat normal of physical materials is by default inferred from the `clearcoatNormalMap`
       * property. This node property allows to overwrite the default
       * and define the clearcoat normal with a node instead.
       *
       * If you don't want to overwrite the clearcoat normal but modify the existing
       * value instead, use {@link module:MaterialNode.materialClearcoatNormal}.
       *
       * @type {Node<vec3>?}
       * @default null
       */
      _this95.clearcoatNormalNode = null;

      /**
       * The sheen of physical materials is by default inferred from the `sheen`, `sheenColor`
       * and `sheenColorMap` properties. This node property allows to overwrite the default
       * and define the sheen with a node instead.
       *
       * If you don't want to overwrite the sheen but modify the existing
       * value instead, use {@link module:MaterialNode.materialSheen}.
       *
       * @type {Node<vec3>?}
       * @default null
       */
      _this95.sheenNode = null;

      /**
       * The sheen roughness of physical materials is by default inferred from the `sheenRoughness` and
       * `sheenRoughnessMap` properties. This node property allows to overwrite the default
       * and define the sheen roughness with a node instead.
       *
       * If you don't want to overwrite the sheen roughness but modify the existing
       * value instead, use {@link module:MaterialNode.materialSheenRoughness}.
       *
       * @type {Node<float>?}
       * @default null
       */
      _this95.sheenRoughnessNode = null;

      /**
       * The iridescence of physical materials is by default inferred from the `iridescence`
       * property. This node property allows to overwrite the default
       * and define the iridescence with a node instead.
       *
       * If you don't want to overwrite the iridescence but modify the existing
       * value instead, use {@link module:MaterialNode.materialIridescence}.
       *
       * @type {Node<float>?}
       * @default null
       */
      _this95.iridescenceNode = null;

      /**
       * The iridescence IOR of physical materials is by default inferred from the `iridescenceIOR`
       * property. This node property allows to overwrite the default
       * and define the iridescence IOR with a node instead.
       *
       * If you don't want to overwrite the iridescence IOR but modify the existing
       * value instead, use {@link module:MaterialNode.materialIridescenceIOR}.
       *
       * @type {Node<float>?}
       * @default null
       */
      _this95.iridescenceIORNode = null;

      /**
       * The iridescence thickness of physical materials is by default inferred from the `iridescenceThicknessRange`
       * and `iridescenceThicknessMap` properties. This node property allows to overwrite the default
       * and define the iridescence thickness with a node instead.
       *
       * If you don't want to overwrite the iridescence thickness but modify the existing
       * value instead, use {@link module:MaterialNode.materialIridescenceThickness}.
       *
       * @type {Node<float>?}
       * @default null
       */
      _this95.iridescenceThicknessNode = null;

      /**
       * The specular intensity of physical materials is by default inferred from the `specularIntensity`
       * and `specularIntensityMap` properties. This node property allows to overwrite the default
       * and define the specular intensity with a node instead.
       *
       * If you don't want to overwrite the specular intensity but modify the existing
       * value instead, use {@link module:MaterialNode.materialSpecularIntensity}.
       *
       * @type {Node<float>?}
       * @default null
       */
      _this95.specularIntensityNode = null;

      /**
       * The specular color of physical materials is by default inferred from the `specularColor`
       * and `specularColorMap` properties. This node property allows to overwrite the default
       * and define the specular color with a node instead.
       *
       * If you don't want to overwrite the specular color but modify the existing
       * value instead, use {@link module:MaterialNode.materialSpecularColor}.
       *
       * @type {Node<vec3>?}
       * @default null
       */
      _this95.specularColorNode = null;

      /**
       * The ior of physical materials is by default inferred from the `ior`
       * property. This node property allows to overwrite the default
       * and define the ior with a node instead.
       *
       * If you don't want to overwrite the ior but modify the existing
       * value instead, use {@link module:MaterialNode.materialIOR}.
       *
       * @type {Node<float>?}
       * @default null
       */
      _this95.iorNode = null;

      /**
       * The transmission of physical materials is by default inferred from the `transmission` and
       * `transmissionMap` properties. This node property allows to overwrite the default
       * and define the transmission with a node instead.
       *
       * If you don't want to overwrite the transmission but modify the existing
       * value instead, use {@link module:MaterialNode.materialTransmission}.
       *
       * @type {Node<float>?}
       * @default null
       */
      _this95.transmissionNode = null;

      /**
       * The thickness of physical materials is by default inferred from the `thickness` and
       * `thicknessMap` properties. This node property allows to overwrite the default
       * and define the thickness with a node instead.
       *
       * If you don't want to overwrite the thickness but modify the existing
       * value instead, use {@link module:MaterialNode.materialThickness}.
       *
       * @type {Node<float>?}
       * @default null
       */
      _this95.thicknessNode = null;

      /**
       * The attenuation distance of physical materials is by default inferred from the
       * `attenuationDistance` property. This node property allows to overwrite the default
       * and define the attenuation distance with a node instead.
       *
       * If you don't want to overwrite the attenuation distance but modify the existing
       * value instead, use {@link module:MaterialNode.materialAttenuationDistance}.
       *
       * @type {Node<float>?}
       * @default null
       */
      _this95.attenuationDistanceNode = null;

      /**
       * The attenuation color of physical materials is by default inferred from the
       * `attenuationColor` property. This node property allows to overwrite the default
       * and define the attenuation color with a node instead.
       *
       * If you don't want to overwrite the attenuation color but modify the existing
       * value instead, use {@link module:MaterialNode.materialAttenuationColor}.
       *
       * @type {Node<vec3>?}
       * @default null
       */
      _this95.attenuationColorNode = null;

      /**
       * The dispersion of physical materials is by default inferred from the
       * `dispersion` property. This node property allows to overwrite the default
       * and define the dispersion with a node instead.
       *
       * If you don't want to overwrite the dispersion but modify the existing
       * value instead, use {@link module:MaterialNode.materialDispersion}.
       *
       * @type {Node<float>?}
       * @default null
       */
      _this95.dispersionNode = null;

      /**
       * The anisotropy of physical materials is by default inferred from the
       * `anisotropy` property. This node property allows to overwrite the default
       * and define the anisotropy with a node instead.
       *
       * If you don't want to overwrite the anisotropy but modify the existing
       * value instead, use {@link module:MaterialNode.materialAnisotropy}.
       *
       * @type {Node<float>?}
       * @default null
       */
      _this95.anisotropyNode = null;
      _this95.setDefaultValues(_defaultValues$5);
      _this95.setValues(parameters);
      return _this95;
    }

    /**
     * Whether the lighting model should use clearcoat or not.
     *
     * @type {Boolean}
     * @default true
     */
    (0, _inherits2.default)(MeshPhysicalNodeMaterial, _MeshStandardNodeMate);
    return (0, _createClass2.default)(MeshPhysicalNodeMaterial, [{
      key: "useClearcoat",
      get: function get() {
        return this.clearcoat > 0 || this.clearcoatNode !== null;
      }

      /**
       * Whether the lighting model should use iridescence or not.
       *
       * @type {Boolean}
       * @default true
       */
    }, {
      key: "useIridescence",
      get: function get() {
        return this.iridescence > 0 || this.iridescenceNode !== null;
      }

      /**
       * Whether the lighting model should use sheen or not.
       *
       * @type {Boolean}
       * @default true
       */
    }, {
      key: "useSheen",
      get: function get() {
        return this.sheen > 0 || this.sheenNode !== null;
      }

      /**
       * Whether the lighting model should use anisotropy or not.
       *
       * @type {Boolean}
       * @default true
       */
    }, {
      key: "useAnisotropy",
      get: function get() {
        return this.anisotropy > 0 || this.anisotropyNode !== null;
      }

      /**
       * Whether the lighting model should use transmission or not.
       *
       * @type {Boolean}
       * @default true
       */
    }, {
      key: "useTransmission",
      get: function get() {
        return this.transmission > 0 || this.transmissionNode !== null;
      }

      /**
       * Whether the lighting model should use dispersion or not.
       *
       * @type {Boolean}
       * @default true
       */
    }, {
      key: "useDispersion",
      get: function get() {
        return this.dispersion > 0 || this.dispersionNode !== null;
      }

      /**
       * Setups the specular related node variables.
       */
    }, {
      key: "setupSpecular",
      value: function setupSpecular() {
        var iorNode = this.iorNode ? float(this.iorNode) : materialIOR;
        ior.assign(iorNode);
        specularColor.assign(mix(min$1(pow2(ior.sub(1.0).div(ior.add(1.0))).mul(materialSpecularColor), vec3(1.0)).mul(materialSpecularIntensity), diffuseColor.rgb, metalness));
        specularF90.assign(mix(materialSpecularIntensity, 1.0, metalness));
      }

      /**
       * Setups the lighting model.
       *
       * @return {PhysicalLightingModel} The lighting model.
       */
    }, {
      key: "setupLightingModel",
      value: function setupLightingModel(/*builder*/
      ) {
        return new PhysicalLightingModel(this.useClearcoat, this.useSheen, this.useIridescence, this.useAnisotropy, this.useTransmission, this.useDispersion);
      }

      /**
       * Setups the physical specific node variables.
       *
       * @param {NodeBuilder} builder - The current node builder.
       */
    }, {
      key: "setupVariants",
      value: function setupVariants(builder) {
        _superPropGet(MeshPhysicalNodeMaterial, "setupVariants", this, 3)([builder]);

        // CLEARCOAT

        if (this.useClearcoat) {
          var clearcoatNode = this.clearcoatNode ? float(this.clearcoatNode) : materialClearcoat;
          var clearcoatRoughnessNode = this.clearcoatRoughnessNode ? float(this.clearcoatRoughnessNode) : materialClearcoatRoughness;
          clearcoat.assign(clearcoatNode);
          clearcoatRoughness.assign(getRoughness({
            roughness: clearcoatRoughnessNode
          }));
        }

        // SHEEN

        if (this.useSheen) {
          var sheenNode = this.sheenNode ? vec3(this.sheenNode) : materialSheen;
          var sheenRoughnessNode = this.sheenRoughnessNode ? float(this.sheenRoughnessNode) : materialSheenRoughness;
          sheen.assign(sheenNode);
          sheenRoughness.assign(sheenRoughnessNode);
        }

        // IRIDESCENCE

        if (this.useIridescence) {
          var iridescenceNode = this.iridescenceNode ? float(this.iridescenceNode) : materialIridescence;
          var iridescenceIORNode = this.iridescenceIORNode ? float(this.iridescenceIORNode) : materialIridescenceIOR;
          var iridescenceThicknessNode = this.iridescenceThicknessNode ? float(this.iridescenceThicknessNode) : materialIridescenceThickness;
          iridescence.assign(iridescenceNode);
          iridescenceIOR.assign(iridescenceIORNode);
          iridescenceThickness.assign(iridescenceThicknessNode);
        }

        // ANISOTROPY

        if (this.useAnisotropy) {
          var anisotropyV = (this.anisotropyNode ? vec2(this.anisotropyNode) : materialAnisotropy).toVar();
          anisotropy.assign(anisotropyV.length());
          If(anisotropy.equal(0.0), function () {
            anisotropyV.assign(vec2(1.0, 0.0));
          }).Else(function () {
            anisotropyV.divAssign(vec2(anisotropy));
            anisotropy.assign(anisotropy.saturate());
          });

          // Roughness along the anisotropy bitangent is the material roughness, while the tangent roughness increases with anisotropy.
          alphaT.assign(anisotropy.pow2().mix(roughness.pow2(), 1.0));
          anisotropyT.assign(TBNViewMatrix[0].mul(anisotropyV.x).add(TBNViewMatrix[1].mul(anisotropyV.y)));
          anisotropyB.assign(TBNViewMatrix[1].mul(anisotropyV.x).sub(TBNViewMatrix[0].mul(anisotropyV.y)));
        }

        // TRANSMISSION

        if (this.useTransmission) {
          var transmissionNode = this.transmissionNode ? float(this.transmissionNode) : materialTransmission;
          var thicknessNode = this.thicknessNode ? float(this.thicknessNode) : materialThickness;
          var attenuationDistanceNode = this.attenuationDistanceNode ? float(this.attenuationDistanceNode) : materialAttenuationDistance;
          var attenuationColorNode = this.attenuationColorNode ? vec3(this.attenuationColorNode) : materialAttenuationColor;
          transmission.assign(transmissionNode);
          thickness.assign(thicknessNode);
          attenuationDistance.assign(attenuationDistanceNode);
          attenuationColor.assign(attenuationColorNode);
          if (this.useDispersion) {
            var dispersionNode = this.dispersionNode ? float(this.dispersionNode) : materialDispersion;
            dispersion.assign(dispersionNode);
          }
        }
      }

      /**
       * Setups the clearcoat normal node.
       *
       * @return {Node<vec3>} The clearcoat noraml.
       */
    }, {
      key: "setupClearcoatNormal",
      value: function setupClearcoatNormal() {
        return this.clearcoatNormalNode ? vec3(this.clearcoatNormalNode) : materialClearcoatNormal;
      }
    }, {
      key: "setup",
      value: function setup(builder) {
        var _this96 = this;
        builder.context.setupClearcoatNormal = function () {
          return _this96.setupClearcoatNormal(builder);
        };
        _superPropGet(MeshPhysicalNodeMaterial, "setup", this, 3)([builder]);
      }
    }, {
      key: "copy",
      value: function copy(source) {
        this.clearcoatNode = source.clearcoatNode;
        this.clearcoatRoughnessNode = source.clearcoatRoughnessNode;
        this.clearcoatNormalNode = source.clearcoatNormalNode;
        this.sheenNode = source.sheenNode;
        this.sheenRoughnessNode = source.sheenRoughnessNode;
        this.iridescenceNode = source.iridescenceNode;
        this.iridescenceIORNode = source.iridescenceIORNode;
        this.iridescenceThicknessNode = source.iridescenceThicknessNode;
        this.specularIntensityNode = source.specularIntensityNode;
        this.specularColorNode = source.specularColorNode;
        this.transmissionNode = source.transmissionNode;
        this.thicknessNode = source.thicknessNode;
        this.attenuationDistanceNode = source.attenuationDistanceNode;
        this.attenuationColorNode = source.attenuationColorNode;
        this.dispersionNode = source.dispersionNode;
        this.anisotropyNode = source.anisotropyNode;
        return _superPropGet(MeshPhysicalNodeMaterial, "copy", this, 3)([source]);
      }
    }], [{
      key: "type",
      get: function get() {
        return 'MeshPhysicalNodeMaterial';
      }
    }]);
  }(MeshStandardNodeMaterial);
  /** @module MeshSSSNodeMaterial **/
  /**
   * Represents the lighting model for {@link MeshSSSNodeMaterial}.
   *
   * @augments PhysicalLightingModel
   */
  var SSSLightingModel = /*#__PURE__*/function (_PhysicalLightingMode) {
    /**
     * Constructs a new physical lighting model.
     *
     * @param {Boolean} [clearcoat=false] - Whether clearcoat is supported or not.
     * @param {Boolean} [sheen=false] - Whether sheen is supported or not.
     * @param {Boolean} [iridescence=false] - Whether iridescence is supported or not.
     * @param {Boolean} [anisotropy=false] - Whether anisotropy is supported or not.
     * @param {Boolean} [transmission=false] - Whether transmission is supported or not.
     * @param {Boolean} [dispersion=false] - Whether dispersion is supported or not.
     * @param {Boolean} [sss=false] - Whether SSS is supported or not.
     */
    function SSSLightingModel() {
      var _this97;
      var clearcoat = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      var sheen = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      var iridescence = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      var anisotropy = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
      var transmission = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
      var dispersion = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;
      var sss = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : false;
      (0, _classCallCheck2.default)(this, SSSLightingModel);
      _this97 = _callSuper(this, SSSLightingModel, [clearcoat, sheen, iridescence, anisotropy, transmission, dispersion]);

      /**
       * Whether the lighting model should use SSS or not.
       *
       * @type {Boolean}
       * @default false
       */
      _this97.useSSS = sss;
      return _this97;
    }

    /**
     * Extends the default implementation with a SSS term.
     *
     * Reference: [Approximating Translucency for a Fast, Cheap and Convincing Subsurface Scattering Look]{@link https://colinbarrebrisebois.com/2011/03/07/gdc-2011-approximating-translucency-for-a-fast-cheap-and-convincing-subsurface-scattering-look/}
     *
     * @param {Object} input - The input data.
     * @param {StackNode} stack - The current stack.
     * @param {NodeBuilder} builder - The current node builder.
     */
    (0, _inherits2.default)(SSSLightingModel, _PhysicalLightingMode);
    return (0, _createClass2.default)(SSSLightingModel, [{
      key: "direct",
      value: function direct(_ref111, stack, builder) {
        var lightDirection = _ref111.lightDirection,
          lightColor = _ref111.lightColor,
          reflectedLight = _ref111.reflectedLight;
        if (this.useSSS === true) {
          var material = builder.material;
          var thicknessColorNode = material.thicknessColorNode,
            thicknessDistortionNode = material.thicknessDistortionNode,
            thicknessAmbientNode = material.thicknessAmbientNode,
            thicknessAttenuationNode = material.thicknessAttenuationNode,
            thicknessPowerNode = material.thicknessPowerNode,
            thicknessScaleNode = material.thicknessScaleNode;
          var scatteringHalf = lightDirection.add(transformedNormalView.mul(thicknessDistortionNode)).normalize();
          var scatteringDot = float(positionViewDirection.dot(scatteringHalf.negate()).saturate().pow(thicknessPowerNode).mul(thicknessScaleNode));
          var scatteringIllu = vec3(scatteringDot.add(thicknessAmbientNode).mul(thicknessColorNode));
          reflectedLight.directDiffuse.addAssign(scatteringIllu.mul(thicknessAttenuationNode.mul(lightColor)));
        }
        _superPropGet(SSSLightingModel, "direct", this, 3)([{
          lightDirection: lightDirection,
          lightColor: lightColor,
          reflectedLight: reflectedLight
        }, stack, builder]);
      }
    }]);
  }(PhysicalLightingModel);
  /**
   * This node material is an experimental extension of {@link MeshPhysicalNodeMaterial}
   * that implements a Subsurface scattering (SSS) term.
   *
   * @augments MeshPhysicalNodeMaterial
   */
  var MeshSSSNodeMaterial = exports.MeshSSSNodeMaterial = /*#__PURE__*/function (_MeshPhysicalNodeMate) {
    /**
     * Constructs a new mesh SSS node material.
     *
     * @param {Object?} parameters - The configuration parameter.
     */
    function MeshSSSNodeMaterial(parameters) {
      var _this98;
      (0, _classCallCheck2.default)(this, MeshSSSNodeMaterial);
      _this98 = _callSuper(this, MeshSSSNodeMaterial, [parameters]);

      /**
       * Represents the thickness color.
       *
       * @type {Node<vec3>?}
       * @default null
       */
      _this98.thicknessColorNode = null;

      /**
       * Represents the distortion factor.
       *
       * @type {Node<float>?}
       */
      _this98.thicknessDistortionNode = float(0.1);

      /**
       * Represents the thickness ambient factor.
       *
       * @type {Node<float>?}
       */
      _this98.thicknessAmbientNode = float(0.0);

      /**
       * Represents the thickness attenuation.
       *
       * @type {Node<float>?}
       */
      _this98.thicknessAttenuationNode = float(.1);

      /**
       * Represents the thickness power.
       *
       * @type {Node<float>?}
       */
      _this98.thicknessPowerNode = float(2.0);

      /**
       * Represents the thickness scale.
       *
       * @type {Node<float>?}
       */
      _this98.thicknessScaleNode = float(10.0);
      return _this98;
    }

    /**
     * Whether the lighting model should use SSS or not.
     *
     * @type {Boolean}
     * @default true
     */
    (0, _inherits2.default)(MeshSSSNodeMaterial, _MeshPhysicalNodeMate);
    return (0, _createClass2.default)(MeshSSSNodeMaterial, [{
      key: "useSSS",
      get: function get() {
        return this.thicknessColorNode !== null;
      }

      /**
       * Setups the lighting model.
       *
       * @return {SSSLightingModel} The lighting model.
       */
    }, {
      key: "setupLightingModel",
      value: function setupLightingModel(/*builder*/
      ) {
        return new SSSLightingModel(this.useClearcoat, this.useSheen, this.useIridescence, this.useAnisotropy, this.useTransmission, this.useDispersion, this.useSSS);
      }
    }, {
      key: "copy",
      value: function copy(source) {
        this.thicknessColorNode = source.thicknessColorNode;
        this.thicknessDistortionNode = source.thicknessDistortionNode;
        this.thicknessAmbientNode = source.thicknessAmbientNode;
        this.thicknessAttenuationNode = source.thicknessAttenuationNode;
        this.thicknessPowerNode = source.thicknessPowerNode;
        this.thicknessScaleNode = source.thicknessScaleNode;
        return _superPropGet(MeshSSSNodeMaterial, "copy", this, 3)([source]);
      }
    }], [{
      key: "type",
      get: function get() {
        return 'MeshSSSNodeMaterial';
      }
    }]);
  }(MeshPhysicalNodeMaterial);
  var getGradientIrradiance = /*@__PURE__*/Fn(function (_ref112) {
    var normal = _ref112.normal,
      lightDirection = _ref112.lightDirection,
      builder = _ref112.builder;
    // dotNL will be from -1.0 to 1.0
    var dotNL = normal.dot(lightDirection);
    var coord = vec2(dotNL.mul(0.5).add(0.5), 0.0);
    if (builder.material.gradientMap) {
      var gradientMap = materialReference('gradientMap', 'texture').context({
        getUV: function getUV() {
          return coord;
        }
      });
      return vec3(gradientMap.r);
    } else {
      var fw = coord.fwidth().mul(0.5);
      return mix(vec3(0.7), vec3(1.0), smoothstep(float(0.7).sub(fw.x), float(0.7).add(fw.x), coord.x));
    }
  });

  /**
   * Represents the lighting model for a toon material. Used in {@link MeshToonNodeMaterial}.
   *
   * @augments LightingModel
   */
  var ToonLightingModel = /*#__PURE__*/function (_LightingModel3) {
    function ToonLightingModel() {
      (0, _classCallCheck2.default)(this, ToonLightingModel);
      return _callSuper(this, ToonLightingModel, arguments);
    }
    (0, _inherits2.default)(ToonLightingModel, _LightingModel3);
    return (0, _createClass2.default)(ToonLightingModel, [{
      key: "direct",
      value:
      /**
       * Implements the direct lighting. Instead of using a conventional smooth irradiance, the irradiance is
       * reduced to a small number of discrete shades to create a comic-like, flat look.
       *
       * @param {Object} input - The input data.
       * @param {StackNode} stack - The current stack.
       * @param {NodeBuilder} builder - The current node builder.
       */
      function direct(_ref113, stack, builder) {
        var lightDirection = _ref113.lightDirection,
          lightColor = _ref113.lightColor,
          reflectedLight = _ref113.reflectedLight;
        var irradiance = getGradientIrradiance({
          normal: normalGeometry,
          lightDirection: lightDirection,
          builder: builder
        }).mul(lightColor);
        reflectedLight.directDiffuse.addAssign(irradiance.mul(BRDF_Lambert({
          diffuseColor: diffuseColor.rgb
        })));
      }

      /**
       * Implements the indirect lighting.
       *
       * @param {ContextNode} input - The current node context.
       * @param {StackNode} stack - The current stack.
       * @param {NodeBuilder} builder - The current node builder.
       */
    }, {
      key: "indirect",
      value: function indirect(_ref114) {
        var ambientOcclusion = _ref114.ambientOcclusion,
          irradiance = _ref114.irradiance,
          reflectedLight = _ref114.reflectedLight;
        reflectedLight.indirectDiffuse.addAssign(irradiance.mul(BRDF_Lambert({
          diffuseColor: diffuseColor
        })));
        reflectedLight.indirectDiffuse.mulAssign(ambientOcclusion);
      }
    }]);
  }(LightingModel);
  var _defaultValues$4 = /*@__PURE__*/new (_$$_REQUIRE(_dependencyMap[1], "./three.core.js").MeshToonMaterial)();

  /**
   * Node material version of `MeshToonMaterial`.
   *
   * @augments NodeMaterial
   */
  var MeshToonNodeMaterial = exports.MeshToonNodeMaterial = /*#__PURE__*/function (_NodeMaterial10) {
    /**
     * Constructs a new mesh toon node material.
     *
     * @param {Object?} parameters - The configuration parameter.
     */
    function MeshToonNodeMaterial(parameters) {
      var _this99;
      (0, _classCallCheck2.default)(this, MeshToonNodeMaterial);
      _this99 = _callSuper(this, MeshToonNodeMaterial);

      /**
       * This flag can be used for type testing.
       *
       * @type {Boolean}
       * @readonly
       * @default true
       */
      _this99.isMeshToonNodeMaterial = true;

      /**
       * Set to `true` because toon materials react on lights.
       *
       * @type {Boolean}
       * @default true
       */
      _this99.lights = true;
      _this99.setDefaultValues(_defaultValues$4);
      _this99.setValues(parameters);
      return _this99;
    }

    /**
     * Setups the lighting model.
     *
     * @return {ToonLightingModel} The lighting model.
     */
    (0, _inherits2.default)(MeshToonNodeMaterial, _NodeMaterial10);
    return (0, _createClass2.default)(MeshToonNodeMaterial, [{
      key: "setupLightingModel",
      value: function setupLightingModel(/*builder*/
      ) {
        return new ToonLightingModel();
      }
    }], [{
      key: "type",
      get: function get() {
        return 'MeshToonNodeMaterial';
      }
    }]);
  }(NodeMaterial);
  /** @module MatcapUVNode **/
  /**
   * Can be used to compute texture coordinates for projecting a
   * matcap onto a mesh. Used by {@link MeshMatcapNodeMaterial}.
   *
   * @augments TempNode
   */
  var MatcapUVNode = exports.MatcapUVNode = /*#__PURE__*/function (_TempNode16) {
    /**
     * Constructs a new matcap uv node.
     */
    function MatcapUVNode() {
      (0, _classCallCheck2.default)(this, MatcapUVNode);
      return _callSuper(this, MatcapUVNode, ['vec2']);
    }
    (0, _inherits2.default)(MatcapUVNode, _TempNode16);
    return (0, _createClass2.default)(MatcapUVNode, [{
      key: "setup",
      value: function setup() {
        var x = vec3(positionViewDirection.z, 0, positionViewDirection.x.negate()).normalize();
        var y = positionViewDirection.cross(x);
        return vec2(x.dot(transformedNormalView), y.dot(transformedNormalView)).mul(0.495).add(0.5); // 0.495 to remove artifacts caused by undersized matcap disks
      }
    }], [{
      key: "type",
      get: function get() {
        return 'MatcapUVNode';
      }
    }]);
  }(TempNode);
  /**
   * TSL function for creating a matcap uv node.
   *
   * @function
   * @returns {MatcapUVNode}
   */
  var matcapUV = /*@__PURE__*/nodeImmutable(MatcapUVNode);
  var _defaultValues$3 = /*@__PURE__*/new (_$$_REQUIRE(_dependencyMap[1], "./three.core.js").MeshMatcapMaterial)();

  /**
   * Node material version of `MeshMatcapMaterial`.
   *
   * @augments NodeMaterial
   */
  var MeshMatcapNodeMaterial = exports.MeshMatcapNodeMaterial = /*#__PURE__*/function (_NodeMaterial11) {
    /**
     * Constructs a new mesh normal node material.
     *
     * @param {Object?} parameters - The configuration parameter.
     */
    function MeshMatcapNodeMaterial(parameters) {
      var _this100;
      (0, _classCallCheck2.default)(this, MeshMatcapNodeMaterial);
      _this100 = _callSuper(this, MeshMatcapNodeMaterial);

      /**
       * This flag can be used for type testing.
       *
       * @type {Boolean}
       * @readonly
       * @default true
       */
      _this100.isMeshMatcapNodeMaterial = true;
      _this100.setDefaultValues(_defaultValues$3);
      _this100.setValues(parameters);
      return _this100;
    }

    /**
     * Setups the matcap specific node variables.
     *
     * @param {NodeBuilder} builder - The current node builder.
     */
    (0, _inherits2.default)(MeshMatcapNodeMaterial, _NodeMaterial11);
    return (0, _createClass2.default)(MeshMatcapNodeMaterial, [{
      key: "setupVariants",
      value: function setupVariants(builder) {
        var uv = matcapUV;
        var matcapColor;
        if (builder.material.matcap) {
          matcapColor = materialReference('matcap', 'texture').context({
            getUV: function getUV() {
              return uv;
            }
          });
        } else {
          matcapColor = vec3(mix(0.2, 0.8, uv.y)); // default if matcap is missing
        }
        diffuseColor.rgb.mulAssign(matcapColor.rgb);
      }
    }], [{
      key: "type",
      get: function get() {
        return 'MeshMatcapNodeMaterial';
      }
    }]);
  }(NodeMaterial);
  var _defaultValues$2 = /*@__PURE__*/new (_$$_REQUIRE(_dependencyMap[1], "./three.core.js").PointsMaterial)();

  /**
   * Node material version of `PointsMaterial`.
   *
   * Since WebGPU can render point primitives only with a size of one pixel,
   * this material type does not evaluate the `size` and `sizeAttenuation`
   * property of `PointsMaterial`. Use {@link InstancedPointsNodeMaterial}
   * instead if you need points with a size larger than one pixel.
   *
   * @augments NodeMaterial
   */
  var PointsNodeMaterial = exports.PointsNodeMaterial = /*#__PURE__*/function (_NodeMaterial12) {
    /**
     * Constructs a new points node material.
     *
     * @param {Object?} parameters - The configuration parameter.
     */
    function PointsNodeMaterial(parameters) {
      var _this101;
      (0, _classCallCheck2.default)(this, PointsNodeMaterial);
      _this101 = _callSuper(this, PointsNodeMaterial);

      /**
       * This flag can be used for type testing.
       *
       * @type {Boolean}
       * @readonly
       * @default true
       */
      _this101.isPointsNodeMaterial = true;
      _this101.setDefaultValues(_defaultValues$2);
      _this101.setValues(parameters);
      return _this101;
    }
    (0, _inherits2.default)(PointsNodeMaterial, _NodeMaterial12);
    return (0, _createClass2.default)(PointsNodeMaterial, null, [{
      key: "type",
      get: function get() {
        return 'PointsNodeMaterial';
      }
    }]);
  }(NodeMaterial);
  /** @module RotateNode **/
  /**
   * Applies a rotation to the given position node.
   *
   * @augments TempNode
   */
  var RotateNode = exports.RotateNode = /*#__PURE__*/function (_TempNode17) {
    /**
     * Constructs a new rotate node.
     *
     * @param {Node} positionNode - The position node.
     * @param {Node} rotationNode - Represents the rotation that is applied to the position node. Depending
     * on whether the position data are 2D or 3D, the rotation is expressed a single float value or an Euler value.
     */
    function RotateNode(positionNode, rotationNode) {
      var _this102;
      (0, _classCallCheck2.default)(this, RotateNode);
      _this102 = _callSuper(this, RotateNode);

      /**
       * The position node.
       *
       * @type {Node}
       */
      _this102.positionNode = positionNode;

      /**
       *  Represents the rotation that is applied to the position node.
       *  Depending on whether the position data are 2D or 3D, the rotation is expressed a single float value or an Euler value.
       *
       * @type {Node}
       */
      _this102.rotationNode = rotationNode;
      return _this102;
    }

    /**
     * The type of the {@link RotateNode#positionNode} defines the node's type.
     *
     * @param {NodeBuilder} builder - The current node builder.
     * @return {String} The node's type.
     */
    (0, _inherits2.default)(RotateNode, _TempNode17);
    return (0, _createClass2.default)(RotateNode, [{
      key: "getNodeType",
      value: function getNodeType(builder) {
        return this.positionNode.getNodeType(builder);
      }
    }, {
      key: "setup",
      value: function setup(builder) {
        var rotationNode = this.rotationNode,
          positionNode = this.positionNode;
        var nodeType = this.getNodeType(builder);
        if (nodeType === 'vec2') {
          var cosAngle = rotationNode.cos();
          var sinAngle = rotationNode.sin();
          var rotationMatrix = mat2(cosAngle, sinAngle, sinAngle.negate(), cosAngle);
          return rotationMatrix.mul(positionNode);
        } else {
          var rotation = rotationNode;
          var rotationXMatrix = mat4(vec4(1.0, 0.0, 0.0, 0.0), vec4(0.0, cos(rotation.x), sin(rotation.x).negate(), 0.0), vec4(0.0, sin(rotation.x), cos(rotation.x), 0.0), vec4(0.0, 0.0, 0.0, 1.0));
          var rotationYMatrix = mat4(vec4(cos(rotation.y), 0.0, sin(rotation.y), 0.0), vec4(0.0, 1.0, 0.0, 0.0), vec4(sin(rotation.y).negate(), 0.0, cos(rotation.y), 0.0), vec4(0.0, 0.0, 0.0, 1.0));
          var rotationZMatrix = mat4(vec4(cos(rotation.z), sin(rotation.z).negate(), 0.0, 0.0), vec4(sin(rotation.z), cos(rotation.z), 0.0, 0.0), vec4(0.0, 0.0, 1.0, 0.0), vec4(0.0, 0.0, 0.0, 1.0));
          return rotationXMatrix.mul(rotationYMatrix).mul(rotationZMatrix).mul(vec4(positionNode, 1.0)).xyz;
        }
      }
    }], [{
      key: "type",
      get: function get() {
        return 'RotateNode';
      }
    }]);
  }(TempNode);
  /**
   * TSL function for creating a rotate node.
   *
   * @function
   * @param {Node} positionNode - The position node.
   * @param {Node} rotationNode - Represents the rotation that is applied to the position node. Depending
   * on whether the position data are 2D or 3D, the rotation is expressed a single float value or an Euler value.
   * @returns {RotateNode}
   */
  var rotate = /*@__PURE__*/nodeProxy(RotateNode);
  var _defaultValues$1 = /*@__PURE__*/new (_$$_REQUIRE(_dependencyMap[1], "./three.core.js").SpriteMaterial)();

  /**
   * Node material version of `SpriteMaterial`.
   *
   * @augments NodeMaterial
   */
  var SpriteNodeMaterial = exports.SpriteNodeMaterial = /*#__PURE__*/function (_NodeMaterial13) {
    /**
     * Constructs a new sprite node material.
     *
     * @param {Object?} parameters - The configuration parameter.
     */
    function SpriteNodeMaterial(parameters) {
      var _this103;
      (0, _classCallCheck2.default)(this, SpriteNodeMaterial);
      _this103 = _callSuper(this, SpriteNodeMaterial);

      /**
       * This flag can be used for type testing.
       *
       * @type {Boolean}
       * @readonly
       * @default true
       */
      _this103.isSpriteNodeMaterial = true;
      _this103._useSizeAttenuation = true;

      /**
       * This property makes it possible to define the position of the sprite with a
       * node. That can be useful when the material is used with instanced rendering
       * and node data are defined with an instanced attribute node:
       * ```js
       * const positionAttribute = new InstancedBufferAttribute( new Float32Array( positions ), 3 );
       * material.positionNode = instancedBufferAttribute( positionAttribute );
       * ```
       * Another possibility is to compute the instanced data with a compute shader:
       * ```js
       * const positionBuffer = instancedArray( particleCount, 'vec3' );
       * particleMaterial.positionNode = positionBuffer.toAttribute();
       * ```
       *
       * @type {Node<vec2>?}
       * @default null
       */
      _this103.positionNode = null;

      /**
       * The rotation of sprite materials is by default inferred from the `rotation`,
       * property. This node property allows to overwrite the default and define
       * the rotation with a node instead.
       *
       * If you don't want to overwrite the rotation but modify the existing
       * value instead, use {@link module:MaterialNode.materialRotation}.
       *
       * @type {Node<float>?}
       * @default null
       */
      _this103.rotationNode = null;

      /**
       * This node property provides an additional way to scale sprites next to
       * `Object3D.scale`. The scale transformation based in `Object3D.scale`
       * is multiplied with the scale value of this node in the vertex shader.
       *
       * @type {Node<vec2>?}
       * @default null
       */
      _this103.scaleNode = null;
      _this103.setDefaultValues(_defaultValues$1);
      _this103.setValues(parameters);
      return _this103;
    }

    /**
     * Setups the position node in view space. This method implements
     * the sprite specific vertex shader.
     *
     * @param {NodeBuilder} builder - The current node builder.
     * @return {Node<vec3>} The position in view space.
     */
    (0, _inherits2.default)(SpriteNodeMaterial, _NodeMaterial13);
    return (0, _createClass2.default)(SpriteNodeMaterial, [{
      key: "setupPositionView",
      value: function setupPositionView(builder) {
        var object = builder.object,
          camera = builder.camera;
        var sizeAttenuation = this.sizeAttenuation;
        var positionNode = this.positionNode,
          rotationNode = this.rotationNode,
          scaleNode = this.scaleNode;
        var mvPosition = modelViewMatrix.mul(vec3(positionNode || 0));
        var scale = vec2(modelWorldMatrix[0].xyz.length(), modelWorldMatrix[1].xyz.length());
        if (scaleNode !== null) {
          scale = scale.mul(scaleNode);
        }
        if (sizeAttenuation === false) {
          if (camera.isPerspectiveCamera) {
            scale = scale.mul(mvPosition.z.negate());
          } else {
            var orthoScale = float(2.0).div(cameraProjectionMatrix.element(1).element(1));
            scale = scale.mul(orthoScale.mul(2));
          }
        }
        var alignedPosition = positionGeometry.xy;
        if (object.center && object.center.isVector2 === true) {
          var center = reference$1('center', 'vec2', object);
          alignedPosition = alignedPosition.sub(center.sub(0.5));
        }
        alignedPosition = alignedPosition.mul(scale);
        var rotation = float(rotationNode || materialRotation);
        var rotatedPosition = rotate(alignedPosition, rotation);
        return vec4(mvPosition.xy.add(rotatedPosition), mvPosition.zw);
      }
    }, {
      key: "copy",
      value: function copy(source) {
        this.positionNode = source.positionNode;
        this.rotationNode = source.rotationNode;
        this.scaleNode = source.scaleNode;
        return _superPropGet(SpriteNodeMaterial, "copy", this, 3)([source]);
      }

      /**
       * Whether to use size attenuation or not.
       *
       * @type {Boolean}
       * @default true
       */
    }, {
      key: "sizeAttenuation",
      get: function get() {
        return this._useSizeAttenuation;
      },
      set: function set(value) {
        if (this._useSizeAttenuation !== value) {
          this._useSizeAttenuation = value;
          this.needsUpdate = true;
        }
      }
    }], [{
      key: "type",
      get: function get() {
        return 'SpriteNodeMaterial';
      }
    }]);
  }(NodeMaterial);
  /**
   * Represents lighting model for a shadow material. Used in {@link ShadowNodeMaterial}.
   *
   * @augments LightingModel
   */
  var ShadowMaskModel = /*#__PURE__*/function (_LightingModel4) {
    /**
     * Constructs a new shadow mask model.
     */
    function ShadowMaskModel() {
      var _this104;
      (0, _classCallCheck2.default)(this, ShadowMaskModel);
      _this104 = _callSuper(this, ShadowMaskModel);

      /**
       * The shadow mask node.
       *
       * @type {Node}
       */
      _this104.shadowNode = float(1).toVar('shadowMask');
      return _this104;
    }

    /**
     * Only used to save the shadow mask.
     *
     * @param {Object} input - The input data.
     */
    (0, _inherits2.default)(ShadowMaskModel, _LightingModel4);
    return (0, _createClass2.default)(ShadowMaskModel, [{
      key: "direct",
      value: function direct(_ref115) {
        var shadowMask = _ref115.shadowMask;
        this.shadowNode.mulAssign(shadowMask);
      }

      /**
       * Uses the shadow mask to produce the final color.
       *
       * @param {ContextNode} context - The current node context.
       */
    }, {
      key: "finish",
      value: function finish(context) {
        diffuseColor.a.mulAssign(this.shadowNode.oneMinus());
        context.outgoingLight.rgb.assign(diffuseColor.rgb); // TODO: Optimize LightsNode to avoid this assignment
      }
    }]);
  }(LightingModel);
  var _defaultValues = /*@__PURE__*/new (_$$_REQUIRE(_dependencyMap[1], "./three.core.js").ShadowMaterial)();

  /**
   * Node material version of `ShadowMaterial`.
   *
   * @augments NodeMaterial
   */
  var ShadowNodeMaterial = exports.ShadowNodeMaterial = /*#__PURE__*/function (_NodeMaterial14) {
    /**
     * Constructs a new shadow node material.
     *
     * @param {Object?} parameters - The configuration parameter.
     */
    function ShadowNodeMaterial(parameters) {
      var _this105;
      (0, _classCallCheck2.default)(this, ShadowNodeMaterial);
      _this105 = _callSuper(this, ShadowNodeMaterial);

      /**
       * This flag can be used for type testing.
       *
       * @type {Boolean}
       * @readonly
       * @default true
       */
      _this105.isShadowNodeMaterial = true;

      /**
       * Set to `true` because so it's possible to implement
       * the shadow mask effect.
       *
       * @type {Boolean}
       * @default true
       */
      _this105.lights = true;
      _this105.setDefaultValues(_defaultValues);
      _this105.setValues(parameters);
      return _this105;
    }

    /**
     * Setups the lighting model.
     *
     * @return {ShadowMaskModel} The lighting model.
     */
    (0, _inherits2.default)(ShadowNodeMaterial, _NodeMaterial14);
    return (0, _createClass2.default)(ShadowNodeMaterial, [{
      key: "setupLightingModel",
      value: function setupLightingModel(/*builder*/
      ) {
        return new ShadowMaskModel();
      }
    }], [{
      key: "type",
      get: function get() {
        return 'ShadowNodeMaterial';
      }
    }]);
  }(NodeMaterial);
  /** @module Texture3DNode **/
  var _normal2 = Fn(function (_ref116) {
    var texture = _ref116.texture,
      uv = _ref116.uv;
    var epsilon = 0.0001;
    var ret = vec3().toVar();
    If(uv.x.lessThan(epsilon), function () {
      ret.assign(vec3(1, 0, 0));
    }).ElseIf(uv.y.lessThan(epsilon), function () {
      ret.assign(vec3(0, 1, 0));
    }).ElseIf(uv.z.lessThan(epsilon), function () {
      ret.assign(vec3(0, 0, 1));
    }).ElseIf(uv.x.greaterThan(1 - epsilon), function () {
      ret.assign(vec3(-1, 0, 0));
    }).ElseIf(uv.y.greaterThan(1 - epsilon), function () {
      ret.assign(vec3(0, -1, 0));
    }).ElseIf(uv.z.greaterThan(1 - epsilon), function () {
      ret.assign(vec3(0, 0, -1));
    }).Else(function () {
      var step = 0.01;
      var x = texture.sample(uv.add(vec3(-step, 0.0, 0.0))).r.sub(texture.sample(uv.add(vec3(step, 0.0, 0.0))).r);
      var y = texture.sample(uv.add(vec3(0.0, -step, 0.0))).r.sub(texture.sample(uv.add(vec3(0.0, step, 0.0))).r);
      var z = texture.sample(uv.add(vec3(0.0, 0.0, -step))).r.sub(texture.sample(uv.add(vec3(0.0, 0.0, step))).r);
      ret.assign(vec3(x, y, z));
    });
    return ret.normalize();
  });

  /**
   * This type of uniform node represents a 3D texture.
   *
   * @augments module:TextureNode~TextureNode
   */
  var Texture3DNode = exports.Texture3DNode = /*#__PURE__*/function (_TextureNode3) {
    /**
     * Constructs a new 3D texture node.
     *
     * @param {Data3DTexture} value - The 3D texture.
     * @param {Node<vec2|vec3>?} [uvNode=null] - The uv node.
     * @param {Node<int>?} [levelNode=null] - The level node.
     */
    function Texture3DNode(value) {
      var _this106;
      var uvNode = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      var levelNode = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
      (0, _classCallCheck2.default)(this, Texture3DNode);
      _this106 = _callSuper(this, Texture3DNode, [value, uvNode, levelNode]);

      /**
       * This flag can be used for type testing.
       *
       * @type {Boolean}
       * @readonly
       * @default true
       */
      _this106.isTexture3DNode = true;
      return _this106;
    }

    /**
     * Overwrites the default implementation to return a fixed value `'texture3D'`.
     *
     * @param {NodeBuilder} builder - The current node builder.
     * @return {String} The input type.
     */
    (0, _inherits2.default)(Texture3DNode, _TextureNode3);
    return (0, _createClass2.default)(Texture3DNode, [{
      key: "getInputType",
      value: function getInputType(/*builder*/
      ) {
        return 'texture3D';
      }

      /**
       * Returns a default uv node which is in context of 3D textures a three-dimensional
       * uv node.
       *
       * @return {Node<vec3>} The default uv node.
       */
    }, {
      key: "getDefaultUV",
      value: function getDefaultUV() {
        return vec3(0.5, 0.5, 0.5);
      }

      /**
       * Overwritten with an empty implementation since the `updateMatrix` flag is ignored
       * for 3D textures. The uv transformation matrix is not applied to 3D textures.
       *
       * @param {Boolean} value - The update toggle.
       */
    }, {
      key: "setUpdateMatrix",
      value: function setUpdateMatrix(/*updateMatrix*/) {} // Ignore .updateMatrix for 3d TextureNode

      /**
       * Overwrites the default implementation to return the unmodified uv node.
       *
       * @param {NodeBuilder} builder - The current node builder.
       * @param {Node} uvNode - The uv node to setup.
       * @return {Node} The unmodified uv node.
       */
    }, {
      key: "setupUV",
      value: function setupUV(builder, uvNode) {
        var texture = this.value;
        if (builder.isFlipY() && (texture.isRenderTargetTexture === true || texture.isFramebufferTexture === true)) {
          if (this.sampler) {
            uvNode = uvNode.flipY();
          } else {
            uvNode = uvNode.setY(int(textureSize(this, this.levelNode).y).sub(uvNode.y).sub(1));
          }
        }
        return uvNode;
      }

      /**
       * Generates the uv code snippet.
       *
       * @param {NodeBuilder} builder - The current node builder.
       * @param {Node} uvNode - The uv node to generate code for.
       * @return {String} The generated code snippet.
       */
    }, {
      key: "generateUV",
      value: function generateUV(builder, uvNode) {
        return uvNode.build(builder, 'vec3');
      }

      /**
       * TODO.
       *
       * @param {Node<vec3>} uvNode - The uv node .
       * @return {Node<vec3>} TODO.
       */
    }, {
      key: "normal",
      value: function normal(uvNode) {
        return _normal2({
          texture: this,
          uv: uvNode
        });
      }
    }], [{
      key: "type",
      get: function get() {
        return 'Texture3DNode';
      }
    }]);
  }(TextureNode);
  /**
   * TSL function for creating a 3D texture node.
   *
   * @function
   * @param {Data3DTexture} value - The 3D texture.
   * @param {Node<vec2|vec3>?} [uvNode=null] - The uv node.
   * @param {Node<int>?} [levelNode=null] - The level node.
   * @returns {Texture3DNode}
   */
  var texture3D = /*@__PURE__*/nodeProxy(Texture3DNode);

  /** @module VolumeNodeMaterial **/

  /**
   * Node material intended for volume rendering. The volumetic data are
   * defined with an instance of {@link Data3DTexture}.
   *
   * @augments NodeMaterial
   */
  var VolumeNodeMaterial = exports.VolumeNodeMaterial = /*#__PURE__*/function (_NodeMaterial15) {
    /**
     * Constructs a new volume node material.
     *
     * @param {Object?} parameters - The configuration parameter.
     */
    function VolumeNodeMaterial(parameters) {
      var _this107;
      (0, _classCallCheck2.default)(this, VolumeNodeMaterial);
      _this107 = _callSuper(this, VolumeNodeMaterial);

      /**
       * This flag can be used for type testing.
       *
       * @type {Boolean}
       * @readonly
       * @default true
       */
      _this107.isVolumeNodeMaterial = true;

      /**
       * The base color of the volume.
       *
       * @type {Color}
       * @default 100
       */
      _this107.base = new (_$$_REQUIRE(_dependencyMap[1], "./three.core.js").Color)(0xffffff);

      /**
       * A 3D data texture holding the volumetric data.
       *
       * @type {Data3DTexture?}
       * @default null
       */
      _this107.map = null;

      /**
       * This number of samples for each ray that hits the mesh's surface
       * and travels through the volume.
       *
       * @type {Number}
       * @default 100
       */
      _this107.steps = 100;

      /**
       * Callback for {@link VolumeNodeMaterial#testNode}.
       *
       * @callback testNodeCallback
       * @param {Data3DTexture<float>} map - The 3D texture.
       * @param {Node<float>} mapValue - The sampled value inside the volume.
       * @param {Node<vec3>} probe - The probe which is the entry point of the ray on the mesh's surface.
       * @param {Node<vec4>} finalColor - The final color.
       */

      /**
       * The volume rendering of this material works by shooting rays
       * from the camera position through each fragment of the mesh's
       * surface and sample the inner volume in a raymarching fashion
       * mutiple times.
       *
       * This node can be used to assign a callback function of type `Fn`
       * that will be exexuted per sample. The callback receives the
       * texture, the sampled texture value as well as position on the surface
       * where the rays enters the volume. The last parameter is a color
       * that allows the callback to determine the final color.
       *
       * @type {testNodeCallback?}
       * @default null
       */
      _this107.testNode = null;
      _this107.setValues(parameters);
      return _this107;
    }

    /**
     * Setups the vertex and fragment stage of this node material.
     *
     * @param {NodeBuilder} builder - The current node builder.
     */
    (0, _inherits2.default)(VolumeNodeMaterial, _NodeMaterial15);
    return (0, _createClass2.default)(VolumeNodeMaterial, [{
      key: "setup",
      value: function setup(builder) {
        var _this108 = this;
        var map = texture3D(this.map, null, 0);
        var hitBox = Fn(function (_ref117) {
          var orig = _ref117.orig,
            dir = _ref117.dir;
          var box_min = vec3(-0.5);
          var box_max = vec3(0.5);
          var inv_dir = dir.reciprocal();
          var tmin_tmp = box_min.sub(orig).mul(inv_dir);
          var tmax_tmp = box_max.sub(orig).mul(inv_dir);
          var tmin = min$1(tmin_tmp, tmax_tmp);
          var tmax = max$1(tmin_tmp, tmax_tmp);
          var t0 = max$1(tmin.x, max$1(tmin.y, tmin.z));
          var t1 = min$1(tmax.x, min$1(tmax.y, tmax.z));
          return vec2(t0, t1);
        });
        this.fragmentNode = Fn(function () {
          var vOrigin = varying(vec3(modelWorldMatrixInverse.mul(vec4(cameraPosition, 1.0))));
          var vDirection = varying(positionGeometry.sub(vOrigin));
          var rayDir = vDirection.normalize();
          var bounds = vec2(hitBox({
            orig: vOrigin,
            dir: rayDir
          })).toVar();
          bounds.x.greaterThan(bounds.y).discard();
          bounds.assign(vec2(max$1(bounds.x, 0.0), bounds.y));
          var p = vec3(vOrigin.add(bounds.x.mul(rayDir))).toVar();
          var inc = vec3(rayDir.abs().reciprocal()).toVar();
          var delta = float(min$1(inc.x, min$1(inc.y, inc.z))).toVar('delta'); // used 'delta' name in loop

          delta.divAssign(materialReference('steps', 'float'));
          var ac = vec4(materialReference('base', 'color'), 0.0).toVar();
          Loop({
            type: 'float',
            start: bounds.x,
            end: bounds.y,
            update: '+= delta'
          }, function () {
            var d = property('float', 'd').assign(map.sample(p.add(0.5)).r);
            if (_this108.testNode !== null) {
              _this108.testNode({
                map: map,
                mapValue: d,
                probe: p,
                finalColor: ac
              }).append();
            } else {
              // default to show surface of mesh
              ac.a.assign(1);
              Break();
            }
            p.addAssign(rayDir.mul(delta));
          });
          ac.a.equal(0).discard();
          return vec4(ac);
        })();
        _superPropGet(VolumeNodeMaterial, "setup", this, 3)([builder]);
      }
    }], [{
      key: "type",
      get: function get() {
        return 'VolumeNodeMaterial';
      }
    }]);
  }(NodeMaterial);
  /**
   * This module manages the internal animation loop of the renderer.
   *
   * @private
   */
  var Animation = /*#__PURE__*/function () {
    /**
     * Constructs a new animation loop management component.
     *
     * @param {Nodes} nodes - Renderer component for managing nodes related logic.
     * @param {Info} info - Renderer component for managing metrics and monitoring data.
     */
    function Animation(nodes, info) {
      (0, _classCallCheck2.default)(this, Animation);
      /**
       * Renderer component for managing nodes related logic.
       *
       * @type {Nodes}
       */
      this.nodes = nodes;

      /**
       * Renderer component for managing metrics and monitoring data.
       *
       * @type {Info}
       */
      this.info = info;

      /**
       * A reference to the context from `requestAnimationFrame()` can
       * be called (usually `window`).
       *
       * @type {Window|XRSession}
       */
      this._context = self;

      /**
       * The user-defined animation loop.
       *
       * @type {Function?}
       * @default null
       */
      this._animationLoop = null;

      /**
       * The requestId whic is returned from the `requestAnimationFrame()` call.
       * Can be used to cancel the stop the animation loop.
       *
       * @type {Number?}
       * @default null
       */
      this._requestId = null;
    }

    /**
     * Starts the internal animation loop.
     */
    return (0, _createClass2.default)(Animation, [{
      key: "start",
      value: function start() {
        var _this109 = this;
        var _update = function update(time, frame) {
          _this109._requestId = _this109._context.requestAnimationFrame(_update);
          if (_this109.info.autoReset === true) _this109.info.reset();
          _this109.nodes.nodeFrame.update();
          _this109.info.frame = _this109.nodes.nodeFrame.frameId;
          if (_this109._animationLoop !== null) _this109._animationLoop(time, frame);
        };
        _update();
      }

      /**
       * Stops the internal animation loop.
       */
    }, {
      key: "stop",
      value: function stop() {
        this._context.cancelAnimationFrame(this._requestId);
        this._requestId = null;
      }

      /**
       * Defines the user-level animation loop.
       *
       * @param {Function} callback - The animation loop.
       */
    }, {
      key: "setAnimationLoop",
      value: function setAnimationLoop(callback) {
        this._animationLoop = callback;
      }

      /**
       * Defines the context in which `requestAnimationFrame()` is executed.
       *
       * @param {Window|XRSession} context - The context to set.
       */
    }, {
      key: "setContext",
      value: function setContext(context) {
        this._context = context;
      }

      /**
       * Frees all internal resources and stops the animation loop.
       */
    }, {
      key: "dispose",
      value: function dispose() {
        this.stop();
      }
    }]);
  }();
  /**
   * Data structure for the renderer. It allows defining values
   * with chained, hierarchical keys. Keys are meant to be
   * objects since the module internally works with Weak Maps
   * for perforamnce reasons.
   *
   * @private
   */
  var ChainMap = /*#__PURE__*/function () {
    /**
     * Constructs a new chained map.
     */
    function ChainMap() {
      (0, _classCallCheck2.default)(this, ChainMap);
      /**
       * The root Weak Map.
       *
       * @type {WeakMap}
       */
      this.weakMap = new WeakMap();
    }

    /**
     * Returns the value for the given array of keys.
     *
     * @param {Array<Object>} keys - List of keys.
     * @return {Any} The value. Returns `undefined` if no value was found.
     */
    return (0, _createClass2.default)(ChainMap, [{
      key: "get",
      value: function get(keys) {
        var map = this.weakMap;
        for (var i = 0; i < keys.length; i++) {
          map = map.get(keys[i]);
          if (map === undefined) return undefined;
        }
        return map.get(keys[keys.length - 1]);
      }

      /**
       * Sets the value for the given keys.
       *
       * @param {Array<Object>} keys - List of keys.
       * @param {Any} value - The value to set.
       * @return {ChainMap} A reference to this chain map.
       */
    }, {
      key: "set",
      value: function set(keys, value) {
        var map = this.weakMap;
        for (var i = 0; i < keys.length; i++) {
          var key = keys[i];
          if (map.has(key) === false) map.set(key, new WeakMap());
          map = map.get(key);
        }
        map.set(keys[keys.length - 1], value);
        return this;
      }

      /**
       * Deletes a value for the given keys.
       *
       * @param {Array<Object>} keys - The keys.
       * @return {Boolean} Returns `true` if the value has been removed successfully and `false` if the value has not be found.
       */
    }, {
      key: "delete",
      value: function _delete(keys) {
        var map = this.weakMap;
        for (var i = 0; i < keys.length; i++) {
          map = map.get(keys[i]);
          if (map === undefined) return false;
        }
        return map.delete(keys[keys.length - 1]);
      }
    }]);
  }();
  var _id$9 = 0;
  function getKeys(obj) {
    var keys = Object.keys(obj);
    var proto = Object.getPrototypeOf(obj);
    while (proto) {
      var descriptors = Object.getOwnPropertyDescriptors(proto);
      for (var key in descriptors) {
        if (descriptors[key] !== undefined) {
          var descriptor = descriptors[key];
          if (descriptor && typeof descriptor.get === 'function') {
            keys.push(key);
          }
        }
      }
      proto = Object.getPrototypeOf(proto);
    }
    return keys;
  }

  /**
   * A render object is the renderer's representation of single entity that gets drawn
   * with a draw command. There is no unique mapping of render objects to 3D objects in the
   * scene since render objects also depend from the used material, the current render context
   * and the current scene's lighting.
   *
   * In general, the basic process of the renderer is:
   *
   * - Analyze the 3D objects in the scene and generate render lists containing render items.
   * - Process the render lists by calling one or more render commands for each render item.
   * - For each render command, request a render object and perform the draw.
   *
   * The module provides an interface to get data required for the draw command like the actual
   * draw parameters or vertex buffers. It also holds a series of caching related methods since
   * creating render objects should only be done when necessary.
   *
   * @private
   */
  var RenderObject = /*#__PURE__*/function () {
    /**
     * Constructs a new render object.
     *
     * @param {Nodes} nodes - Renderer component for managing nodes related logic.
     * @param {Geometries} geometries - Renderer component for managing geometries.
     * @param {Renderer} renderer - The renderer.
     * @param {Object3D} object - The 3D object.
     * @param {Material} material - The 3D object's material.
     * @param {Scene} scene - The scene the 3D object belongs to.
     * @param {Camera} camera - The camera the object should be rendered with.
     * @param {LightsNode} lightsNode - The lights node.
     * @param {RenderContext} renderContext - The render context.
     * @param {ClippingContext} clippingContext - The clipping context.
     */
    function RenderObject(nodes, geometries, renderer, object, material, scene, camera, lightsNode, renderContext, clippingContext) {
      var _this110 = this;
      (0, _classCallCheck2.default)(this, RenderObject);
      this.id = _id$9++;

      /**
       * Renderer component for managing nodes related logic.
       *
       * @type {Nodes}
       * @private
       */
      this._nodes = nodes;

      /**
       * Renderer component for managing geometries.
       *
       * @type {Geometries}
       * @private
       */
      this._geometries = geometries;

      /**
       * The renderer.
       *
       * @type {Renderer}
       */
      this.renderer = renderer;

      /**
       * The 3D object.
       *
       * @type {Object3D}
       */
      this.object = object;

      /**
       * The 3D object's material.
       *
       * @type {Material}
       */
      this.material = material;

      /**
       * The scene the 3D object belongs to.
       *
       * @type {Scene}
       */
      this.scene = scene;

      /**
       * The camera the 3D object should be rendered with.
       *
       * @type {Camera}
       */
      this.camera = camera;

      /**
       * The lights node.
       *
       * @type {LightsNode}
       */
      this.lightsNode = lightsNode;

      /**
       * The render context.
       *
       * @type {RenderContext}
       */
      this.context = renderContext;

      /**
       * The 3D object's geometry.
       *
       * @type {BufferGeometry}
       */
      this.geometry = object.geometry;

      /**
       * The render object's version.
       *
       * @type {Number}
       */
      this.version = material.version;

      /**
       * The draw range of the geometry.
       *
       * @type {Object?}
       * @default null
       */
      this.drawRange = null;

      /**
       * An array holding the buffer attributes
       * of the render object. This entails attribute
       * definitions on geometry and node level.
       *
       * @type {Array<BufferAttribute>?}
       * @default null
       */
      this.attributes = null;

      /**
       * A reference to a render pipeline the render
       * object is processed with.
       *
       * @type {RenderPipeline}
       * @default null
       */
      this.pipeline = null;

      /**
       * An array holding the vertex buffers which can
       * be buffer attributes but also interleaved buffers.
       *
       * @type {Array<BufferAttribute|InterleavedBuffer>?}
       * @default null
       */
      this.vertexBuffers = null;

      /**
       * The parameters for the draw command.
       *
       * @type {Object?}
       * @default null
       */
      this.drawParams = null;

      /**
       * If this render object is used inside a render bundle,
       * this property points to the respective bundle group.
       *
       * @type {BundleGroup?}
       * @default null
       */
      this.bundle = null;

      /**
       * The clipping context.
       *
       * @type {ClippingContext}
       */
      this.clippingContext = clippingContext;

      /**
       * The clipping context's cache key.
       *
       * @type {String}
       */
      this.clippingContextCacheKey = clippingContext !== null ? clippingContext.cacheKey : '';

      /**
       * The initial node cache key.
       *
       * @type {Number}
       */
      this.initialNodesCacheKey = this.getDynamicCacheKey();

      /**
       * The initial cache key.
       *
       * @type {Number}
       */
      this.initialCacheKey = this.getCacheKey();

      /**
       * The node builder state.
       *
       * @type {NodeBuilderState?}
       * @private
       * @default null
       */
      this._nodeBuilderState = null;

      /**
       * An array of bindings.
       *
       * @type {Array<BindGroup>?}
       * @private
       * @default null
       */
      this._bindings = null;

      /**
       * Reference to the node material observer.
       *
       * @type {NodeMaterialObserver?}
       * @private
       * @default null
       */
      this._monitor = null;

      /**
       * An event listener which is defined by `RenderObjects`. It performs
       * clean up tasks when `dispose()` on this render object.
       *
       * @method
       */
      this.onDispose = null;

      /**
       * This flag can be used for type testing.
       *
       * @type {Boolean}
       * @readonly
       * @default true
       */
      this.isRenderObject = true;

      /**
       * An event listener which is executed when `dispose()` is called on
       * the render object's material.
       *
       * @method
       */
      this.onMaterialDispose = function () {
        _this110.dispose();
      };
      this.material.addEventListener('dispose', this.onMaterialDispose);
    }

    /**
     * Updates the clipping context.
     *
     * @param {ClippingContext} context - The clipping context to set.
     */
    return (0, _createClass2.default)(RenderObject, [{
      key: "updateClipping",
      value: function updateClipping(context) {
        this.clippingContext = context;
      }

      /**
       * Whether the clipping requires an update or not.
       *
       * @type {Boolean}
       * @readonly
       */
    }, {
      key: "clippingNeedsUpdate",
      get: function get() {
        if (this.clippingContext === null || this.clippingContext.cacheKey === this.clippingContextCacheKey) return false;
        this.clippingContextCacheKey = this.clippingContext.cacheKey;
        return true;
      }

      /**
       * The number of clipping planes defined in context of hardware clipping.
       *
       * @type {Number}
       * @readonly
       */
    }, {
      key: "hardwareClippingPlanes",
      get: function get() {
        return this.material.hardwareClipping === true ? this.clippingContext.unionClippingCount : 0;
      }

      /**
       * Returns the node builder state of this render object.
       *
       * @return {NodeBuilderState} The node buider state.
       */
    }, {
      key: "getNodeBuilderState",
      value: function getNodeBuilderState() {
        return this._nodeBuilderState || (this._nodeBuilderState = this._nodes.getForRender(this));
      }

      /**
       * Returns the node material observer of this render object.
       *
       * @return {NodeMaterialObserver} The node material observer.
       */
    }, {
      key: "getMonitor",
      value: function getMonitor() {
        return this._monitor || (this._monitor = this.getNodeBuilderState().monitor);
      }

      /**
       * Returns an array of bind groups of this render object.
       *
       * @return {Array<BindGroup>} The bindings.
       */
    }, {
      key: "getBindings",
      value: function getBindings() {
        return this._bindings || (this._bindings = this.getNodeBuilderState().createBindings());
      }

      /**
       * Returns the index of the render object's geometry.
       *
       * @return {BufferAttribute?} The index. Returns `null` for non-indexed geometries.
       */
    }, {
      key: "getIndex",
      value: function getIndex() {
        return this._geometries.getIndex(this);
      }

      /**
       * Returns the indirect buffer attribute.
       *
       * @return {BufferAttribute?} The indirect attribute. `null` if no indirect drawing is used.
       */
    }, {
      key: "getIndirect",
      value: function getIndirect() {
        return this._geometries.getIndirect(this);
      }

      /**
       * Returns an array that acts as a key for identifying the render object in a chain map.
       *
       * @return {Array<Object>} An array with object references.
       */
    }, {
      key: "getChainArray",
      value: function getChainArray() {
        return [this.object, this.material, this.context, this.lightsNode];
      }

      /**
       * This method is used when the geometry of a 3D object has been exchanged and the
       * respective render object now requires an update.
       *
       * @param {BufferGeometry} geometry - The geometry to set.
       */
    }, {
      key: "setGeometry",
      value: function setGeometry(geometry) {
        this.geometry = geometry;
        this.attributes = null;
      }

      /**
       * Returns the buffer attributes of the render object. The returned array holds
       * attribute definitions on geometry and node level.
       *
       * @return {Array<BufferAttribute>} An array with buffer attributes.
       */
    }, {
      key: "getAttributes",
      value: function getAttributes() {
        if (this.attributes !== null) return this.attributes;
        var nodeAttributes = this.getNodeBuilderState().nodeAttributes;
        var geometry = this.geometry;
        var attributes = [];
        var vertexBuffers = new Set();
        for (var nodeAttribute of nodeAttributes) {
          var _attribute5 = nodeAttribute.node && nodeAttribute.node.attribute ? nodeAttribute.node.attribute : geometry.getAttribute(nodeAttribute.name);
          if (_attribute5 === undefined) continue;
          attributes.push(_attribute5);
          var _bufferAttribute = _attribute5.isInterleavedBufferAttribute ? _attribute5.data : _attribute5;
          vertexBuffers.add(_bufferAttribute);
        }
        this.attributes = attributes;
        this.vertexBuffers = Array.from(vertexBuffers.values());
        return attributes;
      }

      /**
       * Returns the vertex buffers of the render object.
       *
       * @return {Array<BufferAttribute|InterleavedBuffer>} An array with buffer attribute or interleaved buffers.
       */
    }, {
      key: "getVertexBuffers",
      value: function getVertexBuffers() {
        if (this.vertexBuffers === null) this.getAttributes();
        return this.vertexBuffers;
      }

      /**
       * Returns the draw parameters for the render object.
       *
       * @return {{vertexCount: Number, firstVertex: Number, instanceCount: Number, firstInstance: Number}} The draw parameters.
       */
    }, {
      key: "getDrawParameters",
      value: function getDrawParameters() {
        var object = this.object,
          material = this.material,
          geometry = this.geometry,
          group = this.group,
          drawRange = this.drawRange;
        var drawParams = this.drawParams || (this.drawParams = {
          vertexCount: 0,
          firstVertex: 0,
          instanceCount: 0,
          firstInstance: 0
        });
        var index = this.getIndex();
        var hasIndex = index !== null;
        var instanceCount = geometry.isInstancedBufferGeometry ? geometry.instanceCount : object.count > 1 ? object.count : 1;
        if (instanceCount === 0) return null;
        drawParams.instanceCount = instanceCount;
        if (object.isBatchedMesh === true) return drawParams;
        var rangeFactor = 1;
        if (material.wireframe === true && !object.isPoints && !object.isLineSegments && !object.isLine && !object.isLineLoop) {
          rangeFactor = 2;
        }
        var firstVertex = drawRange.start * rangeFactor;
        var lastVertex = (drawRange.start + drawRange.count) * rangeFactor;
        if (group !== null) {
          firstVertex = Math.max(firstVertex, group.start * rangeFactor);
          lastVertex = Math.min(lastVertex, (group.start + group.count) * rangeFactor);
        }
        var position = geometry.attributes.position;
        var itemCount = Infinity;
        if (hasIndex) {
          itemCount = index.count;
        } else if (position !== undefined && position !== null) {
          itemCount = position.count;
        }
        firstVertex = Math.max(firstVertex, 0);
        lastVertex = Math.min(lastVertex, itemCount);
        var count = lastVertex - firstVertex;
        if (count < 0 || count === Infinity) return null;
        drawParams.vertexCount = count;
        drawParams.firstVertex = firstVertex;
        return drawParams;
      }

      /**
       * Returns the render object's geometry cache key.
       *
       * The geometry cache key is part of the material cache key.
       *
       * @return {String} The geometry cache key.
       */
    }, {
      key: "getGeometryCacheKey",
      value: function getGeometryCacheKey() {
        var geometry = this.geometry;
        var cacheKey = '';
        for (var name of Object.keys(geometry.attributes).sort()) {
          var _attribute6 = geometry.attributes[name];
          cacheKey += name + ',';
          if (_attribute6.data) cacheKey += _attribute6.data.stride + ',';
          if (_attribute6.offset) cacheKey += _attribute6.offset + ',';
          if (_attribute6.itemSize) cacheKey += _attribute6.itemSize + ',';
          if (_attribute6.normalized) cacheKey += 'n,';
        }
        if (geometry.index) {
          cacheKey += 'index,';
        }
        return cacheKey;
      }

      /**
       * Returns the render object's material cache key.
       *
       * The material cache key is part of the render object cache key.
       *
       * @return {String} The material cache key.
       */
    }, {
      key: "getMaterialCacheKey",
      value: function getMaterialCacheKey() {
        var object = this.object,
          material = this.material;
        var cacheKey = material.customProgramCacheKey();
        for (var _property10 of getKeys(material)) {
          if (/^(is[A-Z]|_)|^(visible|version|uuid|name|opacity|userData)$/.test(_property10)) continue;
          var value = material[_property10];
          var valueKey = void 0;
          if (value !== null) {
            // some material values require a formatting

            var type = typeof value;
            if (type === 'number') {
              valueKey = value !== 0 ? '1' : '0'; // Convert to on/off, important for clearcoat, transmission, etc
            } else if (type === 'object') {
              valueKey = '{';
              if (value.isTexture) {
                valueKey += value.mapping;
              }
              valueKey += '}';
            } else {
              valueKey = String(value);
            }
          } else {
            valueKey = String(value);
          }
          cacheKey += /*property + ':' +*/valueKey + ',';
        }
        cacheKey += this.clippingContextCacheKey + ',';
        if (object.geometry) {
          cacheKey += this.getGeometryCacheKey();
        }
        if (object.skeleton) {
          cacheKey += object.skeleton.bones.length + ',';
        }
        if (object.morphTargetInfluences) {
          cacheKey += object.morphTargetInfluences.length + ',';
        }
        if (object.isBatchedMesh) {
          cacheKey += object._matricesTexture.uuid + ',';
          if (object._colorsTexture !== null) {
            cacheKey += object._colorsTexture.uuid + ',';
          }
        }
        if (object.count > 1) {
          // TODO: https://github.com/mrdoob/three.js/pull/29066#issuecomment-2269400850

          cacheKey += object.uuid + ',';
        }
        cacheKey += object.receiveShadow + ',';
        return hashString(cacheKey);
      }

      /**
       * Whether the geometry requires an update or not.
       *
       * @type {Boolean}
       * @readonly
       */
    }, {
      key: "needsGeometryUpdate",
      get: function get() {
        return this.geometry.id !== this.object.geometry.id;
      }

      /**
       * Whether the render object requires an update or not.
       *
       * Note: There are two distinct places where render objects are checked for an update.
       *
       * 1. In `RenderObjects.get()` which is executed when the render object is request. This
       * method checks the `needsUpdate` flag and recreates the render object if necessary.
       * 2. In `Renderer._renderObjectDirect()` right after getting the render object via
       * `RenderObjects.get()`. The render object's NodeMaterialObserver is then used to detect
       * a need for a refresh due to material, geometry or object related value changes.
       *
       * TODO: Investigate if it's possible to merge boths steps so there is only a single place
       * that performs the 'needsUpdate' check.
       *
       * @type {Boolean}
       * @readonly
       */
    }, {
      key: "needsUpdate",
      get: function get() {
        return /*this.object.static !== true &&*/this.initialNodesCacheKey !== this.getDynamicCacheKey() || this.clippingNeedsUpdate;
      }

      /**
       * Returns the dynamic cache key which represents a key that is computed per draw command.
       *
       * @return {String} The cache key.
       */
    }, {
      key: "getDynamicCacheKey",
      value: function getDynamicCacheKey() {
        // Environment Nodes Cache Key

        var cacheKey = this._nodes.getCacheKey(this.scene, this.lightsNode);
        if (this.object.receiveShadow) {
          cacheKey += 1;
        }
        return cacheKey;
      }

      /**
       * Returns the render object's cache key.
       *
       * @return {String} The cache key.
       */
    }, {
      key: "getCacheKey",
      value: function getCacheKey() {
        return this.getMaterialCacheKey() + this.getDynamicCacheKey();
      }

      /**
       * Frees internal resources.
       */
    }, {
      key: "dispose",
      value: function dispose() {
        this.material.removeEventListener('dispose', this.onMaterialDispose);
        this.onDispose();
      }
    }]);
  }();
  var _chainArray = [];

  /**
   * This module manages the render objects of the renderer.
   *
   * @private
   */
  var RenderObjects = /*#__PURE__*/function () {
    /**
     * Constructs a new render object management component.
     *
     * @param {Renderer} renderer - The renderer.
     * @param {Nodes} nodes - Renderer component for managing nodes related logic.
     * @param {Geometries} geometries - Renderer component for managing geometries.
     * @param {Pipelines} pipelines - Renderer component for managing pipelines.
     * @param {Bindings} bindings - Renderer component for managing bindings.
     * @param {Info} info - Renderer component for managing metrics and monitoring data.
     */
    function RenderObjects(renderer, nodes, geometries, pipelines, bindings, info) {
      (0, _classCallCheck2.default)(this, RenderObjects);
      /**
       * The renderer.
       *
       * @type {Renderer}
       */
      this.renderer = renderer;

      /**
       * Renderer component for managing nodes related logic.
       *
       * @type {Nodes}
       */
      this.nodes = nodes;

      /**
       * Renderer component for managing geometries.
       *
       * @type {Geometries}
       */
      this.geometries = geometries;

      /**
       * Renderer component for managing pipelines.
       *
       * @type {Pipelines}
       */
      this.pipelines = pipelines;

      /**
       * Renderer component for managing bindings.
       *
       * @type {Bindings}
       */
      this.bindings = bindings;

      /**
       * Renderer component for managing metrics and monitoring data.
       *
       * @type {Info}
       */
      this.info = info;

      /**
       * A dictionary that manages render contexts in chain maps
       * for each pass ID.
       *
       * @type {Object<String,ChainMap>}
       */
      this.chainMaps = {};
    }

    /**
     * Returns a render object for the given object and state data.
     *
     * @param {Object3D} object - The 3D object.
     * @param {Material} material - The 3D object's material.
     * @param {Scene} scene - The scene the 3D object belongs to.
     * @param {Camera} camera - The camera the 3D object should be rendered with.
     * @param {LightsNode} lightsNode - The lights node.
     * @param {RenderContext} renderContext - The render context.
     * @param {ClippingContext} clippingContext - The clipping context.
     * @param {String?} passId - An optional ID for identifying the pass.
     * @return {RenderObject} The render object.
     */
    return (0, _createClass2.default)(RenderObjects, [{
      key: "get",
      value: function get(object, material, scene, camera, lightsNode, renderContext, clippingContext, passId) {
        var chainMap = this.getChainMap(passId);

        // reuse chainArray
        _chainArray[0] = object;
        _chainArray[1] = material;
        _chainArray[2] = renderContext;
        _chainArray[3] = lightsNode;
        var renderObject = chainMap.get(_chainArray);
        if (renderObject === undefined) {
          renderObject = this.createRenderObject(this.nodes, this.geometries, this.renderer, object, material, scene, camera, lightsNode, renderContext, clippingContext, passId);
          chainMap.set(_chainArray, renderObject);
        } else {
          renderObject.updateClipping(clippingContext);
          if (renderObject.needsGeometryUpdate) {
            renderObject.setGeometry(object.geometry);
          }
          if (renderObject.version !== material.version || renderObject.needsUpdate) {
            if (renderObject.initialCacheKey !== renderObject.getCacheKey()) {
              renderObject.dispose();
              renderObject = this.get(object, material, scene, camera, lightsNode, renderContext, clippingContext, passId);
            } else {
              renderObject.version = material.version;
            }
          }
        }
        return renderObject;
      }

      /**
       * Returns a chain map for the given pass ID.
       *
       * @param {String} [passId='default'] - The pass ID.
       * @return {ChainMap} The chain map.
       */
    }, {
      key: "getChainMap",
      value: function getChainMap() {
        var passId = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'default';
        return this.chainMaps[passId] || (this.chainMaps[passId] = new ChainMap());
      }

      /**
       * Frees internal resources.
       */
    }, {
      key: "dispose",
      value: function dispose() {
        this.chainMaps = {};
      }

      /**
       * Factory method for creating render objects with the given list of parameters.
       *
       * @param {Nodes} nodes - Renderer component for managing nodes related logic.
       * @param {Geometries} geometries - Renderer component for managing geometries.
       * @param {Renderer} renderer - The renderer.
       * @param {Object3D} object - The 3D object.
       * @param {Material} material - The object's material.
       * @param {Scene} scene - The scene the 3D object belongs to.
       * @param {Camera} camera - The camera the object should be rendered with.
       * @param {LightsNode} lightsNode - The lights node.
       * @param {RenderContext} renderContext - The render context.
       * @param {ClippingContext} clippingContext - The clipping context.
       * @param {String?} passId - An optional ID for identifying the pass.
       * @return {RenderObject} The render object.
       */
    }, {
      key: "createRenderObject",
      value: function createRenderObject(nodes, geometries, renderer, object, material, scene, camera, lightsNode, renderContext, clippingContext, passId) {
        var _this111 = this;
        var chainMap = this.getChainMap(passId);
        var renderObject = new RenderObject(nodes, geometries, renderer, object, material, scene, camera, lightsNode, renderContext, clippingContext);
        renderObject.onDispose = function () {
          _this111.pipelines.delete(renderObject);
          _this111.bindings.delete(renderObject);
          _this111.nodes.delete(renderObject);
          chainMap.delete(renderObject.getChainArray());
        };
        return renderObject;
      }
    }]);
  }();
  /**
   * Data structure for the renderer. It is intended to manage
   * data of objects in dictionaries.
   *
   * @private
   */
  var DataMap = /*#__PURE__*/function () {
    /**
     * Constructs a new data map.
     */
    function DataMap() {
      (0, _classCallCheck2.default)(this, DataMap);
      /**
       * `DataMap` internally uses a weak map
       * to manage its data.
       *
       * @type {WeakMap}
       */
      this.data = new WeakMap();
    }

    /**
     * Returns the dictionary for the given object.
     *
     * @param {Object} object - The object.
     * @return {Object} The dictionary.
     */
    return (0, _createClass2.default)(DataMap, [{
      key: "get",
      value: function get(object) {
        var map = this.data.get(object);
        if (map === undefined) {
          map = {};
          this.data.set(object, map);
        }
        return map;
      }

      /**
       * Deletes the dictionary for the given object.
       *
       * @param {Object} object - The object.
       * @return {Object?} The deleted dictionary.
       */
    }, {
      key: "delete",
      value: function _delete(object) {
        var map = null;
        if (this.data.has(object)) {
          map = this.data.get(object);
          this.data.delete(object);
        }
        return map;
      }

      /**
       * Returns `true` if the given object has a dictionary defined.
       *
       * @param {Object} object - The object to test.
       * @return {Boolean} Whether a dictionary is defined or not.
       */
    }, {
      key: "has",
      value: function has(object) {
        return this.data.has(object);
      }

      /**
       * Frees internal resources.
       */
    }, {
      key: "dispose",
      value: function dispose() {
        this.data = new WeakMap();
      }
    }]);
  }();
  var AttributeType = {
    VERTEX: 1,
    INDEX: 2,
    STORAGE: 3,
    INDIRECT: 4
  };

  // size of a chunk in bytes (STD140 layout)

  var GPU_CHUNK_BYTES = 16;

  // @TODO: Move to src/constants.js

  var BlendColorFactor = 211;
  var OneMinusBlendColorFactor = 212;

  /**
   * This renderer module manages geometry attributes.
   *
   * @private
   * @augments DataMap
   */
  var Attributes = /*#__PURE__*/function (_DataMap) {
    /**
     * Constructs a new attribute management component.
     *
     * @param {Backend} backend - The renderer's backend.
     */
    function Attributes(backend) {
      var _this112;
      (0, _classCallCheck2.default)(this, Attributes);
      _this112 = _callSuper(this, Attributes);

      /**
       * The renderer's backend.
       *
       * @type {Backend}
       */
      _this112.backend = backend;
      return _this112;
    }

    /**
     * Deletes the data for the given attribute.
     *
     * @param {BufferAttribute} attribute - The attribute.
     * @return {Object} The deleted attribute data.
     */
    (0, _inherits2.default)(Attributes, _DataMap);
    return (0, _createClass2.default)(Attributes, [{
      key: "delete",
      value: function _delete(attribute) {
        var attributeData = _superPropGet(Attributes, "delete", this, 3)([attribute]);
        if (attributeData !== undefined) {
          this.backend.destroyAttribute(attribute);
        }
        return attributeData;
      }

      /**
       * Updates the given attribute. This method creates attribute buffers
       * for new attributes and updates data for existing ones.
       *
       * @param {BufferAttribute} attribute - The attribute to update.
       * @param {Number} type - The attribute type.
       */
    }, {
      key: "update",
      value: function update(attribute, type) {
        var data = this.get(attribute);
        if (data.version === undefined) {
          if (type === AttributeType.VERTEX) {
            this.backend.createAttribute(attribute);
          } else if (type === AttributeType.INDEX) {
            this.backend.createIndexAttribute(attribute);
          } else if (type === AttributeType.STORAGE) {
            this.backend.createStorageAttribute(attribute);
          } else if (type === AttributeType.INDIRECT) {
            this.backend.createIndirectStorageAttribute(attribute);
          }
          data.version = this._getBufferAttribute(attribute).version;
        } else {
          var _bufferAttribute2 = this._getBufferAttribute(attribute);
          if (data.version < _bufferAttribute2.version || _bufferAttribute2.usage === _$$_REQUIRE(_dependencyMap[1], "./three.core.js").DynamicDrawUsage) {
            this.backend.updateAttribute(attribute);
            data.version = _bufferAttribute2.version;
          }
        }
      }

      /**
       * Utility method for handling interleaved buffer attributes correctly.
       * To process them, their `InterleavedBuffer` is returned.
       *
       * @param {BufferAttribute} attribute - The attribute.
       * @return {BufferAttribute|InterleavedBuffer}
       */
    }, {
      key: "_getBufferAttribute",
      value: function _getBufferAttribute(attribute) {
        if (attribute.isInterleavedBufferAttribute) attribute = attribute.data;
        return attribute;
      }
    }]);
  }(DataMap);
  /**
   * Returns `true` if the given array has values that require an Uint32 array type.
   *
   * @private
   * @function
   * @param {Array<Number>} array - The array to test.
   * @return {Booolean} Whether the given array has values that require an Uint32 array type or not.
   */
  function arrayNeedsUint32(array) {
    // assumes larger values usually on last

    for (var i = array.length - 1; i >= 0; --i) {
      if (array[i] >= 65535) return true; // account for PRIMITIVE_RESTART_FIXED_INDEX, #24565
    }
    return false;
  }

  /**
   * Returns the wireframe version for the given geometry.
   *
   * @private
   * @function
   * @param {BufferGeometry} geometry - The geometry.
   * @return {Number} The versio.
   */
  function getWireframeVersion(geometry) {
    return geometry.index !== null ? geometry.index.version : geometry.attributes.position.version;
  }

  /**
   * Returns a wireframe index attribute for the given geometry.
   *
   * @private
   * @function
   * @param {BufferGeometry} geometry - The geometry.
   * @return {BufferAttribute} The wireframe index attribute.
   */
  function getWireframeIndex(geometry) {
    var indices = [];
    var geometryIndex = geometry.index;
    var geometryPosition = geometry.attributes.position;
    if (geometryIndex !== null) {
      var array = geometryIndex.array;
      for (var i = 0, l = array.length; i < l; i += 3) {
        var a = array[i + 0];
        var b = array[i + 1];
        var c = array[i + 2];
        indices.push(a, b, b, c, c, a);
      }
    } else {
      var _array = geometryPosition.array;
      for (var _i9 = 0, _l2 = _array.length / 3 - 1; _i9 < _l2; _i9 += 3) {
        var _a = _i9 + 0;
        var _b = _i9 + 1;
        var _c = _i9 + 2;
        indices.push(_a, _b, _b, _c, _c, _a);
      }
    }
    var attribute = new (arrayNeedsUint32(indices) ? _$$_REQUIRE(_dependencyMap[1], "./three.core.js").Uint32BufferAttribute : _$$_REQUIRE(_dependencyMap[1], "./three.core.js").Uint16BufferAttribute)(indices, 1);
    attribute.version = getWireframeVersion(geometry);
    return attribute;
  }

  /**
   * This renderer module manages geometries.
   *
   * @private
   * @augments DataMap
   */
  var Geometries = /*#__PURE__*/function (_DataMap2) {
    /**
     * Constructs a new geometry management component.
     *
     * @param {Attributes} attributes - Renderer component for managing attributes.
     * @param {Info} info - Renderer component for managing metrics and monitoring data.
     */
    function Geometries(attributes, info) {
      var _this113;
      (0, _classCallCheck2.default)(this, Geometries);
      _this113 = _callSuper(this, Geometries);

      /**
       * Renderer component for managing attributes.
       *
       * @type {Attributes}
       */
      _this113.attributes = attributes;

      /**
       * Renderer component for managing metrics and monitoring data.
       *
       * @type {Info}
       */
      _this113.info = info;

      /**
       * Weak Map for managing attributes for wireframe rendering.
       *
       * @type {WeakMap<BufferGeometry,BufferAttribute>}
       */
      _this113.wireframes = new WeakMap();

      /**
       * This Weak Map is used to make sure buffer attributes are
       * updated only once per render call.
       *
       * @type {WeakMap<BufferAttribute,Number>}
       */
      _this113.attributeCall = new WeakMap();
      return _this113;
    }

    /**
     * Returns `true` if the given render object has an initialized geometry.
     *
     * @param {RenderObject} renderObject - The render object.
     * @return {Boolean} Whether if the given render object has an initialized geometry or not.
     */
    (0, _inherits2.default)(Geometries, _DataMap2);
    return (0, _createClass2.default)(Geometries, [{
      key: "has",
      value: function has(renderObject) {
        var geometry = renderObject.geometry;
        return _superPropGet(Geometries, "has", this, 3)([geometry]) && this.get(geometry).initialized === true;
      }

      /**
       * Prepares the geometry of the given render object for rendering.
       *
       * @param {RenderObject} renderObject - The render object.
       */
    }, {
      key: "updateForRender",
      value: function updateForRender(renderObject) {
        if (this.has(renderObject) === false) this.initGeometry(renderObject);
        this.updateAttributes(renderObject);
      }

      /**
       * Initializes the geometry of the given render object.
       *
       * @param {RenderObject} renderObject - The render object.
       */
    }, {
      key: "initGeometry",
      value: function initGeometry(renderObject) {
        var _this114 = this;
        var geometry = renderObject.geometry;
        var geometryData = this.get(geometry);
        geometryData.initialized = true;
        this.info.memory.geometries++;
        var _onDispose = function onDispose() {
          _this114.info.memory.geometries--;
          var index = geometry.index;
          var geometryAttributes = renderObject.getAttributes();
          if (index !== null) {
            _this114.attributes.delete(index);
          }
          for (var geometryAttribute of geometryAttributes) {
            _this114.attributes.delete(geometryAttribute);
          }
          var wireframeAttribute = _this114.wireframes.get(geometry);
          if (wireframeAttribute !== undefined) {
            _this114.attributes.delete(wireframeAttribute);
          }
          geometry.removeEventListener('dispose', _onDispose);
        };
        geometry.addEventListener('dispose', _onDispose);
      }

      /**
       * Updates the geometry attributes of the given render object.
       *
       * @param {RenderObject} renderObject - The render object.
       */
    }, {
      key: "updateAttributes",
      value: function updateAttributes(renderObject) {
        // attributes

        var attributes = renderObject.getAttributes();
        for (var _attribute7 of attributes) {
          if (_attribute7.isStorageBufferAttribute || _attribute7.isStorageInstancedBufferAttribute) {
            this.updateAttribute(_attribute7, AttributeType.STORAGE);
          } else {
            this.updateAttribute(_attribute7, AttributeType.VERTEX);
          }
        }

        // indexes

        var index = this.getIndex(renderObject);
        if (index !== null) {
          this.updateAttribute(index, AttributeType.INDEX);
        }

        // indirect

        var indirect = renderObject.geometry.indirect;
        if (indirect !== null) {
          this.updateAttribute(indirect, AttributeType.INDIRECT);
        }
      }

      /**
       * Updates the given attribute.
       *
       * @param {BufferAttribute} attribute - The attribute to update.
       * @param {Number} type - The attribute type.
       */
    }, {
      key: "updateAttribute",
      value: function updateAttribute(attribute, type) {
        var callId = this.info.render.calls;
        if (!attribute.isInterleavedBufferAttribute) {
          if (this.attributeCall.get(attribute) !== callId) {
            this.attributes.update(attribute, type);
            this.attributeCall.set(attribute, callId);
          }
        } else {
          if (this.attributeCall.get(attribute) === undefined) {
            this.attributes.update(attribute, type);
            this.attributeCall.set(attribute, callId);
          } else if (this.attributeCall.get(attribute.data) !== callId) {
            this.attributes.update(attribute, type);
            this.attributeCall.set(attribute.data, callId);
            this.attributeCall.set(attribute, callId);
          }
        }
      }

      /**
       * Returns the indirect buffer attribute of the given render object.
       *
       * @param {RenderObject} renderObject - The render object.
       * @return {BufferAttribute?} The indirect attribute. `null` if no indirect drawing is used.
       */
    }, {
      key: "getIndirect",
      value: function getIndirect(renderObject) {
        return renderObject.geometry.indirect;
      }

      /**
       * Returns the index of the given render object's geometry. This is implemented
       * in a method to return a wireframe index if necessary.
       *
       * @param {RenderObject} renderObject - The render object.
       * @return {BufferAttribute?} The index. Returns `null` for non-indexed geometries.
       */
    }, {
      key: "getIndex",
      value: function getIndex(renderObject) {
        var geometry = renderObject.geometry,
          material = renderObject.material;
        var index = geometry.index;
        if (material.wireframe === true) {
          var wireframes = this.wireframes;
          var wireframeAttribute = wireframes.get(geometry);
          if (wireframeAttribute === undefined) {
            wireframeAttribute = getWireframeIndex(geometry);
            wireframes.set(geometry, wireframeAttribute);
          } else if (wireframeAttribute.version !== getWireframeVersion(geometry)) {
            this.attributes.delete(wireframeAttribute);
            wireframeAttribute = getWireframeIndex(geometry);
            wireframes.set(geometry, wireframeAttribute);
          }
          index = wireframeAttribute;
        }
        return index;
      }
    }]);
  }(DataMap);
  /**
   * This renderer module provides a series of statistical information
   * about the GPU memory and the rendering process. Useful for debugging
   * and monitoring.
   */
  var Info = /*#__PURE__*/function () {
    /**
     * Constructs a new info component.
     */
    function Info() {
      (0, _classCallCheck2.default)(this, Info);
      /**
       * Whether frame related metrics should automatically
       * be resetted or not. This property should be set to `false`
       * by apps which manage their own animation loop. They must
       * then call `renderer.info.reset()` once per frame manually.
       *
       * @type {Boolean}
       * @default true
       */
      this.autoReset = true;

      /**
       * The current frame ID. This ID is managed
       * by `NodeFrame`.
       *
       * @type {Number}
       * @readonly
       * @default 0
       */
      this.frame = 0;

      /**
       * The number of render calls since the
       * app has been started.
       *
       * @type {Number}
       * @readonly
       * @default 0
       */
      this.calls = 0;

      /**
       * Render related metrics.
       *
       * @type {Object}
       * @readonly
       * @property {Number} calls - The number of render calls since the app has been started.
       * @property {Number} frameCalls - The number of render calls of the current frame.
       * @property {Number} drawCalls - The number of draw calls of the current frame.
       * @property {Number} triangles - The number of rendered triangle primitives of the current frame.
       * @property {Number} points - The number of rendered point primitives of the current frame.
       * @property {Number} lines - The number of rendered line primitives of the current frame.
       * @property {Number} previousFrameCalls - The number of render calls of the previous frame.
       * @property {Number} timestamp - The timestamp of the frame when using `renderer.renderAsync()`.
       * @property {Number} timestampCalls - The number of render calls using `renderer.renderAsync()`.
       */
      this.render = {
        calls: 0,
        frameCalls: 0,
        drawCalls: 0,
        triangles: 0,
        points: 0,
        lines: 0,
        timestamp: 0,
        previousFrameCalls: 0,
        timestampCalls: 0
      };

      /**
       * Compute related metrics.
       *
       * @type {Object}
       * @readonly
       * @property {Number} calls - The number of compute calls since the app has been started.
       * @property {Number} frameCalls - The number of compute calls of the current frame.
       * @property {Number} previousFrameCalls - The number of compute calls of the previous frame.
       * @property {Number} timestamp - The timestamp of the frame when using `renderer.computeAsync()`.
       * @property {Number} timestampCalls - The number of render calls using `renderer.computeAsync()`.
       */
      this.compute = {
        calls: 0,
        frameCalls: 0,
        timestamp: 0,
        previousFrameCalls: 0,
        timestampCalls: 0
      };

      /**
       * Memory related metrics.
       *
       * @type {Object}
       * @readonly
       * @property {Number} geometries - The number of active geometries.
       * @property {Number} frameCalls - The number of active textures.
       */
      this.memory = {
        geometries: 0,
        textures: 0
      };
    }

    /**
     * This method should be executed per draw call and updates the corresponding metrics.
     *
     * @param {Object3D} object - The 3D object that is going to be rendered.
     * @param {Number} count - The vertex or index count.
     * @param {Number} instanceCount - The instance count.
     */
    return (0, _createClass2.default)(Info, [{
      key: "update",
      value: function update(object, count, instanceCount) {
        this.render.drawCalls++;
        if (object.isMesh || object.isSprite) {
          this.render.triangles += instanceCount * (count / 3);
        } else if (object.isPoints) {
          this.render.points += instanceCount * count;
        } else if (object.isLineSegments) {
          this.render.lines += instanceCount * (count / 2);
        } else if (object.isLine) {
          this.render.lines += instanceCount * (count - 1);
        } else {
          console.error('THREE.WebGPUInfo: Unknown object type.');
        }
      }

      /**
       * Used by async render methods to updated timestamp metrics.
       *
       * @param {('render'|'compute')} type - The type of render call.
       * @param {Number} time - The duration of the compute/render call in milliseconds.
       */
    }, {
      key: "updateTimestamp",
      value: function updateTimestamp(type, time) {
        if (this[type].timestampCalls === 0) {
          this[type].timestamp = 0;
        }
        this[type].timestamp += time;
        this[type].timestampCalls++;
        if (this[type].timestampCalls >= this[type].previousFrameCalls) {
          this[type].timestampCalls = 0;
        }
      }

      /**
       * Resets frame related metrics.
       */
    }, {
      key: "reset",
      value: function reset() {
        var previousRenderFrameCalls = this.render.frameCalls;
        this.render.previousFrameCalls = previousRenderFrameCalls;
        var previousComputeFrameCalls = this.compute.frameCalls;
        this.compute.previousFrameCalls = previousComputeFrameCalls;
        this.render.drawCalls = 0;
        this.render.frameCalls = 0;
        this.compute.frameCalls = 0;
        this.render.triangles = 0;
        this.render.points = 0;
        this.render.lines = 0;
      }

      /**
       * Performs a complete reset of the object.
       */
    }, {
      key: "dispose",
      value: function dispose() {
        this.reset();
        this.calls = 0;
        this.render.calls = 0;
        this.compute.calls = 0;
        this.render.timestamp = 0;
        this.compute.timestamp = 0;
        this.memory.geometries = 0;
        this.memory.textures = 0;
      }
    }]);
  }();
  /**
   * Abstract class for representing pipelines.
   *
   * @private
   * @abstract
   */
  var Pipeline = /*#__PURE__*/(0, _createClass2.default)(
  /**
   * Constructs a new pipeline.
   *
   * @param {String} cacheKey - The pipeline's cache key.
   */
  function Pipeline(cacheKey) {
    (0, _classCallCheck2.default)(this, Pipeline);
    /**
     * The pipeline's cache key.
     *
     * @type {String}
     */
    this.cacheKey = cacheKey;

    /**
     * How often the pipeline is currently in use.
     *
     * @type {Number}
     * @default 0
     */
    this.usedTimes = 0;
  });
  /**
   * Class for representing render pipelines.
   *
   * @private
   * @augments Pipeline
   */
  var RenderPipeline = /*#__PURE__*/function (_Pipeline) {
    /**
     * Constructs a new render pipeline.
     *
     * @param {String} cacheKey - The pipeline's cache key.
     * @param {ProgrammableStage} vertexProgram - The pipeline's vertex shader.
     * @param {ProgrammableStage} fragmentProgram - The pipeline's fragment shader.
     */
    function RenderPipeline(cacheKey, vertexProgram, fragmentProgram) {
      var _this115;
      (0, _classCallCheck2.default)(this, RenderPipeline);
      _this115 = _callSuper(this, RenderPipeline, [cacheKey]);

      /**
       * The pipeline's vertex shader.
       *
       * @type {ProgrammableStage}
       */
      _this115.vertexProgram = vertexProgram;

      /**
       * The pipeline's fragment shader.
       *
       * @type {ProgrammableStage}
       */
      _this115.fragmentProgram = fragmentProgram;
      return _this115;
    }
    (0, _inherits2.default)(RenderPipeline, _Pipeline);
    return (0, _createClass2.default)(RenderPipeline);
  }(Pipeline);
  /**
   * Class for representing compute pipelines.
   *
   * @private
   * @augments Pipeline
   */
  var ComputePipeline = /*#__PURE__*/function (_Pipeline2) {
    /**
     * Constructs a new render pipeline.
     *
     * @param {String} cacheKey - The pipeline's cache key.
     * @param {ProgrammableStage} computeProgram - The pipeline's compute shader.
     */
    function ComputePipeline(cacheKey, computeProgram) {
      var _this116;
      (0, _classCallCheck2.default)(this, ComputePipeline);
      _this116 = _callSuper(this, ComputePipeline, [cacheKey]);

      /**
       * The pipeline's compute shader.
       *
       * @type {ProgrammableStage}
       */
      _this116.computeProgram = computeProgram;

      /**
       * This flag can be used for type testing.
       *
       * @type {Boolean}
       * @readonly
       * @default true
       */
      _this116.isComputePipeline = true;
      return _this116;
    }
    (0, _inherits2.default)(ComputePipeline, _Pipeline2);
    return (0, _createClass2.default)(ComputePipeline);
  }(Pipeline);
  var _id$8 = 0;

  /**
   * Class for representing programmable stages which are vertex,
   * fragment or compute shaders. Unlike fixed-function states (like blending),
   * they represent the programmable part of a pipeline.
   *
   * @private
   */
  var ProgrammableStage = /*#__PURE__*/(0, _createClass2.default)(
  /**
   * Constructs a new programmable stage.
   *
   * @param {String} code - The shader code.
   * @param {('vertex'|'fragment'|'compute')} stage - The type of stage.
   * @param {String} name - The name of the shader.
   * @param {Array<Object>?} [transforms=null] - The transforms (only relevant for compute stages with WebGL 2 which uses Transform Feedback).
   * @param {Array<Object>?} [attributes=null] - The attributes (only relevant for compute stages with WebGL 2 which uses Transform Feedback).
   */
  function ProgrammableStage(code, stage, name) {
    var transforms = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
    var attributes = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;
    (0, _classCallCheck2.default)(this, ProgrammableStage);
    /**
     * The id of the programmable stage.
     *
     * @type {Number}
     */
    this.id = _id$8++;

    /**
     * The shader code.
     *
     * @type {String}
     */
    this.code = code;

    /**
     * The type of stage.
     *
     * @type {String}
     */
    this.stage = stage;

    /**
     * The name of the stage.
     * This is used for debugging purposes.
     *
     * @type {String}
     */
    this.name = name;

    /**
     * The transforms (only relevant for compute stages with WebGL 2 which uses Transform Feedback).
     *
     * @type {Array<Object>?}
     */
    this.transforms = transforms;

    /**
     * The attributes (only relevant for compute stages with WebGL 2 which uses Transform Feedback).
     *
     * @type {Array<Object>?}
     */
    this.attributes = attributes;

    /**
     * How often the programmable stage is currently in use.
     *
     * @type {Number}
     * @default 0
     */
    this.usedTimes = 0;
  });
  /**
   * This renderer module manages the pipelines of the renderer.
   *
   * @private
   * @augments DataMap
   */
  var Pipelines = /*#__PURE__*/function (_DataMap3) {
    /**
     * Constructs a new pipeline management component.
     *
     * @param {Backend} backend - The renderer's backend.
     * @param {Nodes} nodes - Renderer component for managing nodes related logic.
     */
    function Pipelines(backend, nodes) {
      var _this117;
      (0, _classCallCheck2.default)(this, Pipelines);
      _this117 = _callSuper(this, Pipelines);

      /**
       * The renderer's backend.
       *
       * @type {Backend}
       */
      _this117.backend = backend;

      /**
       * Renderer component for managing nodes related logic.
       *
       * @type {Nodes}
       */
      _this117.nodes = nodes;

      /**
       * A references to the bindings management component.
       * This reference will be set inside the `Bindings`
       * constructor.
       *
       * @type {Bindings?}
       * @default null
       */
      _this117.bindings = null;

      /**
       * Internal cache for maintaining pipelines.
       * The key of the map is a cache key, the value the pipeline.
       *
       * @type {Map<String,Pipeline>}
       */
      _this117.caches = new Map();

      /**
       * This dictionary maintains for each shader stage type (vertex,
       * fragment and compute) the progammable stage objects which
       * represent the actual shader code.
       *
       * @type {Object<String,Map>}
       */
      _this117.programs = {
        vertex: new Map(),
        fragment: new Map(),
        compute: new Map()
      };
      return _this117;
    }

    /**
     * Returns a compute pipeline for the given compute node.
     *
     * @param {Node} computeNode - The compute node.
     * @param {Array<BindGroup>} bindings - The bindings.
     * @return {ComputePipeline} The compute pipeline.
     */
    (0, _inherits2.default)(Pipelines, _DataMap3);
    return (0, _createClass2.default)(Pipelines, [{
      key: "getForCompute",
      value: function getForCompute(computeNode, bindings) {
        var backend = this.backend;
        var data = this.get(computeNode);
        if (this._needsComputeUpdate(computeNode)) {
          var previousPipeline = data.pipeline;
          if (previousPipeline) {
            previousPipeline.usedTimes--;
            previousPipeline.computeProgram.usedTimes--;
          }

          // get shader

          var nodeBuilderState = this.nodes.getForCompute(computeNode);

          // programmable stage

          var stageCompute = this.programs.compute.get(nodeBuilderState.computeShader);
          if (stageCompute === undefined) {
            if (previousPipeline && previousPipeline.computeProgram.usedTimes === 0) this._releaseProgram(previousPipeline.computeProgram);
            stageCompute = new ProgrammableStage(nodeBuilderState.computeShader, 'compute', computeNode.name, nodeBuilderState.transforms, nodeBuilderState.nodeAttributes);
            this.programs.compute.set(nodeBuilderState.computeShader, stageCompute);
            backend.createProgram(stageCompute);
          }

          // determine compute pipeline

          var cacheKey = this._getComputeCacheKey(computeNode, stageCompute);
          var pipeline = this.caches.get(cacheKey);
          if (pipeline === undefined) {
            if (previousPipeline && previousPipeline.usedTimes === 0) this._releasePipeline(previousPipeline);
            pipeline = this._getComputePipeline(computeNode, stageCompute, cacheKey, bindings);
          }

          // keep track of all used times

          pipeline.usedTimes++;
          stageCompute.usedTimes++;

          //

          data.version = computeNode.version;
          data.pipeline = pipeline;
        }
        return data.pipeline;
      }

      /**
       * Returns a render pipeline for the given render object.
       *
       * @param {RenderObject} renderObject - The render object.
       * @param {Array<Promise>?} [promises=null] - An array of compilation promises which is only relevant in context of `Renderer.compileAsync()`.
       * @return {RenderPipeline} The render pipeline.
       */
    }, {
      key: "getForRender",
      value: function getForRender(renderObject) {
        var promises = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
        var backend = this.backend;
        var data = this.get(renderObject);
        if (this._needsRenderUpdate(renderObject)) {
          var previousPipeline = data.pipeline;
          if (previousPipeline) {
            previousPipeline.usedTimes--;
            previousPipeline.vertexProgram.usedTimes--;
            previousPipeline.fragmentProgram.usedTimes--;
          }

          // get shader

          var nodeBuilderState = renderObject.getNodeBuilderState();
          var name = renderObject.material ? renderObject.material.name : '';

          // programmable stages

          var stageVertex = this.programs.vertex.get(nodeBuilderState.vertexShader);
          if (stageVertex === undefined) {
            if (previousPipeline && previousPipeline.vertexProgram.usedTimes === 0) this._releaseProgram(previousPipeline.vertexProgram);
            stageVertex = new ProgrammableStage(nodeBuilderState.vertexShader, 'vertex', name);
            this.programs.vertex.set(nodeBuilderState.vertexShader, stageVertex);
            backend.createProgram(stageVertex);
          }
          var stageFragment = this.programs.fragment.get(nodeBuilderState.fragmentShader);
          if (stageFragment === undefined) {
            if (previousPipeline && previousPipeline.fragmentProgram.usedTimes === 0) this._releaseProgram(previousPipeline.fragmentProgram);
            stageFragment = new ProgrammableStage(nodeBuilderState.fragmentShader, 'fragment', name);
            this.programs.fragment.set(nodeBuilderState.fragmentShader, stageFragment);
            backend.createProgram(stageFragment);
          }

          // determine render pipeline

          var cacheKey = this._getRenderCacheKey(renderObject, stageVertex, stageFragment);
          var pipeline = this.caches.get(cacheKey);
          if (pipeline === undefined) {
            if (previousPipeline && previousPipeline.usedTimes === 0) this._releasePipeline(previousPipeline);
            pipeline = this._getRenderPipeline(renderObject, stageVertex, stageFragment, cacheKey, promises);
          } else {
            renderObject.pipeline = pipeline;
          }

          // keep track of all used times

          pipeline.usedTimes++;
          stageVertex.usedTimes++;
          stageFragment.usedTimes++;

          //

          data.pipeline = pipeline;
        }
        return data.pipeline;
      }

      /**
       * Deletes the pipeline for the given render object.
       *
       * @param {RenderObject} object - The render object.
       * @return {Object?} The deleted dictionary.
       */
    }, {
      key: "delete",
      value: function _delete(object) {
        var pipeline = this.get(object).pipeline;
        if (pipeline) {
          // pipeline

          pipeline.usedTimes--;
          if (pipeline.usedTimes === 0) this._releasePipeline(pipeline);

          // programs

          if (pipeline.isComputePipeline) {
            pipeline.computeProgram.usedTimes--;
            if (pipeline.computeProgram.usedTimes === 0) this._releaseProgram(pipeline.computeProgram);
          } else {
            pipeline.fragmentProgram.usedTimes--;
            pipeline.vertexProgram.usedTimes--;
            if (pipeline.vertexProgram.usedTimes === 0) this._releaseProgram(pipeline.vertexProgram);
            if (pipeline.fragmentProgram.usedTimes === 0) this._releaseProgram(pipeline.fragmentProgram);
          }
        }
        return _superPropGet(Pipelines, "delete", this, 3)([object]);
      }

      /**
       * Frees internal resources.
       */
    }, {
      key: "dispose",
      value: function dispose() {
        _superPropGet(Pipelines, "dispose", this, 3)([]);
        this.caches = new Map();
        this.programs = {
          vertex: new Map(),
          fragment: new Map(),
          compute: new Map()
        };
      }

      /**
       * Updates the pipeline for the given render object.
       *
       * @param {RenderObject} renderObject - The render object.
       */
    }, {
      key: "updateForRender",
      value: function updateForRender(renderObject) {
        this.getForRender(renderObject);
      }

      /**
       * Returns a compute pipeline for the given parameters.
       *
       * @private
       * @param {Node} computeNode - The compute node.
       * @param {ProgrammableStage} stageCompute - The programmable stage representing the compute shader.
       * @param {String} cacheKey - The cache key.
       * @param {Array<BindGroup>} bindings - The bindings.
       * @return {ComputePipeline} The compute pipeline.
       */
    }, {
      key: "_getComputePipeline",
      value: function _getComputePipeline(computeNode, stageCompute, cacheKey, bindings) {
        // check for existing pipeline

        cacheKey = cacheKey || this._getComputeCacheKey(computeNode, stageCompute);
        var pipeline = this.caches.get(cacheKey);
        if (pipeline === undefined) {
          pipeline = new ComputePipeline(cacheKey, stageCompute);
          this.caches.set(cacheKey, pipeline);
          this.backend.createComputePipeline(pipeline, bindings);
        }
        return pipeline;
      }

      /**
       * Returns a render pipeline for the given parameters.
       *
       * @private
       * @param {RenderObject} renderObject - The render object.
       * @param {ProgrammableStage} stageVertex - The programmable stage representing the vertex shader.
       * @param {ProgrammableStage} stageFragment - The programmable stage representing the fragment shader.
       * @param {String} cacheKey - The cache key.
       * @param {Array} promises - An array of compilation promises which is only relevant in context of `Renderer.compileAsync()`.
       * @return {ComputePipeline} The compute pipeline.
       */
    }, {
      key: "_getRenderPipeline",
      value: function _getRenderPipeline(renderObject, stageVertex, stageFragment, cacheKey, promises) {
        // check for existing pipeline

        cacheKey = cacheKey || this._getRenderCacheKey(renderObject, stageVertex, stageFragment);
        var pipeline = this.caches.get(cacheKey);
        if (pipeline === undefined) {
          pipeline = new RenderPipeline(cacheKey, stageVertex, stageFragment);
          this.caches.set(cacheKey, pipeline);
          renderObject.pipeline = pipeline;

          // The `promises` array is `null` by default and only set to an empty array when
          // `Renderer.compileAsync()` is used. The next call actually fills the array with
          // pending promises that resolve when the render pipelines are ready for rendering.

          this.backend.createRenderPipeline(renderObject, promises);
        }
        return pipeline;
      }

      /**
       * Computes a cache key representing a compute pipeline.
       *
       * @private
       * @param {Node} computeNode - The compute node.
       * @param {ProgrammableStage} stageCompute - The programmable stage representing the compute shader.
       * @return {String} The cache key.
       */
    }, {
      key: "_getComputeCacheKey",
      value: function _getComputeCacheKey(computeNode, stageCompute) {
        return computeNode.id + ',' + stageCompute.id;
      }

      /**
       * Computes a cache key representing a render pipeline.
       *
       * @private
       * @param {RenderObject} renderObject - The render object.
       * @param {ProgrammableStage} stageVertex - The programmable stage representing the vertex shader.
       * @param {ProgrammableStage} stageFragment - The programmable stage representing the fragment shader.
       * @return {String} The cache key.
       */
    }, {
      key: "_getRenderCacheKey",
      value: function _getRenderCacheKey(renderObject, stageVertex, stageFragment) {
        return stageVertex.id + ',' + stageFragment.id + ',' + this.backend.getRenderCacheKey(renderObject);
      }

      /**
       * Releases the given pipeline.
       *
       * @private
       * @param {Pipeline} pipeline - The pipeline to release.
       */
    }, {
      key: "_releasePipeline",
      value: function _releasePipeline(pipeline) {
        this.caches.delete(pipeline.cacheKey);
      }

      /**
       * Releases the shader program.
       *
       * @private
       * @param {Object} program - The shdaer program to release.
       */
    }, {
      key: "_releaseProgram",
      value: function _releaseProgram(program) {
        var code = program.code;
        var stage = program.stage;
        this.programs[stage].delete(code);
      }

      /**
       * Returns `true` if the compute pipeline for the given compute node requires an update.
       *
       * @private
       * @param {Node} computeNode - The compute node.
       * @return {Boolean} Whether the compute pipeline for the given compute node requires an update or not.
       */
    }, {
      key: "_needsComputeUpdate",
      value: function _needsComputeUpdate(computeNode) {
        var data = this.get(computeNode);
        return data.pipeline === undefined || data.version !== computeNode.version;
      }

      /**
       * Returns `true` if the render pipeline for the given render object requires an update.
       *
       * @private
       * @param {RenderObject} renderObject - The render object.
       * @return {Boolean} Whether the render object for the given render object requires an update or not.
       */
    }, {
      key: "_needsRenderUpdate",
      value: function _needsRenderUpdate(renderObject) {
        var data = this.get(renderObject);
        return data.pipeline === undefined || this.backend.needsRenderUpdate(renderObject);
      }
    }]);
  }(DataMap);
  /**
   * This renderer module manages the bindings of the renderer.
   *
   * @private
   * @augments DataMap
   */
  var Bindings = /*#__PURE__*/function (_DataMap4) {
    /**
     * Constructs a new bindings management component.
     *
     * @param {Backend} backend - The renderer's backend.
     * @param {Nodes} nodes - Renderer component for managing nodes related logic.
     * @param {Textures} textures - Renderer component for managing textures.
     * @param {Attributes} attributes - Renderer component for managing attributes.
     * @param {Pipelines} pipelines - Renderer component for managing pipelines.
     * @param {Info} info - Renderer component for managing metrics and monitoring data.
     */
    function Bindings(backend, nodes, textures, attributes, pipelines, info) {
      var _this118;
      (0, _classCallCheck2.default)(this, Bindings);
      _this118 = _callSuper(this, Bindings);

      /**
       * The renderer's backend.
       *
       * @type {Backend}
       */
      _this118.backend = backend;

      /**
       * Renderer component for managing textures.
       *
       * @type {Textures}
       */
      _this118.textures = textures;

      /**
       * Renderer component for managing pipelines.
       *
       * @type {Pipelines}
       */
      _this118.pipelines = pipelines;

      /**
       * Renderer component for managing attributes.
       *
       * @type {Attributes}
       */
      _this118.attributes = attributes;

      /**
       * Renderer component for managing nodes related logic.
       *
       * @type {Nodes}
       */
      _this118.nodes = nodes;

      /**
       * Renderer component for managing metrics and monitoring data.
       *
       * @type {Info}
       */
      _this118.info = info;
      _this118.pipelines.bindings = _this118; // assign bindings to pipelines
      return _this118;
    }

    /**
     * Returns the bind groups for the given render object.
     *
     * @param {RenderObject} renderObject - The render object.
     * @return {Array<BindGroup>} The bind groups.
     */
    (0, _inherits2.default)(Bindings, _DataMap4);
    return (0, _createClass2.default)(Bindings, [{
      key: "getForRender",
      value: function getForRender(renderObject) {
        var bindings = renderObject.getBindings();
        for (var bindGroup of bindings) {
          var groupData = this.get(bindGroup);
          if (groupData.bindGroup === undefined) {
            // each object defines an array of bindings (ubos, textures, samplers etc.)

            this._init(bindGroup);
            this.backend.createBindings(bindGroup, bindings, 0);
            groupData.bindGroup = bindGroup;
          }
        }
        return bindings;
      }

      /**
       * Returns the bind groups for the given compute node.
       *
       * @param {Node} computeNode - The compute node.
       * @return {Array<BindGroup>} The bind groups.
       */
    }, {
      key: "getForCompute",
      value: function getForCompute(computeNode) {
        var bindings = this.nodes.getForCompute(computeNode).bindings;
        for (var bindGroup of bindings) {
          var groupData = this.get(bindGroup);
          if (groupData.bindGroup === undefined) {
            this._init(bindGroup);
            this.backend.createBindings(bindGroup, bindings, 0);
            groupData.bindGroup = bindGroup;
          }
        }
        return bindings;
      }

      /**
       * Updates the bindings for the given compute node.
       *
       * @param {Node} computeNode - The compute node.
       */
    }, {
      key: "updateForCompute",
      value: function updateForCompute(computeNode) {
        this._updateBindings(this.getForCompute(computeNode));
      }

      /**
       * Updates the bindings for the given render object.
       *
       * @param {RenderObject} renderObject - The render object.
       */
    }, {
      key: "updateForRender",
      value: function updateForRender(renderObject) {
        this._updateBindings(this.getForRender(renderObject));
      }

      /**
       * Updates the given array of bindings.
       *
       * @param {Array<BindGroup>} bindings - The bind groups.
       */
    }, {
      key: "_updateBindings",
      value: function _updateBindings(bindings) {
        for (var bindGroup of bindings) {
          this._update(bindGroup, bindings);
        }
      }

      /**
       * Initializes the given bind group.
       *
       * @param {BindGroup} bindGroup - The bind group to initialize.
       */
    }, {
      key: "_init",
      value: function _init(bindGroup) {
        for (var binding of bindGroup.bindings) {
          if (binding.isSampledTexture) {
            this.textures.updateTexture(binding.texture);
          } else if (binding.isStorageBuffer) {
            var _attribute8 = binding.attribute;
            var attributeType = _attribute8.isIndirectStorageBufferAttribute ? AttributeType.INDIRECT : AttributeType.STORAGE;
            this.attributes.update(_attribute8, attributeType);
          }
        }
      }

      /**
       * Updates the given bind group.
       *
       * @param {BindGroup} bindGroup - The bind group to update.
       * @param {Array<BindGroup>} bindings - The bind groups.
       */
    }, {
      key: "_update",
      value: function _update(bindGroup, bindings) {
        var backend = this.backend;
        var needsBindingsUpdate = false;
        var cacheBindings = true;
        var cacheIndex = 0;
        var version = 0;

        // iterate over all bindings and check if buffer updates or a new binding group is required

        for (var binding of bindGroup.bindings) {
          if (binding.isNodeUniformsGroup) {
            var updated = this.nodes.updateGroup(binding);

            // every uniforms group is a uniform buffer. So if no update is required,
            // we move one with the next binding. Otherwise the next if block will update the group.

            if (updated === false) continue;
          }
          if (binding.isUniformBuffer) {
            var _updated = binding.update();
            if (_updated) {
              backend.updateBinding(binding);
            }
          } else if (binding.isSampler) {
            binding.update();
          } else if (binding.isSampledTexture) {
            var texturesTextureData = this.textures.get(binding.texture);
            if (binding.needsBindingsUpdate(texturesTextureData.generation)) needsBindingsUpdate = true;
            var _updated2 = binding.update();
            var _texture2 = binding.texture;
            if (_updated2) {
              this.textures.updateTexture(_texture2);
            }
            var textureData = backend.get(_texture2);
            if (textureData.externalTexture !== undefined || texturesTextureData.isDefaultTexture) {
              cacheBindings = false;
            } else {
              cacheIndex = cacheIndex * 10 + _texture2.id;
              version += _texture2.version;
            }
            if (backend.isWebGPUBackend === true && textureData.texture === undefined && textureData.externalTexture === undefined) {
              // TODO: Remove this once we found why updated === false isn't bound to a texture in the WebGPU backend
              console.error('Bindings._update: binding should be available:', binding, _updated2, _texture2, binding.textureNode.value, needsBindingsUpdate);
              this.textures.updateTexture(_texture2);
              needsBindingsUpdate = true;
            }
            if (_texture2.isStorageTexture === true) {
              var _textureData = this.get(_texture2);
              if (binding.store === true) {
                _textureData.needsMipmap = true;
              } else if (this.textures.needsMipmaps(_texture2) && _textureData.needsMipmap === true) {
                this.backend.generateMipmaps(_texture2);
                _textureData.needsMipmap = false;
              }
            }
          }
        }
        if (needsBindingsUpdate === true) {
          this.backend.updateBindings(bindGroup, bindings, cacheBindings ? cacheIndex : 0, version);
        }
      }
    }]);
  }(DataMap);
  /**
   * Default sorting function for opaque render items.
   *
   * @private
   * @function
   * @param {Object} a - The first render item.
   * @param {Object} b - The second render item.
   * @return {Number} A numeric value which defines the sort order.
   */
  function painterSortStable(a, b) {
    if (a.groupOrder !== b.groupOrder) {
      return a.groupOrder - b.groupOrder;
    } else if (a.renderOrder !== b.renderOrder) {
      return a.renderOrder - b.renderOrder;
    } else if (a.material.id !== b.material.id) {
      return a.material.id - b.material.id;
    } else if (a.z !== b.z) {
      return a.z - b.z;
    } else {
      return a.id - b.id;
    }
  }

  /**
   * Default sorting function for transparent render items.
   *
   * @private
   * @function
   * @param {Object} a - The first render item.
   * @param {Object} b - The second render item.
   * @return {Number} A numeric value which defines the sort order.
   */
  function reversePainterSortStable(a, b) {
    if (a.groupOrder !== b.groupOrder) {
      return a.groupOrder - b.groupOrder;
    } else if (a.renderOrder !== b.renderOrder) {
      return a.renderOrder - b.renderOrder;
    } else if (a.z !== b.z) {
      return b.z - a.z;
    } else {
      return a.id - b.id;
    }
  }

  /**
   * Returns `true` if the given transparent material requires a double pass.
   *
   * @private
   * @function
   * @param {Material} material - The transparent material.
   * @return {Boolean} Whether the given material requires a double pass or not.
   */
  function needsDoublePass(material) {
    var hasTransmission = material.transmission > 0 || material.transmissionNode;
    return hasTransmission && material.side === _$$_REQUIRE(_dependencyMap[1], "./three.core.js").DoubleSide && material.forceSinglePass === false;
  }

  /**
   * When the renderer analyzes the scene at the beginning of a render call,
   * it stores 3D object for further processing in render lists. Depending on the
   * properties of a 3D objects (like their transformation or material state), the
   * objects are maintained in ordered lists for the actual rendering.
   *
   * Render lists are unique per scene and camera combination.
   *
   * @private
   * @augments Pipeline
   */
  var RenderList = /*#__PURE__*/function () {
    /**
     * Constructs a render list.
     *
     * @param {Lighting} lighting - The lighting management component.
     * @param {Scene} scene - The scene.
     * @param {Camera} camera - The camera the scene is rendered with.
     */
    function RenderList(lighting, scene, camera) {
      (0, _classCallCheck2.default)(this, RenderList);
      /**
       * 3D objects are transformed into render items and stored in this array.
       *
       * @type {Array<Object>}
       */
      this.renderItems = [];

      /**
       * The current render items index.
       *
       * @type {Number}
       * @default 0
       */
      this.renderItemsIndex = 0;

      /**
       * A list with opaque render items.
       *
       * @type {Array<Object>}
       */
      this.opaque = [];

      /**
       * A list with transparent render items which require
       * double pass rendering (e.g. transmissive objects).
       *
       * @type {Array<Object>}
       */
      this.transparentDoublePass = [];

      /**
       * A list with transparent render items.
       *
       * @type {Array<Object>}
       */
      this.transparent = [];

      /**
       * A list with transparent render bundle data.
       *
       * @type {Array<Object>}
       */
      this.bundles = [];

      /**
       * The render list's lights node. This node is later
       * relevant for the actual analytical light nodes which
       * compute the scene's lighting in the shader.
       *
       * @type {LightsNode}
       */
      this.lightsNode = lighting.getNode(scene, camera);

      /**
       * The scene's lights stored in an array. This array
       * is used to setup the lights node.
       *
       * @type {Array<Light>}
       */
      this.lightsArray = [];

      /**
       * The scene.
       *
       * @type {Scene}
       */
      this.scene = scene;

      /**
       * The camera the scene is rendered with.
       *
       * @type {Camera}
       */
      this.camera = camera;

      /**
       * How many objects perform occlusion query tests.
       *
       * @type {Number}
       * @default 0
       */
      this.occlusionQueryCount = 0;
    }

    /**
     * This method is called right at the beginning of a render call
     * before the scene is analyzed. It prepares the internal data
     * structures for the upcoming render lists generation.
     *
     * @return {RenderList} A reference to this render list.
     */
    return (0, _createClass2.default)(RenderList, [{
      key: "begin",
      value: function begin() {
        this.renderItemsIndex = 0;
        this.opaque.length = 0;
        this.transparentDoublePass.length = 0;
        this.transparent.length = 0;
        this.bundles.length = 0;
        this.lightsArray.length = 0;
        this.occlusionQueryCount = 0;
        return this;
      }

      /**
       * Returns a render item for the giving render item state. The state is defined
       * by a series of object-related parameters.
       *
       * The method avoids object creation by holding render items and reusing them in
       * subsequent render calls (just with different property values).
       *
       * @param {Object3D} object - The 3D object.
       * @param {BufferGeometry} geometry - The 3D object's geometry.
       * @param {Material} material - The 3D object's material.
       * @param {Number} groupOrder - The current group order.
       * @param {Number} z - Th 3D object's depth value (z value in clip space).
       * @param {Number?} group - {Object?} group - Only relevant for objects using multiple materials. This represents a group entry from the respective `BufferGeometry`.
       * @param {ClippingContext} clippingContext - The current clipping context.
       * @return {Object} The render item.
       */
    }, {
      key: "getNextRenderItem",
      value: function getNextRenderItem(object, geometry, material, groupOrder, z, group, clippingContext) {
        var renderItem = this.renderItems[this.renderItemsIndex];
        if (renderItem === undefined) {
          renderItem = {
            id: object.id,
            object: object,
            geometry: geometry,
            material: material,
            groupOrder: groupOrder,
            renderOrder: object.renderOrder,
            z: z,
            group: group,
            clippingContext: clippingContext
          };
          this.renderItems[this.renderItemsIndex] = renderItem;
        } else {
          renderItem.id = object.id;
          renderItem.object = object;
          renderItem.geometry = geometry;
          renderItem.material = material;
          renderItem.groupOrder = groupOrder;
          renderItem.renderOrder = object.renderOrder;
          renderItem.z = z;
          renderItem.group = group;
          renderItem.clippingContext = clippingContext;
        }
        this.renderItemsIndex++;
        return renderItem;
      }

      /**
       * Pushes the given object as a render item to the internal render lists.
       * The selected lists depend on the object properties.
       *
       * @param {Object3D} object - The 3D object.
       * @param {BufferGeometry} geometry - The 3D object's geometry.
       * @param {Material} material - The 3D object's material.
       * @param {Number} groupOrder - The current group order.
       * @param {Number} z - Th 3D object's depth value (z value in clip space).
       * @param {Number?} group - {Object?} group - Only relevant for objects using multiple materials. This represents a group entry from the respective `BufferGeometry`.
       * @param {ClippingContext} clippingContext - The current clipping context.
       */
    }, {
      key: "push",
      value: function push(object, geometry, material, groupOrder, z, group, clippingContext) {
        var renderItem = this.getNextRenderItem(object, geometry, material, groupOrder, z, group, clippingContext);
        if (object.occlusionTest === true) this.occlusionQueryCount++;
        if (material.transparent === true || material.transmission > 0) {
          if (needsDoublePass(material)) this.transparentDoublePass.push(renderItem);
          this.transparent.push(renderItem);
        } else {
          this.opaque.push(renderItem);
        }
      }

      /**
       * Inserts the given object as a render item at the start of the internal render lists.
       * The selected lists depend on the object properties.
       *
       * @param {Object3D} object - The 3D object.
       * @param {BufferGeometry} geometry - The 3D object's geometry.
       * @param {Material} material - The 3D object's material.
       * @param {Number} groupOrder - The current group order.
       * @param {Number} z - Th 3D object's depth value (z value in clip space).
       * @param {Number?} group - {Object?} group - Only relevant for objects using multiple materials. This represents a group entry from the respective `BufferGeometry`.
       * @param {ClippingContext} clippingContext - The current clipping context.
       */
    }, {
      key: "unshift",
      value: function unshift(object, geometry, material, groupOrder, z, group, clippingContext) {
        var renderItem = this.getNextRenderItem(object, geometry, material, groupOrder, z, group, clippingContext);
        if (material.transparent === true || material.transmission > 0) {
          if (needsDoublePass(material)) this.transparentDoublePass.unshift(renderItem);
          this.transparent.unshift(renderItem);
        } else {
          this.opaque.unshift(renderItem);
        }
      }

      /**
       * Pushes render bundle group data into the render list.
       *
       * @param {Object} group - Bundle group data.
       */
    }, {
      key: "pushBundle",
      value: function pushBundle(group) {
        this.bundles.push(group);
      }

      /**
       * Pushes a light into the render list.
       *
       * @param {Light} light - The light.
       */
    }, {
      key: "pushLight",
      value: function pushLight(light) {
        this.lightsArray.push(light);
      }

      /**
       * Sorts the internal render lists.
       *
       * @param {Function} customOpaqueSort - A custom sort function for opaque objects.
       * @param {Function} customTransparentSort -  A custom sort function for transparent objects.
       */
    }, {
      key: "sort",
      value: function sort(customOpaqueSort, customTransparentSort) {
        if (this.opaque.length > 1) this.opaque.sort(customOpaqueSort || painterSortStable);
        if (this.transparentDoublePass.length > 1) this.transparentDoublePass.sort(customTransparentSort || reversePainterSortStable);
        if (this.transparent.length > 1) this.transparent.sort(customTransparentSort || reversePainterSortStable);
      }

      /**
       * This method performs finalizing tasks right after the render lists
       * have been generated.
       */
    }, {
      key: "finish",
      value: function finish() {
        // update lights

        this.lightsNode.setLights(this.lightsArray);

        // Clear references from inactive renderItems in the list

        for (var i = this.renderItemsIndex, il = this.renderItems.length; i < il; i++) {
          var renderItem = this.renderItems[i];
          if (renderItem.id === null) break;
          renderItem.id = null;
          renderItem.object = null;
          renderItem.geometry = null;
          renderItem.material = null;
          renderItem.groupOrder = null;
          renderItem.renderOrder = null;
          renderItem.z = null;
          renderItem.group = null;
          renderItem.clippingContext = null;
        }
      }
    }]);
  }();
  /**
   * This renderer module manages the render lists which are unique
   * per scene and camera combination.
   *
   * @private
   */
  var RenderLists = /*#__PURE__*/function () {
    /**
     * Constructs a render lists management component.
     *
     * @param {Lighting} lighting - The lighting management component.
     */
    function RenderLists(lighting) {
      (0, _classCallCheck2.default)(this, RenderLists);
      /**
       * The lighting management component.
       *
       * @type {Lighting}
       */
      this.lighting = lighting;

      /**
       * The internal chain map which holds the render lists.
       *
       * @type {ChainMap}
       */
      this.lists = new ChainMap();
    }

    /**
     * Returns a render list for the given scene and camera.
     *
     * @param {Scene} scene - The scene.
     * @param {Camera} camera - The camera.
     * @return {RenderList} The render list.
     */
    return (0, _createClass2.default)(RenderLists, [{
      key: "get",
      value: function get(scene, camera) {
        var lists = this.lists;
        var keys = [scene, camera];
        var list = lists.get(keys);
        if (list === undefined) {
          list = new RenderList(this.lighting, scene, camera);
          lists.set(keys, list);
        }
        return list;
      }

      /**
       * Frees all internal resources.
       */
    }, {
      key: "dispose",
      value: function dispose() {
        this.lists = new ChainMap();
      }
    }]);
  }();
  var _id$7 = 0;

  /**
   * Any render or compute command is executed in a specific context that defines
   * the state of the renderer and its backend. Typical examples for such context
   * data are the current clear values or data from the active framebuffer. This
   * module is used to represent these contexts as objects.
   *
   * @private
   */
  var RenderContext = /*#__PURE__*/function () {
    /**
     * Constructs a new render context.
     */
    function RenderContext() {
      (0, _classCallCheck2.default)(this, RenderContext);
      /**
       * The context's ID.
       *
       * @type {Number}
       */
      this.id = _id$7++;

      /**
       * Whether the current active framebuffer has a color attachment.
       *
       * @type {Boolean}
       * @default true
       */
      this.color = true;

      /**
       * Whether the color attachment should be cleared or not.
       *
       * @type {Boolean}
       * @default true
       */
      this.clearColor = true;

      /**
       * The clear color value.
       *
       * @type {Object}
       * @default true
       */
      this.clearColorValue = {
        r: 0,
        g: 0,
        b: 0,
        a: 1
      };

      /**
       * Whether the current active framebuffer has a depth attachment.
       *
       * @type {Boolean}
       * @default true
       */
      this.depth = true;

      /**
       * Whether the depth attachment should be cleared or not.
       *
       * @type {Boolean}
       * @default true
       */
      this.clearDepth = true;

      /**
       * The clear depth value.
       *
       * @type {Number}
       * @default 1
       */
      this.clearDepthValue = 1;

      /**
       * Whether the current active framebuffer has a stencil attachment.
       *
       * @type {Boolean}
       * @default false
       */
      this.stencil = false;

      /**
       * Whether the stencil attachment should be cleared or not.
       *
       * @type {Boolean}
       * @default true
       */
      this.clearStencil = true;

      /**
       * The clear stencil value.
       *
       * @type {Number}
       * @default 1
       */
      this.clearStencilValue = 1;

      /**
       * By default the viewport encloses the entire framebuffer If a smaller
       * viewport is manually defined, this property is to `true` by the renderer.
       *
       * @type {Boolean}
       * @default false
       */
      this.viewport = false;

      /**
       * The viewport value. This value is in physical pixels meaning it incorporates
       * the renderer's pixel ratio. The viewport property of render targets or
       * the renderer is in logical pixels.
       *
       * @type {Vector4}
       */
      this.viewportValue = new (_$$_REQUIRE(_dependencyMap[1], "./three.core.js").Vector4)();

      /**
       * When the scissor test is active and scissor rectangle smaller than the
       * framebuffers dimensions, this property is to `true` by the renderer.
       *
       * @type {Boolean}
       * @default false
       */
      this.scissor = false;

      /**
       * The scissor rectangle.
       *
       * @type {Vector4}
       */
      this.scissorValue = new (_$$_REQUIRE(_dependencyMap[1], "./three.core.js").Vector4)();

      /**
       * The textures of the active render target.
       * `null` when no render target is set.
       *
       * @type {Array<Texture>?}
       * @default null
       */
      this.textures = null;

      /**
       * The depth texture of the active render target.
       * `null` when no render target is set.
       *
       * @type {DepthTexture?}
       * @default null
       */
      this.depthTexture = null;

      /**
       * The active cube face.
       *
       * @type {Number}
       * @default 0
       */
      this.activeCubeFace = 0;

      /**
       * The number of MSAA samples. This value is always `1` when
       * MSAA isn't used.
       *
       * @type {Number}
       * @default 1
       */
      this.sampleCount = 1;

      /**
       * The framebuffers width in physical pixels.
       *
       * @type {Number}
       * @default 0
       */
      this.width = 0;

      /**
       * The framebuffers height in physical pixels.
       *
       * @type {Number}
       * @default 0
       */
      this.height = 0;

      /**
       * This flag can be used for type testing.
       *
       * @type {Boolean}
       * @readonly
       * @default true
       */
      this.isRenderContext = true;
    }

    /**
     * Returns the cache key of this render context.
     *
     * @return {Number} The cache key.
     */
    return (0, _createClass2.default)(RenderContext, [{
      key: "getCacheKey",
      value: function getCacheKey() {
        return _getCacheKey(this);
      }
    }]);
  }();
  /**
   * Computes a cache key for the given render context.
   *
   * @param {RenderContext} renderContext - The render context.
   * @return {Number} The cache key.
   */
  function _getCacheKey(renderContext) {
    var textures = renderContext.textures,
      activeCubeFace = renderContext.activeCubeFace;
    var values = [activeCubeFace];
    for (var _texture3 of textures) {
      values.push(_texture3.id);
    }
    return hashArray(values);
  }

  /**
   * This module manages the render contexts of the renderer.
   *
   * @private
   */
  var RenderContexts = /*#__PURE__*/function () {
    /**
     * Constructs a new render context management component.
     */
    function RenderContexts() {
      (0, _classCallCheck2.default)(this, RenderContexts);
      /**
       * A dictionary that manages render contexts in chain maps
       * for each attachment state.
       *
       * @type {Object<String,ChainMap>}
       */
      this.chainMaps = {};
    }

    /**
     * Returns a render context for the given scene, camera and render target.
     *
     * @param {Scene?} [scene=null] - The scene. The parameter can become `null` e.g. when the renderer clears a render target.
     * @param {Camera?} [camera=null] - The camera that is used to render the scene. The parameter can become `null` e.g. when the renderer clears a render target.
     * @param {RenderTarget?} [renderTarget=null] - The active render target.
     * @return {RenderContext} The render context.
     */
    return (0, _createClass2.default)(RenderContexts, [{
      key: "get",
      value: function get() {
        var scene = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
        var camera = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
        var renderTarget = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
        var chainKey = [];
        if (scene !== null) chainKey.push(scene);
        if (camera !== null) chainKey.push(camera);
        if (chainKey.length === 0) {
          chainKey.push({
            id: 'default'
          });
        }
        var attachmentState;
        if (renderTarget === null) {
          attachmentState = 'default';
        } else {
          var format = renderTarget.texture.format;
          var count = renderTarget.textures.length;
          attachmentState = `${count}:${format}:${renderTarget.samples}:${renderTarget.depthBuffer}:${renderTarget.stencilBuffer}`;
        }
        var chainMap = this.getChainMap(attachmentState);
        var renderState = chainMap.get(chainKey);
        if (renderState === undefined) {
          renderState = new RenderContext();
          chainMap.set(chainKey, renderState);
        }
        if (renderTarget !== null) renderState.sampleCount = renderTarget.samples === 0 ? 1 : renderTarget.samples;
        return renderState;
      }

      /**
       * Returns a chain map for the given attachment state.
       *
       * @param {String} attachmentState - The attachment state.
       * @return {ChainMap} The chain map.
       */
    }, {
      key: "getChainMap",
      value: function getChainMap(attachmentState) {
        return this.chainMaps[attachmentState] || (this.chainMaps[attachmentState] = new ChainMap());
      }

      /**
       * Frees internal resources.
       */
    }, {
      key: "dispose",
      value: function dispose() {
        this.chainMaps = {};
      }
    }]);
  }();
  var _size$3 = /*@__PURE__*/new (_$$_REQUIRE(_dependencyMap[1], "./three.core.js").Vector3)();

  /**
   * This module manages the textures of the renderer.
   *
   * @private
   * @augments DataMap
   */
  var Textures = /*#__PURE__*/function (_DataMap5) {
    /**
     * Constructs a new texture management component.
     *
     * @param {Renderer} renderer - The renderer.
     * @param {Backend} backend - The renderer's backend.
     * @param {Info} info - Renderer component for managing metrics and monitoring data.
     */
    function Textures(renderer, backend, info) {
      var _this119;
      (0, _classCallCheck2.default)(this, Textures);
      _this119 = _callSuper(this, Textures);

      /**
       * The renderer.
       *
       * @type {Renderer}
       */
      _this119.renderer = renderer;

      /**
       * The backend.
       *
       * @type {Backend}
       */
      _this119.backend = backend;

      /**
       * Renderer component for managing metrics and monitoring data.
       *
       * @type {Info}
       */
      _this119.info = info;
      return _this119;
    }

    /**
     * Updates the given render target. Based on the given render target configuration,
     * it updates the texture states representing the attachments of the framebuffer.
     *
     * @param {RenderTarget} renderTarget - The render target to update.
     * @param {Number} [activeMipmapLevel=0] - The active mipmap level.
     */
    (0, _inherits2.default)(Textures, _DataMap5);
    return (0, _createClass2.default)(Textures, [{
      key: "updateRenderTarget",
      value: function updateRenderTarget(renderTarget) {
        var _this120 = this;
        var activeMipmapLevel = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        var renderTargetData = this.get(renderTarget);
        var sampleCount = renderTarget.samples === 0 ? 1 : renderTarget.samples;
        var depthTextureMips = renderTargetData.depthTextureMips || (renderTargetData.depthTextureMips = {});
        var textures = renderTarget.textures;
        var size = this.getSize(textures[0]);
        var mipWidth = size.width >> activeMipmapLevel;
        var mipHeight = size.height >> activeMipmapLevel;
        var depthTexture = renderTarget.depthTexture || depthTextureMips[activeMipmapLevel];
        var useDepthTexture = renderTarget.depthBuffer === true || renderTarget.stencilBuffer === true;
        var textureNeedsUpdate = false;
        if (depthTexture === undefined && useDepthTexture) {
          depthTexture = new (_$$_REQUIRE(_dependencyMap[1], "./three.core.js").DepthTexture)();
          depthTexture.format = renderTarget.stencilBuffer ? _$$_REQUIRE(_dependencyMap[1], "./three.core.js").DepthStencilFormat : _$$_REQUIRE(_dependencyMap[1], "./three.core.js").DepthFormat;
          depthTexture.type = renderTarget.stencilBuffer ? _$$_REQUIRE(_dependencyMap[1], "./three.core.js").UnsignedInt248Type : _$$_REQUIRE(_dependencyMap[1], "./three.core.js").UnsignedIntType; // FloatType
          depthTexture.image.width = mipWidth;
          depthTexture.image.height = mipHeight;
          depthTextureMips[activeMipmapLevel] = depthTexture;
        }
        if (renderTargetData.width !== size.width || size.height !== renderTargetData.height) {
          textureNeedsUpdate = true;
          if (depthTexture) {
            depthTexture.needsUpdate = true;
            depthTexture.image.width = mipWidth;
            depthTexture.image.height = mipHeight;
          }
        }
        renderTargetData.width = size.width;
        renderTargetData.height = size.height;
        renderTargetData.textures = textures;
        renderTargetData.depthTexture = depthTexture || null;
        renderTargetData.depth = renderTarget.depthBuffer;
        renderTargetData.stencil = renderTarget.stencilBuffer;
        renderTargetData.renderTarget = renderTarget;
        if (renderTargetData.sampleCount !== sampleCount) {
          textureNeedsUpdate = true;
          if (depthTexture) {
            depthTexture.needsUpdate = true;
          }
          renderTargetData.sampleCount = sampleCount;
        }

        //

        var options = {
          sampleCount: sampleCount
        };
        for (var i = 0; i < textures.length; i++) {
          var _texture4 = textures[i];
          if (textureNeedsUpdate) _texture4.needsUpdate = true;
          this.updateTexture(_texture4, options);
        }
        if (depthTexture) {
          this.updateTexture(depthTexture, options);
        }

        // dispose handler

        if (renderTargetData.initialized !== true) {
          renderTargetData.initialized = true;

          // dispose

          var _onDispose2 = function onDispose() {
            renderTarget.removeEventListener('dispose', _onDispose2);
            for (var _i10 = 0; _i10 < textures.length; _i10++) {
              _this120._destroyTexture(textures[_i10]);
            }
            if (depthTexture) {
              _this120._destroyTexture(depthTexture);
            }
            _this120.delete(renderTarget);
          };
          renderTarget.addEventListener('dispose', _onDispose2);
        }
      }

      /**
       * Updates the given texture. Depending on the texture state, this method
       * triggers the upload of texture data to the GPU memory. If the texture data are
       * not yet ready for the upload, it uses default texture data for as a placeholder.
       *
       * @param {Texture} texture - The texture to update.
       * @param {Object} [options={}] - The options.
       */
    }, {
      key: "updateTexture",
      value: function updateTexture(texture) {
        var _this121 = this;
        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        var textureData = this.get(texture);
        if (textureData.initialized === true && textureData.version === texture.version) return;
        var isRenderTarget = texture.isRenderTargetTexture || texture.isDepthTexture || texture.isFramebufferTexture;
        var backend = this.backend;
        if (isRenderTarget && textureData.initialized === true) {
          // it's an update

          backend.destroySampler(texture);
          backend.destroyTexture(texture);
        }

        //

        if (texture.isFramebufferTexture) {
          var renderTarget = this.renderer.getRenderTarget();
          if (renderTarget) {
            texture.type = renderTarget.texture.type;
          } else {
            texture.type = _$$_REQUIRE(_dependencyMap[1], "./three.core.js").UnsignedByteType;
          }
        }

        //

        var _this$getSize = this.getSize(texture),
          width = _this$getSize.width,
          height = _this$getSize.height,
          depth = _this$getSize.depth;
        options.width = width;
        options.height = height;
        options.depth = depth;
        options.needsMipmaps = this.needsMipmaps(texture);
        options.levels = options.needsMipmaps ? this.getMipLevels(texture, width, height) : 1;

        //

        if (isRenderTarget || texture.isStorageTexture === true) {
          backend.createSampler(texture);
          backend.createTexture(texture, options);
          textureData.generation = texture.version;
        } else {
          var needsCreate = textureData.initialized !== true;
          if (needsCreate) backend.createSampler(texture);
          if (texture.version > 0) {
            var image = texture.image;
            if (image === undefined) {
              console.warn('THREE.Renderer: Texture marked for update but image is undefined.');
            } else if (image.complete === false) {
              console.warn('THREE.Renderer: Texture marked for update but image is incomplete.');
            } else {
              if (texture.images) {
                var images = [];
                for (var _image of texture.images) {
                  images.push(_image);
                }
                options.images = images;
              } else {
                options.image = image;
              }
              if (textureData.isDefaultTexture === undefined || textureData.isDefaultTexture === true) {
                backend.createTexture(texture, options);
                textureData.isDefaultTexture = false;
                textureData.generation = texture.version;
              }
              if (texture.source.dataReady === true) backend.updateTexture(texture, options);
              if (options.needsMipmaps && texture.mipmaps.length === 0) backend.generateMipmaps(texture);
            }
          } else {
            // async update

            backend.createDefaultTexture(texture);
            textureData.isDefaultTexture = true;
            textureData.generation = texture.version;
          }
        }

        // dispose handler

        if (textureData.initialized !== true) {
          textureData.initialized = true;
          textureData.generation = texture.version;

          //

          this.info.memory.textures++;

          // dispose

          var _onDispose3 = function onDispose() {
            texture.removeEventListener('dispose', _onDispose3);
            _this121._destroyTexture(texture);
            _this121.info.memory.textures--;
          };
          texture.addEventListener('dispose', _onDispose3);
        }

        //

        textureData.version = texture.version;
      }

      /**
       * Computes the size of the given texture and writes the result
       * into the target vector. This vector is also returned by the
       * method.
       *
       * If no texture data are available for the compute yet, the method
       * returns default size values.
       *
       * @param {Texture} texture - The texture to compute the size for.
       * @param {Vector3} target - The target vector.
       * @return {Vector3} The target vector.
       */
    }, {
      key: "getSize",
      value: function getSize(texture) {
        var target = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _size$3;
        var image = texture.images ? texture.images[0] : texture.image;
        if (image) {
          if (image.image !== undefined) image = image.image;
          target.width = image.width || 1;
          target.height = image.height || 1;
          target.depth = texture.isCubeTexture ? 6 : image.depth || 1;
        } else {
          target.width = target.height = target.depth = 1;
        }
        return target;
      }

      /**
       * Computes the number of mipmap levels for the given texture.
       *
       * @param {Texture} texture - The texture.
       * @param {Number} width - The texture's width.
       * @param {Number} height - The texture's height.
       * @return {Number} The number of mipmap levels.
       */
    }, {
      key: "getMipLevels",
      value: function getMipLevels(texture, width, height) {
        var mipLevelCount;
        if (texture.isCompressedTexture) {
          if (texture.mipmaps) {
            mipLevelCount = texture.mipmaps.length;
          } else {
            mipLevelCount = 1;
          }
        } else {
          mipLevelCount = Math.floor(Math.log2(Math.max(width, height))) + 1;
        }
        return mipLevelCount;
      }

      /**
       * Returns `true` if the given texture requires mipmaps.
       *
       * @param {Texture} texture - The texture.
       * @return {Boolean} Whether mipmaps are required or not.
       */
    }, {
      key: "needsMipmaps",
      value: function needsMipmaps(texture) {
        return this.isEnvironmentTexture(texture) || texture.isCompressedTexture === true || texture.generateMipmaps;
      }

      /**
       * Returns `true` if the given texture is an environment map.
       *
       * @param {Texture} texture - The texture.
       * @return {Boolean} Whether the given texture is an environment map or not.
       */
    }, {
      key: "isEnvironmentTexture",
      value: function isEnvironmentTexture(texture) {
        var mapping = texture.mapping;
        return mapping === _$$_REQUIRE(_dependencyMap[1], "./three.core.js").EquirectangularReflectionMapping || mapping === _$$_REQUIRE(_dependencyMap[1], "./three.core.js").EquirectangularRefractionMapping || mapping === _$$_REQUIRE(_dependencyMap[1], "./three.core.js").CubeReflectionMapping || mapping === _$$_REQUIRE(_dependencyMap[1], "./three.core.js").CubeRefractionMapping;
      }

      /**
       * Frees internal resource when the given texture isn't
       * required anymore.
       *
       * @param {Texture} texture - The texture to destroy.
       */
    }, {
      key: "_destroyTexture",
      value: function _destroyTexture(texture) {
        this.backend.destroySampler(texture);
        this.backend.destroyTexture(texture);
        this.delete(texture);
      }
    }]);
  }(DataMap);
  /**
   * A four-component version of {@link Color} which is internally
   * used by the renderer to represents clear color with alpha as
   * one object.
   *
   * @private
   * @augments Color
   */
  var Color4 = /*#__PURE__*/function (_Color) {
    /**
     * Constructs a new four-component color.
     *
     * @param {Number|String} r - The red value.
     * @param {Number} g - The green value.
     * @param {Number} b - The blue value.
     * @param {Number} [a=1] - The alpha value.
     */
    function Color4(r, g, b) {
      var _this122;
      var a = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;
      (0, _classCallCheck2.default)(this, Color4);
      _this122 = _callSuper(this, Color4, [r, g, b]);
      _this122.a = a;
      return _this122;
    }

    /**
     * Overwrites the default to honor alpha.
     *
     * @param {Number|String} r - The red value.
     * @param {Number} g - The green value.
     * @param {Number} b - The blue value.
     * @param {Number} [a=1] - The alpha value.
     * @return {Color4} A reference to this object.
     */
    (0, _inherits2.default)(Color4, _Color);
    return (0, _createClass2.default)(Color4, [{
      key: "set",
      value: function set(r, g, b) {
        var a = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;
        this.a = a;
        return _superPropGet(Color4, "set", this, 3)([r, g, b]);
      }

      /**
       * Overwrites the default to honor alpha.
       *
       * @param {Color4} color - The color to copy.
       * @return {Color4} A reference to this object.
       */
    }, {
      key: "copy",
      value: function copy(color) {
        if (color.a !== undefined) this.a = color.a;
        return _superPropGet(Color4, "copy", this, 3)([color]);
      }

      /**
       * Overwrites the default to honor alpha.
       *
       * @return {Color4} The cloned color.
       */
    }, {
      key: "clone",
      value: function clone() {
        return new this.constructor(this.r, this.g, this.b, this.a);
      }
    }]);
  }(_$$_REQUIRE(_dependencyMap[1], "./three.core.js").Color);
  /** @module ParameterNode **/
  /**
   * Special version of {@link PropertyNode} which is used for parameters.
   *
   * @augments PropertyNode
   */
  var ParameterNode = exports.ParameterNode = /*#__PURE__*/function (_PropertyNode) {
    /**
     * Constructs a new parameter node.
     *
     * @param {String} nodeType - The type of the node.
     * @param {String?} [name=null] - The name of the parameter in the shader.
     */
    function ParameterNode(nodeType) {
      var _this123;
      var name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      (0, _classCallCheck2.default)(this, ParameterNode);
      _this123 = _callSuper(this, ParameterNode, [nodeType, name]);

      /**
       * This flag can be used for type testing.
       *
       * @type {Boolean}
       * @readonly
       * @default true
       */
      _this123.isParameterNode = true;
      return _this123;
    }
    (0, _inherits2.default)(ParameterNode, _PropertyNode);
    return (0, _createClass2.default)(ParameterNode, [{
      key: "getHash",
      value: function getHash() {
        return this.uuid;
      }
    }, {
      key: "generate",
      value: function generate() {
        return this.name;
      }
    }], [{
      key: "type",
      get: function get() {
        return 'ParameterNode';
      }
    }]);
  }(PropertyNode);
  /**
   * TSL function for creating a parameter node.
   *
   * @function
   * @param {String} type - The type of the node.
   * @param {String?} name - The name of the parameter in the shader.
   * @returns {ParameterNode}
   */
  var parameter = function parameter(type, name) {
    return nodeObject(new ParameterNode(type, name));
  };

  /** @module StackNode **/

  /**
   * Stack is a helper for Nodes that need to produce stack-based code instead of continuous flow.
   * They are usually needed in cases like `If`, `Else`.
   *
   * @augments Node
   */
  var StackNode = exports.StackNode = /*#__PURE__*/function (_Node37) {
    /**
     * Constructs a new stack node.
     *
     * @param {StackNode?} [parent=null] - The parent stack node.
     */
    function StackNode() {
      var _this124;
      var parent = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      (0, _classCallCheck2.default)(this, StackNode);
      _this124 = _callSuper(this, StackNode);

      /**
       * List of nodes.
       *
       * @type {Array<Node>}
       */
      _this124.nodes = [];

      /**
       * The output node.
       *
       * @type {Node?}
       * @default null
       */
      _this124.outputNode = null;

      /**
       * The parent stack node.
       *
       * @type {StackNode}
       * @default null
       */
      _this124.parent = parent;

      /**
       * The current conditional node.
       *
       * @private
       * @type {ConditionalNode}
       * @default null
       */
      _this124._currentCond = null;

      /**
       * This flag can be used for type testing.
       *
       * @type {Boolean}
       * @readonly
       * @default true
       */
      _this124.isStackNode = true;
      return _this124;
    }
    (0, _inherits2.default)(StackNode, _Node37);
    return (0, _createClass2.default)(StackNode, [{
      key: "getNodeType",
      value: function getNodeType(builder) {
        return this.outputNode ? this.outputNode.getNodeType(builder) : 'void';
      }

      /**
       * Adds a node to this stack.
       *
       * @param {Node} node - The node to add.
       * @return {StackNode} A reference to this stack node.
       */
    }, {
      key: "add",
      value: function add(node) {
        this.nodes.push(node);
        return this;
      }

      /**
       * Represent an `if` statement in TSL.
       *
       * @param {Node} boolNode - Represents the condition.
       * @param {Function} method - TSL code which is executed if the condition evaluates to `true`.
       * @return {StackNode} A reference to this stack node.
       */
    }, {
      key: "If",
      value: function If(boolNode, method) {
        var methodNode = new ShaderNode(method);
        this._currentCond = select(boolNode, methodNode);
        return this.add(this._currentCond);
      }

      /**
       * Represent an `elseif` statement in TSL.
       *
       * @param {Node} boolNode - Represents the condition.
       * @param {Function} method - TSL code which is executed if the condition evaluates to `true`.
       * @return {StackNode} A reference to this stack node.
       */
    }, {
      key: "ElseIf",
      value: function ElseIf(boolNode, method) {
        var methodNode = new ShaderNode(method);
        var ifNode = select(boolNode, methodNode);
        this._currentCond.elseNode = ifNode;
        this._currentCond = ifNode;
        return this;
      }

      /**
       * Represent an `else` statement in TSL.
       *
       * @param {Function} method - TSL code which is executed in the `else` case.
       * @return {StackNode} A reference to this stack node.
       */
    }, {
      key: "Else",
      value: function Else(method) {
        this._currentCond.elseNode = new ShaderNode(method);
        return this;
      }
    }, {
      key: "build",
      value: function build(builder) {
        var _this$outputNode;
        var previousStack = getCurrentStack();
        setCurrentStack(this);
        for (var node of this.nodes) {
          node.build(builder, 'void');
        }
        setCurrentStack(previousStack);
        for (var _len17 = arguments.length, params = new Array(_len17 > 1 ? _len17 - 1 : 0), _key17 = 1; _key17 < _len17; _key17++) {
          params[_key17 - 1] = arguments[_key17];
        }
        return this.outputNode ? (_this$outputNode = this.outputNode).build.apply(_this$outputNode, [builder].concat(params)) : _superPropGet(StackNode, "build", this, 3)([builder].concat(params));
      }

      //
    }, {
      key: "else",
      value: function _else() {
        // @deprecated, r168

        console.warn('TSL.StackNode: .else() has been renamed to .Else().');
        return this.Else.apply(this, arguments);
      }
    }, {
      key: "elseif",
      value: function elseif() {
        // @deprecated, r168

        console.warn('TSL.StackNode: .elseif() has been renamed to .ElseIf().');
        return this.ElseIf.apply(this, arguments);
      }
    }], [{
      key: "type",
      get: function get() {
        return 'StackNode';
      }
    }]);
  }(Node);
  /**
   * TSL function for creating a stack node.
   *
   * @function
   * @param {StackNode?} [parent=null] - The parent stack node.
   * @returns {StackNode}
   */
  var stack = /*@__PURE__*/nodeProxy(StackNode);

  /** @module OutputStructNode **/

  /**
   * This node can be used to define multiple outputs in a shader programs.
   *
   * @augments Node
   */
  var OutputStructNode = exports.OutputStructNode = /*#__PURE__*/function (_Node38) {
    /**
     * Constructs a new output struct node. The constructor can be invoked with an
     * arbitrary number of nodes representing the members.
     *
     * @param {...Node} members - A parameter list of nodes.
     */
    function OutputStructNode() {
      var _this125;
      (0, _classCallCheck2.default)(this, OutputStructNode);
      _this125 = _callSuper(this, OutputStructNode);

      /**
       * An array of nodes which defines the output.
       *
       * @type {Array<Node>}
       */
      for (var _len18 = arguments.length, members = new Array(_len18), _key18 = 0; _key18 < _len18; _key18++) {
        members[_key18] = arguments[_key18];
      }
      _this125.members = members;

      /**
       * This flag can be used for type testing.
       *
       * @type {Boolean}
       * @readonly
       * @default true
       */
      _this125.isOutputStructNode = true;
      return _this125;
    }
    (0, _inherits2.default)(OutputStructNode, _Node38);
    return (0, _createClass2.default)(OutputStructNode, [{
      key: "setup",
      value: function setup(builder) {
        _superPropGet(OutputStructNode, "setup", this, 3)([builder]);
        var members = this.members;
        var types = [];
        for (var i = 0; i < members.length; i++) {
          types.push(members[i].getNodeType(builder));
        }
        this.nodeType = builder.getStructTypeFromNode(this, types).name;
      }
    }, {
      key: "generate",
      value: function generate(builder, output) {
        var propertyName = builder.getOutputStructName();
        var members = this.members;
        var structPrefix = propertyName !== '' ? propertyName + '.' : '';
        for (var i = 0; i < members.length; i++) {
          var snippet = members[i].build(builder, output);
          builder.addLineFlowCode(`${structPrefix}m${i} = ${snippet}`, this);
        }
        return propertyName;
      }
    }], [{
      key: "type",
      get: function get() {
        return 'OutputStructNode';
      }
    }]);
  }(Node);
  /**
   * TSL function for creating an output struct node.
   *
   * @function
   * @param {...Node} members - A parameter list of nodes.
   * @returns {OutputStructNode}
   */
  var outputStruct = /*@__PURE__*/nodeProxy(OutputStructNode);

  /** @module MRTNode **/

  /**
   * Returns the MRT texture index for the given name.
   *
   * @param {Array<Texture>} textures - The textures of a MRT-configured render target.
   * @param {String} name - The name of the MRT texture which index is requested.
   * @return {Number} The texture index.
   */
  function getTextureIndex(textures, name) {
    for (var i = 0; i < textures.length; i++) {
      if (textures[i].name === name) {
        return i;
      }
    }
    return -1;
  }

  /**
   * This node can be used setup a MRT context for rendering. A typical MRT setup for
   * post-processing is shown below:
   * ```js
   * const mrtNode = mrt( {
   *   output: output,
   *   normal: normalView
   * } ) );
   * ```
   * The MRT output is defined as a dictionary.
   *
   * @augments OutputStructNode
   */
  var MRTNode = exports.MRTNode = /*#__PURE__*/function (_OutputStructNode) {
    /**
     * Constructs a new output struct node.
     *
     * @param {Object<String, Node>} outputNodes - The MRT outputs.
     */
    function MRTNode(outputNodes) {
      var _this126;
      (0, _classCallCheck2.default)(this, MRTNode);
      _this126 = _callSuper(this, MRTNode);

      /**
       * A dictionary representing the MRT outputs. The key
       * is the name of the output, the value the node which produces
       * the output result.
       *
       * @type {Object<String, Node>}
       */
      _this126.outputNodes = outputNodes;

      /**
       * This flag can be used for type testing.
       *
       * @type {Boolean}
       * @readonly
       * @default true
       */
      _this126.isMRTNode = true;
      return _this126;
    }

    /**
     * Returns `true` if the MRT node has an output with the given name.
     *
     * @param {String} name - The name of the output.
     * @return {NodeBuilder} Whether the MRT node has an output for the given name or not.
     */
    (0, _inherits2.default)(MRTNode, _OutputStructNode);
    return (0, _createClass2.default)(MRTNode, [{
      key: "has",
      value: function has(name) {
        return this.outputNodes[name] !== undefined;
      }

      /**
       * Returns the output node for the given name.
       *
       * @param {String} name - The name of the output.
       * @return {Node} The output node.
       */
    }, {
      key: "get",
      value: function get(name) {
        return this.outputNodes[name];
      }

      /**
       * Merges the outputs of the given MRT node with the outputs of this node.
       *
       * @param {MRTNode} mrtNode - The MRT to merge.
       * @return {MRTNode} A new MRT node with merged outputs..
       */
    }, {
      key: "merge",
      value: function merge(mrtNode) {
        var outputs = Object.assign({}, this.outputNodes, mrtNode.outputNodes);
        return mrt(outputs);
      }
    }, {
      key: "setup",
      value: function setup(builder) {
        var outputNodes = this.outputNodes;
        var mrt = builder.renderer.getRenderTarget();
        var members = [];
        var textures = mrt.textures;
        for (var name in outputNodes) {
          var index = getTextureIndex(textures, name);
          members[index] = vec4(outputNodes[name]);
        }
        this.members = members;
        return _superPropGet(MRTNode, "setup", this, 3)([builder]);
      }
    }], [{
      key: "type",
      get: function get() {
        return 'MRTNode';
      }
    }]);
  }(OutputStructNode);
  /**
   * TSL function for creating a MRT node.
   *
   * @function
   * @param {Object<String, Node>} outputNodes - The MRT outputs.
   * @returns {MRTNode}
   */
  var mrt = /*@__PURE__*/nodeProxy(MRTNode);

  /** @module Hash **/

  /**
   * Generates a hash value in the range `[0, 1]` from the given seed.
   *
   * @method
   * @param {Node<float>} seed - The seed.
   * @return {Node<float>} The hash value.
   */
  var hash = /*@__PURE__*/Fn(function (_ref118) {
    var _ref119 = (0, _slicedToArray2.default)(_ref118, 1),
      seed = _ref119[0];
    // Taken from https://www.shadertoy.com/view/XlGcRh, originally from pcg-random.org

    var state = seed.toUint().mul(747796405).add(2891336453);
    var word = state.shiftRight(state.shiftRight(28).add(4)).bitXor(state).mul(277803737);
    var result = word.shiftRight(22).bitXor(word);
    return result.toFloat().mul(1 / 2 ** 32); // Convert to range [0, 1)
  });

  /** @module MathUtils **/

  /**
   * A function that remaps the `[0,1]` interval into the `[0,1]` interval.
   * The corners are mapped to `0` and the center to `1`.
   * Reference: {@link https://iquilezles.org/articles/functions/}.
   *
   * @method
   * @param {Node<float>} x - The value to remap.
   * @param {Node<float>} k - Allows to control the remapping functions shape by rising the parabola to a power `k`.
   * @return {Node<float>} The remapped value.
   */
  var parabola = function parabola(x, k) {
    return pow(mul(4.0, x.mul(sub(1.0, x))), k);
  };

  /**
   * A function that remaps the `[0,1]` interval into the `[0,1]` interval.
   * Expands the sides and compresses the center, and keeps `0.5` mapped to `0.5`.
   * Reference: {@link https://iquilezles.org/articles/functions/}.
   *
   * @method
   * @param {Node<float>} x - The value to remap.
   * @param {Node<float>} k - `k=1` is the identity curve,`k<1` produces the classic `gain()` shape, and `k>1` produces "s" shaped curves.
   * @return {Node<float>} The remapped value.
   */
  var gain = function gain(x, k) {
    return x.lessThan(0.5) ? parabola(x.mul(2.0), k).div(2.0) : sub(1.0, parabola(mul(sub(1.0, x), 2.0), k).div(2.0));
  };

  /**
   * A function that remaps the `[0,1]` interval into the `[0,1]` interval.
   * A generalization of the `parabola()`. Keeps the corners mapped to 0 but allows the control of the shape one either side of the curve.
   * Reference: {@link https://iquilezles.org/articles/functions/}.
   *
   * @method
   * @param {Node<float>} x - The value to remap.
   * @param {Node<float>} a - First control parameter.
   * @param {Node<float>} b - Second control parameter.
   * @return {Node<float>} The remapped value.
   */
  var pcurve = function pcurve(x, a, b) {
    return pow(div(pow(x, a), add(pow(x, a), pow(sub(1.0, x), b))), 1.0 / a);
  };

  /**
   * A phase shifted sinus curve that starts at zero and ends at zero, with bouncing behavior.
   * Reference: {@link https://iquilezles.org/articles/functions/}.
   *
   * @method
   * @param {Node<float>} x - The value to compute the sin for.
   * @param {Node<float>} k - Controls the amount of bounces.
   * @return {Node<float>} The result value.
   */
  var sinc = function sinc(x, k) {
    return sin(PI.mul(k.mul(x).sub(1.0))).div(PI.mul(k.mul(x).sub(1.0)));
  };

  // https://github.com/cabbibo/glsl-tri-noise-3d

  /** @module TriNoise3D **/

  var tri = /*@__PURE__*/Fn(function (_ref120) {
    var _ref121 = (0, _slicedToArray2.default)(_ref120, 1),
      x = _ref121[0];
    return x.fract().sub(.5).abs();
  }).setLayout({
    name: 'tri',
    type: 'float',
    inputs: [{
      name: 'x',
      type: 'float'
    }]
  });
  var tri3 = /*@__PURE__*/Fn(function (_ref122) {
    var _ref123 = (0, _slicedToArray2.default)(_ref122, 1),
      p = _ref123[0];
    return vec3(tri(p.z.add(tri(p.y.mul(1.)))), tri(p.z.add(tri(p.x.mul(1.)))), tri(p.y.add(tri(p.x.mul(1.)))));
  }).setLayout({
    name: 'tri3',
    type: 'vec3',
    inputs: [{
      name: 'p',
      type: 'vec3'
    }]
  });

  /**
   * Generates a noise value from the given position, speed and time parameters.
   *
   * @method
   * @param {Node<vec3>} position - The position.
   * @param {Node<float>} speed - The speed.
   * @param {Node<float>} time - The time.
   * @return {Node<float>} The generated noise.
   */
  var triNoise3D = /*@__PURE__*/Fn(function (_ref124) {
    var _ref125 = (0, _slicedToArray2.default)(_ref124, 3),
      position = _ref125[0],
      speed = _ref125[1],
      time = _ref125[2];
    var p = vec3(position).toVar();
    var z = float(1.4).toVar();
    var rz = float(0.0).toVar();
    var bp = vec3(p).toVar();
    Loop({
      start: float(0.0),
      end: float(3.0),
      type: 'float',
      condition: '<='
    }, function () {
      var dg = vec3(tri3(bp.mul(2.0))).toVar();
      p.addAssign(dg.add(time.mul(float(0.1).mul(speed))));
      bp.mulAssign(1.8);
      z.mulAssign(1.5);
      p.mulAssign(1.2);
      var t = float(tri(p.z.add(tri(p.x.add(tri(p.y)))))).toVar();
      rz.addAssign(t.div(z));
      bp.addAssign(0.14);
    });
    return rz;
  }).setLayout({
    name: 'triNoise3D',
    type: 'float',
    inputs: [{
      name: 'position',
      type: 'vec3'
    }, {
      name: 'speed',
      type: 'float'
    }, {
      name: 'time',
      type: 'float'
    }]
  });

  /** @module FunctionOverloadingNode **/

  /**
   * This class allows to define multiple overloaded versions
   * of the same function. Depending on the parameters of the function
   * call, the node picks the best-fit overloaded version.
   *
   * @augments Node
   */
  var FunctionOverloadingNode = exports.FunctionOverloadingNode = /*#__PURE__*/function (_Node39) {
    /**
     * Constructs a new function overloading node.
     *
     * @param {Array<Function>} functionNodes - Array of `Fn` function definitions.
     * @param {...Node} parametersNodes - A list of parameter nodes.
     */
    function FunctionOverloadingNode() {
      var _this127;
      var functionNodes = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      (0, _classCallCheck2.default)(this, FunctionOverloadingNode);
      _this127 = _callSuper(this, FunctionOverloadingNode);

      /**
       * Array of `Fn` function definitions.
       *
       * @type {Array<Function>}
       */
      _this127.functionNodes = functionNodes;

      /**
       * A list of parameter nodes.
       *
       * @type {Array<Node>}
       */
      for (var _len19 = arguments.length, parametersNodes = new Array(_len19 > 1 ? _len19 - 1 : 0), _key19 = 1; _key19 < _len19; _key19++) {
        parametersNodes[_key19 - 1] = arguments[_key19];
      }
      _this127.parametersNodes = parametersNodes;

      /**
       * The selected overloaded function call.
       *
       * @private
       * @type {ShaderCallNodeInternal}
       */
      _this127._candidateFnCall = null;

      /**
       * This node is marked as global.
       *
       * @type {Boolean}
       * @default true
       */
      _this127.global = true;
      return _this127;
    }

    /**
     * This method is overwritten since the node type is inferred from
     * the function's return type.
     *
     * @param {NodeBuilder} builder - The current node builder.
     * @return {String} The node type.
     */
    (0, _inherits2.default)(FunctionOverloadingNode, _Node39);
    return (0, _createClass2.default)(FunctionOverloadingNode, [{
      key: "getNodeType",
      value: function getNodeType() {
        return this.functionNodes[0].shaderNode.layout.type;
      }
    }, {
      key: "setup",
      value: function setup(builder) {
        var params = this.parametersNodes;
        var candidateFnCall = this._candidateFnCall;
        if (candidateFnCall === null) {
          var candidateFn = null;
          var candidateScore = -1;
          for (var functionNode of this.functionNodes) {
            var shaderNode = functionNode.shaderNode;
            var layout = shaderNode.layout;
            if (layout === null) {
              throw new Error('FunctionOverloadingNode: FunctionNode must be a layout.');
            }
            var inputs = layout.inputs;
            if (params.length === inputs.length) {
              var score = 0;
              for (var i = 0; i < params.length; i++) {
                var param = params[i];
                var input = inputs[i];
                if (param.getNodeType(builder) === input.type) {
                  score++;
                } else {
                  score = 0;
                }
              }
              if (score > candidateScore) {
                candidateFn = functionNode;
                candidateScore = score;
              }
            }
          }
          this._candidateFnCall = candidateFnCall = candidateFn.apply(void 0, (0, _toConsumableArray2.default)(params));
        }
        return candidateFnCall;
      }
    }], [{
      key: "type",
      get: function get() {
        return 'FunctionOverloadingNode';
      }
    }]);
  }(Node);
  var overloadingBaseFn = /*@__PURE__*/nodeProxy(FunctionOverloadingNode);

  /**
   * TSL function for creating a function overloading node.
   *
   * @function
   * @param {Array<Function>} functionNodes - Array of `Fn` function definitions.
   * @returns {FunctionOverloadingNode}
   */
  var overloadingFn = function overloadingFn(functionNodes) {
    return function () {
      for (var _len20 = arguments.length, params = new Array(_len20), _key20 = 0; _key20 < _len20; _key20++) {
        params[_key20] = arguments[_key20];
      }
      return overloadingBaseFn.apply(void 0, [functionNodes].concat(params));
    };
  };

  /** @module Timer **/

  /**
   * Represents the elapsed time in seconds.
   *
   * @type {UniformNode<float>}
   */
  var time = /*@__PURE__*/uniform(0).setGroup(renderGroup).onRenderUpdate(function (frame) {
    return frame.time;
  });

  /**
   * Represents the delta time in seconds.
   *
   * @type {UniformNode<float>}
   */
  var deltaTime = /*@__PURE__*/uniform(0).setGroup(renderGroup).onRenderUpdate(function (frame) {
    return frame.deltaTime;
  });

  /**
   * Represents the current frame ID.
   *
   * @type {UniformNode<uint>}
   */
  var frameId = /*@__PURE__*/uniform(0, 'uint').setGroup(renderGroup).onRenderUpdate(function (frame) {
    return frame.frameId;
  });

  // Deprecated

  var timerLocal = function timerLocal() {
    var timeScale = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
    // @deprecated, r170

    console.warn('TSL: timerLocal() is deprecated. Use "time" instead.');
    return time.mul(timeScale);
  };
  var timerGlobal = function timerGlobal() {
    var timeScale = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
    // @deprecated, r170

    console.warn('TSL: timerGlobal() is deprecated. Use "time" instead.');
    return time.mul(timeScale);
  };
  var timerDelta = function timerDelta() {
    var timeScale = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
    // @deprecated, r170

    console.warn('TSL: timerDelta() is deprecated. Use "deltaTime" instead.');
    return deltaTime.mul(timeScale);
  };

  /** @module Oscillators **/

  /**
   * Generates a sine wave oscillation based on a timer.
   *
   * @method
   * @param {Node<float>} t - The timer to generate the oscillation with.
   * @return {Node<float>} The oscillation node.
   */
  var oscSine = function oscSine() {
    var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : time;
    return t.add(0.75).mul(Math.PI * 2).sin().mul(0.5).add(0.5);
  };

  /**
   * Generates a square wave oscillation based on a timer.
   *
   * @method
   * @param {Node<float>} t - The timer to generate the oscillation with.
   * @return {Node<float>} The oscillation node.
   */
  var oscSquare = function oscSquare() {
    var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : time;
    return t.fract().round();
  };

  /**
   * Generates a triangle wave oscillation based on a timer.
   *
   * @method
   * @param {Node<float>} t - The timer to generate the oscillation with.
   * @return {Node<float>} The oscillation node.
   */
  var oscTriangle = function oscTriangle() {
    var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : time;
    return t.add(0.5).fract().mul(2).sub(1).abs();
  };

  /**
   * Generates a sawtooth wave oscillation based on a timer.
   *
   * @method
   * @param {Node<float>} t - The timer to generate the oscillation with.
   * @return {Node<float>} The oscillation node.
   */
  var oscSawtooth = function oscSawtooth() {
    var t = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : time;
    return t.fract();
  };

  /** @module UVUtils **/

  /**
   * Rotates the given uv coordinates around a center point
   *
   * @method
   * @param {Node<vec2>} uv - The uv coordinates.
   * @param {Node<float>} rotation - The rotation defined in radians.
   * @param {Node<vec2>} center - The center of rotation
   * @return {Node<vec2>} The rotated uv coordinates.
   */
  var rotateUV = /*@__PURE__*/Fn(function (_ref126) {
    var _ref127 = (0, _slicedToArray2.default)(_ref126, 3),
      uv = _ref127[0],
      rotation = _ref127[1],
      _ref127$ = _ref127[2],
      center = _ref127$ === void 0 ? vec2(0.5) : _ref127$;
    return rotate(uv.sub(center), rotation).add(center);
  });

  /**
   * Applies a spherical warping effect to the given uv coordinates.
   *
   * @method
   * @param {Node<vec2>} uv - The uv coordinates.
   * @param {Node<float>} strength - The strength of the effect.
   * @param {Node<vec2>} center - The center point
   * @return {Node<vec2>} The updated uv coordinates.
   */
  var spherizeUV = /*@__PURE__*/Fn(function (_ref128) {
    var _ref129 = (0, _slicedToArray2.default)(_ref128, 3),
      uv = _ref129[0],
      strength = _ref129[1],
      _ref129$ = _ref129[2],
      center = _ref129$ === void 0 ? vec2(0.5) : _ref129$;
    var delta = uv.sub(center);
    var delta2 = delta.dot(delta);
    var delta4 = delta2.mul(delta2);
    var deltaOffset = delta4.mul(strength);
    return uv.add(delta.mul(deltaOffset));
  });

  /** @module SpriteUtils **/

  /**
   * This can be used to achieve a billboarding behavior for flat meshes. That means they are
   * oriented always towards the camera.
   *
   * ```js
   * material.vertexNode = billboarding();
   * ```
   *
   * @method
   * @param {Object} config - The configuration object.
   * @param {Node<vec3>?} [config.position=null] - Can be used to define the vertex positions in world space.
   * @param {Boolean} [config.horizontal=true] - Whether to follow the camera rotation horizontally or not.
   * @param {Boolean} [config.vertical=false] - Whether to follow the camera rotation vertically or not.
   * @return {Node<vec3>} The updated vertex position in clip space.
   */
  var billboarding = /*@__PURE__*/Fn(function (_ref130) {
    var _ref130$position = _ref130.position,
      position = _ref130$position === void 0 ? null : _ref130$position,
      _ref130$horizontal = _ref130.horizontal,
      horizontal = _ref130$horizontal === void 0 ? true : _ref130$horizontal,
      _ref130$vertical = _ref130.vertical,
      vertical = _ref130$vertical === void 0 ? false : _ref130$vertical;
    var worldMatrix;
    if (position !== null) {
      worldMatrix = modelWorldMatrix.toVar();
      worldMatrix[3][0] = position.x;
      worldMatrix[3][1] = position.y;
      worldMatrix[3][2] = position.z;
    } else {
      worldMatrix = modelWorldMatrix;
    }
    var modelViewMatrix = cameraViewMatrix.mul(worldMatrix);
    if (defined(horizontal)) {
      modelViewMatrix[0][0] = modelWorldMatrix[0].length();
      modelViewMatrix[0][1] = 0;
      modelViewMatrix[0][2] = 0;
    }
    if (defined(vertical)) {
      modelViewMatrix[1][0] = 0;
      modelViewMatrix[1][1] = modelWorldMatrix[1].length();
      modelViewMatrix[1][2] = 0;
    }
    modelViewMatrix[2][0] = 0;
    modelViewMatrix[2][1] = 0;
    modelViewMatrix[2][2] = 1;
    return cameraProjectionMatrix.mul(modelViewMatrix).mul(positionLocal);
  });

  /** @module ViewportUtils **/

  /**
   * A special version of a screen uv function that involves a depth comparison
   * when computing the final uvs. The function mitigates visual errors when
   * using viewport texture nodes for refraction purposes. Without this function
   * objects in front of a refractive surface might appear on the refractive surface
   * which is incorrect.
   *
   * @method
   * @param {Node<vec2>?} uv - Optional uv coordinates. By default `screenUV` is used.
   * @return {Node<vec2>} The update uv coordinates.
   */
  var viewportSafeUV = /*@__PURE__*/Fn(function (_ref131) {
    var _ref132 = (0, _slicedToArray2.default)(_ref131, 1),
      _ref132$ = _ref132[0],
      uv = _ref132$ === void 0 ? null : _ref132$;
    var depth = linearDepth();
    var depthDiff = linearDepth(viewportDepthTexture(uv)).sub(depth);
    var finalUV = depthDiff.lessThan(0).select(screenUV, uv);
    return finalUV;
  });

  /** @module SpriteSheetUVNode **/

  /**
   * Can be used to compute texture coordinates for animated sprite sheets.
   *
   * ```js
   * const uvNode = spritesheetUV( vec2( 6, 6 ), uv(), time.mul( animationSpeed ) );
   *
   * material.colorNode = texture( spriteSheet, uvNode );
   * ```
   *
   * @augments Node
   */
  var SpriteSheetUVNode = exports.SpriteSheetUVNode = /*#__PURE__*/function (_Node40) {
    /**
     * Constructs a new sprite sheet uv node.
     *
     * @param {Node<vec2>} countNode - The node that defines the number of sprites in the x and y direction (e.g 6x6).
     * @param {Node<vec2>} [uvNode=uv()] - The uv node.
     * @param {Node<float>} [frameNode=float()] - The node that defines the current frame/sprite.
     */
    function SpriteSheetUVNode(countNode) {
      var _this128;
      var uvNode = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : uv();
      var frameNode = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : float(0);
      (0, _classCallCheck2.default)(this, SpriteSheetUVNode);
      _this128 = _callSuper(this, SpriteSheetUVNode, ['vec2']);

      /**
       * The node that defines the number of sprites in the x and y direction (e.g 6x6).
       *
       * @type {Node<vec2>}
       */
      _this128.countNode = countNode;

      /**
       * The uv node.
       *
       * @type {Node<vec2>}
       */
      _this128.uvNode = uvNode;

      /**
       * The node that defines the current frame/sprite.
       *
       * @type {Node<float>}
       */
      _this128.frameNode = frameNode;
      return _this128;
    }
    (0, _inherits2.default)(SpriteSheetUVNode, _Node40);
    return (0, _createClass2.default)(SpriteSheetUVNode, [{
      key: "setup",
      value: function setup() {
        var frameNode = this.frameNode,
          uvNode = this.uvNode,
          countNode = this.countNode;
        var width = countNode.width,
          height = countNode.height;
        var frameNum = frameNode.mod(width.mul(height)).floor();
        var column = frameNum.mod(width);
        var row = height.sub(frameNum.add(1).div(width).ceil());
        var scale = countNode.reciprocal();
        var uvFrameOffset = vec2(column, row);
        return uvNode.add(uvFrameOffset).mul(scale);
      }
    }], [{
      key: "type",
      get: function get() {
        return 'SpriteSheetUVNode';
      }
    }]);
  }(Node);
  /**
   * TSL function for creating a sprite sheet uv node.
   *
   * @function
   * @param {Node<vec2>} countNode - The node that defines the number of sprites in the x and y direction (e.g 6x6).
   * @param {Node<vec2>} [uvNode=uv()] - The uv node.
   * @param {Node<float>} [frameNode=float()] - The node that defines the current frame/sprite.
   * @returns {SpriteSheetUVNode}
   */
  var spritesheetUV = /*@__PURE__*/nodeProxy(SpriteSheetUVNode);

  /** @module TriplanarTexturesNode **/

  /**
   * Can be used for triplanar texture mapping.
   *
   * ```js
   * material.colorNode = triplanarTexture( texture( diffuseMap ) );
   * ```
   *
   * @augments Node
   */
  var TriplanarTexturesNode = exports.TriplanarTexturesNode = /*#__PURE__*/function (_Node41) {
    /**
     * Constructs a new triplanar textures node.
     *
     * @param {Node} textureXNode - First texture node.
     * @param {Node?} [textureYNode=null] - Second texture node. When not set, the shader will sample from `textureXNode` instead.
     * @param {Node?} [textureZNode=null] - Third texture node. When not set, the shader will sample from `textureXNode` instead.
     * @param {Node<float>?} [scaleNode=float(1)] - The scale node.
     * @param {Node<vec3>?} [positionNode=positionLocal] - Vertex positions in local space.
     * @param {Node<vec3>?} [normalNode=normalLocal] - Normals in local space.
     */
    function TriplanarTexturesNode(textureXNode) {
      var _this129;
      var textureYNode = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      var textureZNode = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
      var scaleNode = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : float(1);
      var positionNode = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : positionLocal;
      var normalNode = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : normalLocal;
      (0, _classCallCheck2.default)(this, TriplanarTexturesNode);
      _this129 = _callSuper(this, TriplanarTexturesNode, ['vec4']);

      /**
       * First texture node.
       *
       * @type {Node}
       */
      _this129.textureXNode = textureXNode;

      /**
       * Second texture node. When not set, the shader will sample from `textureXNode` instead.
       *
       * @type {Node}
       * @default null
       */
      _this129.textureYNode = textureYNode;

      /**
       * Third texture node. When not set, the shader will sample from `textureXNode` instead.
       *
       * @type {Node}
       * @default null
       */
      _this129.textureZNode = textureZNode;

      /**
       * The scale node.
       *
       * @type {Node<float>}
       * @default float(1)
       */
      _this129.scaleNode = scaleNode;

      /**
       * Vertex positions in local space.
       *
       * @type {Node<vec3>}
       * @default positionLocal
       */
      _this129.positionNode = positionNode;

      /**
       * Normals in local space.
       *
       * @type {Node<vec3>}
       * @default normalLocal
       */
      _this129.normalNode = normalNode;
      return _this129;
    }
    (0, _inherits2.default)(TriplanarTexturesNode, _Node41);
    return (0, _createClass2.default)(TriplanarTexturesNode, [{
      key: "setup",
      value: function setup() {
        var textureXNode = this.textureXNode,
          textureYNode = this.textureYNode,
          textureZNode = this.textureZNode,
          scaleNode = this.scaleNode,
          positionNode = this.positionNode,
          normalNode = this.normalNode;

        // Ref: https://github.com/keijiro/StandardTriplanar

        // Blending factor of triplanar mapping
        var bf = normalNode.abs().normalize();
        bf = bf.div(bf.dot(vec3(1.0)));

        // Triplanar mapping
        var tx = positionNode.yz.mul(scaleNode);
        var ty = positionNode.zx.mul(scaleNode);
        var tz = positionNode.xy.mul(scaleNode);

        // Base color
        var textureX = textureXNode.value;
        var textureY = textureYNode !== null ? textureYNode.value : textureX;
        var textureZ = textureZNode !== null ? textureZNode.value : textureX;
        var cx = texture(textureX, tx).mul(bf.x);
        var cy = texture(textureY, ty).mul(bf.y);
        var cz = texture(textureZ, tz).mul(bf.z);
        return add(cx, cy, cz);
      }
    }], [{
      key: "type",
      get: function get() {
        return 'TriplanarTexturesNode';
      }
    }]);
  }(Node);
  /**
   * TSL function for creating a triplanar textures node.
   *
   * @function
   * @param {Node} textureXNode - First texture node.
   * @param {Node?} [textureYNode=null] - Second texture node. When not set, the shader will sample from `textureXNode` instead.
   * @param {Node?} [textureZNode=null] - Third texture node. When not set, the shader will sample from `textureXNode` instead.
   * @param {Node<float>?} [scaleNode=float(1)] - The scale node.
   * @param {Node<vec3>?} [positionNode=positionLocal] - Vertex positions in local space.
   * @param {Node<vec3>?} [normalNode=normalLocal] - Normals in local space.
   * @returns {TriplanarTexturesNode}
   */
  var triplanarTextures = /*@__PURE__*/nodeProxy(TriplanarTexturesNode);

  /**
   * TSL function for creating a triplanar textures node.
   *
   * @function
   * @param {Node} textureXNode - First texture node.
   * @param {Node?} [textureYNode=null] - Second texture node. When not set, the shader will sample from `textureXNode` instead.
   * @param {Node?} [textureZNode=null] - Third texture node. When not set, the shader will sample from `textureXNode` instead.
   * @param {Node<float>?} [scaleNode=float(1)] - The scale node.
   * @param {Node<vec3>?} [positionNode=positionLocal] - Vertex positions in local space.
   * @param {Node<vec3>?} [normalNode=normalLocal] - Normals in local space.
   * @returns {TriplanarTexturesNode}
   */
  var triplanarTexture = function triplanarTexture() {
    return triplanarTextures.apply(void 0, arguments);
  };

  /** @module ReflectorNode **/

  var _reflectorPlane = new (_$$_REQUIRE(_dependencyMap[1], "./three.core.js").Plane)();
  var _normal = new (_$$_REQUIRE(_dependencyMap[1], "./three.core.js").Vector3)();
  var _reflectorWorldPosition = new (_$$_REQUIRE(_dependencyMap[1], "./three.core.js").Vector3)();
  var _cameraWorldPosition = new (_$$_REQUIRE(_dependencyMap[1], "./three.core.js").Vector3)();
  var _rotationMatrix = new (_$$_REQUIRE(_dependencyMap[1], "./three.core.js").Matrix4)();
  var _lookAtPosition = new (_$$_REQUIRE(_dependencyMap[1], "./three.core.js").Vector3)(0, 0, -1);
  var clipPlane = new (_$$_REQUIRE(_dependencyMap[1], "./three.core.js").Vector4)();
  var _view = new (_$$_REQUIRE(_dependencyMap[1], "./three.core.js").Vector3)();
  var _target = new (_$$_REQUIRE(_dependencyMap[1], "./three.core.js").Vector3)();
  var _q = new (_$$_REQUIRE(_dependencyMap[1], "./three.core.js").Vector4)();
  var _size$2 = new (_$$_REQUIRE(_dependencyMap[1], "./three.core.js").Vector2)();
  var _defaultRT = new (_$$_REQUIRE(_dependencyMap[1], "./three.core.js").RenderTarget)();
  var _defaultUV = screenUV.flipX();
  _defaultRT.depthTexture = new (_$$_REQUIRE(_dependencyMap[1], "./three.core.js").DepthTexture)(1, 1);
  var _inReflector = false;

  /**
   * This node can be used to implement mirror-like flat reflective surfaces.
   *
   * ```js
   * const groundReflector = reflector();
   * material.colorNode = groundReflector;
   *
   * const plane = new Mesh( geometry, material );
   * plane.add( groundReflector.target );
   * ```
   *
   * @augments module:TextureNode~TextureNode
   */
  var ReflectorNode = exports.ReflectorNode = /*#__PURE__*/function (_TextureNode4) {
    /**
     * Constructs a new reflector node.
     *
     * @param {Object} [parameters={}] - An object holding configuration parameters.
     * @param {Object3D} [parameters.target=new Object3D()] - The 3D object the reflector is linked to.
     * @param {Number} [parameters.resolution=1] - The resolution scale.
     * @param {Boolean} [parameters.generateMipmaps=false] - Whether mipmaps should be generated or not.
     * @param {Boolean} [parameters.bounces=true] - Whether reflectors can render other reflector nodes or not.
     * @param {Boolean} [parameters.depth=false] - Whether depth data should be generated or not.
     * @param {TextureNode} [parameters.defaultTexture] - The default texture node.
     * @param {ReflectorBaseNode} [parameters.reflector] - The reflector base node.
     */
    function ReflectorNode() {
      var _this130;
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      (0, _classCallCheck2.default)(this, ReflectorNode);
      _this130 = _callSuper(this, ReflectorNode, [parameters.defaultTexture || _defaultRT.texture, _defaultUV]);

      /**
       * A reference to the internal reflector base node which holds the actual implementation.
       *
       * @private
       * @type {ReflectorBaseNode?}
       * @default null
       */
      _this130._reflectorBaseNode = parameters.reflector || new ReflectorBaseNode(_this130, parameters);

      /**
       * A reference to the internal depth node.
       *
       * @private
       * @type {Node?}
       * @default null
       */
      _this130._depthNode = null;
      _this130.setUpdateMatrix(false);
      return _this130;
    }

    /**
     * A reference to the internal reflector node.
     *
     * @type {ReflectorBaseNode}
     */
    (0, _inherits2.default)(ReflectorNode, _TextureNode4);
    return (0, _createClass2.default)(ReflectorNode, [{
      key: "reflector",
      get: function get() {
        return this._reflectorBaseNode;
      }

      /**
       * A reference to 3D object the reflector is linked to.
       *
       * @type {Object3D}
       */
    }, {
      key: "target",
      get: function get() {
        return this._reflectorBaseNode.target;
      }

      /**
       * Returns a node representing the mirror's depth. That can be used
       * to implement more advanced reflection effects like distance attenuation.
       *
       * @return {Node} The depth node.
       */
    }, {
      key: "getDepthNode",
      value: function getDepthNode() {
        if (this._depthNode === null) {
          if (this._reflectorBaseNode.depth !== true) {
            throw new Error('THREE.ReflectorNode: Depth node can only be requested when the reflector is created with { depth: true }. ');
          }
          this._depthNode = nodeObject(new ReflectorNode({
            defaultTexture: _defaultRT.depthTexture,
            reflector: this._reflectorBaseNode
          }));
        }
        return this._depthNode;
      }
    }, {
      key: "setup",
      value: function setup(builder) {
        // ignore if used in post-processing
        if (!builder.object.isQuadMesh) this._reflectorBaseNode.build(builder);
        return _superPropGet(ReflectorNode, "setup", this, 3)([builder]);
      }
    }, {
      key: "clone",
      value: function clone() {
        var texture = new this.constructor(this.reflectorNode);
        texture._reflectorBaseNode = this._reflectorBaseNode;
        return texture;
      }
    }], [{
      key: "type",
      get: function get() {
        return 'ReflectorNode';
      }
    }]);
  }(TextureNode);
  /**
   * Holds the actual implementation of the reflector.
   *
   * TODO: Explain why `ReflectorBaseNode`. Originally the entire logic was implemented
   * in `ReflectorNode`, see #29619.
   *
   * @private
   * @augments Node
   */
  var ReflectorBaseNode = /*#__PURE__*/function (_Node42) {
    /**
     * Constructs a new reflector base node.
     *
     * @param {TextureNode} textureNode - Represents the rendered reflections as a texture node.
     * @param {Object} [parameters={}] - An object holding configuration parameters.
     * @param {Object3D} [parameters.target=new Object3D()] - The 3D object the reflector is linked to.
     * @param {Number} [parameters.resolution=1] - The resolution scale.
     * @param {Boolean} [parameters.generateMipmaps=false] - Whether mipmaps should be generated or not.
     * @param {Boolean} [parameters.bounces=true] - Whether reflectors can render other reflector nodes or not.
     * @param {Boolean} [parameters.depth=false] - Whether depth data should be generated or not.
     */
    function ReflectorBaseNode(textureNode) {
      var _this131;
      var parameters = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      (0, _classCallCheck2.default)(this, ReflectorBaseNode);
      _this131 = _callSuper(this, ReflectorBaseNode);
      var _parameters$target = parameters.target,
        target = _parameters$target === void 0 ? new (_$$_REQUIRE(_dependencyMap[1], "./three.core.js").Object3D)() : _parameters$target,
        _parameters$resolutio = parameters.resolution,
        resolution = _parameters$resolutio === void 0 ? 1 : _parameters$resolutio,
        _parameters$generateM = parameters.generateMipmaps,
        generateMipmaps = _parameters$generateM === void 0 ? false : _parameters$generateM,
        _parameters$bounces = parameters.bounces,
        bounces = _parameters$bounces === void 0 ? true : _parameters$bounces,
        _parameters$depth = parameters.depth,
        depth = _parameters$depth === void 0 ? false : _parameters$depth;

      /**
       * Represents the rendered reflections as a texture node.
       *
       * @type {TextureNode}
       */
      _this131.textureNode = textureNode;

      /**
       * The 3D object the reflector is linked to.
       *
       * @type {Object3D}
       * @default {new Object3D()}
       */
      _this131.target = target;

      /**
       * The resolution scale.
       *
       * @type {Number}
       * @default {1}
       */
      _this131.resolution = resolution;

      /**
       * Whether mipmaps should be generated or not.
       *
       * @type {Boolean}
       * @default {false}
       */
      _this131.generateMipmaps = generateMipmaps;

      /**
       * Whether reflectors can render other reflector nodes or not.
       *
       * @type {Boolean}
       * @default {true}
       */
      _this131.bounces = bounces;

      /**
       * Whether depth data should be generated or not.
       *
       * @type {Boolean}
       * @default {false}
       */
      _this131.depth = depth;

      /**
       * The `updateBeforeType` is set to `NodeUpdateType.RENDER` when {@link ReflectorBaseNode#bounces}
       * is `true`. Otherwise it's `NodeUpdateType.FRAME`.
       *
       * @type {String}
       * @default 'render'
       */
      _this131.updateBeforeType = bounces ? NodeUpdateType.RENDER : NodeUpdateType.FRAME;

      /**
       * Weak map for managing virtual cameras.
       *
       * @type {WeakMap<Camera, Camera>}
       */
      _this131.virtualCameras = new WeakMap();

      /**
       * Weak map for managing render targets.
       *
       * @type {WeakMap<Camera, RenderTarget>}
       */
      _this131.renderTargets = new WeakMap();
      return _this131;
    }

    /**
     * Updates the resolution of the internal render target.
     *
     * @private
     * @param {RenderTarget} renderTarget - The render target to resize.
     * @param {Renderer} renderer - The renderer that is used to determine the new size.
     */
    (0, _inherits2.default)(ReflectorBaseNode, _Node42);
    return (0, _createClass2.default)(ReflectorBaseNode, [{
      key: "_updateResolution",
      value: function _updateResolution(renderTarget, renderer) {
        var resolution = this.resolution;
        renderer.getDrawingBufferSize(_size$2);
        renderTarget.setSize(Math.round(_size$2.width * resolution), Math.round(_size$2.height * resolution));
      }
    }, {
      key: "setup",
      value: function setup(builder) {
        this._updateResolution(_defaultRT, builder.renderer);
        return _superPropGet(ReflectorBaseNode, "setup", this, 3)([builder]);
      }

      /**
       * Returns a virtual camera for the given camera. The virtual camera is used to
       * render the scene from the reflector's view so correct reflections can be produced.
       *
       * @param {Camera} camera - The scene's camera.
       * @return {Camera} The corresponding virtual camera.
       */
    }, {
      key: "getVirtualCamera",
      value: function getVirtualCamera(camera) {
        var virtualCamera = this.virtualCameras.get(camera);
        if (virtualCamera === undefined) {
          virtualCamera = camera.clone();
          this.virtualCameras.set(camera, virtualCamera);
        }
        return virtualCamera;
      }

      /**
       * Returns a render target for the given camera. The reflections are rendered
       * into this render target.
       *
       * @param {Camera} camera - The scene's camera.
       * @return {RenderTarget} The render target.
       */
    }, {
      key: "getRenderTarget",
      value: function getRenderTarget(camera) {
        var renderTarget = this.renderTargets.get(camera);
        if (renderTarget === undefined) {
          renderTarget = new (_$$_REQUIRE(_dependencyMap[1], "./three.core.js").RenderTarget)(0, 0, {
            type: _$$_REQUIRE(_dependencyMap[1], "./three.core.js").HalfFloatType
          });
          if (this.generateMipmaps === true) {
            renderTarget.texture.minFilter = _$$_REQUIRE(_dependencyMap[1], "./three.core.js").LinearMipMapLinearFilter;
            renderTarget.texture.generateMipmaps = true;
          }
          if (this.depth === true) {
            renderTarget.depthTexture = new (_$$_REQUIRE(_dependencyMap[1], "./three.core.js").DepthTexture)();
          }
          this.renderTargets.set(camera, renderTarget);
        }
        return renderTarget;
      }
    }, {
      key: "updateBefore",
      value: function updateBefore(frame) {
        if (this.bounces === false && _inReflector) return false;
        _inReflector = true;
        var scene = frame.scene,
          camera = frame.camera,
          renderer = frame.renderer,
          material = frame.material;
        var target = this.target;
        var virtualCamera = this.getVirtualCamera(camera);
        var renderTarget = this.getRenderTarget(virtualCamera);
        renderer.getDrawingBufferSize(_size$2);
        this._updateResolution(renderTarget, renderer);

        //

        _reflectorWorldPosition.setFromMatrixPosition(target.matrixWorld);
        _cameraWorldPosition.setFromMatrixPosition(camera.matrixWorld);
        _rotationMatrix.extractRotation(target.matrixWorld);
        _normal.set(0, 0, 1);
        _normal.applyMatrix4(_rotationMatrix);
        _view.subVectors(_reflectorWorldPosition, _cameraWorldPosition);

        // Avoid rendering when reflector is facing away

        if (_view.dot(_normal) > 0) return;
        _view.reflect(_normal).negate();
        _view.add(_reflectorWorldPosition);
        _rotationMatrix.extractRotation(camera.matrixWorld);
        _lookAtPosition.set(0, 0, -1);
        _lookAtPosition.applyMatrix4(_rotationMatrix);
        _lookAtPosition.add(_cameraWorldPosition);
        _target.subVectors(_reflectorWorldPosition, _lookAtPosition);
        _target.reflect(_normal).negate();
        _target.add(_reflectorWorldPosition);

        //

        virtualCamera.coordinateSystem = camera.coordinateSystem;
        virtualCamera.position.copy(_view);
        virtualCamera.up.set(0, 1, 0);
        virtualCamera.up.applyMatrix4(_rotationMatrix);
        virtualCamera.up.reflect(_normal);
        virtualCamera.lookAt(_target);
        virtualCamera.near = camera.near;
        virtualCamera.far = camera.far;
        virtualCamera.updateMatrixWorld();
        virtualCamera.projectionMatrix.copy(camera.projectionMatrix);

        // Now update projection matrix with new clip plane, implementing code from: http://www.terathon.com/code/oblique.html
        // Paper explaining this technique: http://www.terathon.com/lengyel/Lengyel-Oblique.pdf
        _reflectorPlane.setFromNormalAndCoplanarPoint(_normal, _reflectorWorldPosition);
        _reflectorPlane.applyMatrix4(virtualCamera.matrixWorldInverse);
        clipPlane.set(_reflectorPlane.normal.x, _reflectorPlane.normal.y, _reflectorPlane.normal.z, _reflectorPlane.constant);
        var projectionMatrix = virtualCamera.projectionMatrix;
        _q.x = (Math.sign(clipPlane.x) + projectionMatrix.elements[8]) / projectionMatrix.elements[0];
        _q.y = (Math.sign(clipPlane.y) + projectionMatrix.elements[9]) / projectionMatrix.elements[5];
        _q.z = -1.0;
        _q.w = (1.0 + projectionMatrix.elements[10]) / projectionMatrix.elements[14];

        // Calculate the scaled plane vector
        clipPlane.multiplyScalar(1.0 / clipPlane.dot(_q));
        var clipBias = 0;

        // Replacing the third row of the projection matrix
        projectionMatrix.elements[2] = clipPlane.x;
        projectionMatrix.elements[6] = clipPlane.y;
        projectionMatrix.elements[10] = renderer.coordinateSystem === _$$_REQUIRE(_dependencyMap[1], "./three.core.js").WebGPUCoordinateSystem ? clipPlane.z - clipBias : clipPlane.z + 1.0 - clipBias;
        projectionMatrix.elements[14] = clipPlane.w;

        //

        this.textureNode.value = renderTarget.texture;
        if (this.depth === true) {
          this.textureNode.getDepthNode().value = renderTarget.depthTexture;
        }
        material.visible = false;
        var currentRenderTarget = renderer.getRenderTarget();
        var currentMRT = renderer.getMRT();
        var currentAutoClear = renderer.autoClear;
        renderer.setMRT(null);
        renderer.setRenderTarget(renderTarget);
        renderer.autoClear = true;
        renderer.render(scene, virtualCamera);
        renderer.setMRT(currentMRT);
        renderer.setRenderTarget(currentRenderTarget);
        renderer.autoClear = currentAutoClear;
        material.visible = true;
        _inReflector = false;
      }
    }], [{
      key: "type",
      get: function get() {
        return 'ReflectorBaseNode';
      }
    }]);
  }(Node);
  /**
   * TSL function for creating a reflector node.
   *
   * @function
   * @param {Object} [parameters={}] - An object holding configuration parameters.
   * @param {Object3D} [parameters.target=new Object3D()] - The 3D object the reflector is linked to.
   * @param {Number} [parameters.resolution=1] - The resolution scale.
   * @param {Boolean} [parameters.generateMipmaps=false] - Whether mipmaps should be generated or not.
   * @param {Boolean} [parameters.bounces=true] - Whether reflectors can render other reflector nodes or not.
   * @param {Boolean} [parameters.depth=false] - Whether depth data should be generated or not.
   * @param {TextureNode} [parameters.defaultTexture] - The default texture node.
   * @param {ReflectorBaseNode} [parameters.reflector] - The reflector base node.
   * @returns {ReflectorNode}
   */
  var reflector = function reflector(parameters) {
    return nodeObject(new ReflectorNode(parameters));
  };
  var _camera = /*@__PURE__*/new (_$$_REQUIRE(_dependencyMap[1], "./three.core.js").OrthographicCamera)(-1, 1, 1, -1, 0, 1);

  /**
   * The purpose of this special geometry is to fill the entire viewport with a single triangle.
   *
   * Reference: {@link https://github.com/mrdoob/three.js/pull/21358}
   *
   * @private
   * @augments BufferGeometry
   */
  var QuadGeometry = /*#__PURE__*/function (_BufferGeometry) {
    /**
     * Constructs a new quad geometry.
     *
     * @param {Boolean} [flipY=false] - Whether the uv coordinates should be flipped along the vertical axis or not.
     */
    function QuadGeometry() {
      var _this132;
      var flipY = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      (0, _classCallCheck2.default)(this, QuadGeometry);
      _this132 = _callSuper(this, QuadGeometry);
      var uv = flipY === false ? [0, -1, 0, 1, 2, 1] : [0, 2, 0, 0, 2, 0];
      _this132.setAttribute('position', new (_$$_REQUIRE(_dependencyMap[1], "./three.core.js").Float32BufferAttribute)([-1, 3, 0, -1, -1, 0, 3, -1, 0], 3));
      _this132.setAttribute('uv', new (_$$_REQUIRE(_dependencyMap[1], "./three.core.js").Float32BufferAttribute)(uv, 2));
      return _this132;
    }
    (0, _inherits2.default)(QuadGeometry, _BufferGeometry);
    return (0, _createClass2.default)(QuadGeometry);
  }(_$$_REQUIRE(_dependencyMap[1], "./three.core.js").BufferGeometry);
  var _geometry = /*@__PURE__*/new QuadGeometry();

  /**
   * This module is a helper for passes which need to render a full
   * screen effect which is quite common in context of post processing.
   *
   * The intended usage is to reuse a single quad mesh for rendering
   * subsequent passes by just reassigning the `material` reference.
   *
   * @augments BufferGeometry
   */
  var QuadMesh = exports.QuadMesh = /*#__PURE__*/function (_Mesh) {
    /**
     * Constructs a new quad mesh.
     *
     * @param {Material?} [material=null] - The material to render the quad mesh with.
     */
    function QuadMesh() {
      var _this133;
      var material = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      (0, _classCallCheck2.default)(this, QuadMesh);
      _this133 = _callSuper(this, QuadMesh, [_geometry, material]);

      /**
       * The camera to render the quad mesh with.
       *
       * @type {OrthographicCamera}
       * @readonly
       */
      _this133.camera = _camera;

      /**
       * This flag can be used for type testing.
       *
       * @type {Boolean}
       * @readonly
       * @default true
       */
      _this133.isQuadMesh = true;
      return _this133;
    }

    /**
     * Async version of `render()`.
     *
     * @async
     * @param {Renderer} renderer - The renderer.
     * @return {Promise} A Promise that resolves when the render has been finished.
     */
    (0, _inherits2.default)(QuadMesh, _Mesh);
    return (0, _createClass2.default)(QuadMesh, [{
      key: "renderAsync",
      value: (function () {
        var _renderAsync = (0, _asyncToGenerator2.default)(function* (renderer) {
          return renderer.renderAsync(this, _camera);
        });
        function renderAsync(_x) {
          return _renderAsync.apply(this, arguments);
        }
        return renderAsync;
      }()
      /**
       * Renders the quad mesh
       *
       * @param {Renderer} renderer - The renderer.
       */
      )
    }, {
      key: "render",
      value: function render(renderer) {
        renderer.render(this, _camera);
      }
    }]);
  }(_$$_REQUIRE(_dependencyMap[1], "./three.core.js").Mesh);
  /** @module RTTNode **/
  var _size$1 = /*@__PURE__*/new (_$$_REQUIRE(_dependencyMap[1], "./three.core.js").Vector2)();

  /**
   * `RTTNode` takes another node and uses it with a `QuadMesh` to render into a texture (RTT).
   * This module is especially relevant in context of post processing where certain nodes require
   * texture input for their effects. With the helper function `convertToTexture()` which is based
   * on this module, the node system can automatically ensure texture input if required.
   *
   * @augments module:TextureNode~TextureNode
   */
  var RTTNode = exports.RTTNode = /*#__PURE__*/function (_TextureNode5) {
    /**
     * Constructs a new RTT node.
     *
     * @param {Node} node - The node to render a texture with.
     * @param {Number?} [width=null] - The width of the internal render target. If not width is applied, the render target is automatically resized.
     * @param {Number?} [height=null] - The height of the internal render target.
     * @param {Object} [options={type:HalfFloatType}] - The options for the internal render target.
     */
    function RTTNode(node) {
      var _this134;
      var width = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      var height = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
      var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {
        type: _$$_REQUIRE(_dependencyMap[1], "./three.core.js").HalfFloatType
      };
      (0, _classCallCheck2.default)(this, RTTNode);
      var renderTarget = new (_$$_REQUIRE(_dependencyMap[1], "./three.core.js").RenderTarget)(width, height, options);
      _this134 = _callSuper(this, RTTNode, [renderTarget.texture, uv()]);

      /**
       * The node to render a texture with.
       *
       * @type {Node}
       */
      _this134.node = node;

      /**
       * The width of the internal render target.
       * If not width is applied, the render target is automatically resized.
       *
       * @type {Number?}
       * @default null
       */
      _this134.width = width;

      /**
       * The height of the internal render target.
       *
       * @type {Number?}
       * @default null
       */
      _this134.height = height;

      /**
       * The pixel ratio
       *
       * @type {Number}
       * @default 1
       */
      _this134.pixelRatio = 1;

      /**
       * The render target
       *
       * @type {RenderTarget}
       */
      _this134.renderTarget = renderTarget;

      /**
       * Whether the texture requires an update or not.
       *
       * @type {Boolean}
       * @default true
       */
      _this134.textureNeedsUpdate = true;

      /**
       * Whether the texture should automatically be updated or not.
       *
       * @type {Boolean}
       * @default true
       */
      _this134.autoUpdate = true;

      /**
       * The node which is used with the quad mesh for RTT.
       *
       * @private
       * @type {Node}
       * @default null
       */
      _this134._rttNode = null;

      /**
       * The internal quad mesh for RTT.
       *
       * @private
       * @type {QuadMesh}
       */
      _this134._quadMesh = new QuadMesh(new NodeMaterial());

      /**
       * The `updateBeforeType` is set to `NodeUpdateType.RENDER` since the node updates
       * the texture once per render in its {@link RTTNode#updateBefore} method.
       *
       * @type {String}
       * @default 'render'
       */
      _this134.updateBeforeType = NodeUpdateType.RENDER;
      return _this134;
    }

    /**
     * Whether the internal render target should automatically be resized or not.
     *
     * @type {Boolean}
     * @readonly
     * @default true
     */
    (0, _inherits2.default)(RTTNode, _TextureNode5);
    return (0, _createClass2.default)(RTTNode, [{
      key: "autoSize",
      get: function get() {
        return this.width === null;
      }
    }, {
      key: "setup",
      value: function setup(builder) {
        this._rttNode = this.node.context(builder.getSharedContext());
        this._quadMesh.material.name = 'RTT';
        this._quadMesh.material.needsUpdate = true;
        return _superPropGet(RTTNode, "setup", this, 3)([builder]);
      }

      /**
       * Sets the size of the internal render target
       *
       * @param {Number} width - The width to set.
       * @param {Number} height - The width to set.
       */
    }, {
      key: "setSize",
      value: function setSize(width, height) {
        this.width = width;
        this.height = height;
        var effectiveWidth = width * this.pixelRatio;
        var effectiveHeight = height * this.pixelRatio;
        this.renderTarget.setSize(effectiveWidth, effectiveHeight);
        this.textureNeedsUpdate = true;
      }

      /**
       * Sets the pixel ratio. This will also resize the render target.
       *
       * @param {Number} pixelRatio - The pixel ratio to set.
       */
    }, {
      key: "setPixelRatio",
      value: function setPixelRatio(pixelRatio) {
        this.pixelRatio = pixelRatio;
        this.setSize(this.width, this.height);
      }
    }, {
      key: "updateBefore",
      value: function updateBefore(_ref133) {
        var renderer = _ref133.renderer;
        if (this.textureNeedsUpdate === false && this.autoUpdate === false) return;
        this.textureNeedsUpdate = false;

        //

        if (this.autoSize === true) {
          this.pixelRatio = renderer.getPixelRatio();
          var size = renderer.getSize(_size$1);
          this.setSize(size.width, size.height);
        }

        //

        this._quadMesh.material.fragmentNode = this._rttNode;

        //

        var currentRenderTarget = renderer.getRenderTarget();
        renderer.setRenderTarget(this.renderTarget);
        this._quadMesh.render(renderer);
        renderer.setRenderTarget(currentRenderTarget);
      }
    }, {
      key: "clone",
      value: function clone() {
        var newNode = new TextureNode(this.value, this.uvNode, this.levelNode);
        newNode.sampler = this.sampler;
        newNode.referenceNode = this;
        return newNode;
      }
    }], [{
      key: "type",
      get: function get() {
        return 'RTTNode';
      }
    }]);
  }(TextureNode);
  /**
   * TSL function for creating a RTT node.
   *
   * @function
   * @param {Node} node - The node to render a texture with.
   * @param {Number?} [width=null] - The width of the internal render target. If not width is applied, the render target is automatically resized.
   * @param {Number?} [height=null] - The height of the internal render target.
   * @param {Object} [options={type:HalfFloatType}] - The options for the internal render target.
   * @returns {RTTNode}
   */
  var rtt = function rtt(node) {
    for (var _len21 = arguments.length, params = new Array(_len21 > 1 ? _len21 - 1 : 0), _key21 = 1; _key21 < _len21; _key21++) {
      params[_key21 - 1] = arguments[_key21];
    }
    return nodeObject((0, _construct2.default)(RTTNode, [nodeObject(node)].concat(params)));
  };

  /**
   * TSL function for converting nodes to textures nodes.
   *
   * @function
   * @param {Node} node - The node to render a texture with.
   * @param {Number?} [width=null] - The width of the internal render target. If not width is applied, the render target is automatically resized.
   * @param {Number?} [height=null] - The height of the internal render target.
   * @param {Object} [options={type:HalfFloatType}] - The options for the internal render target.
   * @returns {RTTNode}
   */
  var convertToTexture = function convertToTexture(node) {
    if (node.isTextureNode) return node;
    if (node.isPassNode) return node.getTextureNode();
    for (var _len22 = arguments.length, params = new Array(_len22 > 1 ? _len22 - 1 : 0), _key22 = 1; _key22 < _len22; _key22++) {
      params[_key22 - 1] = arguments[_key22];
    }
    return rtt.apply(void 0, [node].concat(params));
  };

  /** @module PostProcessingUtils **/

  /**
   * Computes a position in view space based on a fragment's screen position expressed as uv coordinates, the fragments
   * depth value and the camera's inverse projection matrix.
   *
   * @method
   * @param {Node<vec2>} screenPosition - The fragment's screen position expressed as uv coordinates.
   * @param {Node<float>} depth - The fragment's depth value.
   * @param {Node<mat4>} projectionMatrixInverse - The camera's inverse projection matrix.
   * @return {Node<vec3>} The fragments position in view space.
   */
  var getViewPosition = /*@__PURE__*/Fn(function (_ref134, builder) {
    var _ref135 = (0, _slicedToArray2.default)(_ref134, 3),
      screenPosition = _ref135[0],
      depth = _ref135[1],
      projectionMatrixInverse = _ref135[2];
    var clipSpacePosition;
    if (builder.renderer.coordinateSystem === _$$_REQUIRE(_dependencyMap[1], "./three.core.js").WebGPUCoordinateSystem) {
      screenPosition = vec2(screenPosition.x, screenPosition.y.oneMinus()).mul(2.0).sub(1.0);
      clipSpacePosition = vec4(vec3(screenPosition, depth), 1.0);
    } else {
      clipSpacePosition = vec4(vec3(screenPosition.x, screenPosition.y.oneMinus(), depth).mul(2.0).sub(1.0), 1.0);
    }
    var viewSpacePosition = vec4(projectionMatrixInverse.mul(clipSpacePosition));
    return viewSpacePosition.xyz.div(viewSpacePosition.w);
  });

  /**
   * Computes a screen position expressed as uv coordinates based on a fragment's position in view space
   * and the camera's projection matrix
   *
   * @method
   * @param {Node<vec3>} viewPosition - The fragments position in view space.
   * @param {Node<mat4>} projectionMatrix - The camera's projection matrix.
   * @return {Node<vec2>} The fragment's screen position expressed as uv coordinates.
   */
  var getScreenPosition = /*@__PURE__*/Fn(function (_ref136) {
    var _ref137 = (0, _slicedToArray2.default)(_ref136, 2),
      viewPosition = _ref137[0],
      projectionMatrix = _ref137[1];
    var sampleClipPos = projectionMatrix.mul(vec4(viewPosition, 1.0));
    var sampleUv = sampleClipPos.xy.div(sampleClipPos.w).mul(0.5).add(0.5).toVar();
    return vec2(sampleUv.x, sampleUv.y.oneMinus());
  });

  /**
   * Computes a normal vector based on depth data. Can be used as a fallback when no normal render
   * target is available or if flat surface normals are required.
   *
   * @method
   * @param {Node<vec2>} uv - The texture coordinate.
   * @param {DepthTexture} depthTexture - The depth texture.
   * @param {Node<mat4>} projectionMatrixInverse - The camera's inverse projection matrix.
   * @return {Node<vec3>} The computed normal vector.
   */
  var getNormalFromDepth = /*@__PURE__*/Fn(function (_ref138) {
    var _ref139 = (0, _slicedToArray2.default)(_ref138, 3),
      uv = _ref139[0],
      depthTexture = _ref139[1],
      projectionMatrixInverse = _ref139[2];
    var size = textureSize(textureLoad(depthTexture));
    var p = ivec2(uv.mul(size)).toVar();
    var c0 = textureLoad(depthTexture, p).toVar();
    var l2 = textureLoad(depthTexture, p.sub(ivec2(2, 0))).toVar();
    var l1 = textureLoad(depthTexture, p.sub(ivec2(1, 0))).toVar();
    var r1 = textureLoad(depthTexture, p.add(ivec2(1, 0))).toVar();
    var r2 = textureLoad(depthTexture, p.add(ivec2(2, 0))).toVar();
    var b2 = textureLoad(depthTexture, p.add(ivec2(0, 2))).toVar();
    var b1 = textureLoad(depthTexture, p.add(ivec2(0, 1))).toVar();
    var t1 = textureLoad(depthTexture, p.sub(ivec2(0, 1))).toVar();
    var t2 = textureLoad(depthTexture, p.sub(ivec2(0, 2))).toVar();
    var dl = abs(sub(float(2).mul(l1).sub(l2), c0)).toVar();
    var dr = abs(sub(float(2).mul(r1).sub(r2), c0)).toVar();
    var db = abs(sub(float(2).mul(b1).sub(b2), c0)).toVar();
    var dt = abs(sub(float(2).mul(t1).sub(t2), c0)).toVar();
    var ce = getViewPosition(uv, c0, projectionMatrixInverse).toVar();
    var dpdx = dl.lessThan(dr).select(ce.sub(getViewPosition(uv.sub(vec2(float(1).div(size.x), 0)), l1, projectionMatrixInverse)), ce.negate().add(getViewPosition(uv.add(vec2(float(1).div(size.x), 0)), r1, projectionMatrixInverse)));
    var dpdy = db.lessThan(dt).select(ce.sub(getViewPosition(uv.add(vec2(0, float(1).div(size.y))), b1, projectionMatrixInverse)), ce.negate().add(getViewPosition(uv.sub(vec2(0, float(1).div(size.y))), t1, projectionMatrixInverse)));
    return normalize(cross(dpdx, dpdy));
  });

  /**
   * This special type of instanced buffer attribute is intended for compute shaders.
   * In earlier three.js versions it was only possible to update attribute data
   * on the CPU via JavaScript and then upload the data to the GPU. With the
   * new material system and renderer it is now possible to use compute shaders
   * to compute the data for an attribute more efficiently on the GPU.
   *
   * The idea is to create an instance of this class and provide it as an input
   * to {@link module:StorageBufferNode}.
   *
   * Note: This type of buffer attribute can only be used with `WebGPURenderer`.
   *
   * @augments InstancedBufferAttribute
   */
  var StorageInstancedBufferAttribute = exports.StorageInstancedBufferAttribute = /*#__PURE__*/function (_InstancedBufferAttri) {
    /**
     * Constructs a new storage instanced buffer attribute.
     *
     * @param {Number|TypedArray} count - The item count. It is also valid to pass a typed array as an argument.
     * The subsequent parameters are then obsolete.
     * @param {Number} itemSize - The item size.
     * @param {TypedArray.contructor} [typeClass=Float32Array] - A typed array constructor.
     */
    function StorageInstancedBufferAttribute(count, itemSize) {
      var _this135;
      var typeClass = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : Float32Array;
      (0, _classCallCheck2.default)(this, StorageInstancedBufferAttribute);
      var array = ArrayBuffer.isView(count) ? count : new typeClass(count * itemSize);
      _this135 = _callSuper(this, StorageInstancedBufferAttribute, [array, itemSize]);

      /**
       * This flag can be used for type testing.
       *
       * @type {Boolean}
       * @readonly
       * @default true
       */
      _this135.isStorageInstancedBufferAttribute = true;
      return _this135;
    }
    (0, _inherits2.default)(StorageInstancedBufferAttribute, _InstancedBufferAttri);
    return (0, _createClass2.default)(StorageInstancedBufferAttribute);
  }(_$$_REQUIRE(_dependencyMap[1], "./three.core.js").InstancedBufferAttribute);
  /**
   * This special type of buffer attribute is intended for compute shaders.
   * In earlier three.js versions it was only possible to update attribute data
   * on the CPU via JavaScript and then upload the data to the GPU. With the
   * new material system and renderer it is now possible to use compute shaders
   * to compute the data for an attribute more efficiently on the GPU.
   *
   * The idea is to create an instance of this class and provide it as an input
   * to {@link module:StorageBufferNode}.
   *
   * Note: This type of buffer attribute can only be used with `WebGPURenderer`.
   *
   * @augments BufferAttribute
   */
  var StorageBufferAttribute = exports.StorageBufferAttribute = /*#__PURE__*/function (_BufferAttribute) {
    /**
     * Constructs a new storage buffer attribute.
     *
     * @param {Number|TypedArray} count - The item count. It is also valid to pass a typed array as an argument.
     * The subsequent parameters are then obsolete.
     * @param {Number} itemSize - The item size.
     * @param {TypedArray.contructor} [typeClass=Float32Array] - A typed array constructor.
     */
    function StorageBufferAttribute(count, itemSize) {
      var _this136;
      var typeClass = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : Float32Array;
      (0, _classCallCheck2.default)(this, StorageBufferAttribute);
      var array = ArrayBuffer.isView(count) ? count : new typeClass(count * itemSize);
      _this136 = _callSuper(this, StorageBufferAttribute, [array, itemSize]);

      /**
       * This flag can be used for type testing.
       *
       * @type {Boolean}
       * @readonly
       * @default true
       */
      _this136.isStorageBufferAttribute = true;
      return _this136;
    }
    (0, _inherits2.default)(StorageBufferAttribute, _BufferAttribute);
    return (0, _createClass2.default)(StorageBufferAttribute);
  }(_$$_REQUIRE(_dependencyMap[1], "./three.core.js").BufferAttribute);
  /** @module StorageArrayElementNode **/
  /**
   * This class enables element access on instances of {@link StorageBufferNode}.
   * In most cases, it is indirectly used when accessing elements with the
   * {@link StorageBufferNode#element} method.
   *
   * ```js
   * const position = positionStorage.element( instanceIndex );
   * ```
   *
   * @augments ArrayElementNode
   */
  var StorageArrayElementNode = exports.StorageArrayElementNode = /*#__PURE__*/function (_ArrayElementNode4) {
    /**
     * Constructs storage buffer element node.
     *
     * @param {StorageBufferNode} storageBufferNode - The storage buffer node.
     * @param {Node} indexNode - The index node that defines the element access.
     */
    function StorageArrayElementNode(storageBufferNode, indexNode) {
      var _this137;
      (0, _classCallCheck2.default)(this, StorageArrayElementNode);
      _this137 = _callSuper(this, StorageArrayElementNode, [storageBufferNode, indexNode]);

      /**
       * This flag can be used for type testing.
       *
       * @type {Boolean}
       * @readonly
       * @default true
       */
      _this137.isStorageArrayElementNode = true;
      return _this137;
    }

    /**
     * The storage buffer node.
     *
     * @param {Node} value
     * @type {StorageBufferNode}
     */
    (0, _inherits2.default)(StorageArrayElementNode, _ArrayElementNode4);
    return (0, _createClass2.default)(StorageArrayElementNode, [{
      key: "storageBufferNode",
      get: function get() {
        return this.node;
      },
      set: function set(value) {
        this.node = value;
      }
    }, {
      key: "setup",
      value: function setup(builder) {
        if (builder.isAvailable('storageBuffer') === false) {
          if (this.node.isPBO === true) {
            builder.setupPBO(this.node);
          }
        }
        return _superPropGet(StorageArrayElementNode, "setup", this, 3)([builder]);
      }
    }, {
      key: "generate",
      value: function generate(builder, output) {
        var snippet;
        var isAssignContext = builder.context.assign;

        //

        if (builder.isAvailable('storageBuffer') === false) {
          if (this.node.isPBO === true && isAssignContext !== true && (this.node.value.isInstancedBufferAttribute || builder.shaderStage !== 'compute')) {
            snippet = builder.generatePBO(this);
          } else {
            snippet = this.node.build(builder);
          }
        } else {
          snippet = _superPropGet(StorageArrayElementNode, "generate", this, 3)([builder]);
        }
        if (isAssignContext !== true) {
          var type = this.getNodeType(builder);
          snippet = builder.format(snippet, type, output);
        }
        return snippet;
      }
    }], [{
      key: "type",
      get: function get() {
        return 'StorageArrayElementNode';
      }
    }]);
  }(ArrayElementNode);
  /**
   * TSL function for creating a storage element node.
   *
   * @function
   * @param {StorageBufferNode} storageBufferNode - The storage buffer node.
   * @param {Node} indexNode - The index node that defines the element access.
   * @returns {StorageArrayElementNode}
   */
  var storageElement = /*@__PURE__*/nodeProxy(StorageArrayElementNode);

  /** @module StorageBufferNode **/

  /**
   * This node is used in context of compute shaders and allows to define a
   * storage buffer for data. A typical workflow is to create instances of
   * this node with the convenience functions `attributeArray()` or `instancedArray()`,
   * setup up a compute shader that writes into the buffers and then convert
   * the storage buffers to attribute nodes for rendering.
   *
   * ```js
   * const positionBuffer = instancedArray( particleCount, 'vec3' ); // the storage buffer node
   *
   * const computeInit = Fn( () => { // the compute shader
   *
   * 	const position = positionBuffer.element( instanceIndex );
   *
   * 	// compute position data
   *
   * 	position.x = 1;
   * 	position.y = 1;
   * 	position.z = 1;
   *
   * } )().compute( particleCount );
   *
   * const particleMaterial = new THREE.SpriteNodeMaterial();
   * particleMaterial.positionNode = positionBuffer.toAttribute();
   *
   * renderer.computeAsync( computeInit );
   *
   * ```
   *
   * @augments BufferNode
   */
  var StorageBufferNode = exports.StorageBufferNode = /*#__PURE__*/function (_BufferNode2) {
    /**
     * Constructs a new storage buffer node.
     *
     * @param {StorageBufferAttribute|StorageInstancedBufferAttribute|BufferAttribute} value - The buffer data.
     * @param {String?} [bufferType=null] - The buffer type (e.g. `'vec3'`).
     * @param {Number} [bufferCount=0] - The buffer count.
     */
    function StorageBufferNode(value) {
      var _this138;
      var bufferType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      var bufferCount = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      (0, _classCallCheck2.default)(this, StorageBufferNode);
      if (bufferType === null && (value.isStorageBufferAttribute || value.isStorageInstancedBufferAttribute)) {
        bufferType = _getTypeFromLength(value.itemSize);
        bufferCount = value.count;
      }
      _this138 = _callSuper(this, StorageBufferNode, [value, bufferType, bufferCount]);

      /**
       * This flag can be used for type testing.
       *
       * @type {Boolean}
       * @readonly
       * @default true
       */
      _this138.isStorageBufferNode = true;

      /**
       * The access type of the texture node.
       *
       * @type {String}
       * @default 'readWrite'
       */
      _this138.access = NodeAccess.READ_WRITE;

      /**
       * Whether the node is atomic or not.
       *
       * @type {Boolean}
       * @default false
       */
      _this138.isAtomic = false;

      /**
       * Whether the node represents a PBO or not.
       * Only relevant for WebGL.
       *
       * @type {Boolean}
       * @default false
       */
      _this138.isPBO = false;

      /**
       * A reference to the internal buffer attribute node.
       *
       * @type {BufferAttributeNode?}
       * @default null
       */
      _this138._attribute = null;

      /**
       * A reference to the internal varying node.
       *
       * @type {VaryingNode?}
       * @default null
       */
      _this138._varying = null;

      /**
       * `StorageBufferNode` sets this property to `true` by default.
       *
       * @type {Boolean}
       * @default true
       */
      _this138.global = true;
      if (value.isStorageBufferAttribute !== true && value.isStorageInstancedBufferAttribute !== true) {
        // TODO: Improve it, possibly adding a new property to the BufferAttribute to identify it as a storage buffer read-only attribute in Renderer

        if (value.isInstancedBufferAttribute) value.isStorageInstancedBufferAttribute = true;else value.isStorageBufferAttribute = true;
      }
      return _this138;
    }

    /**
     * This method is overwritten since the buffer data might be shared
     * and thus the hash should be shared as well.
     *
     * @param {NodeBuilder} builder - The current node builder.
     * @return {String} The hash.
     */
    (0, _inherits2.default)(StorageBufferNode, _BufferNode2);
    return (0, _createClass2.default)(StorageBufferNode, [{
      key: "getHash",
      value: function getHash(builder) {
        if (this.bufferCount === 0) {
          var bufferData = builder.globalCache.getData(this.value);
          if (bufferData === undefined) {
            bufferData = {
              node: this
            };
            builder.globalCache.setData(this.value, bufferData);
          }
          return bufferData.node.uuid;
        }
        return this.uuid;
      }

      /**
       * Overwrites the default implementation to return a fixed value `'indirectStorageBuffer'` or `'storageBuffer'`.
       *
       * @param {NodeBuilder} builder - The current node builder.
       * @return {String} The input type.
       */
    }, {
      key: "getInputType",
      value: function getInputType(/*builder*/
      ) {
        return this.value.isIndirectStorageBufferAttribute ? 'indirectStorageBuffer' : 'storageBuffer';
      }

      /**
       * Enables element access with the given index node.
       *
       * @param {IndexNode} indexNode - The index node.
       * @return {StorageArrayElementNode} A node representing the element access.
       */
    }, {
      key: "element",
      value: function element(indexNode) {
        return storageElement(this, indexNode);
      }

      /**
       * Defines whether this node is a PBO or not. Only relevant for WebGL.
       *
       * @param {Boolean} value - The value so set.
       * @return {StorageBufferNode} A reference to this node.
       */
    }, {
      key: "setPBO",
      value: function setPBO(value) {
        this.isPBO = value;
        return this;
      }

      /**
       * Returns the `isPBO` value.
       *
       * @return {Boolean} Whether the node represents a PBO or not.
       */
    }, {
      key: "getPBO",
      value: function getPBO() {
        return this.isPBO;
      }

      /**
       * Defines the node access.
       *
       * @param {String} value - The node access.
       * @return {StorageBufferNode} A reference to this node.
       */
    }, {
      key: "setAccess",
      value: function setAccess(value) {
        this.access = value;
        return this;
      }

      /**
       * Convenience method for configuring a read-only node access.
       *
       * @return {StorageBufferNode} A reference to this node.
       */
    }, {
      key: "toReadOnly",
      value: function toReadOnly() {
        return this.setAccess(NodeAccess.READ_ONLY);
      }

      /**
       * Defines whether the node is atomic or not.
       *
       * @param {Boolean} value - The atomic flag.
       * @return {StorageBufferNode} A reference to this node.
       */
    }, {
      key: "setAtomic",
      value: function setAtomic(value) {
        this.isAtomic = value;
        return this;
      }

      /**
       * Convenience method for making this node atomic.
       *
       * @return {StorageBufferNode} A reference to this node.
       */
    }, {
      key: "toAtomic",
      value: function toAtomic() {
        return this.setAtomic(true);
      }

      /**
       * Returns attribute data for this storage buffer node.
       *
       * @return {{attribute: BufferAttributeNode, varying: VaryingNode}} The attribute data.
       */
    }, {
      key: "getAttributeData",
      value: function getAttributeData() {
        if (this._attribute === null) {
          this._attribute = bufferAttribute(this.value);
          this._varying = varying(this._attribute);
        }
        return {
          attribute: this._attribute,
          varying: this._varying
        };
      }

      /**
       * This method is overwritten since the node type from the availability of storage buffers
       * and the attribute data.
       *
       * @param {NodeBuilder} builder - The current node builder.
       * @return {String} The node type.
       */
    }, {
      key: "getNodeType",
      value: function getNodeType(builder) {
        if (builder.isAvailable('storageBuffer') || builder.isAvailable('indirectStorageBuffer')) {
          return _superPropGet(StorageBufferNode, "getNodeType", this, 3)([builder]);
        }
        var _this$getAttributeDat = this.getAttributeData(),
          attribute = _this$getAttributeDat.attribute;
        return attribute.getNodeType(builder);
      }

      /**
       * Generates the code snippet of the storage buffer node.
       *
       * @param {NodeBuilder} builder - The current node builder.
       * @return {String} The generated code snippet.
       */
    }, {
      key: "generate",
      value: function generate(builder) {
        if (builder.isAvailable('storageBuffer') || builder.isAvailable('indirectStorageBuffer')) {
          return _superPropGet(StorageBufferNode, "generate", this, 3)([builder]);
        }
        var _this$getAttributeDat2 = this.getAttributeData(),
          attribute = _this$getAttributeDat2.attribute,
          varying = _this$getAttributeDat2.varying;
        var output = varying.build(builder);
        builder.registerTransform(output, attribute);
        return output;
      }
    }], [{
      key: "type",
      get: function get() {
        return 'StorageBufferNode';
      }
    }]);
  }(BufferNode);
  /**
   * TSL function for creating a storage buffer node.
   *
   * @function
   * @param {StorageBufferAttribute|StorageInstancedBufferAttribute|BufferAttribute} value - The buffer data.
   * @param {String?} [type=null] - The buffer type (e.g. `'vec3'`).
   * @param {Number} [count=0] - The buffer count.
   * @returns {StorageBufferNode}
   */
  var storage = function storage(value) {
    var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    var count = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
    return nodeObject(new StorageBufferNode(value, type, count));
  };
  var storageObject = function storageObject(value, type, count) {
    // @deprecated, r171

    console.warn('THREE.TSL: "storageObject()" is deprecated. Use "storage().setPBO( true )" instead.');
    return storage(value, type, count).setPBO(true);
  };

  /** @module Arrays **/

  /**
   * TSL function for creating a storage buffer node with a configured `StorageBufferAttribute`.
   *
   * @function
   * @param {Number} count - The data count.
   * @param {String} [type='float'] - The data type.
   * @returns {StorageBufferNode}
   */
  var attributeArray = function attributeArray(count) {
    var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'float';
    var itemSize = getLengthFromType(type);
    var typedArray = getTypedArrayFromType(type);
    var buffer = new StorageBufferAttribute(count, itemSize, typedArray);
    var node = storage(buffer, type, count);
    return node;
  };

  /**
   * TSL function for creating a storage buffer node with a configured `StorageInstancedBufferAttribute`.
   *
   * @function
   * @param {Number} count - The data count.
   * @param {String} [type='float'] - The data type.
   * @returns {StorageBufferNode}
   */
  var instancedArray = function instancedArray(count) {
    var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'float';
    var itemSize = getLengthFromType(type);
    var typedArray = getTypedArrayFromType(type);
    var buffer = new StorageInstancedBufferAttribute(count, itemSize, typedArray);
    var node = storage(buffer, type, count);
    return node;
  };

  /** @module VertexColorNode **/

  /**
   * An attribute node for representing vertex colors.
   *
   * @augments module:AttributeNode~AttributeNode
   */
  var VertexColorNode = exports.VertexColorNode = /*#__PURE__*/function (_AttributeNode) {
    /**
     * Constructs a new vertex color node.
     *
     * @param {Number} [index=0] - The attribute index.
     */
    function VertexColorNode() {
      var _this139;
      var index = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      (0, _classCallCheck2.default)(this, VertexColorNode);
      _this139 = _callSuper(this, VertexColorNode, [null, 'vec4']);

      /**
       * This flag can be used for type testing.
       *
       * @type {Boolean}
       * @readonly
       * @default true
       */
      _this139.isVertexColorNode = true;

      /**
       * The attribute index to enable more than one sets of vertex colors.
       *
       * @type {Number}
       * @default 0
       */
      _this139.index = index;
      return _this139;
    }

    /**
     * Overwrites the default implementation by honoring the attribute index.
     *
     * @param {NodeBuilder} builder - The current node builder.
     * @return {String} The attribute name.
     */
    (0, _inherits2.default)(VertexColorNode, _AttributeNode);
    return (0, _createClass2.default)(VertexColorNode, [{
      key: "getAttributeName",
      value: function getAttributeName(/*builder*/
      ) {
        var index = this.index;
        return 'color' + (index > 0 ? index : '');
      }
    }, {
      key: "generate",
      value: function generate(builder) {
        var attributeName = this.getAttributeName(builder);
        var geometryAttribute = builder.hasGeometryAttribute(attributeName);
        var result;
        if (geometryAttribute === true) {
          result = _superPropGet(VertexColorNode, "generate", this, 3)([builder]);
        } else {
          // Vertex color fallback should be white
          result = builder.generateConst(this.nodeType, new (_$$_REQUIRE(_dependencyMap[1], "./three.core.js").Vector4)(1, 1, 1, 1));
        }
        return result;
      }
    }, {
      key: "serialize",
      value: function serialize(data) {
        _superPropGet(VertexColorNode, "serialize", this, 3)([data]);
        data.index = this.index;
      }
    }, {
      key: "deserialize",
      value: function deserialize(data) {
        _superPropGet(VertexColorNode, "deserialize", this, 3)([data]);
        this.index = data.index;
      }
    }], [{
      key: "type",
      get: function get() {
        return 'VertexColorNode';
      }
    }]);
  }(AttributeNode);
  /**
   * TSL function for creating a reference node.
   *
   * @function
   * @param {Number} index - The attribute index.
   * @returns {VertexColorNode}
   */
  var vertexColor = function vertexColor(index) {
    return nodeObject(new VertexColorNode(index));
  };

  /** @module PointUVNode **/

  /**
   * A node for representing the uv coordinates of points.
   *
   * Can only be used with a WebGL backend. In WebGPU, point
   * primitives always have the size of one pixel and can thus
   * can't be used as sprite-like objects that display textures.
   *
   * @augments Node
   */
  var PointUVNode = exports.PointUVNode = /*#__PURE__*/function (_Node43) {
    /**
     * Constructs a new point uv node.
     */
    function PointUVNode() {
      var _this140;
      (0, _classCallCheck2.default)(this, PointUVNode);
      _this140 = _callSuper(this, PointUVNode, ['vec2']);

      /**
       * This flag can be used for type testing.
       *
       * @type {Boolean}
       * @readonly
       * @default true
       */
      _this140.isPointUVNode = true;
      return _this140;
    }
    (0, _inherits2.default)(PointUVNode, _Node43);
    return (0, _createClass2.default)(PointUVNode, [{
      key: "generate",
      value: function generate(/*builder*/
      ) {
        return 'vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y )';
      }
    }], [{
      key: "type",
      get: function get() {
        return 'PointUVNode';
      }
    }]);
  }(Node);
  /**
   * TSL object that represents the uv coordinates of points.
   *
   * @type {PointUVNode}
   */
  var pointUV = /*@__PURE__*/nodeImmutable(PointUVNode);
  var _e1 = /*@__PURE__*/new (_$$_REQUIRE(_dependencyMap[1], "./three.core.js").Euler)();
  var _m1 = /*@__PURE__*/new (_$$_REQUIRE(_dependencyMap[1], "./three.core.js").Matrix4)();

  /** @module SceneNode **/

  /**
   * This module allows access to a collection of scene properties. The following predefined TSL objects
   * are available for easier use:
   *
   * - `backgroundBlurriness`: A node that represents the scene's background blurriness.
   * - `backgroundIntensity`: A node that represents the scene's background intensity.
   * - `backgroundRotation`: A node that represents the scene's background rotation.
   *
   * @augments Node
   */
  var SceneNode = exports.SceneNode = /*#__PURE__*/function (_Node44) {
    /**
     * Constructs a new scene node.
     *
     * @param {('backgroundBlurriness'|'backgroundIntensity'|'backgroundRotation')} scope - The scope defines the type of scene property that is accessed.
     * @param {Scene?} [scene=null] - A reference to the scene.
     */
    function SceneNode() {
      var _this141;
      var scope = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : SceneNode.BACKGROUND_BLURRINESS;
      var scene = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      (0, _classCallCheck2.default)(this, SceneNode);
      _this141 = _callSuper(this, SceneNode);

      /**
       * The scope defines the type of scene property that is accessed.
       *
       * @type {('backgroundBlurriness'|'backgroundIntensity'|'backgroundRotation')}
       */
      _this141.scope = scope;

      /**
       * A reference to the scene that is going to be accessed.
       *
       * @type {Scene?}
       * @default null
       */
      _this141.scene = scene;
      return _this141;
    }

    /**
     * Depending on the scope, the method returns a different type of node that represents
     * the respective scene property.
     *
     * @param {NodeBuilder} builder - The current node builder.
     * @return {Node} The output node.
     */
    (0, _inherits2.default)(SceneNode, _Node44);
    return (0, _createClass2.default)(SceneNode, [{
      key: "setup",
      value: function setup(builder) {
        var scope = this.scope;
        var scene = this.scene !== null ? this.scene : builder.scene;
        var output;
        if (scope === SceneNode.BACKGROUND_BLURRINESS) {
          output = reference('backgroundBlurriness', 'float', scene);
        } else if (scope === SceneNode.BACKGROUND_INTENSITY) {
          output = reference('backgroundIntensity', 'float', scene);
        } else if (scope === SceneNode.BACKGROUND_ROTATION) {
          output = uniform('mat4').label('backgroundRotation').setGroup(renderGroup).onRenderUpdate(function () {
            var background = scene.background;
            if (background !== null && background.isTexture && background.mapping !== _$$_REQUIRE(_dependencyMap[1], "./three.core.js").UVMapping) {
              _e1.copy(scene.backgroundRotation);

              // accommodate left-handed frame
              _e1.x *= -1;
              _e1.y *= -1;
              _e1.z *= -1;
              _m1.makeRotationFromEuler(_e1);
            } else {
              _m1.identity();
            }
            return _m1;
          });
        } else {
          console.error('THREE.SceneNode: Unknown scope:', scope);
        }
        return output;
      }
    }], [{
      key: "type",
      get: function get() {
        return 'SceneNode';
      }
    }]);
  }(Node);
  SceneNode.BACKGROUND_BLURRINESS = 'backgroundBlurriness';
  SceneNode.BACKGROUND_INTENSITY = 'backgroundIntensity';
  SceneNode.BACKGROUND_ROTATION = 'backgroundRotation';

  /**
   * TSL object that represents the scene's background blurriness.
   *
   * @type {SceneNode}
   */
  var backgroundBlurriness = /*@__PURE__*/nodeImmutable(SceneNode, SceneNode.BACKGROUND_BLURRINESS);

  /**
   * TSL object that represents the scene's background intensity.
   *
   * @type {SceneNode}
   */
  var backgroundIntensity = /*@__PURE__*/nodeImmutable(SceneNode, SceneNode.BACKGROUND_INTENSITY);

  /**
   * TSL object that represents the scene's background rotation.
   *
   * @type {SceneNode}
   */
  var backgroundRotation = /*@__PURE__*/nodeImmutable(SceneNode, SceneNode.BACKGROUND_ROTATION);

  /** @module StorageTextureNode **/

  /**
   * This special version of a texture node can be used to
   * write data into a storage texture with a compute shader.
   *
   * ```js
   * const storageTexture = new THREE.StorageTexture( width, height );
   *
   * const computeTexture = Fn( ( { storageTexture } ) => {
   *
   * 	const posX = instanceIndex.modInt( width );
   * 	const posY = instanceIndex.div( width );
   * 	const indexUV = uvec2( posX, posY );
   *
   * 	// generate RGB values
   *
   * 	const r = 1;
   * 	const g = 1;
   * 	const b = 1;
   *
   * 	textureStore( storageTexture, indexUV, vec4( r, g, b, 1 ) ).toWriteOnly();
   *
   * } );
   *
   * const computeNode = computeTexture( { storageTexture } ).compute( width * height );
   * renderer.computeAsync( computeNode );
   * ```
   *
   * This node can only be used with a WebGPU backend.
   *
   * @augments module:TextureNode~TextureNode
   */
  var StorageTextureNode = exports.StorageTextureNode = /*#__PURE__*/function (_TextureNode6) {
    /**
     * Constructs a new storage texture node.
     *
     * @param {StorageTexture} value - The storage texture.
     * @param {Node<vec2|vec3>} uvNode - The uv node.
     * @param {Node?} [storeNode=null] - The value node that should be stored in the texture.
     */
    function StorageTextureNode(value, uvNode) {
      var _this142;
      var storeNode = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
      (0, _classCallCheck2.default)(this, StorageTextureNode);
      _this142 = _callSuper(this, StorageTextureNode, [value, uvNode]);

      /**
       * The value node that should be stored in the texture.
       *
       * @type {Node?}
       * @default null
       */
      _this142.storeNode = storeNode;

      /**
       * This flag can be used for type testing.
       *
       * @type {Boolean}
       * @readonly
       * @default true
       */
      _this142.isStorageTextureNode = true;

      /**
       * The access type of the texture node.
       *
       * @type {String}
       * @default 'writeOnly'
       */
      _this142.access = NodeAccess.WRITE_ONLY;
      return _this142;
    }

    /**
     * Overwrites the default implementation to return a fixed value `'storageTexture'`.
     *
     * @param {NodeBuilder} builder - The current node builder.
     * @return {String} The input type.
     */
    (0, _inherits2.default)(StorageTextureNode, _TextureNode6);
    return (0, _createClass2.default)(StorageTextureNode, [{
      key: "getInputType",
      value: function getInputType(/*builder*/
      ) {
        return 'storageTexture';
      }
    }, {
      key: "setup",
      value: function setup(builder) {
        _superPropGet(StorageTextureNode, "setup", this, 3)([builder]);
        var properties = builder.getNodeProperties(this);
        properties.storeNode = this.storeNode;
      }

      /**
       * Defines the node access.
       *
       * @param {String} value - The node access.
       * @return {StorageTextureNode} A reference to this node.
       */
    }, {
      key: "setAccess",
      value: function setAccess(value) {
        this.access = value;
        return this;
      }

      /**
       * Generates the code snippet of the stroge node. If no `storeNode`
       * is defined, the texture node is generated as normal texture.
       *
       * @param {NodeBuilder} builder - The current node builder.
       * @param {String} output - The current output.
       * @return {String} The generated code snippet.
       */
    }, {
      key: "generate",
      value: function generate(builder, output) {
        var snippet;
        if (this.storeNode !== null) {
          snippet = this.generateStore(builder);
        } else {
          snippet = _superPropGet(StorageTextureNode, "generate", this, 3)([builder, output]);
        }
        return snippet;
      }

      /**
       * Convenience method for configuring a read/write node access.
       *
       * @return {StorageTextureNode} A reference to this node.
       */
    }, {
      key: "toReadWrite",
      value: function toReadWrite() {
        return this.setAccess(NodeAccess.READ_WRITE);
      }

      /**
       * Convenience method for configuring a read-only node access.
       *
       * @return {StorageTextureNode} A reference to this node.
       */
    }, {
      key: "toReadOnly",
      value: function toReadOnly() {
        return this.setAccess(NodeAccess.READ_ONLY);
      }

      /**
       * Convenience method for configuring a write-only node access.
       *
       * @return {StorageTextureNode} A reference to this node.
       */
    }, {
      key: "toWriteOnly",
      value: function toWriteOnly() {
        return this.setAccess(NodeAccess.WRITE_ONLY);
      }

      /**
       * Generates the code snippet of the storage texture node.
       *
       * @param {NodeBuilder} builder - The current node builder.
       */
    }, {
      key: "generateStore",
      value: function generateStore(builder) {
        var properties = builder.getNodeProperties(this);
        var uvNode = properties.uvNode,
          storeNode = properties.storeNode;
        var textureProperty = _superPropGet(StorageTextureNode, "generate", this, 3)([builder, 'property']);
        var uvSnippet = uvNode.build(builder, 'uvec2');
        var storeSnippet = storeNode.build(builder, 'vec4');
        var snippet = builder.generateTextureStore(builder, textureProperty, uvSnippet, storeSnippet);
        builder.addLineFlowCode(snippet, this);
      }
    }], [{
      key: "type",
      get: function get() {
        return 'StorageTextureNode';
      }
    }]);
  }(TextureNode);
  /**
   * TSL function for creating a storage texture node.
   *
   * @function
   * @param {StorageTexture} value - The storage texture.
   * @param {Node<vec2|vec3>} uvNode - The uv node.
   * @param {Node?} [storeNode=null] - The value node that should be stored in the texture.
   * @returns {StorageTextureNode}
   */
  var storageTexture = /*@__PURE__*/nodeProxy(StorageTextureNode);

  /**
   * TODO: Explain difference to `storageTexture()`.
   *
   * @function
   * @param {StorageTexture} value - The storage texture.
   * @param {Node<vec2|vec3>} uvNode - The uv node.
   * @param {Node?} [storeNode=null] - The value node that should be stored in the texture.
   * @returns {StorageTextureNode}
   */
  var textureStore = function textureStore(value, uvNode, storeNode) {
    var node = storageTexture(value, uvNode, storeNode);
    if (storeNode !== null) node.append();
    return node;
  };

  /** @module UserDataNode **/

  /**
   * A special type of reference node that allows to link values in
   * `userData` fields to node objects.
   * ```js
   * sprite.userData.rotation = 1; // stores individual rotation per sprite
   *
   * const material = new THREE.SpriteNodeMaterial();
   * material.rotationNode = userData( 'rotation', 'float' );
   * ```
   * Since `UserDataNode` is extended from {@link module:ReferenceNode~ReferenceNode}, the node value
   * will automatically be updated when the `rotation` user data field changes.
   *
   * @augments module:ReferenceNode~ReferenceNode
   */
  var UserDataNode = exports.UserDataNode = /*#__PURE__*/function (_ReferenceNode2) {
    /**
     * Constructs a new user data node.
     *
     * @param {String} property - The property name that should be referenced by the node.
     * @param {String} inputType - The node data type of the reference.
     * @param {Object?} [userData=null] - A reference to the `userData` object. If not provided, the `userData` property of the 3D object that uses the node material is evaluated.
     */
    function UserDataNode(property, inputType) {
      var _this143;
      var userData = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
      (0, _classCallCheck2.default)(this, UserDataNode);
      _this143 = _callSuper(this, UserDataNode, [property, inputType, userData]);

      /**
       * A reference to the `userData` object. If not provided, the `userData`
       * property of the 3D object that uses the node material is evaluated.
       *
       * @type {Object?}
       * @default null
       */
      _this143.userData = userData;
      return _this143;
    }

    /**
     * Overwritten to make sure {@link module:ReferenceNode~ReferenceNode#reference} points to the correct
     * `userData` field.
     *
     * @param {(NodeFrame|NodeBuilder)} state - The current state to evaluate.
     * @return {Object} A reference to the `userData` field.
     */
    (0, _inherits2.default)(UserDataNode, _ReferenceNode2);
    return (0, _createClass2.default)(UserDataNode, [{
      key: "updateReference",
      value: function updateReference(state) {
        this.reference = this.userData !== null ? this.userData : state.object.userData;
        return this.reference;
      }
    }], [{
      key: "type",
      get: function get() {
        return 'UserDataNode';
      }
    }]);
  }(ReferenceNode);
  /**
   * TSL function for creating a user data node.
   *
   * @function
   * @param {String} name - The property name that should be referenced by the node.
   * @param {String} inputType - The node data type of the reference.
   * @param {Object?} userData - A reference to the `userData` object. If not provided, the `userData` property of the 3D object that uses the node material is evaluated.
   * @returns {UserDataNode}
   */
  var userData = function userData(name, inputType, _userData) {
    return nodeObject(new UserDataNode(name, inputType, _userData));
  };
  var _objectData = new WeakMap();

  /** @module VelocityNode **/

  /**
   * A node for representing motion or velocity vectors. Foundation
   * for advanced post processing effects like motion blur or TRAA.
   *
   * The node keeps track of the model, view and projection matrices
   * of the previous frame and uses them to compute offsets in NDC space.
   * These offsets represent the final velocity.
   *
   * @augments TempNode
   */
  var VelocityNode = /*#__PURE__*/function (_TempNode18) {
    /**
     * Constructs a new vertex color node.
     *
     * @param {Number} [index=0] - The attribute index.
     */
    function VelocityNode() {
      var _this144;
      (0, _classCallCheck2.default)(this, VelocityNode);
      _this144 = _callSuper(this, VelocityNode, ['vec2']);

      /**
       * The current projection matrix.
       *
       * @type {Matrix4?}
       * @default null
       */
      _this144.projectionMatrix = null;

      /**
       * Overwritten since velocity nodes are updated per object.
       *
       * @type {String}
       * @default 'object'
       */
      _this144.updateType = NodeUpdateType.OBJECT;

      /**
       * Overwritten since velocity nodes save data after the update.
       *
       * @type {String}
       * @default 'object'
       */
      _this144.updateAfterType = NodeUpdateType.OBJECT;

      /**
       * Uniform node representing the previous model matrix in world space.
       *
       * @type {UniformNode<mat4>}
       * @default null
       */
      _this144.previousModelWorldMatrix = uniform(new (_$$_REQUIRE(_dependencyMap[1], "./three.core.js").Matrix4)());

      /**
       * Uniform node representing the previous projection matrix.
       *
       * @type {UniformNode<mat4>}
       * @default null
       */
      _this144.previousProjectionMatrix = uniform(new (_$$_REQUIRE(_dependencyMap[1], "./three.core.js").Matrix4)()).setGroup(renderGroup);

      /**
       * Uniform node representing the previous view matrix.
       *
       * @type {UniformNode<mat4>}
       * @default null
       */
      _this144.previousCameraViewMatrix = uniform(new (_$$_REQUIRE(_dependencyMap[1], "./three.core.js").Matrix4)());
      return _this144;
    }

    /**
     * Sets the given projection matrix.
     *
     * @param {Matrix4} projectionMatrix - The projection matrix to set.
     */
    (0, _inherits2.default)(VelocityNode, _TempNode18);
    return (0, _createClass2.default)(VelocityNode, [{
      key: "setProjectionMatrix",
      value: function setProjectionMatrix(projectionMatrix) {
        this.projectionMatrix = projectionMatrix;
      }

      /**
       * Updates velocity specific uniforms.
       *
       * @param {NodeFrame} frame - A reference to the current node frame.
       */
    }, {
      key: "update",
      value: function update(_ref140) {
        var frameId = _ref140.frameId,
          camera = _ref140.camera,
          object = _ref140.object;
        var previousModelMatrix = getPreviousMatrix(object);
        this.previousModelWorldMatrix.value.copy(previousModelMatrix);

        //

        var cameraData = getData(camera);
        if (cameraData.frameId !== frameId) {
          cameraData.frameId = frameId;
          if (cameraData.previousProjectionMatrix === undefined) {
            cameraData.previousProjectionMatrix = new (_$$_REQUIRE(_dependencyMap[1], "./three.core.js").Matrix4)();
            cameraData.previousCameraViewMatrix = new (_$$_REQUIRE(_dependencyMap[1], "./three.core.js").Matrix4)();
            cameraData.currentProjectionMatrix = new (_$$_REQUIRE(_dependencyMap[1], "./three.core.js").Matrix4)();
            cameraData.currentCameraViewMatrix = new (_$$_REQUIRE(_dependencyMap[1], "./three.core.js").Matrix4)();
            cameraData.previousProjectionMatrix.copy(this.projectionMatrix || camera.projectionMatrix);
            cameraData.previousCameraViewMatrix.copy(camera.matrixWorldInverse);
          } else {
            cameraData.previousProjectionMatrix.copy(cameraData.currentProjectionMatrix);
            cameraData.previousCameraViewMatrix.copy(cameraData.currentCameraViewMatrix);
          }
          cameraData.currentProjectionMatrix.copy(this.projectionMatrix || camera.projectionMatrix);
          cameraData.currentCameraViewMatrix.copy(camera.matrixWorldInverse);
          this.previousProjectionMatrix.value.copy(cameraData.previousProjectionMatrix);
          this.previousCameraViewMatrix.value.copy(cameraData.previousCameraViewMatrix);
        }
      }

      /**
       * Overwritten to updated velocity specific uniforms.
       *
       * @param {NodeFrame} frame - A reference to the current node frame.
       */
    }, {
      key: "updateAfter",
      value: function updateAfter(_ref141) {
        var object = _ref141.object;
        getPreviousMatrix(object).copy(object.matrixWorld);
      }

      /**
       * Implements the velocity computation based on the previous and current vertex data.
       *
       * @param {NodeBuilder} builder - A reference to the current node builder.
       * @return {Node<vec2>} The motion vector.
       */
    }, {
      key: "setup",
      value: function setup(/*builder*/
      ) {
        var projectionMatrix = this.projectionMatrix === null ? cameraProjectionMatrix : uniform(this.projectionMatrix);
        var previousModelViewMatrix = this.previousCameraViewMatrix.mul(this.previousModelWorldMatrix);
        var clipPositionCurrent = projectionMatrix.mul(modelViewMatrix).mul(positionLocal);
        var clipPositionPrevious = this.previousProjectionMatrix.mul(previousModelViewMatrix).mul(positionPrevious);
        var ndcPositionCurrent = clipPositionCurrent.xy.div(clipPositionCurrent.w);
        var ndcPositionPrevious = clipPositionPrevious.xy.div(clipPositionPrevious.w);
        var velocity = sub(ndcPositionCurrent, ndcPositionPrevious);
        return velocity;
      }
    }], [{
      key: "type",
      get: function get() {
        return 'VelocityNode';
      }
    }]);
  }(TempNode);
  function getData(object) {
    var objectData = _objectData.get(object);
    if (objectData === undefined) {
      objectData = {};
      _objectData.set(object, objectData);
    }
    return objectData;
  }
  function getPreviousMatrix(object) {
    var index = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var objectData = getData(object);
    var matrix = objectData[index];
    if (matrix === undefined) {
      objectData[index] = matrix = new (_$$_REQUIRE(_dependencyMap[1], "./three.core.js").Matrix4)();
    }
    return matrix;
  }

  /**
   * TSL object that represents the velocity of a render pass.
   *
   * @type {VelocityNode}
   */
  var velocity = /*@__PURE__*/nodeImmutable(VelocityNode);
  var blendBurn = /*@__PURE__*/Fn(function (_ref142) {
    var _ref143 = (0, _slicedToArray2.default)(_ref142, 2),
      base = _ref143[0],
      blend = _ref143[1];
    return min$1(1.0, base.oneMinus().div(blend)).oneMinus();
  }).setLayout({
    name: 'blendBurn',
    type: 'vec3',
    inputs: [{
      name: 'base',
      type: 'vec3'
    }, {
      name: 'blend',
      type: 'vec3'
    }]
  });
  var blendDodge = /*@__PURE__*/Fn(function (_ref144) {
    var _ref145 = (0, _slicedToArray2.default)(_ref144, 2),
      base = _ref145[0],
      blend = _ref145[1];
    return min$1(base.div(blend.oneMinus()), 1.0);
  }).setLayout({
    name: 'blendDodge',
    type: 'vec3',
    inputs: [{
      name: 'base',
      type: 'vec3'
    }, {
      name: 'blend',
      type: 'vec3'
    }]
  });
  var blendScreen = /*@__PURE__*/Fn(function (_ref146) {
    var _ref147 = (0, _slicedToArray2.default)(_ref146, 2),
      base = _ref147[0],
      blend = _ref147[1];
    return base.oneMinus().mul(blend.oneMinus()).oneMinus();
  }).setLayout({
    name: 'blendScreen',
    type: 'vec3',
    inputs: [{
      name: 'base',
      type: 'vec3'
    }, {
      name: 'blend',
      type: 'vec3'
    }]
  });
  var blendOverlay = /*@__PURE__*/Fn(function (_ref148) {
    var _ref149 = (0, _slicedToArray2.default)(_ref148, 2),
      base = _ref149[0],
      blend = _ref149[1];
    return mix(base.mul(2.0).mul(blend), base.oneMinus().mul(2.0).mul(blend.oneMinus()).oneMinus(), step(0.5, base));
  }).setLayout({
    name: 'blendOverlay',
    type: 'vec3',
    inputs: [{
      name: 'base',
      type: 'vec3'
    }, {
      name: 'blend',
      type: 'vec3'
    }]
  });
  var blendColor = /*@__PURE__*/Fn(function (_ref150) {
    var _ref151 = (0, _slicedToArray2.default)(_ref150, 2),
      base = _ref151[0],
      blend = _ref151[1];
    var outAlpha = blend.a.add(base.a.mul(blend.a.oneMinus()));
    return vec4(blend.rgb.mul(blend.a).add(base.rgb.mul(base.a).mul(blend.a.oneMinus())).div(outAlpha), outAlpha);
  }).setLayout({
    name: 'blendColor',
    type: 'vec4',
    inputs: [{
      name: 'base',
      type: 'vec4'
    }, {
      name: 'blend',
      type: 'vec4'
    }]
  });

  // deprecated

  var burn = function burn() {
    // @deprecated, r171

    console.warn('THREE.TSL: "burn" has been renamed. Use "blendBurn" instead.');
    for (var _len23 = arguments.length, params = new Array(_len23), _key23 = 0; _key23 < _len23; _key23++) {
      params[_key23] = arguments[_key23];
    }
    return blendBurn(params);
  };
  var dodge = function dodge() {
    // @deprecated, r171

    console.warn('THREE.TSL: "dodge" has been renamed. Use "blendDodge" instead.');
    for (var _len24 = arguments.length, params = new Array(_len24), _key24 = 0; _key24 < _len24; _key24++) {
      params[_key24] = arguments[_key24];
    }
    return blendDodge(params);
  };
  var screen = function screen() {
    // @deprecated, r171

    console.warn('THREE.TSL: "screen" has been renamed. Use "blendScreen" instead.');
    for (var _len25 = arguments.length, params = new Array(_len25), _key25 = 0; _key25 < _len25; _key25++) {
      params[_key25] = arguments[_key25];
    }
    return blendScreen(params);
  };
  var overlay = function overlay() {
    // @deprecated, r171

    console.warn('THREE.TSL: "overlay" has been renamed. Use "blendOverlay" instead.');
    for (var _len26 = arguments.length, params = new Array(_len26), _key26 = 0; _key26 < _len26; _key26++) {
      params[_key26] = arguments[_key26];
    }
    return blendOverlay(params);
  };

  /** @module ColorAdjustment **/

  /**
   * Computes a grayscale value for the given RGB color value.
   *
   * @method
   * @param {Node<vec3>} color - The color value to compute the grayscale for.
   * @return {Node<vec3>} The grayscale color.
   */
  var grayscale = /*@__PURE__*/Fn(function (_ref152) {
    var _ref153 = (0, _slicedToArray2.default)(_ref152, 1),
      color = _ref153[0];
    return luminance(color.rgb);
  });

  /**
   * Super-saturates or desaturates the given RGB color.
   *
   * @method
   * @param {Node<vec3>} color - The input color.
   * @param {Node<float>} [adjustment=1] - Specifies the amount of the conversion. A value under `1` desaturates the color, a value over `1` super-saturates it.
   * @return {Node<vec3>} The saturated color.
   */
  var saturation = /*@__PURE__*/Fn(function (_ref154) {
    var _ref155 = (0, _slicedToArray2.default)(_ref154, 2),
      color = _ref155[0],
      _ref155$ = _ref155[1],
      adjustment = _ref155$ === void 0 ? float(1) : _ref155$;
    return adjustment.mix(luminance(color.rgb), color.rgb);
  });

  /**
   * Selectively enhance the intensity of less saturated RGB colors. Can result
   * in a more natural and visually appealing image with enhanced color depth
   * compared to {@link ColorAdjustment#saturation}.
   *
   * @method
   * @param {Node<vec3>} color - The input color.
   * @param {Node<float>} [adjustment=1] - Controls the intensity of the vibrance effect.
   * @return {Node<vec3>} The updated color.
   */
  var vibrance = /*@__PURE__*/Fn(function (_ref156) {
    var _ref157 = (0, _slicedToArray2.default)(_ref156, 2),
      color = _ref157[0],
      _ref157$ = _ref157[1],
      adjustment = _ref157$ === void 0 ? float(1) : _ref157$;
    var average = add(color.r, color.g, color.b).div(3.0);
    var mx = color.r.max(color.g.max(color.b));
    var amt = mx.sub(average).mul(adjustment).mul(-3.0);
    return mix(color.rgb, mx, amt);
  });

  /**
   * Updates the hue component of the given RGB color while preserving its luminance and saturation.
   *
   * @method
   * @param {Node<vec3>} color - The input color.
   * @param {Node<float>} [adjustment=1] - Defines the degree of hue rotation in radians. A positive value rotates the hue clockwise, while a negative value rotates it counterclockwise.
   * @return {Node<vec3>} The updated color.
   */
  var hue = /*@__PURE__*/Fn(function (_ref158) {
    var _ref159 = (0, _slicedToArray2.default)(_ref158, 2),
      color = _ref159[0],
      _ref159$ = _ref159[1],
      adjustment = _ref159$ === void 0 ? float(1) : _ref159$;
    var k = vec3(0.57735, 0.57735, 0.57735);
    var cosAngle = adjustment.cos();
    return vec3(color.rgb.mul(cosAngle).add(k.cross(color.rgb).mul(adjustment.sin()).add(k.mul(dot(k, color.rgb).mul(cosAngle.oneMinus())))));
  });

  /**
   * Computes the luminance for the given RGB color value.
   *
   * @method
   * @param {Node<vec3>} color - The color value to compute the luminance for.
   * @param {Node<vec3>?} luminanceCoefficients - The luminance coefficients. By default predefined values of the current working color space are used.
   * @return {Node<vec3>} The luminance.
   */
  var luminance = function luminance(color) {
    var luminanceCoefficients = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : vec3(_$$_REQUIRE(_dependencyMap[1], "./three.core.js").ColorManagement.getLuminanceCoefficients(new (_$$_REQUIRE(_dependencyMap[1], "./three.core.js").Vector3)()));
    return dot(color, luminanceCoefficients);
  };

  /**
   * Color Decision List (CDL) v1.2
   *
   * Compact representation of color grading information, defined by slope, offset, power, and
   * saturation. The CDL should be typically be given input in a log space (such as LogC, ACEScc,
   * or AgX Log), and will return output in the same space. Output may require clamping >=0.
   *
   * @method
   * @param {Node<vec4>} color Input (-Infinity < input < +Infinity)
   * @param {Node<vec3>} slope Slope (0  slope < +Infinity)
   * @param {Node<vec3>} offset Offset (-Infinity < offset < +Infinity; typically -1 < offset < 1)
   * @param {Node<vec3>} power Power (0 < power < +Infinity)
   * @param {Node<float>} saturation Saturation (0  saturation < +Infinity; typically 0  saturation < 4)
   * @param {Node<vec3>} luminanceCoefficients Luminance coefficients for saturation term, typically Rec. 709
   * @return {Node<vec4>} Output, -Infinity < output < +Infinity
   *
   * References:
   * - ASC CDL v1.2
   * - {@link https://blender.stackexchange.com/a/55239/43930}
   * - {@link https://docs.acescentral.com/specifications/acescc/}
   */
  var cdl = /*@__PURE__*/Fn(function (_ref160) {
    var _ref161 = (0, _slicedToArray2.default)(_ref160, 6),
      color = _ref161[0],
      _ref161$ = _ref161[1],
      slope = _ref161$ === void 0 ? vec3(1) : _ref161$,
      _ref161$2 = _ref161[2],
      offset = _ref161$2 === void 0 ? vec3(0) : _ref161$2,
      _ref161$3 = _ref161[3],
      power = _ref161$3 === void 0 ? vec3(1) : _ref161$3,
      _ref161$4 = _ref161[4],
      saturation = _ref161$4 === void 0 ? float(1) : _ref161$4,
      _ref161$5 = _ref161[5],
      luminanceCoefficients = _ref161$5 === void 0 ? vec3(_$$_REQUIRE(_dependencyMap[1], "./three.core.js").ColorManagement.getLuminanceCoefficients(new (_$$_REQUIRE(_dependencyMap[1], "./three.core.js").Vector3)(), _$$_REQUIRE(_dependencyMap[1], "./three.core.js").LinearSRGBColorSpace)) : _ref161$5;
    // NOTE: The ASC CDL v1.2 defines a [0, 1] clamp on the slope+offset term, and another on the
    // saturation term. Per the ACEScc specification and Filament, limits may be omitted to support
    // values outside [0, 1], requiring a workaround for negative values in the power expression.

    var luma = color.rgb.dot(vec3(luminanceCoefficients));
    var v = max$1(color.rgb.mul(slope).add(offset), 0.0).toVar();
    var pv = v.pow(power).toVar();
    If(v.r.greaterThan(0.0), function () {
      v.r.assign(pv.r);
    }); // eslint-disable-line
    If(v.g.greaterThan(0.0), function () {
      v.g.assign(pv.g);
    }); // eslint-disable-line
    If(v.b.greaterThan(0.0), function () {
      v.b.assign(pv.b);
    }); // eslint-disable-line

    v.assign(luma.add(v.sub(luma).mul(saturation)));
    return vec4(v.rgb, color.a);
  });

  /** @module PosterizeNode **/

  /**
   * Represents a posterize effect which reduces the number of colors
   * in an image, resulting in a more blocky and stylized appearance.
   *
   * @augments TempNode
   */
  var PosterizeNode = exports.PosterizeNode = /*#__PURE__*/function (_TempNode19) {
    /**
     * Constructs a new posterize node.
     *
     * @param {Node} sourceNode - The input color.
     * @param {Node} stepsNode - Controls the intensity of the posterization effect. A lower number results in a more blocky appearance.
     */
    function PosterizeNode(sourceNode, stepsNode) {
      var _this145;
      (0, _classCallCheck2.default)(this, PosterizeNode);
      _this145 = _callSuper(this, PosterizeNode);

      /**
       * The input color.
       *
       * @type {Node}
       */
      _this145.sourceNode = sourceNode;

      /**
       * Controls the intensity of the posterization effect. A lower number results in a more blocky appearance.
       *
       * @type {Node}
       */
      _this145.stepsNode = stepsNode;
      return _this145;
    }
    (0, _inherits2.default)(PosterizeNode, _TempNode19);
    return (0, _createClass2.default)(PosterizeNode, [{
      key: "setup",
      value: function setup() {
        var sourceNode = this.sourceNode,
          stepsNode = this.stepsNode;
        return sourceNode.mul(stepsNode).floor().div(stepsNode);
      }
    }], [{
      key: "type",
      get: function get() {
        return 'PosterizeNode';
      }
    }]);
  }(TempNode);
  /**
   * TSL function for creating a posterize node.
   *
   * @function
   * @param {Node} sourceNode - The input color.
   * @param {Node} stepsNode - Controls the intensity of the posterization effect. A lower number results in a more blocky appearance.
   * @returns {PosterizeNode}
   */
  var posterize = /*@__PURE__*/nodeProxy(PosterizeNode);

  /** @module PassNode **/

  var _size = /*@__PURE__*/new (_$$_REQUIRE(_dependencyMap[1], "./three.core.js").Vector2)();

  /**
   * Represents the texture of a pass node.
   *
   * @augments module:TextureNode~TextureNode
   */
  var PassTextureNode = /*#__PURE__*/function (_TextureNode7) {
    /**
     * Constructs a new pass texture node.
     *
     * @param {PassNode} passNode - The pass node.
     * @param {Texture} texture - The output texture.
     */
    function PassTextureNode(passNode, texture) {
      var _this146;
      (0, _classCallCheck2.default)(this, PassTextureNode);
      _this146 = _callSuper(this, PassTextureNode, [texture]);

      /**
       * A reference to the pass node.
       *
       * @type {PassNode}
       */
      _this146.passNode = passNode;
      _this146.setUpdateMatrix(false);
      return _this146;
    }
    (0, _inherits2.default)(PassTextureNode, _TextureNode7);
    return (0, _createClass2.default)(PassTextureNode, [{
      key: "setup",
      value: function setup(builder) {
        if (builder.object.isQuadMesh) this.passNode.build(builder);
        return _superPropGet(PassTextureNode, "setup", this, 3)([builder]);
      }
    }, {
      key: "clone",
      value: function clone() {
        return new this.constructor(this.passNode, this.value);
      }
    }], [{
      key: "type",
      get: function get() {
        return 'PassTextureNode';
      }
    }]);
  }(TextureNode);
  /**
   * An extension of `PassTextureNode` which allows to manage more than one
   * internal texture. Relevant for the `getPreviousTexture()` related API.
   *
   * @augments module:PassTextureNode~PassTextureNode
   */
  var PassMultipleTextureNode = /*#__PURE__*/function (_PassTextureNode) {
    /**
     * Constructs a new pass texture node.
     *
     * @param {PassNode} passNode - The pass node.
     * @param {String} textureName - The output texture name.
     * @param {Boolean} [previousTexture=false] - Whether previous frame data should be used or not.
     */
    function PassMultipleTextureNode(passNode, textureName) {
      var _this147;
      var previousTexture = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      (0, _classCallCheck2.default)(this, PassMultipleTextureNode);
      // null is passed to the super call since this class does not
      // use an external texture for rendering pass data into. Instead
      // the texture is managed by the pass node itself

      _this147 = _callSuper(this, PassMultipleTextureNode, [passNode, null]);

      /**
       * The output texture name.
       *
       * @type {String}
       */
      _this147.textureName = textureName;

      /**
       * Whether previous frame data should be used or not.
       *
       * @type {Boolean}
       */
      _this147.previousTexture = previousTexture;
      return _this147;
    }

    /**
     * Updates the texture reference of this node.
     */
    (0, _inherits2.default)(PassMultipleTextureNode, _PassTextureNode);
    return (0, _createClass2.default)(PassMultipleTextureNode, [{
      key: "updateTexture",
      value: function updateTexture() {
        this.value = this.previousTexture ? this.passNode.getPreviousTexture(this.textureName) : this.passNode.getTexture(this.textureName);
      }
    }, {
      key: "setup",
      value: function setup(builder) {
        this.updateTexture();
        return _superPropGet(PassMultipleTextureNode, "setup", this, 3)([builder]);
      }
    }, {
      key: "clone",
      value: function clone() {
        return new this.constructor(this.passNode, this.textureName, this.previousTexture);
      }
    }], [{
      key: "type",
      get: function get() {
        return 'PassMultipleTextureNode';
      }
    }]);
  }(PassTextureNode);
  /**
   * Represents a render pass (sometimes called beauty pass) in context of post processing.
   * This pass produces a render for the given scene and camera and can provide multiple outputs
   * via MRT for further processing.
   *
   * ```js
   * const postProcessing = new PostProcessing( renderer );
   *
   * const scenePass = pass( scene, camera );
   *
   * postProcessing.outputNode = scenePass;
   * ```
   *
   * @augments TempNode
   */
  var PassNode = exports.PassNode = /*#__PURE__*/function (_TempNode20) {
    /**
     * Constructs a new pass node.
     *
     * @param {('color'|'depth')} scope - The scope of the pass. The scope determines whether the node outputs color or depth.
     * @param {Scene} scene - A reference to the scene.
     * @param {Camera} camera - A reference to the camera.
     * @param {Object} options - Options for the internal render target.
     */
    function PassNode(scope, scene, camera) {
      var _this148;
      var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
      (0, _classCallCheck2.default)(this, PassNode);
      _this148 = _callSuper(this, PassNode, ['vec4']);

      /**
       * The scope of the pass. The scope determines whether the node outputs color or depth.
       *
       * @type {('color'|'depth')}
       */
      _this148.scope = scope;

      /**
       * A reference to the scene.
       *
       * @type {Scene}
       */
      _this148.scene = scene;

      /**
       * A reference to the camera.
       *
       * @type {Camera}
       */
      _this148.camera = camera;

      /**
       * Options for the internal render target.
       *
       * @type {Object}
       */
      _this148.options = options;

      /**
       * The pass's pixel ratio. Will be kept automatically kept in sync with the renderer's pixel ratio.
       *
       * @private
       * @type {Number}
       * @default 1
       */
      _this148._pixelRatio = 1;

      /**
       * The pass's pixel width. Will be kept automatically kept in sync with the renderer's width.
       * @private
       * @type {Number}
       * @default 1
       */
      _this148._width = 1;

      /**
       * The pass's pixel height. Will be kept automatically kept in sync with the renderer's height.
       * @private
       * @type {Number}
       * @default 1
       */
      _this148._height = 1;
      var depthTexture = new (_$$_REQUIRE(_dependencyMap[1], "./three.core.js").DepthTexture)();
      depthTexture.isRenderTargetTexture = true;
      //depthTexture.type = FloatType;
      depthTexture.name = 'depth';
      var renderTarget = new (_$$_REQUIRE(_dependencyMap[1], "./three.core.js").RenderTarget)(_this148._width * _this148._pixelRatio, _this148._height * _this148._pixelRatio, Object.assign({
        type: _$$_REQUIRE(_dependencyMap[1], "./three.core.js").HalfFloatType
      }, options));
      renderTarget.texture.name = 'output';
      renderTarget.depthTexture = depthTexture;

      /**
       * The pass's render target.
       *
       * @type {RenderTarget}
       */
      _this148.renderTarget = renderTarget;

      /**
       * A dictionary holding the internal result textures.
       *
       * @private
       * @type {Object<String, Texture>}
       */
      _this148._textures = {
        output: renderTarget.texture,
        depth: depthTexture
      };

      /**
       * A dictionary holding the internal texture nodes.
       *
       * @private
       * @type {Object<String, TextureNode>}
       */
      _this148._textureNodes = {};

      /**
       * A dictionary holding the internal depth nodes.
       *
       * @private
       * @type {Object}
       */
      _this148._linearDepthNodes = {};

      /**
       * A dictionary holding the internal viewZ nodes.
       *
       * @private
       * @type {Object}
       */
      _this148._viewZNodes = {};

      /**
       * A dictionary holding the texture data of the previous frame.
       * Used for computing velocity/motion vectors.
       *
       * @private
       * @type {Object<String, Texture>}
       */
      _this148._previousTextures = {};

      /**
       * A dictionary holding the texture nodes of the previous frame.
       * Used for computing velocity/motion vectors.
       *
       * @private
       * @type {Object<String, TextureNode>}
       */
      _this148._previousTextureNodes = {};

      /**
       * The `near` property of the camera as a uniform.
       *
       * @private
       * @type {UniformNode}
       */
      _this148._cameraNear = uniform(0);

      /**
       * The `far` property of the camera as a uniform.
       *
       * @private
       * @type {UniformNode}
       */
      _this148._cameraFar = uniform(0);

      /**
       * A MRT node configuring the MRT settings.
       *
       * @private
       * @type {MRTNode?}
       * @default null
       */
      _this148._mrt = null;

      /**
       * This flag can be used for type testing.
       *
       * @type {Boolean}
       * @readonly
       * @default true
       */
      _this148.isPassNode = true;

      /**
       * The `updateBeforeType` is set to `NodeUpdateType.FRAME` since the node renders the
       * scene once per frame in its {@link PassNode#updateBefore} method.
       *
       * @type {String}
       * @default 'frame'
       */
      _this148.updateBeforeType = NodeUpdateType.FRAME;
      return _this148;
    }

    /**
     * Sets the given MRT node to setup MRT for this pass.
     *
     * @param {MRTNode} mrt - The MRT object.
     * @return {PassNode} A reference to this pass.
     */
    (0, _inherits2.default)(PassNode, _TempNode20);
    return (0, _createClass2.default)(PassNode, [{
      key: "setMRT",
      value: function setMRT(mrt) {
        this._mrt = mrt;
        return this;
      }

      /**
       * Returns the current MRT node.
       *
       * @return {MRTNode} The current MRT node.
       */
    }, {
      key: "getMRT",
      value: function getMRT() {
        return this._mrt;
      }

      /**
       * The method is overwritten so it always returns `true`.
       *
       * @return {Boolean} Whether this node is global or not.
       */
    }, {
      key: "isGlobal",
      value: function isGlobal() {
        return true;
      }

      /**
       * Returns the texture for the given output name.
       *
       * @param {String} name - The output name to get the texture for.
       * @return {Texture} The texture.
       */
    }, {
      key: "getTexture",
      value: function getTexture(name) {
        var texture = this._textures[name];
        if (texture === undefined) {
          var refTexture = this.renderTarget.texture;
          texture = refTexture.clone();
          texture.name = name;
          this._textures[name] = texture;
          this.renderTarget.textures.push(texture);
        }
        return texture;
      }

      /**
       * Returns the texture holding the data of the previous frame for the given output name.
       *
       * @param {String} name - The output name to get the texture for.
       * @return {Texture} The texture holding the data of the previous frame.
       */
    }, {
      key: "getPreviousTexture",
      value: function getPreviousTexture(name) {
        var texture = this._previousTextures[name];
        if (texture === undefined) {
          texture = this.getTexture(name).clone();
          this._previousTextures[name] = texture;
        }
        return texture;
      }

      /**
       * Switches current and previous textures for the given output name.
       *
       * @param {String} name - The output name.
       */
    }, {
      key: "toggleTexture",
      value: function toggleTexture(name) {
        var prevTexture = this._previousTextures[name];
        if (prevTexture !== undefined) {
          var _texture5 = this._textures[name];
          var index = this.renderTarget.textures.indexOf(_texture5);
          this.renderTarget.textures[index] = prevTexture;
          this._textures[name] = prevTexture;
          this._previousTextures[name] = _texture5;
          this._textureNodes[name].updateTexture();
          this._previousTextureNodes[name].updateTexture();
        }
      }

      /**
       * Returns the texture node for the given output name.
       *
       * @param {String} [name='output'] - The output name to get the texture node for.
       * @return {TextureNode} The texture node.
       */
    }, {
      key: "getTextureNode",
      value: function getTextureNode() {
        var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'output';
        var textureNode = this._textureNodes[name];
        if (textureNode === undefined) {
          textureNode = nodeObject(new PassMultipleTextureNode(this, name));
          textureNode.updateTexture();
          this._textureNodes[name] = textureNode;
        }
        return textureNode;
      }

      /**
       * Returns the previous texture node for the given output name.
       *
       * @param {String} [name='output'] - The output name to get the previous texture node for.
       * @return {TextureNode} The previous texture node.
       */
    }, {
      key: "getPreviousTextureNode",
      value: function getPreviousTextureNode() {
        var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'output';
        var textureNode = this._previousTextureNodes[name];
        if (textureNode === undefined) {
          if (this._textureNodes[name] === undefined) this.getTextureNode(name);
          textureNode = nodeObject(new PassMultipleTextureNode(this, name, true));
          textureNode.updateTexture();
          this._previousTextureNodes[name] = textureNode;
        }
        return textureNode;
      }

      /**
       * Returns a viewZ node of this pass.
       *
       * @param {String} [name='depth'] - The output name to get the viewZ node for. In most cases the default `'depth'` can be used however the parameter exists for custom depth outputs.
       * @return {Node} The viewZ node.
       */
    }, {
      key: "getViewZNode",
      value: function getViewZNode() {
        var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'depth';
        var viewZNode = this._viewZNodes[name];
        if (viewZNode === undefined) {
          var _cameraNear = this._cameraNear;
          var _cameraFar = this._cameraFar;
          this._viewZNodes[name] = viewZNode = perspectiveDepthToViewZ(this.getTextureNode(name), _cameraNear, _cameraFar);
        }
        return viewZNode;
      }

      /**
       * Returns a linear depth node of this pass.
       *
       * @param {String} [name='depth'] - The output name to get the linear depth node for. In most cases the default `'depth'` can be used however the parameter exists for custom depth outputs.
       * @return {Node} The linear depth node.
       */
    }, {
      key: "getLinearDepthNode",
      value: function getLinearDepthNode() {
        var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'depth';
        var linearDepthNode = this._linearDepthNodes[name];
        if (linearDepthNode === undefined) {
          var _cameraNear2 = this._cameraNear;
          var _cameraFar2 = this._cameraFar;
          var viewZNode = this.getViewZNode(name);

          // TODO: just if ( builder.camera.isPerspectiveCamera )

          this._linearDepthNodes[name] = linearDepthNode = viewZToOrthographicDepth(viewZNode, _cameraNear2, _cameraFar2);
        }
        return linearDepthNode;
      }
    }, {
      key: "setup",
      value: function setup(_ref162) {
        var renderer = _ref162.renderer;
        this.renderTarget.samples = this.options.samples === undefined ? renderer.samples : this.options.samples;

        // Disable MSAA for WebGL backend for now
        if (renderer.backend.isWebGLBackend === true) {
          this.renderTarget.samples = 0;
        }
        return this.scope === PassNode.COLOR ? this.getTextureNode() : this.getLinearDepthNode();
      }
    }, {
      key: "updateBefore",
      value: function updateBefore(frame) {
        var renderer = frame.renderer;
        var scene = this.scene,
          camera = this.camera;
        this._pixelRatio = renderer.getPixelRatio();
        var size = renderer.getSize(_size);
        this.setSize(size.width, size.height);
        var currentRenderTarget = renderer.getRenderTarget();
        var currentMRT = renderer.getMRT();
        this._cameraNear.value = camera.near;
        this._cameraFar.value = camera.far;
        for (var name in this._previousTextures) {
          this.toggleTexture(name);
        }
        renderer.setRenderTarget(this.renderTarget);
        renderer.setMRT(this._mrt);
        renderer.render(scene, camera);
        renderer.setRenderTarget(currentRenderTarget);
        renderer.setMRT(currentMRT);
      }

      /**
       * Sets the size of the pass's render target. Honors the pixel ratio.
       *
       * @param {Number} width - The width to set.
       * @param {Number} height - The height to set.
       */
    }, {
      key: "setSize",
      value: function setSize(width, height) {
        this._width = width;
        this._height = height;
        var effectiveWidth = this._width * this._pixelRatio;
        var effectiveHeight = this._height * this._pixelRatio;
        this.renderTarget.setSize(effectiveWidth, effectiveHeight);
      }

      /**
       * Sets the pixel ratio the pass's render target and updates the size.
       *
       * @param {Number} pixelRatio - The pixel ratio to set.
       */
    }, {
      key: "setPixelRatio",
      value: function setPixelRatio(pixelRatio) {
        this._pixelRatio = pixelRatio;
        this.setSize(this._width, this._height);
      }

      /**
       * Frees internal resources. Should be called when the node is no longer in use.
       */
    }, {
      key: "dispose",
      value: function dispose() {
        this.renderTarget.dispose();
      }
    }], [{
      key: "type",
      get: function get() {
        return 'PassNode';
      }
    }]);
  }(TempNode);
  PassNode.COLOR = 'color';
  PassNode.DEPTH = 'depth';

  /**
   * TSL function for creating a pass node.
   *
   * @function
   * @param {Scene} scene - A reference to the scene.
   * @param {Camera} camera - A reference to the camera.
   * @param {Object} options - Options for the internal render target.
   * @returns {PassNode}
   */
  var pass = function pass(scene, camera, options) {
    return nodeObject(new PassNode(PassNode.COLOR, scene, camera, options));
  };

  /**
   * TSL function for creating a pass texture node.
   *
   * @function
   * @param {PassNode} pass - The pass node.
   * @param {Texture} texture - The output texture.
   * @returns {PassTextureNode}
   */
  var passTexture = function passTexture(pass, texture) {
    return nodeObject(new PassTextureNode(pass, texture));
  };

  /**
   * TSL function for creating a depth pass node.
   *
   * @function
   * @param {Scene} scene - A reference to the scene.
   * @param {Camera} camera - A reference to the camera.
   * @param {Object} options - Options for the internal render target.
   * @returns {PassNode}
   */
  var depthPass = function depthPass(scene, camera, options) {
    return nodeObject(new PassNode(PassNode.DEPTH, scene, camera, options));
  };

  /** @module ToonOutlinePassNode **/

  /**
   * Represents a render pass for producing a toon outline effect on compatible objects.
   * Only 3D objects with materials of type `MeshToonMaterial` and `MeshToonNodeMaterial`
   * will receive the outline.
   *
   * ```js
   * const postProcessing = new PostProcessing( renderer );
   *
   * const scenePass = toonOutlinePass( scene, camera );
   *
   * postProcessing.outputNode = scenePass;
   * ```
   * @augments PassNode
   */
  var ToonOutlinePassNode = exports.ToonOutlinePassNode = /*#__PURE__*/function (_PassNode) {
    /**
     * Constructs a new outline pass node.
     *
     * @param {Scene} scene - A reference to the scene.
     * @param {Camera} camera - A reference to the camera.
     * @param {Node} colorNode - Defines the outline's color.
     * @param {Node} thicknessNode - Defines the outline's thickness.
     * @param {Node} alphaNode - Defines the outline's alpha.
     */
    function ToonOutlinePassNode(scene, camera, colorNode, thicknessNode, alphaNode) {
      var _this149;
      (0, _classCallCheck2.default)(this, ToonOutlinePassNode);
      _this149 = _callSuper(this, ToonOutlinePassNode, [PassNode.COLOR, scene, camera]);

      /**
       * Defines the outline's color.
       *
       * @type {Node}
       */
      _this149.colorNode = colorNode;

      /**
       * Defines the outline's thickness.
       *
       * @type {Node}
       */
      _this149.thicknessNode = thicknessNode;

      /**
       * Defines the outline's alpha.
       *
       * @type {Node}
       */
      _this149.alphaNode = alphaNode;

      /**
       * An internal material cache.
       *
       * @private
       * @type {WeakMap<Material, NodeMaterial>}
       */
      _this149._materialCache = new WeakMap();
      return _this149;
    }
    (0, _inherits2.default)(ToonOutlinePassNode, _PassNode);
    return (0, _createClass2.default)(ToonOutlinePassNode, [{
      key: "updateBefore",
      value: function updateBefore(frame) {
        var _this150 = this;
        var renderer = frame.renderer;
        var currentRenderObjectFunction = renderer.getRenderObjectFunction();
        renderer.setRenderObjectFunction(function (object, scene, camera, geometry, material, group, lightsNode, clippingContext) {
          // only render outline for supported materials

          if (material.isMeshToonMaterial || material.isMeshToonNodeMaterial) {
            if (material.wireframe === false) {
              var outlineMaterial = _this150._getOutlineMaterial(material);
              renderer.renderObject(object, scene, camera, geometry, outlineMaterial, group, lightsNode, clippingContext);
            }
          }

          // default

          renderer.renderObject(object, scene, camera, geometry, material, group, lightsNode, clippingContext);
        });
        _superPropGet(ToonOutlinePassNode, "updateBefore", this, 3)([frame]);
        renderer.setRenderObjectFunction(currentRenderObjectFunction);
      }

      /**
       * Creates the material used for outline rendering.
       *
       * @private
       * @return {NodeMaterial} The outline material.
       */
    }, {
      key: "_createMaterial",
      value: function _createMaterial() {
        var material = new NodeMaterial();
        material.isMeshToonOutlineMaterial = true;
        material.name = 'Toon_Outline';
        material.side = _$$_REQUIRE(_dependencyMap[1], "./three.core.js").BackSide;

        // vertex node

        var outlineNormal = normalLocal.negate();
        var mvp = cameraProjectionMatrix.mul(modelViewMatrix);
        var ratio = float(1.0); // TODO: support outline thickness ratio for each vertex
        var pos = mvp.mul(vec4(positionLocal, 1.0));
        var pos2 = mvp.mul(vec4(positionLocal.add(outlineNormal), 1.0));
        var norm = normalize(pos.sub(pos2)); // NOTE: subtract pos2 from pos because BackSide objectNormal is negative

        material.vertexNode = pos.add(norm.mul(this.thicknessNode).mul(pos.w).mul(ratio));

        // color node

        material.colorNode = vec4(this.colorNode, this.alphaNode);
        return material;
      }

      /**
       * For the given toon material, this method returns a corresponding
       * outline material.
       *
       * @private
       * @param {(MeshToonMaterial|MeshToonNodeMaterial)} originalMaterial - The toon material.
       * @return {NodeMaterial} The outline material.
       */
    }, {
      key: "_getOutlineMaterial",
      value: function _getOutlineMaterial(originalMaterial) {
        var outlineMaterial = this._materialCache.get(originalMaterial);
        if (outlineMaterial === undefined) {
          outlineMaterial = this._createMaterial();
          this._materialCache.set(originalMaterial, outlineMaterial);
        }
        return outlineMaterial;
      }
    }], [{
      key: "type",
      get: function get() {
        return 'ToonOutlinePassNode';
      }
    }]);
  }(PassNode);
  /**
   * TSL function for creating a toon outline pass node.
   *
   * @function
   * @param {Scene} scene - A reference to the scene.
   * @param {Camera} camera - A reference to the camera.
   * @param {Color} color - Defines the outline's color.
   * @param {Number} [thickness=0.003] - Defines the outline's thickness.
   * @param {Number} [alpha=1] - Defines the outline's alpha.
   * @returns {ToonOutlinePassNode}
   */
  var toonOutlinePass = function toonOutlinePass(scene, camera) {
    var color = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new (_$$_REQUIRE(_dependencyMap[1], "./three.core.js").Color)(0, 0, 0);
    var thickness = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0.003;
    var alpha = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 1;
    return nodeObject(new ToonOutlinePassNode(scene, camera, nodeObject(color), nodeObject(thickness), nodeObject(alpha)));
  };

  /** @module ToneMappingFunctions **/

  /**
   * Linear tone mapping, exposure only.
   *
   * @method
   * @param {Node<vec3>} color - The color that should be tone mapped.
   * @param {Node<float>} exposure - The exposure.
   * @return {Node<vec3>} The tone mapped color.
   */
  var linearToneMapping = /*@__PURE__*/Fn(function (_ref163) {
    var _ref164 = (0, _slicedToArray2.default)(_ref163, 2),
      color = _ref164[0],
      exposure = _ref164[1];
    return color.mul(exposure).clamp();
  }).setLayout({
    name: 'linearToneMapping',
    type: 'vec3',
    inputs: [{
      name: 'color',
      type: 'vec3'
    }, {
      name: 'exposure',
      type: 'float'
    }]
  });

  /**
   * Reinhard tone mapping.
   *
   * Reference: {@link https://www.cs.utah.edu/docs/techreports/2002/pdf/UUCS-02-001.pdf}
   *
   * @method
   * @param {Node<vec3>} color - The color that should be tone mapped.
   * @param {Node<float>} exposure - The exposure.
   * @return {Node<vec3>} The tone mapped color.
   */
  var reinhardToneMapping = /*@__PURE__*/Fn(function (_ref165) {
    var _ref166 = (0, _slicedToArray2.default)(_ref165, 2),
      color = _ref166[0],
      exposure = _ref166[1];
    color = color.mul(exposure);
    return color.div(color.add(1.0)).clamp();
  }).setLayout({
    name: 'reinhardToneMapping',
    type: 'vec3',
    inputs: [{
      name: 'color',
      type: 'vec3'
    }, {
      name: 'exposure',
      type: 'float'
    }]
  });

  /**
   * Cineon tone mapping.
   *
   * Reference: {@link http://filmicworlds.com/blog/filmic-tonemapping-operators/}
   *
   * @method
   * @param {Node<vec3>} color - The color that should be tone mapped.
   * @param {Node<float>} exposure - The exposure.
   * @return {Node<vec3>} The tone mapped color.
   */
  var cineonToneMapping = /*@__PURE__*/Fn(function (_ref167) {
    var _ref168 = (0, _slicedToArray2.default)(_ref167, 2),
      color = _ref168[0],
      exposure = _ref168[1];
    // filmic operator by Jim Hejl and Richard Burgess-Dawson
    color = color.mul(exposure);
    color = color.sub(0.004).max(0.0);
    var a = color.mul(color.mul(6.2).add(0.5));
    var b = color.mul(color.mul(6.2).add(1.7)).add(0.06);
    return a.div(b).pow(2.2);
  }).setLayout({
    name: 'cineonToneMapping',
    type: 'vec3',
    inputs: [{
      name: 'color',
      type: 'vec3'
    }, {
      name: 'exposure',
      type: 'float'
    }]
  });

  // source: https://github.com/selfshadow/ltc_code/blob/master/webgl/shaders/ltc/ltc_blit.fs

  var RRTAndODTFit = /*@__PURE__*/Fn(function (_ref169) {
    var _ref170 = (0, _slicedToArray2.default)(_ref169, 1),
      color = _ref170[0];
    var a = color.mul(color.add(0.0245786)).sub(0.000090537);
    var b = color.mul(color.add(0.4329510).mul(0.983729)).add(0.238081);
    return a.div(b);
  });

  /**
   * ACESFilmic tone mapping.
   *
   * Reference: {@link https://github.com/selfshadow/ltc_code/blob/master/webgl/shaders/ltc/ltc_blit.fs}
   *
   * @method
   * @param {Node<vec3>} color - The color that should be tone mapped.
   * @param {Node<float>} exposure - The exposure.
   * @return {Node<vec3>} The tone mapped color.
   */
  var acesFilmicToneMapping = /*@__PURE__*/Fn(function (_ref171) {
    var _ref172 = (0, _slicedToArray2.default)(_ref171, 2),
      color = _ref172[0],
      exposure = _ref172[1];
    // sRGB => XYZ => D65_2_D60 => AP1 => RRT_SAT
    var ACESInputMat = mat3(0.59719, 0.35458, 0.04823, 0.07600, 0.90834, 0.01566, 0.02840, 0.13383, 0.83777);

    // ODT_SAT => XYZ => D60_2_D65 => sRGB
    var ACESOutputMat = mat3(1.60475, -0.53108, -0.07367, -0.10208, 1.10813, -0.00605, -0.00327, -0.07276, 1.07602);
    color = color.mul(exposure).div(0.6);
    color = ACESInputMat.mul(color);

    // Apply RRT and ODT
    color = RRTAndODTFit(color);
    color = ACESOutputMat.mul(color);

    // Clamp to [0, 1]
    return color.clamp();
  }).setLayout({
    name: 'acesFilmicToneMapping',
    type: 'vec3',
    inputs: [{
      name: 'color',
      type: 'vec3'
    }, {
      name: 'exposure',
      type: 'float'
    }]
  });
  var LINEAR_REC2020_TO_LINEAR_SRGB = /*@__PURE__*/mat3(vec3(1.6605, -0.1246, -0.0182), vec3(-0.5876, 1.1329, -0.1006), vec3(-0.0728, -0.0083, 1.1187));
  var LINEAR_SRGB_TO_LINEAR_REC2020 = /*@__PURE__*/mat3(vec3(0.6274, 0.0691, 0.0164), vec3(0.3293, 0.9195, 0.0880), vec3(0.0433, 0.0113, 0.8956));
  var agxDefaultContrastApprox = /*@__PURE__*/Fn(function (_ref173) {
    var _ref174 = (0, _slicedToArray2.default)(_ref173, 1),
      x_immutable = _ref174[0];
    var x = vec3(x_immutable).toVar();
    var x2 = vec3(x.mul(x)).toVar();
    var x4 = vec3(x2.mul(x2)).toVar();
    return float(15.5).mul(x4.mul(x2)).sub(mul(40.14, x4.mul(x))).add(mul(31.96, x4).sub(mul(6.868, x2.mul(x))).add(mul(0.4298, x2).add(mul(0.1191, x).sub(0.00232))));
  });

  /**
   * AgX tone mapping.
   *
   * @method
   * @param {Node<vec3>} color - The color that should be tone mapped.
   * @param {Node<float>} exposure - The exposure.
   * @return {Node<vec3>} The tone mapped color.
   */
  var agxToneMapping = /*@__PURE__*/Fn(function (_ref175) {
    var _ref176 = (0, _slicedToArray2.default)(_ref175, 2),
      color = _ref176[0],
      exposure = _ref176[1];
    var colortone = vec3(color).toVar();
    var AgXInsetMatrix = mat3(vec3(0.856627153315983, 0.137318972929847, 0.11189821299995), vec3(0.0951212405381588, 0.761241990602591, 0.0767994186031903), vec3(0.0482516061458583, 0.101439036467562, 0.811302368396859));
    var AgXOutsetMatrix = mat3(vec3(1.1271005818144368, -0.1413297634984383, -0.14132976349843826), vec3(-0.11060664309660323, 1.157823702216272, -0.11060664309660294), vec3(-0.016493938717834573, -0.016493938717834257, 1.2519364065950405));
    var AgxMinEv = float(-12.47393);
    var AgxMaxEv = float(4.026069);
    colortone.mulAssign(exposure);
    colortone.assign(LINEAR_SRGB_TO_LINEAR_REC2020.mul(colortone));
    colortone.assign(AgXInsetMatrix.mul(colortone));
    colortone.assign(max$1(colortone, 1e-10));
    colortone.assign(log2(colortone));
    colortone.assign(colortone.sub(AgxMinEv).div(AgxMaxEv.sub(AgxMinEv)));
    colortone.assign(clamp(colortone, 0.0, 1.0));
    colortone.assign(agxDefaultContrastApprox(colortone));
    colortone.assign(AgXOutsetMatrix.mul(colortone));
    colortone.assign(pow(max$1(vec3(0.0), colortone), vec3(2.2)));
    colortone.assign(LINEAR_REC2020_TO_LINEAR_SRGB.mul(colortone));
    colortone.assign(clamp(colortone, 0.0, 1.0));
    return colortone;
  }).setLayout({
    name: 'agxToneMapping',
    type: 'vec3',
    inputs: [{
      name: 'color',
      type: 'vec3'
    }, {
      name: 'exposure',
      type: 'float'
    }]
  });

  /**
   * Neutral tone mapping.
   *
   * Reference: {@link https://modelviewer.dev/examples/tone-mapping}
   *
   * @method
   * @param {Node<vec3>} color - The color that should be tone mapped.
   * @param {Node<float>} exposure - The exposure.
   * @return {Node<vec3>} The tone mapped color.
   */
  var neutralToneMapping = /*@__PURE__*/Fn(function (_ref177) {
    var _ref178 = (0, _slicedToArray2.default)(_ref177, 2),
      color = _ref178[0],
      exposure = _ref178[1];
    var StartCompression = float(0.8 - 0.04);
    var Desaturation = float(0.15);
    color = color.mul(exposure);
    var x = min$1(color.r, min$1(color.g, color.b));
    var offset = select(x.lessThan(0.08), x.sub(mul(6.25, x.mul(x))), 0.04);
    color.subAssign(offset);
    var peak = max$1(color.r, max$1(color.g, color.b));
    If(peak.lessThan(StartCompression), function () {
      return color;
    });
    var d = sub(1, StartCompression);
    var newPeak = sub(1, d.mul(d).div(peak.add(d.sub(StartCompression))));
    color.mulAssign(newPeak.div(peak));
    var g = sub(1, div(1, Desaturation.mul(peak.sub(newPeak)).add(1)));
    return mix(color, vec3(newPeak), g);
  }).setLayout({
    name: 'neutralToneMapping',
    type: 'vec3',
    inputs: [{
      name: 'color',
      type: 'vec3'
    }, {
      name: 'exposure',
      type: 'float'
    }]
  });

  /** @module CodeNode **/

  /**
   * This class represents native code sections. It is the base
   * class for modules like {@link FunctionNode} which allows to implement
   * functions with native shader languages.
   *
   * @augments Node
   */
  var CodeNode = exports.CodeNode = /*#__PURE__*/function (_Node45) {
    /**
     * Constructs a new code node.
     *
     * @param {String} [code=''] - The native code.
     * @param {Array<Node>} [includes=[]] - An array of includes.
     * @param {('js'|'wgsl'|'glsl')} [language=''] - The used language.
     */
    function CodeNode() {
      var _this151;
      var code = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
      var includes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
      var language = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';
      (0, _classCallCheck2.default)(this, CodeNode);
      _this151 = _callSuper(this, CodeNode, ['code']);

      /**
       * This flag can be used for type testing.
       *
       * @type {Boolean}
       * @readonly
       * @default true
       */
      _this151.isCodeNode = true;

      /**
       * The native code.
       *
       * @type {String}
       * @default ''
       */
      _this151.code = code;

      /**
       * An array of includes
       *
       * @type {Array<Node>}
       * @default []
       */
      _this151.includes = includes;

      /**
       * The used language.
       *
       * @type {('js'|'wgsl'|'glsl')}
       * @default ''
       */
      _this151.language = language;
      return _this151;
    }

    /**
     * The method is overwritten so it always returns `true`.
     *
     * @return {Boolean} Whether this node is global or not.
     */
    (0, _inherits2.default)(CodeNode, _Node45);
    return (0, _createClass2.default)(CodeNode, [{
      key: "isGlobal",
      value: function isGlobal() {
        return true;
      }

      /**
       * Sets the includes of this code node.
       *
       * @param {Array<Node>} includes - The includes to set.
       * @return {CodeNode} A reference to this node.
       */
    }, {
      key: "setIncludes",
      value: function setIncludes(includes) {
        this.includes = includes;
        return this;
      }

      /**
       * Returns the includes of this code node.
       *
       * @param {NodeBuilder} builder - The current node builder.
       * @return {Array<Node>} The includes.
       */
    }, {
      key: "getIncludes",
      value: function getIncludes(/*builder*/
      ) {
        return this.includes;
      }
    }, {
      key: "generate",
      value: function generate(builder) {
        var includes = this.getIncludes(builder);
        for (var include of includes) {
          include.build(builder);
        }
        var nodeCode = builder.getCodeFromNode(this, this.getNodeType(builder));
        nodeCode.code = this.code;
        return nodeCode.code;
      }
    }, {
      key: "serialize",
      value: function serialize(data) {
        _superPropGet(CodeNode, "serialize", this, 3)([data]);
        data.code = this.code;
        data.language = this.language;
      }
    }, {
      key: "deserialize",
      value: function deserialize(data) {
        _superPropGet(CodeNode, "deserialize", this, 3)([data]);
        this.code = data.code;
        this.language = data.language;
      }
    }], [{
      key: "type",
      get: function get() {
        return 'CodeNode';
      }
    }]);
  }(Node);
  /**
   * TSL function for creating a code node.
   *
   * @function
   * @param {String} [code=''] - The native code.
   * @param {Array<Node>} [includes=[]] - An array of includes.
   * @param {('js'|'wgsl'|'glsl')} [language=''] - The used language.
   * @returns {CodeNode}
   */
  var code = /*@__PURE__*/nodeProxy(CodeNode);

  /**
   * TSL function for creating a JS code node.
   *
   * @function
   * @param {String} src - The native code.
   * @param {Array<Node>} includes - An array of includes.
   * @returns {CodeNode}
   */
  var js = function js(src, includes) {
    return code(src, includes, 'js');
  };

  /**
   * TSL function for creating a WGSL code node.
   *
   * @function
   * @param {String} src - The native code.
   * @param {Array<Node>} includes - An array of includes.
   * @returns {CodeNode}
   */
  var wgsl = function wgsl(src, includes) {
    return code(src, includes, 'wgsl');
  };

  /**
   * TSL function for creating a GLSL code node.
   *
   * @function
   * @param {String} src - The native code.
   * @param {Array<Node>} includes - An array of includes.
   * @returns {CodeNode}
   */
  var glsl = function glsl(src, includes) {
    return code(src, includes, 'glsl');
  };

  /**
   * This class represents a native shader function. It can be used to implement
   * certain aspects of a node material with native shader code. There are two predefined
   * TSL functions for easier usage.
   *
   * - `wgslFn`: Creates a WGSL function node.
   * - `glslFn`: Creates a GLSL function node.
   *
   * A basic example with one include looks like so:
   *
   * ```js
   * const desaturateWGSLFn = wgslFn( `
   *	fn desaturate( color:vec3<f32> ) -> vec3<f32> {
   *		let lum = vec3<f32>( 0.299, 0.587, 0.114 );
   *		return vec3<f32>( dot( lum, color ) );
   *	}`
   *);
   * const someWGSLFn = wgslFn( `
   *	fn someFn( color:vec3<f32> ) -> vec3<f32> {
   * 		return desaturate( color );
   * 	}
   * `, [ desaturateWGSLFn ] );
   * material.colorNode = someWGSLFn( { color: texture( map ) } );
   *```
   * @augments CodeNode
   */
  var FunctionNode = exports.FunctionNode = /*#__PURE__*/function (_CodeNode) {
    /**
     * Constructs a new function node.
     *
     * @param {String} [code=''] - The native code.
     * @param {Array<Node>} [includes=[]] - An array of includes.
     * @param {('js'|'wgsl'|'glsl')} [language=''] - The used language.
     */
    function FunctionNode() {
      var code = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
      var includes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
      var language = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';
      (0, _classCallCheck2.default)(this, FunctionNode);
      return _callSuper(this, FunctionNode, [code, includes, language]);
    }
    (0, _inherits2.default)(FunctionNode, _CodeNode);
    return (0, _createClass2.default)(FunctionNode, [{
      key: "getNodeType",
      value: function getNodeType(builder) {
        return this.getNodeFunction(builder).type;
      }

      /**
       * Returns the inputs of this function node.
       *
       * @param {NodeBuilder} builder - The current node builder.
       * @return {Array<NodeFunctionInput>} The inputs.
       */
    }, {
      key: "getInputs",
      value: function getInputs(builder) {
        return this.getNodeFunction(builder).inputs;
      }

      /**
       * Returns the node function for this function node.
       *
       * @param {NodeBuilder} builder - The current node builder.
       * @return {NodeFunction} The node function.
       */
    }, {
      key: "getNodeFunction",
      value: function getNodeFunction(builder) {
        var nodeData = builder.getDataFromNode(this);
        var nodeFunction = nodeData.nodeFunction;
        if (nodeFunction === undefined) {
          nodeFunction = builder.parser.parseFunction(this.code);
          nodeData.nodeFunction = nodeFunction;
        }
        return nodeFunction;
      }
    }, {
      key: "generate",
      value: function generate(builder, output) {
        _superPropGet(FunctionNode, "generate", this, 3)([builder]);
        var nodeFunction = this.getNodeFunction(builder);
        var name = nodeFunction.name;
        var type = nodeFunction.type;
        var nodeCode = builder.getCodeFromNode(this, type);
        if (name !== '') {
          // use a custom property name

          nodeCode.name = name;
        }
        var propertyName = builder.getPropertyName(nodeCode);
        var code = this.getNodeFunction(builder).getCode(propertyName);
        nodeCode.code = code + '\n';
        if (output === 'property') {
          return propertyName;
        } else {
          return builder.format(`${propertyName}()`, type, output);
        }
      }
    }], [{
      key: "type",
      get: function get() {
        return 'FunctionNode';
      }
    }]);
  }(CodeNode);
  var nativeFn = function nativeFn(code) {
    var includes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
    var language = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';
    for (var i = 0; i < includes.length; i++) {
      var include = includes[i];

      // TSL Function: glslFn, wgslFn

      if (typeof include === 'function') {
        includes[i] = include.functionNode;
      }
    }
    var functionNode = nodeObject(new FunctionNode(code, includes, language));
    var fn = function fn() {
      return functionNode.call.apply(functionNode, arguments);
    };
    fn.functionNode = functionNode;
    return fn;
  };
  var glslFn = function glslFn(code, includes) {
    return nativeFn(code, includes, 'glsl');
  };
  var wgslFn = function wgslFn(code, includes) {
    return nativeFn(code, includes, 'wgsl');
  };

  /** @module ScriptableValueNode **/

  /**
   * `ScriptableNode` uses this class to manage script inputs and outputs.
   *
   * @augments Node
   */
  var ScriptableValueNode = exports.ScriptableValueNode = /*#__PURE__*/function (_Node46) {
    /**
     * Constructs a new scriptable node.
     *
     * @param {Any} [value=null] - The value.
     */
    function ScriptableValueNode() {
      var _this152;
      var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      (0, _classCallCheck2.default)(this, ScriptableValueNode);
      _this152 = _callSuper(this, ScriptableValueNode);

      /**
       * A reference to the value.
       *
       * @private
       * @default null
       */
      _this152._value = value;

      /**
       * Depending on the type of `_value`, this property might cache parsed data.
       *
       * @private
       * @default null
       */
      _this152._cache = null;

      /**
       * If this node represents an input, this property represents the input type.
       *
       * @type {String?}
       * @default null
       */
      _this152.inputType = null;

      /**
       * If this node represents an output, this property represents the output type.
       *
       * @type {String?}
       * @default null
       */
      _this152.outputType = null;

      /**
       * An event dispatcher for managing events.
       *
       * @type {EventDispatcher}
       */
      _this152.events = new (_$$_REQUIRE(_dependencyMap[1], "./three.core.js").EventDispatcher)();

      /**
       * This flag can be used for type testing.
       *
       * @type {Boolean}
       * @readonly
       * @default true
       */
      _this152.isScriptableValueNode = true;
      return _this152;
    }

    /**
     * Whether this node represents an output or not.
     *
     * @type {Boolean}
     * @readonly
     * @default true
     */
    (0, _inherits2.default)(ScriptableValueNode, _Node46);
    return (0, _createClass2.default)(ScriptableValueNode, [{
      key: "isScriptableOutputNode",
      get: function get() {
        return this.outputType !== null;
      }
    }, {
      key: "value",
      get:
      /**
       * The node's value.
       *
       * @type {Any}
       */
      function get() {
        return this._value;
      }

      /**
       * Dispatches the `refresh` event.
       */,
      set: function set(val) {
        if (this._value === val) return;
        if (this._cache && this.inputType === 'URL' && this.value.value instanceof ArrayBuffer) {
          URL.revokeObjectURL(this._cache);
          this._cache = null;
        }
        this._value = val;
        this.events.dispatchEvent({
          type: 'change'
        });
        this.refresh();
      }
    }, {
      key: "refresh",
      value: function refresh() {
        this.events.dispatchEvent({
          type: 'refresh'
        });
      }

      /**
       * The `value` property usually represents a node or even binary data in form of array buffers.
       * In this case, this method tries to return the actual value behind the complex type.
       *
       * @return {Any} The value.
       */
    }, {
      key: "getValue",
      value: function getValue() {
        var value = this.value;
        if (value && this._cache === null && this.inputType === 'URL' && value.value instanceof ArrayBuffer) {
          this._cache = URL.createObjectURL(new Blob([value.value]));
        } else if (value && value.value !== null && value.value !== undefined && ((this.inputType === 'URL' || this.inputType === 'String') && typeof value.value === 'string' || this.inputType === 'Number' && typeof value.value === 'number' || this.inputType === 'Vector2' && value.value.isVector2 || this.inputType === 'Vector3' && value.value.isVector3 || this.inputType === 'Vector4' && value.value.isVector4 || this.inputType === 'Color' && value.value.isColor || this.inputType === 'Matrix3' && value.value.isMatrix3 || this.inputType === 'Matrix4' && value.value.isMatrix4)) {
          return value.value;
        }
        return this._cache || value;
      }

      /**
       * Overwritten since the node type is inferred from the value.
       *
       * @param {NodeBuilder} builder - The current node builder.
       * @return {String} The node type.
       */
    }, {
      key: "getNodeType",
      value: function getNodeType(builder) {
        return this.value && this.value.isNode ? this.value.getNodeType(builder) : 'float';
      }
    }, {
      key: "setup",
      value: function setup() {
        return this.value && this.value.isNode ? this.value : float();
      }
    }, {
      key: "serialize",
      value: function serialize(data) {
        _superPropGet(ScriptableValueNode, "serialize", this, 3)([data]);
        if (this.value !== null) {
          if (this.inputType === 'ArrayBuffer') {
            data.value = arrayBufferToBase64(this.value);
          } else {
            data.value = this.value ? this.value.toJSON(data.meta).uuid : null;
          }
        } else {
          data.value = null;
        }
        data.inputType = this.inputType;
        data.outputType = this.outputType;
      }
    }, {
      key: "deserialize",
      value: function deserialize(data) {
        _superPropGet(ScriptableValueNode, "deserialize", this, 3)([data]);
        var value = null;
        if (data.value !== null) {
          if (data.inputType === 'ArrayBuffer') {
            value = base64ToArrayBuffer(data.value);
          } else if (data.inputType === 'Texture') {
            value = data.meta.textures[data.value];
          } else {
            value = data.meta.nodes[data.value] || null;
          }
        }
        this.value = value;
        this.inputType = data.inputType;
        this.outputType = data.outputType;
      }
    }], [{
      key: "type",
      get: function get() {
        return 'ScriptableValueNode';
      }
    }]);
  }(Node);
  /**
   * TSL function for creating a scriptable value node.
   *
   * @function
   * @param {Any} [value=null] - The value.
   * @returns {ScriptableValueNode}
   */
  var scriptableValue = /*@__PURE__*/nodeProxy(ScriptableValueNode);

  /** @module ScriptableNode **/

  /**
   * A Map-like data structure for managing resources of scriptable nodes.
   *
   * @augments Map
   */
  var Resources = /*#__PURE__*/function (_Map) {
    function Resources() {
      (0, _classCallCheck2.default)(this, Resources);
      return _callSuper(this, Resources, arguments);
    }
    (0, _inherits2.default)(Resources, _Map);
    return (0, _createClass2.default)(Resources, [{
      key: "get",
      value: function get(key) {
        var callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
        if (this.has(key)) return _superPropGet(Resources, "get", this, 3)([key]);
        if (callback !== null) {
          for (var _len27 = arguments.length, params = new Array(_len27 > 2 ? _len27 - 2 : 0), _key27 = 2; _key27 < _len27; _key27++) {
            params[_key27 - 2] = arguments[_key27];
          }
          var value = callback.apply(void 0, params);
          this.set(key, value);
          return value;
        }
      }
    }]);
  }(/*#__PURE__*/(0, _wrapNativeSuper2.default)(Map));
  var Parameters = /*#__PURE__*/function () {
    function Parameters(scriptableNode) {
      (0, _classCallCheck2.default)(this, Parameters);
      this.scriptableNode = scriptableNode;
    }
    return (0, _createClass2.default)(Parameters, [{
      key: "parameters",
      get: function get() {
        return this.scriptableNode.parameters;
      }
    }, {
      key: "layout",
      get: function get() {
        return this.scriptableNode.getLayout();
      }
    }, {
      key: "getInputLayout",
      value: function getInputLayout(id) {
        return this.scriptableNode.getInputLayout(id);
      }
    }, {
      key: "get",
      value: function get(name) {
        var param = this.parameters[name];
        var value = param ? param.getValue() : null;
        return value;
      }
    }]);
  }();
  /**
   * Defines the resouces (e.g. namespaces) of scriptable nodes.
   *
   * @type {Resources}
   */
  var ScriptableNodeResources = new Resources();

  /**
   * This type of node allows to implement nodes with custom scripts. The script
   * section is represented as an instance of `CodeNode` written with JavaScript.
   * The script itself must adhere to a specific structure.
   *
   * - main(): Executed once by default and every time `node.needsUpdate` is set.
   * - layout: The layout object defines the script's interface (inputs and outputs).
   *
   * ```js
   * ScriptableNodeResources.set( 'TSL', TSL );
   *
   * const scriptableNode = scriptable( js( `
   * 	layout = {
   * 		outputType: 'node',
   * 		elements: [
   * 			{ name: 'source', inputType: 'node' },
   * 		]
   * 	};
   *
   * 	const { mul, oscSine } = TSL;
   *
   * 	function main() {
   * 		const source = parameters.get( 'source' ) || float();
   * 		return mul( source, oscSine() ) );
   * 	}
   *
   * ` ) );
   *
   * scriptableNode.setParameter( 'source', color( 1, 0, 0 ) );
   *
   * const material = new THREE.MeshBasicNodeMaterial();
   * material.colorNode = scriptableNode;
   * ```
   *
   * @augments Node
   */
  var ScriptableNode = exports.ScriptableNode = /*#__PURE__*/function (_Node47) {
    /**
     * Constructs a new scriptable node.
     *
     * @param {CodeNode?} [codeNode=null] - The code node.
     * @param {Object} [parameters={}] - The parameters definition.
     */
    function ScriptableNode() {
      var _this153;
      var codeNode = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      var parameters = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      (0, _classCallCheck2.default)(this, ScriptableNode);
      _this153 = _callSuper(this, ScriptableNode);

      /**
       * The code node.
       *
       * @type {CodeNode?}
       * @default null
       */
      _this153.codeNode = codeNode;

      /**
       * The parameters definition.
       *
       * @type {Object}
       * @default {}
       */
      _this153.parameters = parameters;
      _this153._local = new Resources();
      _this153._output = scriptableValue();
      _this153._outputs = {};
      _this153._source = _this153.source;
      _this153._method = null;
      _this153._object = null;
      _this153._value = null;
      _this153._needsOutputUpdate = true;
      _this153.onRefresh = _this153.onRefresh.bind(_this153);

      /**
       * This flag can be used for type testing.
       *
       * @type {Boolean}
       * @readonly
       * @default true
       */
      _this153.isScriptableNode = true;
      return _this153;
    }

    /**
     * The source code of the scriptable node.
     *
     * @type {String}
     */
    (0, _inherits2.default)(ScriptableNode, _Node47);
    return (0, _createClass2.default)(ScriptableNode, [{
      key: "source",
      get: function get() {
        return this.codeNode ? this.codeNode.code : '';
      }

      /**
       * Sets the reference of a local script variable.
       *
       * @param {String} name - The variable name.
       * @param {Object} value - The reference to set.
       * @return {Resources} The resource map
       */
    }, {
      key: "setLocal",
      value: function setLocal(name, value) {
        return this._local.set(name, value);
      }

      /**
       * Gets the value of a local script variable.
       *
       * @param {String} name - The variable name.
       * @return {Object} The value.
       */
    }, {
      key: "getLocal",
      value: function getLocal(name) {
        return this._local.get(name);
      }

      /**
       * Event listener for the `refresh` event.
       */
    }, {
      key: "onRefresh",
      value: function onRefresh() {
        this._refresh();
      }

      /**
       * Returns an input from the layout with the given id/name.
       *
       * @param {String} id - The id/name of the input.
       * @return {Object} The element entry.
       */
    }, {
      key: "getInputLayout",
      value: function getInputLayout(id) {
        for (var _element of this.getLayout()) {
          if (_element.inputType && (_element.id === id || _element.name === id)) {
            return _element;
          }
        }
      }

      /**
       * Returns an output from the layout with the given id/name.
       *
       * @param {String} id - The id/name of the output.
       * @return {Object} The element entry.
       */
    }, {
      key: "getOutputLayout",
      value: function getOutputLayout(id) {
        for (var _element2 of this.getLayout()) {
          if (_element2.outputType && (_element2.id === id || _element2.name === id)) {
            return _element2;
          }
        }
      }

      /**
       * Defines a script output for the given name and value.
       *
       * @param {String} name - The name of the output.
       * @param {Node} value - The node value.
       * @return {ScriptableNode} A reference to this node.
       */
    }, {
      key: "setOutput",
      value: function setOutput(name, value) {
        var outputs = this._outputs;
        if (outputs[name] === undefined) {
          outputs[name] = scriptableValue(value);
        } else {
          outputs[name].value = value;
        }
        return this;
      }

      /**
       * Returns a script output for the given name.
       *
       * @param {String} name - The name of the output.
       * @return {ScriptableValueNode} The node value.
       */
    }, {
      key: "getOutput",
      value: function getOutput(name) {
        return this._outputs[name];
      }

      /**
       * Returns a paramater for the given name
       *
       * @param {String} name - The name of the parameter.
       * @return {ScriptableValueNode} The node value.
       */
    }, {
      key: "getParameter",
      value: function getParameter(name) {
        return this.parameters[name];
      }

      /**
       * Sets a value for the given parameter name.
       *
       * @param {String} name - The parameter name.
       * @param {Any} value - The parameter value.
       * @return {ScriptableNode} A reference to this node.
       */
    }, {
      key: "setParameter",
      value: function setParameter(name, value) {
        var parameters = this.parameters;
        if (value && value.isScriptableNode) {
          this.deleteParameter(name);
          parameters[name] = value;
          parameters[name].getDefaultOutput().events.addEventListener('refresh', this.onRefresh);
        } else if (value && value.isScriptableValueNode) {
          this.deleteParameter(name);
          parameters[name] = value;
          parameters[name].events.addEventListener('refresh', this.onRefresh);
        } else if (parameters[name] === undefined) {
          parameters[name] = scriptableValue(value);
          parameters[name].events.addEventListener('refresh', this.onRefresh);
        } else {
          parameters[name].value = value;
        }
        return this;
      }

      /**
       * Returns the value of this node which is the value of
       * the default output.
       *
       * @return {Node} The value.
       */
    }, {
      key: "getValue",
      value: function getValue() {
        return this.getDefaultOutput().getValue();
      }

      /**
       * Deletes a parameter from the script.
       *
       * @param {String} name - The parameter to remove.
       * @return {ScriptableNode} A reference to this node.
       */
    }, {
      key: "deleteParameter",
      value: function deleteParameter(name) {
        var valueNode = this.parameters[name];
        if (valueNode) {
          if (valueNode.isScriptableNode) valueNode = valueNode.getDefaultOutput();
          valueNode.events.removeEventListener('refresh', this.onRefresh);
        }
        return this;
      }

      /**
       * Deletes all parameters from the script.
       *
       * @return {ScriptableNode} A reference to this node.
       */
    }, {
      key: "clearParameters",
      value: function clearParameters() {
        for (var name of Object.keys(this.parameters)) {
          this.deleteParameter(name);
        }
        this.needsUpdate = true;
        return this;
      }

      /**
       * Calls a function from the script.
       *
       * @param {String} name - The function name.
       * @param {...Any} params - A list of parameters.
       * @return {Any} The result of the function call.
       */
    }, {
      key: "call",
      value: function call(name) {
        var object = this.getObject();
        var method = object[name];
        if (typeof method === 'function') {
          for (var _len28 = arguments.length, params = new Array(_len28 > 1 ? _len28 - 1 : 0), _key28 = 1; _key28 < _len28; _key28++) {
            params[_key28 - 1] = arguments[_key28];
          }
          return method.apply(void 0, params);
        }
      }

      /**
       * Asynchronously calls a function from the script.
       *
       * @param {String} name - The function name.
       * @param {...Any} params - A list of parameters.
       * @return {Any} The result of the function call.
       */
    }, {
      key: "callAsync",
      value: (function () {
        var _callAsync = (0, _asyncToGenerator2.default)(function* (name) {
          var object = this.getObject();
          var method = object[name];
          if (typeof method === 'function') {
            for (var _len29 = arguments.length, params = new Array(_len29 > 1 ? _len29 - 1 : 0), _key29 = 1; _key29 < _len29; _key29++) {
              params[_key29 - 1] = arguments[_key29];
            }
            return method.constructor.name === 'AsyncFunction' ? yield method.apply(void 0, params) : method.apply(void 0, params);
          }
        });
        function callAsync(_x2) {
          return _callAsync.apply(this, arguments);
        }
        return callAsync;
      }()
      /**
       * Overwritten since the node types is inferred from the script's output.
       *
       * @param {NodeBuilder} builder - The current node builder
       * @return {String} The node type.
       */
      )
    }, {
      key: "getNodeType",
      value: function getNodeType(builder) {
        return this.getDefaultOutputNode().getNodeType(builder);
      }

      /**
       * Refreshes the script node.
       *
       * @param {String?} [output=null] - An optional output.
       */
    }, {
      key: "refresh",
      value: function refresh() {
        var output = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
        if (output !== null) {
          this.getOutput(output).refresh();
        } else {
          this._refresh();
        }
      }

      /**
       * Returns an object representation of the script.
       *
       * @return {Object} The result object.
       */
    }, {
      key: "getObject",
      value: function getObject() {
        var _this154 = this;
        if (this.needsUpdate) this.dispose();
        if (this._object !== null) return this._object;

        //

        var refresh = function refresh() {
          return _this154.refresh();
        };
        var setOutput = function setOutput(id, value) {
          return _this154.setOutput(id, value);
        };
        var parameters = new Parameters(this);
        var THREE = ScriptableNodeResources.get('THREE');
        var TSL = ScriptableNodeResources.get('TSL');
        var method = this.getMethod();
        var params = [parameters, this._local, ScriptableNodeResources, refresh, setOutput, THREE, TSL];
        this._object = method.apply(void 0, params);
        var layout = this._object.layout;
        if (layout) {
          if (layout.cache === false) {
            this._local.clear();
          }

          // default output
          this._output.outputType = layout.outputType || null;
          if (Array.isArray(layout.elements)) {
            for (var _element3 of layout.elements) {
              var id = _element3.id || _element3.name;
              if (_element3.inputType) {
                if (this.getParameter(id) === undefined) this.setParameter(id, null);
                this.getParameter(id).inputType = _element3.inputType;
              }
              if (_element3.outputType) {
                if (this.getOutput(id) === undefined) this.setOutput(id, null);
                this.getOutput(id).outputType = _element3.outputType;
              }
            }
          }
        }
        return this._object;
      }
    }, {
      key: "deserialize",
      value: function deserialize(data) {
        _superPropGet(ScriptableNode, "deserialize", this, 3)([data]);
        for (var name in this.parameters) {
          var valueNode = this.parameters[name];
          if (valueNode.isScriptableNode) valueNode = valueNode.getDefaultOutput();
          valueNode.events.addEventListener('refresh', this.onRefresh);
        }
      }

      /**
       * Returns the layout of the script.
       *
       * @return {Object} The script's layout.
       */
    }, {
      key: "getLayout",
      value: function getLayout() {
        return this.getObject().layout;
      }

      /**
       * Returns default node output of the script.
       *
       * @return {Node} The default node output.
       */
    }, {
      key: "getDefaultOutputNode",
      value: function getDefaultOutputNode() {
        var output = this.getDefaultOutput().value;
        if (output && output.isNode) {
          return output;
        }
        return float();
      }

      /**
       * Returns default output of the script.
       *
       * @return {ScriptableValueNode} The default output.
       */
    }, {
      key: "getDefaultOutput",
      value: function getDefaultOutput() {
        return this._exec()._output;
      }

      /**
       * Returns a function created from the node's script.
       *
       * @return {Function} The function representing the node's code.
       */
    }, {
      key: "getMethod",
      value: function getMethod() {
        if (this.needsUpdate) this.dispose();
        if (this._method !== null) return this._method;

        //

        var parametersProps = ['parameters', 'local', 'global', 'refresh', 'setOutput', 'THREE', 'TSL'];
        var interfaceProps = ['layout', 'init', 'main', 'dispose'];
        var properties = interfaceProps.join(', ');
        var declarations = 'var ' + properties + '; var output = {};\n';
        var returns = '\nreturn { ...output, ' + properties + ' };';
        var code = declarations + this.codeNode.code + returns;

        //

        this._method = (0, _construct2.default)(Function, parametersProps.concat([code]));
        return this._method;
      }

      /**
       * Frees all internal resources.
       */
    }, {
      key: "dispose",
      value: function dispose() {
        if (this._method === null) return;
        if (this._object && typeof this._object.dispose === 'function') {
          this._object.dispose();
        }
        this._method = null;
        this._object = null;
        this._source = null;
        this._value = null;
        this._needsOutputUpdate = true;
        this._output.value = null;
        this._outputs = {};
      }
    }, {
      key: "setup",
      value: function setup() {
        return this.getDefaultOutputNode();
      }
    }, {
      key: "getCacheKey",
      value: function getCacheKey(force) {
        var values = [hashString(this.source), this.getDefaultOutputNode().getCacheKey(force)];
        for (var param in this.parameters) {
          values.push(this.parameters[param].getCacheKey(force));
        }
        return hashArray(values);
      }
    }, {
      key: "needsUpdate",
      get: function get() {
        return this.source !== this._source;
      }

      /**
       * Executes the `main` function of the script.
       *
       * @private
       * @return {ScriptableNode} A reference to this node.
       */,
      set: function set(value) {
        if (value === true) this.dispose();
      }
    }, {
      key: "_exec",
      value: function _exec() {
        if (this.codeNode === null) return this;
        if (this._needsOutputUpdate === true) {
          this._value = this.call('main');
          this._needsOutputUpdate = false;
        }
        this._output.value = this._value;
        return this;
      }

      /**
       * Executes the refresh.
       *
       * @private
       */
    }, {
      key: "_refresh",
      value: function _refresh() {
        this.needsUpdate = true;
        this._exec();
        this._output.refresh();
      }
    }], [{
      key: "type",
      get: function get() {
        return 'ScriptableNode';
      }
    }]);
  }(Node);
  /**
   * TSL function for creating a scriptable node.
   *
   * @function
   * @param {CodeNode?} [codeNode=null] - The code node.
   * @param {Object} [parameters={}] - The parameters definition.
   * @returns {ScriptableNode}
   */
  var scriptable = /*@__PURE__*/nodeProxy(ScriptableNode);

  /** @module Fog **/

  /**
   * Returns a node that represents the `z` coordinate in view space
   * for the current fragment. It's a different representation of the
   * default depth value.
   *
   * This value can be part of a computation that defines how the fog
   * density increases when moving away from the camera.
   *
   * @param {NodeBuilder} builder - The current node builder.
   * @return {Node} The viewZ node.
   */
  function getViewZNode(builder) {
    var viewZ;
    var getViewZ = builder.context.getViewZ;
    if (getViewZ !== undefined) {
      viewZ = getViewZ(this);
    }
    return (viewZ || positionView.z).negate();
  }

  /**
   * Constructs a new range factor node.
   *
   * @function
   * @param {Node} near - Defines the near value.
   * @param {Node} far - Defines the far value.
   */
  var rangeFogFactor = Fn(function (_ref179, builder) {
    var _ref180 = (0, _slicedToArray2.default)(_ref179, 2),
      near = _ref180[0],
      far = _ref180[1];
    var viewZ = getViewZNode(builder);
    return smoothstep(near, far, viewZ);
  });

  /**
   * Represents an exponential squared fog. This type of fog gives
   * a clear view near the camera and a faster than exponentially
   * densening fog farther from the camera.
   *
   * @function
   * @param {Node} density - Defines the fog density.
   */
  var densityFogFactor = Fn(function (_ref181, builder) {
    var _ref182 = (0, _slicedToArray2.default)(_ref181, 1),
      density = _ref182[0];
    var viewZ = getViewZNode(builder);
    return density.mul(density, viewZ, viewZ).negate().exp().oneMinus();
  });

  /**
   * This class can be used to configure a fog for the scene.
   * Nodes of this type are assigned to `Scene.fogNode`.
   *
   * @function
   * @param {Node} color - Defines the color of the fog.
   * @param {Node} factor - Defines how the fog is factored in the scene.
   */
  var fog = Fn(function (_ref183) {
    var _ref184 = (0, _slicedToArray2.default)(_ref183, 2),
      color = _ref184[0],
      factor = _ref184[1];
    return vec4(factor.toFloat().mix(output.rgb, color.toVec3()), output.a);
  });

  // Deprecated

  function rangeFog(color, near, far) {
    // @deprecated, r171

    console.warn('THREE.TSL: "rangeFog( color, near, far )" is deprecated. Use "fog( color, rangeFogFactor( near, far ) )" instead.');
    return fog(color, rangeFogFactor(near, far));
  }
  function densityFog(color, density) {
    // @deprecated, r171

    console.warn('THREE.TSL: "densityFog( color, density )" is deprecated. Use "fog( color, densityFogFactor( density ) )" instead.');
    return fog(color, densityFogFactor(density));
  }

  /** @module RangeNode **/

  var min = null;
  var max = null;

  /**
   * `RangeNode` generates random instanced attribute data in a defined range.
   * An exemplary use case for this utility node is to generate random per-instance
   * colors:
   * ```js
   * const material = new MeshBasicNodeMaterial();
   * material.colorNode = range( new Color( 0x000000 ), new Color( 0xFFFFFF ) );
   * const mesh = new InstancedMesh( geometry, material, count );
   * ```
   * @augments Node
   */
  var RangeNode = exports.RangeNode = /*#__PURE__*/function (_Node48) {
    /**
     * Constructs a new range node.
     *
     * @param {Node<any>} [minNode=float()] - A node defining the lower bound of the range.
     * @param {Node<any>} [maxNode=float()] - A node defining the upper bound of the range.
     */
    function RangeNode() {
      var _this155;
      var minNode = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : float();
      var maxNode = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : float();
      (0, _classCallCheck2.default)(this, RangeNode);
      _this155 = _callSuper(this, RangeNode);

      /**
       *  A node defining the lower bound of the range.
       *
       * @type {Node<any>}
       * @default float()
       */
      _this155.minNode = minNode;

      /**
       *  A node defining the upper bound of the range.
       *
       * @type {Node<any>}
       * @default float()
       */
      _this155.maxNode = maxNode;
      return _this155;
    }

    /**
     * Returns the vector length which is computed based on the range definition.
     *
     * @param {NodeBuilder} builder - The current node builder.
     * @return {Number} The vector length.
     */
    (0, _inherits2.default)(RangeNode, _Node48);
    return (0, _createClass2.default)(RangeNode, [{
      key: "getVectorLength",
      value: function getVectorLength(builder) {
        var minLength = builder.getTypeLength(getValueType(this.minNode.value));
        var maxLength = builder.getTypeLength(getValueType(this.maxNode.value));
        return minLength > maxLength ? minLength : maxLength;
      }

      /**
       * This method is overwritten since the node type is inferred from range definition.
       *
       * @param {NodeBuilder} builder - The current node builder.
       * @return {String} The node type.
       */
    }, {
      key: "getNodeType",
      value: function getNodeType(builder) {
        return builder.object.count > 1 ? builder.getTypeFromLength(this.getVectorLength(builder)) : 'float';
      }
    }, {
      key: "setup",
      value: function setup(builder) {
        var object = builder.object;
        var output = null;
        if (object.count > 1) {
          var minValue = this.minNode.value;
          var maxValue = this.maxNode.value;
          var minLength = builder.getTypeLength(getValueType(minValue));
          var maxLength = builder.getTypeLength(getValueType(maxValue));
          min = min || new (_$$_REQUIRE(_dependencyMap[1], "./three.core.js").Vector4)();
          max = max || new (_$$_REQUIRE(_dependencyMap[1], "./three.core.js").Vector4)();
          min.setScalar(0);
          max.setScalar(0);
          if (minLength === 1) min.setScalar(minValue);else if (minValue.isColor) min.set(minValue.r, minValue.g, minValue.b, 1);else min.set(minValue.x, minValue.y, minValue.z || 0, minValue.w || 0);
          if (maxLength === 1) max.setScalar(maxValue);else if (maxValue.isColor) max.set(maxValue.r, maxValue.g, maxValue.b, 1);else max.set(maxValue.x, maxValue.y, maxValue.z || 0, maxValue.w || 0);
          var stride = 4;
          var _length = stride * object.count;
          var array = new Float32Array(_length);
          for (var i = 0; i < _length; i++) {
            var index = i % stride;
            var minElementValue = min.getComponent(index);
            var maxElementValue = max.getComponent(index);
            array[i] = _$$_REQUIRE(_dependencyMap[1], "./three.core.js").MathUtils.lerp(minElementValue, maxElementValue, Math.random());
          }
          var nodeType = this.getNodeType(builder);
          if (object.count <= 4096) {
            output = buffer(array, 'vec4', object.count).element(instanceIndex).convert(nodeType);
          } else {
            // TODO: Improve anonymous buffer attribute creation removing this part
            var _bufferAttribute3 = new (_$$_REQUIRE(_dependencyMap[1], "./three.core.js").InstancedBufferAttribute)(array, 4);
            builder.geometry.setAttribute('__range' + this.id, _bufferAttribute3);
            output = instancedBufferAttribute(_bufferAttribute3).convert(nodeType);
          }
        } else {
          output = float(0);
        }
        return output;
      }
    }], [{
      key: "type",
      get: function get() {
        return 'RangeNode';
      }
    }]);
  }(Node);
  /**
   * TSL function for creating a range node.
   *
   * @function
   * @param {Node<any>} [minNode=float()] - A node defining the lower bound of the range.
   * @param {Node<any>} [maxNode=float()] - A node defining the upper bound of the range.
   * @returns {RangeNode}
   */
  var range = /*@__PURE__*/nodeProxy(RangeNode);

  /** @module ComputeBuiltinNode **/

  /**
   * `ComputeBuiltinNode` represents a compute-scope builtin value that expose information
   * about the currently running dispatch and/or the device it is running on.
   *
   * This node can only be used with a WebGPU backend.
   *
   * @augments Node
   */
  var ComputeBuiltinNode = /*#__PURE__*/function (_Node49) {
    /**
     * Constructs a new compute builtin node.
     *
     * @param {String} builtinName - The built-in name.
     * @param {String} nodeType - The node type.
     */
    function ComputeBuiltinNode(builtinName, nodeType) {
      var _this156;
      (0, _classCallCheck2.default)(this, ComputeBuiltinNode);
      _this156 = _callSuper(this, ComputeBuiltinNode, [nodeType]);

      /**
       * The built-in name.
       *
       * @private
       * @type {String}
       */
      _this156._builtinName = builtinName;
      return _this156;
    }

    /**
     * This method is overwritten since hash is derived from the built-in name.
     *
     * @param {NodeBuilder} builder - The current node builder.
     * @return {String} The hash.
     */
    (0, _inherits2.default)(ComputeBuiltinNode, _Node49);
    return (0, _createClass2.default)(ComputeBuiltinNode, [{
      key: "getHash",
      value: function getHash(builder) {
        return this.getBuiltinName(builder);
      }

      /**
       * This method is overwritten since the node type is simply derived from `nodeType`..
       *
       * @param {NodeBuilder} builder - The current node builder.
       * @return {String} The node type.
       */
    }, {
      key: "getNodeType",
      value: function getNodeType(/*builder*/
      ) {
        return this.nodeType;
      }

      /**
       * Sets the builtin name.
       *
       * @param {String} builtinName - The built-in name.
       * @return {ComputeBuiltinNode} A reference to this node.
       */
    }, {
      key: "setBuiltinName",
      value: function setBuiltinName(builtinName) {
        this._builtinName = builtinName;
        return this;
      }

      /**
       * Returns the builtin name.
       *
       * @param {NodeBuilder} builder - The current node builder.
       * @return {String} The builtin name.
       */
    }, {
      key: "getBuiltinName",
      value: function getBuiltinName(/*builder*/
      ) {
        return this._builtinName;
      }

      /**
       * Whether the current node builder has the builtin or not.
       *
       * @param {NodeBuilder} builder - The current node builder.
       */
    }, {
      key: "hasBuiltin",
      value: function hasBuiltin(builder) {
        builder.hasBuiltin(this._builtinName);
      }
    }, {
      key: "generate",
      value: function generate(builder, output) {
        var builtinName = this.getBuiltinName(builder);
        var nodeType = this.getNodeType(builder);
        if (builder.shaderStage === 'compute') {
          return builder.format(builtinName, nodeType, output);
        } else {
          console.warn(`ComputeBuiltinNode: Compute built-in value ${builtinName} can not be accessed in the ${builder.shaderStage} stage`);
          return builder.generateConst(nodeType);
        }
      }
    }, {
      key: "serialize",
      value: function serialize(data) {
        _superPropGet(ComputeBuiltinNode, "serialize", this, 3)([data]);
        data.global = this.global;
        data._builtinName = this._builtinName;
      }
    }, {
      key: "deserialize",
      value: function deserialize(data) {
        _superPropGet(ComputeBuiltinNode, "deserialize", this, 3)([data]);
        this.global = data.global;
        this._builtinName = data._builtinName;
      }
    }], [{
      key: "type",
      get: function get() {
        return 'ComputeBuiltinNode';
      }
    }]);
  }(Node);
  /**
   * TSL function for creating a compute builtin node.
   *
   * @function
   * @param {String} name - The built-in name.
   * @param {String} nodeType - The node type.
   * @returns {ComputeBuiltinNode}
   */
  var computeBuiltin = function computeBuiltin(name, nodeType) {
    return nodeObject(new ComputeBuiltinNode(name, nodeType));
  };

  /**
   * TSL function for creating a `numWorkgroups` builtin node.
   * Represents the number of workgroups dispatched by the compute shader.
   * ```js
   * // Run 512 invocations/threads with a workgroup size of 128.
   * const computeFn = Fn(() => {
   *
   *     // numWorkgroups.x = 4
   *     storageBuffer.element(0).assign(numWorkgroups.x)
   *
   * })().compute(512, [128]);
   *
   * // Run 512 invocations/threads with the default workgroup size of 64.
   * const computeFn = Fn(() => {
   *
   *     // numWorkgroups.x = 8
   *     storageBuffer.element(0).assign(numWorkgroups.x)
   *
   * })().compute(512);
   * ```
   *
   * @function
   * @returns {ComputeBuiltinNode<uvec3>}
   */
  var numWorkgroups = /*@__PURE__*/computeBuiltin('numWorkgroups', 'uvec3');

  /**
   * TSL function for creating a `workgroupId` builtin node.
   * Represents the 3-dimensional index of the workgroup the current compute invocation belongs to.
   * ```js
   * // Execute 12 compute threads with a workgroup size of 3.
   * const computeFn = Fn( () => {
   *
   * 	If( workgroupId.x.modInt( 2 ).equal( 0 ), () => {
   *
   * 		storageBuffer.element( instanceIndex ).assign( instanceIndex );
   *
   * 	} ).Else( () => {
   *
   * 		storageBuffer.element( instanceIndex ).assign( 0 );
   *
   * 	} );
   *
   * } )().compute( 12, [ 3 ] );
   *
   * // workgroupId.x =  [0, 0, 0, 1, 1, 1, 2, 2, 2, 3, 3, 3];
   * // Buffer Output =  [0, 1, 2, 0, 0, 0, 6, 7, 8, 0, 0, 0];
   * ```
   *
   * @function
   * @returns {ComputeBuiltinNode<uvec3>}
   */
  var workgroupId = /*@__PURE__*/computeBuiltin('workgroupId', 'uvec3');

  /**
   * TSL function for creating a `localId` builtin node. A non-linearized 3-dimensional
   * representation of the current invocation's position within a 3D workgroup grid.
   *
   * @function
   * @returns {ComputeBuiltinNode<uvec3>}
   */
  var localId = /*@__PURE__*/computeBuiltin('localId', 'uvec3');

  /**
   * TSL function for creating a `subgroupSize` builtin node. A device dependent variable
   * that exposes the size of the current invocation's subgroup.
   *
   * @function
   * @returns {ComputeBuiltinNode<uint>}
   */
  var subgroupSize = /*@__PURE__*/computeBuiltin('subgroupSize', 'uint');

  /** @module BarrierNode **/

  /**
   * Represents a GPU control barrier that synchronizes compute operations within a given scope.
   *
   * This node can only be used with a WebGPU backend.
   *
   * @augments Node
   */
  var BarrierNode = /*#__PURE__*/function (_Node50) {
    /**
     * Constructs a new barrier node.
     *
     * @param {String} scope - The scope defines the behavior of the node.
     */
    function BarrierNode(scope) {
      var _this157;
      (0, _classCallCheck2.default)(this, BarrierNode);
      _this157 = _callSuper(this, BarrierNode);
      _this157.scope = scope;
      return _this157;
    }
    (0, _inherits2.default)(BarrierNode, _Node50);
    return (0, _createClass2.default)(BarrierNode, [{
      key: "generate",
      value: function generate(builder) {
        var scope = this.scope;
        var renderer = builder.renderer;
        if (renderer.backend.isWebGLBackend === true) {
          builder.addFlowCode(`\t// ${scope}Barrier \n`);
        } else {
          builder.addLineFlowCode(`${scope}Barrier()`, this);
        }
      }
    }]);
  }(Node);
  /**
   * TSL function for creating a barrier node.
   *
   * @function
   * @param {String} scope - The scope defines the behavior of the node..
   * @returns {BarrierNode}
   */
  var barrier = nodeProxy(BarrierNode);

  /**
   * TSL function for creating a workgroup barrier. All compute shader
   * invocations must wait for each invocation within a workgroup to
   * complete before the barrier can be surpassed.
   *
   * @function
   * @returns {BarrierNode}
   */
  var workgroupBarrier = function workgroupBarrier() {
    return barrier('workgroup').append();
  };

  /**
   * TSL function for creating a storage barrier. All invocations must
   * wait for each access to variables within the 'storage' address space
   * to complete before the barrier can be passed.
   *
   * @function
   * @returns {BarrierNode}
   */
  var storageBarrier = function storageBarrier() {
    return barrier('storage').append();
  };

  /**
   * TSL function for creating a texture barrier. All invocations must
   * wait for each access to variables within the 'texture' address space
   * to complete before the barrier can be passed.
   *
   * @function
   * @returns {BarrierNode}
   */
  var textureBarrier = function textureBarrier() {
    return barrier('texture').append();
  };

  /** @module WorkgroupInfoNode **/

  /**
   * Represents an element of a 'workgroup' scoped buffer.
   *
   * @augments ArrayElementNode
   */
  var WorkgroupInfoElementNode = /*#__PURE__*/function (_ArrayElementNode5) {
    /**
     * Constructs a new workgroup info element node.
     *
     * @param {Node} workgroupInfoNode - The workgroup info node.
     * @param {Node} indexNode - The index node that defines the element access.
     */
    function WorkgroupInfoElementNode(workgroupInfoNode, indexNode) {
      var _this158;
      (0, _classCallCheck2.default)(this, WorkgroupInfoElementNode);
      _this158 = _callSuper(this, WorkgroupInfoElementNode, [workgroupInfoNode, indexNode]);

      /**
       * This flag can be used for type testing.
       *
       * @type {Boolean}
       * @readonly
       * @default true
       */
      _this158.isWorkgroupInfoElementNode = true;
      return _this158;
    }
    (0, _inherits2.default)(WorkgroupInfoElementNode, _ArrayElementNode5);
    return (0, _createClass2.default)(WorkgroupInfoElementNode, [{
      key: "generate",
      value: function generate(builder, output) {
        var snippet;
        var isAssignContext = builder.context.assign;
        snippet = _superPropGet(WorkgroupInfoElementNode, "generate", this, 3)([builder]);
        if (isAssignContext !== true) {
          var type = this.getNodeType(builder);
          snippet = builder.format(snippet, type, output);
        }

        // TODO: Possibly activate clip distance index on index access rather than from clipping context

        return snippet;
      }
    }]);
  }(ArrayElementNode);
  /**
   * A node allowing the user to create a 'workgroup' scoped buffer within the
   * context of a compute shader. Typically, workgroup scoped buffers are
   * created to hold data that is transfered from a global storage scope into
   * a local workgroup scope. For invocations within a workgroup, data
   * access speeds on 'workgroup' scoped buffers can be significantly faster
   * than similar access operations on globally accessible storage buffers.
   *
   * This node can only be used with a WebGPU backend.
   *
   * @augments Node
   */
  var WorkgroupInfoNode = /*#__PURE__*/function (_Node51) {
    /**
     * Constructs a new buffer scoped to type scope.
     *
     * @param {String} scope - TODO.
     * @param {String} bufferType - The data type of a 'workgroup' scoped buffer element.
     * @param {Number} [bufferCount=0] - The number of elements in the buffer.
     */
    function WorkgroupInfoNode(scope, bufferType) {
      var _this159;
      var bufferCount = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      (0, _classCallCheck2.default)(this, WorkgroupInfoNode);
      _this159 = _callSuper(this, WorkgroupInfoNode, [bufferType]);

      /**
       * The buffer type.
       *
       * @type {String}
       */
      _this159.bufferType = bufferType;

      /**
       * The buffer count.
       *
       * @type {Number}
       * @default 0
       */
      _this159.bufferCount = bufferCount;

      /**
       * This flag can be used for type testing.
       *
       * @type {Boolean}
       * @readonly
       * @default true
       */
      _this159.isWorkgroupInfoNode = true;

      /**
       * The data type of the array buffer.
       *
       * @type {String}
       */
      _this159.elementType = bufferType;

      /**
       * TODO.
       *
       * @type {String}
       */
      _this159.scope = scope;
      return _this159;
    }

    /**
     * Sets the name/label of this node.
     *
     * @param {String} name - The name to set.
     * @return {WorkgroupInfoNode} A reference to this node.
     */
    (0, _inherits2.default)(WorkgroupInfoNode, _Node51);
    return (0, _createClass2.default)(WorkgroupInfoNode, [{
      key: "label",
      value: function label(name) {
        this.name = name;
        return this;
      }

      /**
       * Sets the scope of this node.
       *
       * @param {String} scope - The scope to set.
       * @return {WorkgroupInfoNode} A reference to this node.
       */
    }, {
      key: "setScope",
      value: function setScope(scope) {
        this.scope = scope;
        return this;
      }

      /**
       * The data type of the array buffer.
       *
       * @return {String} The element type.
       */
    }, {
      key: "getElementType",
      value: function getElementType() {
        return this.elementType;
      }

      /**
       * Overwrites the default implementation since the input type
       * is inferred from the scope.
       *
       * @param {NodeBuilder} builder - The current node builder.
       * @return {String} The input type.
       */
    }, {
      key: "getInputType",
      value: function getInputType(/*builder*/
      ) {
        return `${this.scope}Array`;
      }

      /**
       * This method can be used to access elements via an index node.
       *
       * @param {IndexNode} indexNode - indexNode.
       * @return {WorkgroupInfoElementNode} A reference to an element.
       */
    }, {
      key: "element",
      value: function element(indexNode) {
        return nodeObject(new WorkgroupInfoElementNode(this, indexNode));
      }
    }, {
      key: "generate",
      value: function generate(builder) {
        return builder.getScopedArray(this.name || `${this.scope}Array_${this.id}`, this.scope.toLowerCase(), this.bufferType, this.bufferCount);
      }
    }]);
  }(Node);
  /**
   * TSL function for creating a workgroup info node.
   * Creates a new 'workgroup' scoped array buffer.
   *
   * @function
   * @param {String} type - The data type of a 'workgroup' scoped buffer element.
   * @param {Number} [count=0] - The number of elements in the buffer.
   * @returns {WorkgroupInfoNode}
   */
  var workgroupArray = function workgroupArray(type, count) {
    return nodeObject(new WorkgroupInfoNode('Workgroup', type, count));
  };

  /** @module AtomicFunctionNode **/

  /**
   * `AtomicFunctionNode` represents any function that can operate on atomic variable types
   * within a shader. In an atomic function, any modifiation to an atomic variable will
   * occur as an indivisble step with a defined order relative to other modifications.
   * Accordingly, even if multiple atomic functions are modifying an atomic variable at once
   * atomic operations will not interfer with each other.
   *
   * This node can only be used with a WebGPU backend.
   *
   * @augments TempNode
   */
  var AtomicFunctionNode = /*#__PURE__*/function (_TempNode21) {
    /**
     * Constructs a new atomic function node.
     *
     * @param {String} method - The signature of the atomic function to construct.
     * @param {Node} pointerNode - An atomic variable or element of an atomic buffer.
     * @param {Node} valueNode - The value that mutates the atomic variable.
     * @param {Node?} [storeNode=null] - A variable storing the return value of an atomic operation, typically the value of the atomic variable before the operation.
     */
    function AtomicFunctionNode(method, pointerNode, valueNode) {
      var _this160;
      var storeNode = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
      (0, _classCallCheck2.default)(this, AtomicFunctionNode);
      _this160 = _callSuper(this, AtomicFunctionNode, ['uint']);

      /**
       * The signature of the atomic function to construct.
       *
       * @type {String}
       */
      _this160.method = method;

      /**
       * An atomic variable or element of an atomic buffer.
       *
       * @type {Node}
       */
      _this160.pointerNode = pointerNode;

      /**
       * A value that modifies the atomic variable.
       *
       * @type {Node}
       */
      _this160.valueNode = valueNode;

      /**
       * A variable storing the return value of an atomic operation, typically the value of the atomic variable before the operation.
       *
       * @type {Node?}
       * @default null
       */
      _this160.storeNode = storeNode;
      return _this160;
    }

    /**
     * Overwrites the default implementation to return the type of
     * the pointer node.
     *
     * @param {NodeBuilder} builder - The current node builder.
     * @return {String} The input type.
     */
    (0, _inherits2.default)(AtomicFunctionNode, _TempNode21);
    return (0, _createClass2.default)(AtomicFunctionNode, [{
      key: "getInputType",
      value: function getInputType(builder) {
        return this.pointerNode.getNodeType(builder);
      }

      /**
       * Overwritten since the node type is inferred from the input type.
       *
       * @param {NodeBuilder} builder - The current node builder.
       * @return {String} The node type.
       */
    }, {
      key: "getNodeType",
      value: function getNodeType(builder) {
        return this.getInputType(builder);
      }
    }, {
      key: "generate",
      value: function generate(builder) {
        var method = this.method;
        var type = this.getNodeType(builder);
        var inputType = this.getInputType(builder);
        var a = this.pointerNode;
        var b = this.valueNode;
        var params = [];
        params.push(`&${a.build(builder, inputType)}`);
        params.push(b.build(builder, inputType));
        var methodSnippet = `${builder.getMethod(method, type)}( ${params.join(', ')} )`;
        if (this.storeNode !== null) {
          var varSnippet = this.storeNode.build(builder, inputType);
          builder.addLineFlowCode(`${varSnippet} = ${methodSnippet}`, this);
        } else {
          builder.addLineFlowCode(methodSnippet, this);
        }
      }
    }], [{
      key: "type",
      get: function get() {
        return 'AtomicFunctionNode';
      }
    }]);
  }(TempNode);
  AtomicFunctionNode.ATOMIC_LOAD = 'atomicLoad';
  AtomicFunctionNode.ATOMIC_STORE = 'atomicStore';
  AtomicFunctionNode.ATOMIC_ADD = 'atomicAdd';
  AtomicFunctionNode.ATOMIC_SUB = 'atomicSub';
  AtomicFunctionNode.ATOMIC_MAX = 'atomicMax';
  AtomicFunctionNode.ATOMIC_MIN = 'atomicMin';
  AtomicFunctionNode.ATOMIC_AND = 'atomicAnd';
  AtomicFunctionNode.ATOMIC_OR = 'atomicOr';
  AtomicFunctionNode.ATOMIC_XOR = 'atomicXor';

  /**
   * TSL function for creating an atomic function node.
   *
   * @function
   * @param {String} method - The signature of the atomic function to construct.
   * @param {Node} pointerNode - An atomic variable or element of an atomic buffer.
   * @param {Node} valueNode - The value that mutates the atomic variable.
   * @param {Node?} [storeNode=null] - A variable storing the return value of an atomic operation, typically the value of the atomic variable before the operation.
   * @returns {AtomicFunctionNode}
   */
  var atomicNode = nodeProxy(AtomicFunctionNode);

  /**
   * TSL function for appending an atomic function call into the programmatic flow of a compute shader.
   *
   * @function
   * @param {String} method - The signature of the atomic function to construct.
   * @param {Node} pointerNode - An atomic variable or element of an atomic buffer.
   * @param {Node} valueNode - The value that mutates the atomic variable.
   * @param {Node?} [storeNode=null] - A variable storing the return value of an atomic operation, typically the value of the atomic variable before the operation.
   * @returns {AtomicFunctionNode}
   */
  var atomicFunc = function atomicFunc(method, pointerNode, valueNode) {
    var storeNode = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
    var node = atomicNode(method, pointerNode, valueNode, storeNode);
    node.append();
    return node;
  };

  /**
   * Stores a value in the atomic variable.
   *
   * @function
   * @param {Node} pointerNode - An atomic variable or element of an atomic buffer.
   * @param {Node} valueNode - The value that mutates the atomic variable.
   * @param {Node?} [storeNode=null] - A variable storing the return value of an atomic operation, typically the value of the atomic variable before the operation.
   * @returns {AtomicFunctionNode}
   */
  var atomicStore = function atomicStore(pointerNode, valueNode) {
    var storeNode = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
    return atomicFunc(AtomicFunctionNode.ATOMIC_STORE, pointerNode, valueNode, storeNode);
  };

  /**
   * Increments the value stored in the atomic variable.
   *
   * @function
   * @param {Node} pointerNode - An atomic variable or element of an atomic buffer.
   * @param {Node} valueNode - The value that mutates the atomic variable.
   * @param {Node?} [storeNode=null] - A variable storing the return value of an atomic operation, typically the value of the atomic variable before the operation.
   * @returns {AtomicFunctionNode}
   */
  var atomicAdd = function atomicAdd(pointerNode, valueNode) {
    var storeNode = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
    return atomicFunc(AtomicFunctionNode.ATOMIC_ADD, pointerNode, valueNode, storeNode);
  };

  /**
   * Decrements the value stored in the atomic variable.
   *
   * @function
   * @param {Node} pointerNode - An atomic variable or element of an atomic buffer.
   * @param {Node} valueNode - The value that mutates the atomic variable.
   * @param {Node?} [storeNode=null] - A variable storing the return value of an atomic operation, typically the value of the atomic variable before the operation.
   * @returns {AtomicFunctionNode}
   */
  var atomicSub = function atomicSub(pointerNode, valueNode) {
    var storeNode = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
    return atomicFunc(AtomicFunctionNode.ATOMIC_SUB, pointerNode, valueNode, storeNode);
  };

  /**
   * Stores in an atomic variable the maximum between its current value and a parameter.
   *
   * @function
   * @param {Node} pointerNode - An atomic variable or element of an atomic buffer.
   * @param {Node} valueNode - The value that mutates the atomic variable.
   * @param {Node?} [storeNode=null] - A variable storing the return value of an atomic operation, typically the value of the atomic variable before the operation.
   * @returns {AtomicFunctionNode}
   */
  var atomicMax = function atomicMax(pointerNode, valueNode) {
    var storeNode = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
    return atomicFunc(AtomicFunctionNode.ATOMIC_MAX, pointerNode, valueNode, storeNode);
  };

  /**
   * Stores in an atomic variable the minimum between its current value and a parameter.
   *
   * @function
   * @param {Node} pointerNode - An atomic variable or element of an atomic buffer.
   * @param {Node} valueNode - The value that mutates the atomic variable.
   * @param {Node?} [storeNode=null] - A variable storing the return value of an atomic operation, typically the value of the atomic variable before the operation.
   * @returns {AtomicFunctionNode}
   */
  var atomicMin = function atomicMin(pointerNode, valueNode) {
    var storeNode = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
    return atomicFunc(AtomicFunctionNode.ATOMIC_MIN, pointerNode, valueNode, storeNode);
  };

  /**
   * Stores in an atomic variable the bitwise AND of its value with a parameter.
   *
   * @function
   * @param {Node} pointerNode - An atomic variable or element of an atomic buffer.
   * @param {Node} valueNode - The value that mutates the atomic variable.
   * @param {Node?} [storeNode=null] - A variable storing the return value of an atomic operation, typically the value of the atomic variable before the operation.
   * @returns {AtomicFunctionNode}
   */
  var atomicAnd = function atomicAnd(pointerNode, valueNode) {
    var storeNode = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
    return atomicFunc(AtomicFunctionNode.ATOMIC_AND, pointerNode, valueNode, storeNode);
  };

  /**
   * Stores in an atomic variable the bitwise OR of its value with a parameter.
   *
   * @function
   * @param {Node} pointerNode - An atomic variable or element of an atomic buffer.
   * @param {Node} valueNode - The value that mutates the atomic variable.
   * @param {Node?} [storeNode=null] - A variable storing the return value of an atomic operation, typically the value of the atomic variable before the operation.
   * @returns {AtomicFunctionNode}
   */
  var atomicOr = function atomicOr(pointerNode, valueNode) {
    var storeNode = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
    return atomicFunc(AtomicFunctionNode.ATOMIC_OR, pointerNode, valueNode, storeNode);
  };

  /**
   * Stores in an atomic variable the bitwise XOR of its value with a parameter.
   *
   * @function
   * @param {Node} pointerNode - An atomic variable or element of an atomic buffer.
   * @param {Node} valueNode - The value that mutates the atomic variable.
   * @param {Node?} [storeNode=null] - A variable storing the return value of an atomic operation, typically the value of the atomic variable before the operation.
   * @returns {AtomicFunctionNode}
   */
  var atomicXor = function atomicXor(pointerNode, valueNode) {
    var storeNode = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
    return atomicFunc(AtomicFunctionNode.ATOMIC_XOR, pointerNode, valueNode, storeNode);
  };

  /** @module Lights **/

  var uniformsLib;
  function getLightData(light) {
    uniformsLib = uniformsLib || new WeakMap();
    var uniforms = uniformsLib.get(light);
    if (uniforms === undefined) uniformsLib.set(light, uniforms = {});
    return uniforms;
  }

  /**
   * TSL function for getting a shadow matrix uniform node for the given light.
   *
   * @function
   * @param {Light} light -The light source.
   * @returns {UniformNode<mat4>} The shadow matrix uniform node.
   */
  function lightShadowMatrix(light) {
    var data = getLightData(light);
    return data.shadowMatrix || (data.shadowMatrix = uniform('mat4').setGroup(renderGroup).onRenderUpdate(function () {
      if (light.castShadow !== true) {
        light.shadow.updateMatrices(light);
      }
      return light.shadow.matrix;
    }));
  }

  /**
   * TSL function for getting projected uv coordinates for the given light.
   * Relevant when using maps with spot lights.
   *
   * @function
   * @param {Light} light -The light source.
   * @returns {Node<vec3>} The projected uvs.
   */
  function lightProjectionUV(light) {
    var data = getLightData(light);
    if (data.projectionUV === undefined) {
      var spotLightCoord = lightShadowMatrix(light).mul(positionWorld);
      data.projectionUV = spotLightCoord.xyz.div(spotLightCoord.w);
    }
    return data.projectionUV;
  }

  /**
   * TSL function for getting the position in world space for the given light.
   *
   * @function
   * @param {Light} light -The light source.
   * @returns {UniformNode<vec3>} The light's position in world space.
   */
  function lightPosition(light) {
    var data = getLightData(light);
    return data.position || (data.position = uniform(new (_$$_REQUIRE(_dependencyMap[1], "./three.core.js").Vector3)()).setGroup(renderGroup).onRenderUpdate(function (_, self) {
      return self.value.setFromMatrixPosition(light.matrixWorld);
    }));
  }

  /**
   * TSL function for getting the light target position in world space for the given light.
   *
   * @function
   * @param {Light} light -The light source.
   * @returns {UniformNode<vec3>} The light target position in world space.
   */
  function lightTargetPosition(light) {
    var data = getLightData(light);
    return data.targetPosition || (data.targetPosition = uniform(new (_$$_REQUIRE(_dependencyMap[1], "./three.core.js").Vector3)()).setGroup(renderGroup).onRenderUpdate(function (_, self) {
      return self.value.setFromMatrixPosition(light.target.matrixWorld);
    }));
  }

  /**
   * TSL function for getting the position in view space for the given light.
   *
   * @function
   * @param {Light} light -The light source.
   * @returns {UniformNode<vec3>} The light's position in view space.
   */
  function lightViewPosition(light) {
    var data = getLightData(light);
    return data.viewPosition || (data.viewPosition = uniform(new (_$$_REQUIRE(_dependencyMap[1], "./three.core.js").Vector3)()).setGroup(renderGroup).onRenderUpdate(function (_ref185, self) {
      var camera = _ref185.camera;
      self.value = self.value || new (_$$_REQUIRE(_dependencyMap[1], "./three.core.js").Vector3)();
      self.value.setFromMatrixPosition(light.matrixWorld);
      self.value.applyMatrix4(camera.matrixWorldInverse);
    }));
  }

  /**
   * TSL function for getting the light target direction for the given light.
   *
   * @function
   * @param {Light} light -The light source.
   * @returns {Node<vec3>} The light's target direction.
   */
  var lightTargetDirection = function lightTargetDirection(light) {
    return cameraViewMatrix.transformDirection(lightPosition(light).sub(lightTargetPosition(light)));
  };

  /** @module LightsNode **/

  var sortLights = function sortLights(lights) {
    return lights.sort(function (a, b) {
      return a.id - b.id;
    });
  };
  var getLightNodeById = function getLightNodeById(id, lightNodes) {
    for (var lightNode of lightNodes) {
      if (lightNode.isAnalyticLightNode && lightNode.light.id === id) {
        return lightNode;
      }
    }
    return null;
  };
  var _lightsNodeRef = /*@__PURE__*/new WeakMap();

  /**
   * This node represents the scene's lighting and manages the lighting model's life cycle
   * for the current build 3D object. It is responsible for computing the total outgoing
   * light in a given lighting context.
   *
   * @augments Node
   */
  var LightsNode = exports.LightsNode = /*#__PURE__*/function (_Node52) {
    /**
     * Constructs a new lights node.
     */
    function LightsNode() {
      var _this161;
      (0, _classCallCheck2.default)(this, LightsNode);
      _this161 = _callSuper(this, LightsNode, ['vec3']);

      /**
       * A node representing the total diffuse light.
       *
       * @type {Node<vec3>}
       */
      _this161.totalDiffuseNode = vec3().toVar('totalDiffuse');

      /**
       * A node representing the total specular light.
       *
       * @type {Node<vec3>}
       */
      _this161.totalSpecularNode = vec3().toVar('totalSpecular');

      /**
       * A node representing the outgoing light.
       *
       * @type {Node<vec3>}
       */
      _this161.outgoingLightNode = vec3().toVar('outgoingLight');

      /**
       * An array representing the lights in the scene.
       *
       * @private
       * @type {Array<Light>}
       */
      _this161._lights = [];

      /**
       * For each light in the scene, this node will create a
       * corresponding light node.
       *
       * @private
       * @type {Array<LightingNode>?}
       * @default null
       */
      _this161._lightNodes = null;

      /**
       * A hash for identifying the current light nodes setup.
       *
       * @private
       * @type {String?}
       * @default null
       */
      _this161._lightNodesHash = null;

      /**
       * `LightsNode` sets this property to `true` by default.
       *
       * @type {Boolean}
       * @default true
       */
      _this161.global = true;
      return _this161;
    }

    /**
     * Overwrites the default {@link Node#customCacheKey} implementation by including the
     * light IDs into the cache key.
     *
     * @return {Number} The custom cache key.
     */
    (0, _inherits2.default)(LightsNode, _Node52);
    return (0, _createClass2.default)(LightsNode, [{
      key: "customCacheKey",
      value: function customCacheKey() {
        var lightIDs = [];
        var lights = this._lights;
        for (var i = 0; i < lights.length; i++) {
          lightIDs.push(lights[i].id);
        }
        return hashArray(lightIDs);
      }

      /**
       * Computes a hash value for identifying the current light nodes setup.
       *
       * @param {NodeBuilder} builder - A reference to the current node builder.
       * @return {String} The computed hash.
       */
    }, {
      key: "getHash",
      value: function getHash(builder) {
        if (this._lightNodesHash === null) {
          if (this._lightNodes === null) this.setupLightsNode(builder);
          var _hash = [];
          for (var lightNode of this._lightNodes) {
            _hash.push(lightNode.getSelf().getHash());
          }
          this._lightNodesHash = 'lights-' + _hash.join(',');
        }
        return this._lightNodesHash;
      }
    }, {
      key: "analyze",
      value: function analyze(builder) {
        var properties = builder.getDataFromNode(this);
        for (var node of properties.nodes) {
          node.build(builder);
        }
      }

      /**
       * Creates lighting nodes for each scene light. This makes it possible to further
       * process lights in the node system.
       *
       * @param {NodeBuilder} builder - A reference to the current node builder.
       */
    }, {
      key: "setupLightsNode",
      value: function setupLightsNode(builder) {
        var lightNodes = [];
        var previousLightNodes = this._lightNodes;
        var lights = sortLights(this._lights);
        var nodeLibrary = builder.renderer.library;
        for (var light of lights) {
          if (light.isNode) {
            lightNodes.push(nodeObject(light));
          } else {
            var lightNode = null;
            if (previousLightNodes !== null) {
              lightNode = getLightNodeById(light.id, previousLightNodes); // reuse existing light node
            }
            if (lightNode === null) {
              // find the corresponding node type for a given light

              var lightNodeClass = nodeLibrary.getLightNodeClass(light.constructor);
              if (lightNodeClass === null) {
                console.warn(`LightsNode.setupNodeLights: Light node not found for ${light.constructor.name}`);
                continue;
              }
              var _lightNode = null;
              if (!_lightsNodeRef.has(light)) {
                _lightNode = nodeObject(new lightNodeClass(light));
                _lightsNodeRef.set(light, _lightNode);
              } else {
                _lightNode = _lightsNodeRef.get(light);
              }
              lightNodes.push(_lightNode);
            }
          }
        }
        this._lightNodes = lightNodes;
      }

      /**
       * Setups the internal lights by building all respective
       * light nodes.
       *
       * @param {NodeBuilder} builder - A reference to the current node builder.
       * @param {Array<LightingNode>} lightNodes - An array of lighting nodes.
       */
    }, {
      key: "setupLights",
      value: function setupLights(builder, lightNodes) {
        for (var lightNode of lightNodes) {
          lightNode.build(builder);
        }
      }

      /**
       * The implementation makes sure that for each light in the scene
       * there is a corresponding light node. By building the light nodes
       * and evaluating the lighting model the outgoing light is computed.
       *
       * @param {NodeBuilder} builder - A reference to the current node builder.
       * @return {Node<vec3>} A node representing the outgoing light.
       */
    }, {
      key: "setup",
      value: function setup(builder) {
        if (this._lightNodes === null) this.setupLightsNode(builder);
        var context = builder.context;
        var lightingModel = context.lightingModel;
        var outgoingLightNode = this.outgoingLightNode;
        if (lightingModel) {
          var _lightNodes = this._lightNodes,
            totalDiffuseNode = this.totalDiffuseNode,
            totalSpecularNode = this.totalSpecularNode;
          context.outgoingLight = outgoingLightNode;
          var _stack = builder.addStack();

          //

          var properties = builder.getDataFromNode(this);
          properties.nodes = _stack.nodes;

          //

          lightingModel.start(context, _stack, builder);

          // lights

          this.setupLights(builder, _lightNodes);

          //

          lightingModel.indirect(context, _stack, builder);

          //

          var backdrop = context.backdrop,
            backdropAlpha = context.backdropAlpha;
          var _context$reflectedLig = context.reflectedLight,
            directDiffuse = _context$reflectedLig.directDiffuse,
            directSpecular = _context$reflectedLig.directSpecular,
            indirectDiffuse = _context$reflectedLig.indirectDiffuse,
            indirectSpecular = _context$reflectedLig.indirectSpecular;
          var totalDiffuse = directDiffuse.add(indirectDiffuse);
          if (backdrop !== null) {
            if (backdropAlpha !== null) {
              totalDiffuse = vec3(backdropAlpha.mix(totalDiffuse, backdrop));
            } else {
              totalDiffuse = vec3(backdrop);
            }
            context.material.transparent = true;
          }
          totalDiffuseNode.assign(totalDiffuse);
          totalSpecularNode.assign(directSpecular.add(indirectSpecular));
          outgoingLightNode.assign(totalDiffuseNode.add(totalSpecularNode));

          //

          lightingModel.finish(context, _stack, builder);

          //

          outgoingLightNode = outgoingLightNode.bypass(builder.removeStack());
        }
        return outgoingLightNode;
      }

      /**
       * Configures this node with an array of lights.
       *
       * @param {Array<Light>} lights - An array of lights.
       * @return {LightsNode} A reference to this node.
       */
    }, {
      key: "setLights",
      value: function setLights(lights) {
        this._lights = lights;
        this._lightNodes = null;
        this._lightNodesHash = null;
        return this;
      }

      /**
       * Returns an array of the scene's lights.
       *
       * @return {Array<Light>} The scene's lights.
       */
    }, {
      key: "getLights",
      value: function getLights() {
        return this._lights;
      }

      /**
       * Whether the scene has lights or not.
       *
       * @type {Boolean}
       */
    }, {
      key: "hasLights",
      get: function get() {
        return this._lights.length > 0;
      }
    }], [{
      key: "type",
      get: function get() {
        return 'LightsNode';
      }
    }]);
  }(Node);
  /**
   * TSL function for creating an instance of `LightsNode` and configuring
   * it with the given array of lights.
   *
   * @function
   * @param {Array<Light>} lights - An array of lights.
   * @return {LightsNode} The created lights node.
   */
  var lights = function lights() {
    var lights = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
    return nodeObject(new LightsNode()).setLights(lights);
  };

  /** @module ShadowBaseNode **/

  /**
   * Base class for all shadow nodes.
   *
   * Shadow nodes encapsulate shadow related logic and are always coupled to lighting nodes.
   * Lighting nodes might share the same shadow node type or use specific ones depending on
   * their requirements.
   *
   * @augments Node
   */
  var ShadowBaseNode = exports.ShadowBaseNode = /*#__PURE__*/function (_Node53) {
    /**
     * Constructs a new shadow base node.
     *
     * @param {Light} light - The shadow casting light.
     */
    function ShadowBaseNode(light) {
      var _this162;
      (0, _classCallCheck2.default)(this, ShadowBaseNode);
      _this162 = _callSuper(this, ShadowBaseNode);

      /**
       * The shadow casting light.
       *
       * @type {Light}
       */
      _this162.light = light;

      /**
       * Overwritten since shadows are updated by default per render.
       *
       * @type {String}
       * @default 'render'
       */
      _this162.updateBeforeType = NodeUpdateType.RENDER;

      /**
       * This flag can be used for type testing.
       *
       * @type {Boolean}
       * @readonly
       * @default true
       */
      _this162.isShadowBaseNode = true;
      return _this162;
    }

    /**
     * Setups the shadow position node which is by default the predefined TSL node object `shadowPositionWorld`.
     *
     * @param {(NodeBuilder|{Material})} object - A configuration object that must at least hold a material reference.
     */
    (0, _inherits2.default)(ShadowBaseNode, _Node53);
    return (0, _createClass2.default)(ShadowBaseNode, [{
      key: "setupShadowPosition",
      value: function setupShadowPosition(_ref186) {
        var material = _ref186.material;
        // Use assign inside an Fn()

        shadowPositionWorld.assign(material.shadowPositionNode || positionWorld);
      }

      /**
       * Can be called when the shadow isn't required anymore. That can happen when
       * a lighting node stops casting shadows by setting {@link Object3D#castShadow}
       * to `false`.
       */
    }, {
      key: "dispose",
      value: function dispose() {
        this.updateBeforeType = NodeUpdateType.NONE;
      }
    }], [{
      key: "type",
      get: function get() {
        return 'ShadowBaseNode';
      }
    }]);
  }(Node);
  /**
   * TSL object that represents the vertex position in world space during the shadow pass.
   *
   * @type {Node<vec3>}
   */
  var shadowPositionWorld = /*@__PURE__*/vec3().toVar('shadowPositionWorld');

  /** @module RendererUtils **/

  /**
   * Saves the state of the given renderer and stores it into the given state object.
   *
   * If not state object is provided, the function creates one.
   *
   * @function
   * @param {Renderer} renderer - The renderer.
   * @param {Object} [state={}] - The state.
   * @return {Object} The state.
   */
  function saveRendererState(renderer) {
    var state = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    state.toneMapping = renderer.toneMapping;
    state.toneMappingExposure = renderer.toneMappingExposure;
    state.outputColorSpace = renderer.outputColorSpace;
    state.renderTarget = renderer.getRenderTarget();
    state.activeCubeFace = renderer.getActiveCubeFace();
    state.activeMipmapLevel = renderer.getActiveMipmapLevel();
    state.renderObjectFunction = renderer.getRenderObjectFunction();
    state.pixelRatio = renderer.getPixelRatio();
    state.mrt = renderer.getMRT();
    state.clearColor = renderer.getClearColor(state.clearColor || new (_$$_REQUIRE(_dependencyMap[1], "./three.core.js").Color)());
    state.clearAlpha = renderer.getClearAlpha();
    state.autoClear = renderer.autoClear;
    state.scissorTest = renderer.getScissorTest();
    return state;
  }

  /**
   * Saves the state of the given renderer and stores it into the given state object.
   * Besides, the function also resets the state of the renderer to its default values.
   *
   * If not state object is provided, the function creates one.
   *
   * @function
   * @param {Renderer} renderer - The renderer.
   * @param {Object} [state={}] - The state.
   * @return {Object} The state.
   */
  function resetRendererState(renderer, state) {
    state = saveRendererState(renderer, state);
    renderer.setMRT(null);
    renderer.setRenderObjectFunction(null);
    renderer.setClearColor(0x000000, 1);
    renderer.autoClear = true;
    return state;
  }

  /**
   * Restores the state of the given renderer from the given state object.
   *
   * @function
   * @param {Renderer} renderer - The renderer.
   * @param {Object} state - The state to restore.
   */
  function restoreRendererState(renderer, state) {
    renderer.toneMapping = state.toneMapping;
    renderer.toneMappingExposure = state.toneMappingExposure;
    renderer.outputColorSpace = state.outputColorSpace;
    renderer.setRenderTarget(state.renderTarget, state.activeCubeFace, state.activeMipmapLevel);
    renderer.setRenderObjectFunction(state.renderObjectFunction);
    renderer.setPixelRatio(state.pixelRatio);
    renderer.setMRT(state.mrt);
    renderer.setClearColor(state.clearColor, state.clearAlpha);
    renderer.autoClear = state.autoClear;
    renderer.setScissorTest(state.scissorTest);
  }

  /**
   * Saves the state of the given scene and stores it into the given state object.
   *
   * If not state object is provided, the function creates one.
   *
   * @function
   * @param {Scene} scene - The scene.
   * @param {Object} [state={}] - The state.
   * @return {Object} The state.
   */
  function saveSceneState(scene) {
    var state = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    state.background = scene.background;
    state.backgroundNode = scene.backgroundNode;
    state.overrideMaterial = scene.overrideMaterial;
    return state;
  }

  /**
   * Saves the state of the given scene and stores it into the given state object.
   * Besides, the function also resets the state of the scene to its default values.
   *
   * If not state object is provided, the function creates one.
   *
   * @function
   * @param {Scene} scene - The scene.
   * @param {Object} [state={}] - The state.
   * @return {Object} The state.
   */
  function resetSceneState(scene, state) {
    state = saveSceneState(scene, state);
    scene.background = null;
    scene.backgroundNode = null;
    scene.overrideMaterial = null;
    return state;
  }

  /**
   * Restores the state of the given scene from the given state object.
   *
   * @function
   * @param {Scene} scene - The scene.
   * @param {Object} state - The state to restore.
   */
  function restoreSceneState(scene, state) {
    scene.background = state.background;
    scene.backgroundNode = state.backgroundNode;
    scene.overrideMaterial = state.overrideMaterial;
  }

  /**
   * Saves the state of the given renderer and scene and stores it into the given state object.
   *
   * If not state object is provided, the function creates one.
   *
   * @function
   * @param {Renderer} renderer - The renderer.
   * @param {Scene} scene - The scene.
   * @param {Object} [state={}] - The state.
   * @return {Object} The state.
   */
  function saveRendererAndSceneState(renderer, scene) {
    var state = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    state = saveRendererState(renderer, state);
    state = saveSceneState(scene, state);
    return state;
  }

  /**
   * Saves the state of the given renderer and scene and stores it into the given state object.
   * Besides, the function also resets the state of the renderer and scene to its default values.
   *
   * If not state object is provided, the function creates one.
   *
   * @function
   * @param {Renderer} renderer - The renderer.
   * @param {Scene} scene - The scene.
   * @param {Object} [state={}] - The state.
   * @return {Object} The state.
   */
  function resetRendererAndSceneState(renderer, scene, state) {
    state = resetRendererState(renderer, state);
    state = resetSceneState(scene, state);
    return state;
  }

  /**
   * Restores the state of the given renderer and scene from the given state object.
   *
   * @function
   * @param {Renderer} renderer - The renderer.
   * @param {Scene} scene - The scene.
   * @param {Object} state - The state to restore.
   */
  function restoreRendererAndSceneState(renderer, scene, state) {
    restoreRendererState(renderer, state);
    restoreSceneState(scene, state);
  }
  var RendererUtils = exports.RendererUtils = /*#__PURE__*/Object.freeze({
    __proto__: null,
    resetRendererAndSceneState: resetRendererAndSceneState,
    resetRendererState: resetRendererState,
    resetSceneState: resetSceneState,
    restoreRendererAndSceneState: restoreRendererAndSceneState,
    restoreRendererState: restoreRendererState,
    restoreSceneState: restoreSceneState,
    saveRendererAndSceneState: saveRendererAndSceneState,
    saveRendererState: saveRendererState,
    saveSceneState: saveSceneState
  });

  /** @module ShadowNode **/

  var shadowMaterialLib = /*@__PURE__*/new WeakMap();
  var linearDistance = /*@__PURE__*/Fn(function (_ref187) {
    var _ref188 = (0, _slicedToArray2.default)(_ref187, 3),
      position = _ref188[0],
      cameraNear = _ref188[1],
      cameraFar = _ref188[2];
    var dist = positionWorld.sub(position).length();
    dist = dist.sub(cameraNear).div(cameraFar.sub(cameraNear));
    dist = dist.saturate(); // clamp to [ 0, 1 ]

    return dist;
  });
  var linearShadowDistance = function linearShadowDistance(light) {
    var camera = light.shadow.camera;
    var nearDistance = reference('near', 'float', camera).setGroup(renderGroup);
    var farDistance = reference('far', 'float', camera).setGroup(renderGroup);
    var referencePosition = objectPosition(light);
    return linearDistance(referencePosition, nearDistance, farDistance);
  };
  var getShadowMaterial = function getShadowMaterial(light) {
    var material = shadowMaterialLib.get(light);
    if (material === undefined) {
      var depthNode = light.isPointLight ? linearShadowDistance(light) : null;
      material = new NodeMaterial();
      material.colorNode = vec4(0, 0, 0, 1);
      material.depthNode = depthNode;
      material.isShadowNodeMaterial = true; // Use to avoid other overrideMaterial override material.colorNode unintentionally when using material.shadowNode
      material.name = 'ShadowMaterial';
      material.fog = false;
      shadowMaterialLib.set(light, material);
    }
    return material;
  };

  /**
   * A shadow filtering function performing basic filtering. This is in fact an unfiltered version of the shadow map
   * with a binary `[0,1]` result.
   *
   * @method
   * @param {Object} inputs - The input parameter object.
   * @param {DepthTexture} inputs.depthTexture - A reference to the shadow map's texture data.
   * @param {Node<vec3>} inputs.shadowCoord - The shadow coordinates.
   * @return {Node<float>} The filtering result.
   */
  var BasicShadowFilter = /*@__PURE__*/Fn(function (_ref189) {
    var depthTexture = _ref189.depthTexture,
      shadowCoord = _ref189.shadowCoord;
    return texture(depthTexture, shadowCoord.xy).compare(shadowCoord.z);
  });

  /**
   * A shadow filtering function performing PCF filtering.
   *
   * @method
   * @param {Object} inputs - The input parameter object.
   * @param {DepthTexture} inputs.depthTexture - A reference to the shadow map's texture data.
   * @param {Node<vec3>} inputs.shadowCoord - The shadow coordinates.
   * @param {LightShadow} inputs.shadow - The light shadow.
   * @return {Node<float>} The filtering result.
   */
  var PCFShadowFilter = /*@__PURE__*/Fn(function (_ref190) {
    var depthTexture = _ref190.depthTexture,
      shadowCoord = _ref190.shadowCoord,
      shadow = _ref190.shadow;
    var depthCompare = function depthCompare(uv, compare) {
      return texture(depthTexture, uv).compare(compare);
    };
    var mapSize = reference('mapSize', 'vec2', shadow).setGroup(renderGroup);
    var radius = reference('radius', 'float', shadow).setGroup(renderGroup);
    var texelSize = vec2(1).div(mapSize);
    var dx0 = texelSize.x.negate().mul(radius);
    var dy0 = texelSize.y.negate().mul(radius);
    var dx1 = texelSize.x.mul(radius);
    var dy1 = texelSize.y.mul(radius);
    var dx2 = dx0.div(2);
    var dy2 = dy0.div(2);
    var dx3 = dx1.div(2);
    var dy3 = dy1.div(2);
    return add(depthCompare(shadowCoord.xy.add(vec2(dx0, dy0)), shadowCoord.z), depthCompare(shadowCoord.xy.add(vec2(0, dy0)), shadowCoord.z), depthCompare(shadowCoord.xy.add(vec2(dx1, dy0)), shadowCoord.z), depthCompare(shadowCoord.xy.add(vec2(dx2, dy2)), shadowCoord.z), depthCompare(shadowCoord.xy.add(vec2(0, dy2)), shadowCoord.z), depthCompare(shadowCoord.xy.add(vec2(dx3, dy2)), shadowCoord.z), depthCompare(shadowCoord.xy.add(vec2(dx0, 0)), shadowCoord.z), depthCompare(shadowCoord.xy.add(vec2(dx2, 0)), shadowCoord.z), depthCompare(shadowCoord.xy, shadowCoord.z), depthCompare(shadowCoord.xy.add(vec2(dx3, 0)), shadowCoord.z), depthCompare(shadowCoord.xy.add(vec2(dx1, 0)), shadowCoord.z), depthCompare(shadowCoord.xy.add(vec2(dx2, dy3)), shadowCoord.z), depthCompare(shadowCoord.xy.add(vec2(0, dy3)), shadowCoord.z), depthCompare(shadowCoord.xy.add(vec2(dx3, dy3)), shadowCoord.z), depthCompare(shadowCoord.xy.add(vec2(dx0, dy1)), shadowCoord.z), depthCompare(shadowCoord.xy.add(vec2(0, dy1)), shadowCoord.z), depthCompare(shadowCoord.xy.add(vec2(dx1, dy1)), shadowCoord.z)).mul(1 / 17);
  });

  /**
   * A shadow filtering function performing PCF soft filtering.
   *
   * @method
   * @param {Object} inputs - The input parameter object.
   * @param {DepthTexture} inputs.depthTexture - A reference to the shadow map's texture data.
   * @param {Node<vec3>} inputs.shadowCoord - The shadow coordinates.
   * @param {LightShadow} inputs.shadow - The light shadow.
   * @return {Node<float>} The filtering result.
   */
  var PCFSoftShadowFilter = /*@__PURE__*/Fn(function (_ref191) {
    var depthTexture = _ref191.depthTexture,
      shadowCoord = _ref191.shadowCoord,
      shadow = _ref191.shadow;
    var depthCompare = function depthCompare(uv, compare) {
      return texture(depthTexture, uv).compare(compare);
    };
    var mapSize = reference('mapSize', 'vec2', shadow).setGroup(renderGroup);
    var texelSize = vec2(1).div(mapSize);
    var dx = texelSize.x;
    var dy = texelSize.y;
    var uv = shadowCoord.xy;
    var f = fract(uv.mul(mapSize).add(0.5));
    uv.subAssign(f.mul(texelSize));
    return add(depthCompare(uv, shadowCoord.z), depthCompare(uv.add(vec2(dx, 0)), shadowCoord.z), depthCompare(uv.add(vec2(0, dy)), shadowCoord.z), depthCompare(uv.add(texelSize), shadowCoord.z), mix(depthCompare(uv.add(vec2(dx.negate(), 0)), shadowCoord.z), depthCompare(uv.add(vec2(dx.mul(2), 0)), shadowCoord.z), f.x), mix(depthCompare(uv.add(vec2(dx.negate(), dy)), shadowCoord.z), depthCompare(uv.add(vec2(dx.mul(2), dy)), shadowCoord.z), f.x), mix(depthCompare(uv.add(vec2(0, dy.negate())), shadowCoord.z), depthCompare(uv.add(vec2(0, dy.mul(2))), shadowCoord.z), f.y), mix(depthCompare(uv.add(vec2(dx, dy.negate())), shadowCoord.z), depthCompare(uv.add(vec2(dx, dy.mul(2))), shadowCoord.z), f.y), mix(mix(depthCompare(uv.add(vec2(dx.negate(), dy.negate())), shadowCoord.z), depthCompare(uv.add(vec2(dx.mul(2), dy.negate())), shadowCoord.z), f.x), mix(depthCompare(uv.add(vec2(dx.negate(), dy.mul(2))), shadowCoord.z), depthCompare(uv.add(vec2(dx.mul(2), dy.mul(2))), shadowCoord.z), f.x), f.y)).mul(1 / 9);
  });

  /**
   * A shadow filtering function performing VSM filtering.
   *
   * @method
   * @param {Object} inputs - The input parameter object.
   * @param {DepthTexture} inputs.depthTexture - A reference to the shadow map's texture data.
   * @param {Node<vec3>} inputs.shadowCoord - The shadow coordinates.
   * @return {Node<float>} The filtering result.
   */
  var VSMShadowFilter = /*@__PURE__*/Fn(function (_ref192) {
    var depthTexture = _ref192.depthTexture,
      shadowCoord = _ref192.shadowCoord;
    var occlusion = float(1).toVar();
    var distribution = texture(depthTexture).sample(shadowCoord.xy).rg;
    var hardShadow = step(shadowCoord.z, distribution.x);
    If(hardShadow.notEqual(float(1.0)), function () {
      var distance = shadowCoord.z.sub(distribution.x);
      var variance = max$1(0, distribution.y.mul(distribution.y));
      var softnessProbability = variance.div(variance.add(distance.mul(distance))); // Chebeyshevs inequality
      softnessProbability = clamp(sub(softnessProbability, 0.3).div(0.95 - 0.3));
      occlusion.assign(clamp(max$1(hardShadow, softnessProbability)));
    });
    return occlusion;
  });

  /**
   * Represents the shader code for the first VSM render pass.
   *
   * @method
   * @param {Object} inputs - The input parameter object.
   * @param {Node<float>} inputs.samples - The number of samples
   * @param {Node<float>} inputs.radius - The radius.
   * @param {Node<float>} inputs.size - The size.
   * @param {TextureNode} inputs.shadowPass - A reference to the render target's depth data.
   * @return {Node<vec2>} The VSM output.
   */
  var VSMPassVertical = /*@__PURE__*/Fn(function (_ref193) {
    var samples = _ref193.samples,
      radius = _ref193.radius,
      size = _ref193.size,
      shadowPass = _ref193.shadowPass;
    var mean = float(0).toVar();
    var squaredMean = float(0).toVar();
    var uvStride = samples.lessThanEqual(float(1)).select(float(0), float(2).div(samples.sub(1)));
    var uvStart = samples.lessThanEqual(float(1)).select(float(0), float(-1));
    Loop({
      start: int(0),
      end: int(samples),
      type: 'int',
      condition: '<'
    }, function (_ref194) {
      var i = _ref194.i;
      var uvOffset = uvStart.add(float(i).mul(uvStride));
      var depth = shadowPass.sample(add(screenCoordinate.xy, vec2(0, uvOffset).mul(radius)).div(size)).x;
      mean.addAssign(depth);
      squaredMean.addAssign(depth.mul(depth));
    });
    mean.divAssign(samples);
    squaredMean.divAssign(samples);
    var std_dev = sqrt(squaredMean.sub(mean.mul(mean)));
    return vec2(mean, std_dev);
  });

  /**
   * Represents the shader code for the second VSM render pass.
   *
   * @method
   * @param {Object} inputs - The input parameter object.
   * @param {Node<float>} inputs.samples - The number of samples
   * @param {Node<float>} inputs.radius - The radius.
   * @param {Node<float>} inputs.size - The size.
   * @param {TextureNode} inputs.shadowPass - The result of the first VSM render pass.
   * @return {Node<vec2>} The VSM output.
   */
  var VSMPassHorizontal = /*@__PURE__*/Fn(function (_ref195) {
    var samples = _ref195.samples,
      radius = _ref195.radius,
      size = _ref195.size,
      shadowPass = _ref195.shadowPass;
    var mean = float(0).toVar();
    var squaredMean = float(0).toVar();
    var uvStride = samples.lessThanEqual(float(1)).select(float(0), float(2).div(samples.sub(1)));
    var uvStart = samples.lessThanEqual(float(1)).select(float(0), float(-1));
    Loop({
      start: int(0),
      end: int(samples),
      type: 'int',
      condition: '<'
    }, function (_ref196) {
      var i = _ref196.i;
      var uvOffset = uvStart.add(float(i).mul(uvStride));
      var distribution = shadowPass.sample(add(screenCoordinate.xy, vec2(uvOffset, 0).mul(radius)).div(size));
      mean.addAssign(distribution.x);
      squaredMean.addAssign(add(distribution.y.mul(distribution.y), distribution.x.mul(distribution.x)));
    });
    mean.divAssign(samples);
    squaredMean.divAssign(samples);
    var std_dev = sqrt(squaredMean.sub(mean.mul(mean)));
    return vec2(mean, std_dev);
  });
  var _shadowFilterLib = [BasicShadowFilter, PCFShadowFilter, PCFSoftShadowFilter, VSMShadowFilter];

  //

  var _rendererState;
  var _quadMesh$1 = /*@__PURE__*/new QuadMesh();

  /**
   * Represents the default shadow implementation for lighting nodes.
   *
   * @augments module:ShadowBaseNode~ShadowBaseNode
   */
  var ShadowNode = exports.ShadowNode = /*#__PURE__*/function (_ShadowBaseNode) {
    /**
     * Constructs a new shadow node.
     *
     * @param {Light} light - The shadow casting light.
     * @param {LightShadow?} [shadow=null] - An optional light shadow.
     */
    function ShadowNode(light) {
      var _this163;
      var shadow = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      (0, _classCallCheck2.default)(this, ShadowNode);
      _this163 = _callSuper(this, ShadowNode, [light]);

      /**
       * The light shadow which defines the properties light's
       * shadow.
       *
       * @type {LightShadow?}
       * @default null
       */
      _this163.shadow = shadow || light.shadow;

      /**
       * A reference to the shadow map which is a render target.
       *
       * @type {RenderTarget?}
       * @default null
       */
      _this163.shadowMap = null;

      /**
       * Only relevant for VSM shadows. Render target for the
       * first VSM render pass.
       *
       * @type {RenderTarget?}
       * @default null
       */
      _this163.vsmShadowMapVertical = null;

      /**
       * Only relevant for VSM shadows. Render target for the
       * second VSM render pass.
       *
       * @type {RenderTarget?}
       * @default null
       */
      _this163.vsmShadowMapHorizontal = null;

      /**
       * Only relevant for VSM shadows. Node material which
       * is used to render the first VSM pass.
       *
       * @type {NodeMaterial?}
       * @default null
       */
      _this163.vsmMaterialVertical = null;

      /**
       * Only relevant for VSM shadows. Node material which
       * is used to render the second VSM pass.
       *
       * @type {NodeMaterial?}
       * @default null
       */
      _this163.vsmMaterialHorizontal = null;

      /**
       * A reference to the output node which defines the
       * final result of this shadow node.
       *
       * @type {Node?}
       * @private
       * @default null
       */
      _this163._node = null;

      /**
       * This flag can be used for type testing.
       *
       * @type {Boolean}
       * @readonly
       * @default true
       */
      _this163.isShadowNode = true;
      return _this163;
    }

    /**
     * Setups the shadow filtering.
     *
     * @param {NodeBuilder} builder - A reference to the current node builder.
     * @param {Object} inputs - A configuration object that defines the shadow filtering.
     * @param {Function} inputs.filterFn - This function defines the filtering type of the shadow map e.g. PCF.
     * @param {DepthTexture} inputs.depthTexture - A reference to the shadow map's texture data.
     * @param {Node<vec3>} inputs.shadowCoord - Shadow coordinates which are used to sample from the shadow map.
     * @param {LightShadow} inputs.shadow - The light shadow.
     * @return {Node<float>} The result node of the shadow filtering.
     */
    (0, _inherits2.default)(ShadowNode, _ShadowBaseNode);
    return (0, _createClass2.default)(ShadowNode, [{
      key: "setupShadowFilter",
      value: function setupShadowFilter(builder, _ref197) {
        var filterFn = _ref197.filterFn,
          depthTexture = _ref197.depthTexture,
          shadowCoord = _ref197.shadowCoord,
          shadow = _ref197.shadow;
        var frustumTest = shadowCoord.x.greaterThanEqual(0).and(shadowCoord.x.lessThanEqual(1)).and(shadowCoord.y.greaterThanEqual(0)).and(shadowCoord.y.lessThanEqual(1)).and(shadowCoord.z.lessThanEqual(1));
        var shadowNode = filterFn({
          depthTexture: depthTexture,
          shadowCoord: shadowCoord,
          shadow: shadow
        });
        return frustumTest.select(shadowNode, float(1));
      }

      /**
       * Setups the shadow coordinates.
       *
       * @param {NodeBuilder} builder - A reference to the current node builder.
       * @param {Node<vec3>} shadowPosition - A node representing the shadow position.
       * @return {Node<vec3>} The shadow coordinates.
       */
    }, {
      key: "setupShadowCoord",
      value: function setupShadowCoord(builder, shadowPosition) {
        var shadow = this.shadow;
        var renderer = builder.renderer;
        var bias = reference('bias', 'float', shadow).setGroup(renderGroup);
        var shadowCoord = shadowPosition;
        var coordZ;
        if (shadow.camera.isOrthographicCamera || renderer.logarithmicDepthBuffer !== true) {
          shadowCoord = shadowCoord.xyz.div(shadowCoord.w);
          coordZ = shadowCoord.z;
          if (renderer.coordinateSystem === _$$_REQUIRE(_dependencyMap[1], "./three.core.js").WebGPUCoordinateSystem) {
            coordZ = coordZ.mul(2).sub(1); // WebGPU: Conversion [ 0, 1 ] to [ - 1, 1 ]
          }
        } else {
          var w = shadowCoord.w;
          shadowCoord = shadowCoord.xy.div(w); // <-- Only divide X/Y coords since we don't need Z

          // The normally available "cameraNear" and "cameraFar" nodes cannot be used here because they do not get
          // updated to use the shadow camera. So, we have to declare our own "local" ones here.
          // TODO: How do we get the cameraNear/cameraFar nodes to use the shadow camera so we don't have to declare local ones here?
          var cameraNearLocal = reference('near', 'float', shadow.camera).setGroup(renderGroup);
          var cameraFarLocal = reference('far', 'float', shadow.camera).setGroup(renderGroup);
          coordZ = viewZToLogarithmicDepth(w.negate(), cameraNearLocal, cameraFarLocal);
        }
        shadowCoord = vec3(shadowCoord.x, shadowCoord.y.oneMinus(),
        // follow webgpu standards
        coordZ.add(bias));
        return shadowCoord;
      }

      /**
       * Returns the shadow filtering function for the given shadow type.
       *
       * @param {Number} type - The shadow type.
       * @return {Function} The filtering function.
       */
    }, {
      key: "getShadowFilterFn",
      value: function getShadowFilterFn(type) {
        return _shadowFilterLib[type];
      }

      /**
       * Setups the shadow output node.
       *
       * @param {NodeBuilder} builder - A reference to the current node builder.
       * @return {Node<vec3>} The shadow output node.
       */
    }, {
      key: "setupShadow",
      value: function setupShadow(builder) {
        var renderer = builder.renderer;
        var light = this.light,
          shadow = this.shadow;
        var shadowMapType = renderer.shadowMap.type;
        var depthTexture = new (_$$_REQUIRE(_dependencyMap[1], "./three.core.js").DepthTexture)(shadow.mapSize.width, shadow.mapSize.height);
        depthTexture.compareFunction = _$$_REQUIRE(_dependencyMap[1], "./three.core.js").LessCompare;
        var shadowMap = builder.createRenderTarget(shadow.mapSize.width, shadow.mapSize.height);
        shadowMap.depthTexture = depthTexture;
        shadow.camera.updateProjectionMatrix();

        // VSM

        if (shadowMapType === _$$_REQUIRE(_dependencyMap[1], "./three.core.js").VSMShadowMap) {
          depthTexture.compareFunction = null; // VSM does not use textureSampleCompare()/texture2DCompare()

          this.vsmShadowMapVertical = builder.createRenderTarget(shadow.mapSize.width, shadow.mapSize.height, {
            format: _$$_REQUIRE(_dependencyMap[1], "./three.core.js").RGFormat,
            type: _$$_REQUIRE(_dependencyMap[1], "./three.core.js").HalfFloatType
          });
          this.vsmShadowMapHorizontal = builder.createRenderTarget(shadow.mapSize.width, shadow.mapSize.height, {
            format: _$$_REQUIRE(_dependencyMap[1], "./three.core.js").RGFormat,
            type: _$$_REQUIRE(_dependencyMap[1], "./three.core.js").HalfFloatType
          });
          var shadowPassVertical = texture(depthTexture);
          var shadowPassHorizontal = texture(this.vsmShadowMapVertical.texture);
          var samples = reference('blurSamples', 'float', shadow).setGroup(renderGroup);
          var radius = reference('radius', 'float', shadow).setGroup(renderGroup);
          var size = reference('mapSize', 'vec2', shadow).setGroup(renderGroup);
          var material = this.vsmMaterialVertical || (this.vsmMaterialVertical = new NodeMaterial());
          material.fragmentNode = VSMPassVertical({
            samples: samples,
            radius: radius,
            size: size,
            shadowPass: shadowPassVertical
          }).context(builder.getSharedContext());
          material.name = 'VSMVertical';
          material = this.vsmMaterialHorizontal || (this.vsmMaterialHorizontal = new NodeMaterial());
          material.fragmentNode = VSMPassHorizontal({
            samples: samples,
            radius: radius,
            size: size,
            shadowPass: shadowPassHorizontal
          }).context(builder.getSharedContext());
          material.name = 'VSMHorizontal';
        }

        //

        var shadowIntensity = reference('intensity', 'float', shadow).setGroup(renderGroup);
        var normalBias = reference('normalBias', 'float', shadow).setGroup(renderGroup);
        var shadowPosition = lightShadowMatrix(light).mul(shadowPositionWorld.add(transformedNormalWorld.mul(normalBias)));
        var shadowCoord = this.setupShadowCoord(builder, shadowPosition);

        //

        var filterFn = shadow.filterNode || this.getShadowFilterFn(renderer.shadowMap.type) || null;
        if (filterFn === null) {
          throw new Error('THREE.WebGPURenderer: Shadow map type not supported yet.');
        }
        var shadowDepthTexture = shadowMapType === _$$_REQUIRE(_dependencyMap[1], "./three.core.js").VSMShadowMap ? this.vsmShadowMapHorizontal.texture : depthTexture;
        var shadowNode = this.setupShadowFilter(builder, {
          filterFn: filterFn,
          shadowTexture: shadowMap.texture,
          depthTexture: shadowDepthTexture,
          shadowCoord: shadowCoord,
          shadow: shadow
        });
        var shadowColor = texture(shadowMap.texture, shadowCoord);
        var shadowOutput = mix(1, shadowNode.rgb.mix(shadowColor, 1), shadowIntensity.mul(shadowColor.a)).toVar();
        this.shadowMap = shadowMap;
        this.shadow.map = shadowMap;
        return shadowOutput;
      }

      /**
       * The implementation performs the setup of the output node. An output is only
       * produces if shadow mapping is globally enabled in the renderer.
       *
       * @param {NodeBuilder} builder - A reference to the current node builder.
       * @return {ShaderCallNodeInternal} The output node.
       */
    }, {
      key: "setup",
      value: function setup(builder) {
        var _this164 = this;
        if (builder.renderer.shadowMap.enabled === false) return;
        return Fn(function () {
          var node = _this164._node;
          _this164.setupShadowPosition(builder);
          if (node === null) {
            _this164._node = node = _this164.setupShadow(builder);
          }
          if (builder.material.shadowNode) {
            // @deprecated, r171

            console.warn('THREE.NodeMaterial: ".shadowNode" is deprecated. Use ".castShadowNode" instead.');
          }
          if (builder.material.receivedShadowNode) {
            node = builder.material.receivedShadowNode(node);
          }
          return node;
        })();
      }

      /**
       * Renders the shadow. The logic of this function could be included
       * into {@link ShadowNode#updateShadow} however more specialized shadow
       * nodes might require a custom shadow map rendering. By having a
       * dedicated method, it's easier to overwrite the default behavior.
       *
       * @param {NodeFrame} frame - A reference to the current node frame.
       */
    }, {
      key: "renderShadow",
      value: function renderShadow(frame) {
        var shadow = this.shadow,
          shadowMap = this.shadowMap,
          light = this.light;
        var renderer = frame.renderer,
          scene = frame.scene;
        shadow.updateMatrices(light);
        shadowMap.setSize(shadow.mapSize.width, shadow.mapSize.height);
        renderer.render(scene, shadow.camera);
      }

      /**
       * Updates the shadow.
       *
       * @param {NodeFrame} frame - A reference to the current node frame.
       */
    }, {
      key: "updateShadow",
      value: function updateShadow(frame) {
        var shadowMap = this.shadowMap,
          light = this.light,
          shadow = this.shadow;
        var renderer = frame.renderer,
          scene = frame.scene,
          camera = frame.camera;
        var shadowType = renderer.shadowMap.type;
        var depthVersion = shadowMap.depthTexture.version;
        this._depthVersionCached = depthVersion;
        shadow.camera.layers.mask = camera.layers.mask;
        var currentRenderObjectFunction = renderer.getRenderObjectFunction();
        var currentMRT = renderer.getMRT();
        var useVelocity = currentMRT ? currentMRT.has('velocity') : false;
        _rendererState = resetRendererAndSceneState(renderer, scene, _rendererState);
        scene.overrideMaterial = getShadowMaterial(light);
        renderer.setRenderObjectFunction(function (object, scene, _camera, geometry, material, group) {
          if (object.castShadow === true || object.receiveShadow && shadowType === _$$_REQUIRE(_dependencyMap[1], "./three.core.js").VSMShadowMap) {
            if (useVelocity) {
              getDataFromObject(object).useVelocity = true;
            }
            object.onBeforeShadow(renderer, object, camera, shadow.camera, geometry, scene.overrideMaterial, group);
            for (var _len30 = arguments.length, params = new Array(_len30 > 6 ? _len30 - 6 : 0), _key30 = 6; _key30 < _len30; _key30++) {
              params[_key30 - 6] = arguments[_key30];
            }
            renderer.renderObject.apply(renderer, [object, scene, _camera, geometry, material, group].concat(params));
            object.onAfterShadow(renderer, object, camera, shadow.camera, geometry, scene.overrideMaterial, group);
          }
        });
        renderer.setRenderTarget(shadowMap);
        this.renderShadow(frame);
        renderer.setRenderObjectFunction(currentRenderObjectFunction);

        // vsm blur pass

        if (light.isPointLight !== true && shadowType === _$$_REQUIRE(_dependencyMap[1], "./three.core.js").VSMShadowMap) {
          this.vsmPass(renderer);
        }
        restoreRendererAndSceneState(renderer, scene, _rendererState);
      }

      /**
       * For VSM additional render passes are required.
       *
       * @param {Renderer} renderer - A reference to the current renderer.
       */
    }, {
      key: "vsmPass",
      value: function vsmPass(renderer) {
        var shadow = this.shadow;
        this.vsmShadowMapVertical.setSize(shadow.mapSize.width, shadow.mapSize.height);
        this.vsmShadowMapHorizontal.setSize(shadow.mapSize.width, shadow.mapSize.height);
        renderer.setRenderTarget(this.vsmShadowMapVertical);
        _quadMesh$1.material = this.vsmMaterialVertical;
        _quadMesh$1.render(renderer);
        renderer.setRenderTarget(this.vsmShadowMapHorizontal);
        _quadMesh$1.material = this.vsmMaterialHorizontal;
        _quadMesh$1.render(renderer);
      }

      /**
       * Frees the internal resources of this shadow node.
       */
    }, {
      key: "dispose",
      value: function dispose() {
        this.shadowMap.dispose();
        this.shadowMap = null;
        if (this.vsmShadowMapVertical !== null) {
          this.vsmShadowMapVertical.dispose();
          this.vsmShadowMapVertical = null;
          this.vsmMaterialVertical.dispose();
          this.vsmMaterialVertical = null;
        }
        if (this.vsmShadowMapHorizontal !== null) {
          this.vsmShadowMapHorizontal.dispose();
          this.vsmShadowMapHorizontal = null;
          this.vsmMaterialHorizontal.dispose();
          this.vsmMaterialHorizontal = null;
        }
        _superPropGet(ShadowNode, "dispose", this, 3)([]);
      }

      /**
       * The implementation performs the update of the shadow map if necessary.
       *
       * @param {NodeFrame} frame - A reference to the current node frame.
       */
    }, {
      key: "updateBefore",
      value: function updateBefore(frame) {
        var shadow = this.shadow;
        var needsUpdate = shadow.needsUpdate || shadow.autoUpdate;
        if (needsUpdate) {
          this.updateShadow(frame);
          if (this.shadowMap.depthTexture.version === this._depthVersionCached) {
            shadow.needsUpdate = false;
          }
        }
      }
    }], [{
      key: "type",
      get: function get() {
        return 'ShadowNode';
      }
    }]);
  }(ShadowBaseNode);
  /**
   * TSL function for creating an instance of `ShadowNode`.
   *
   * @function
   * @param {Light} light - The shadow casting light.
   * @param {LightShadow} shadow - The light shadow.
   * @return {ShadowNode} The created shadow node.
   */
  var shadow = function shadow(light, _shadow) {
    return nodeObject(new ShadowNode(light, _shadow));
  };

  /**
   * Base class for analytic light nodes.
   *
   * @augments LightingNode
   */
  var AnalyticLightNode = exports.AnalyticLightNode = /*#__PURE__*/function (_LightingNode6) {
    /**
     * Constructs a new analytic light node.
     *
     * @param {Light?} [light=null] - The light source.
     */
    function AnalyticLightNode() {
      var _this165;
      var light = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      (0, _classCallCheck2.default)(this, AnalyticLightNode);
      _this165 = _callSuper(this, AnalyticLightNode);

      /**
       * The light source.
       *
       * @type {Light?}
       * @default null
       */
      _this165.light = light;

      /**
       * The light's color value.
       *
       * @type {Color}
       */
      _this165.color = new (_$$_REQUIRE(_dependencyMap[1], "./three.core.js").Color)();

      /**
       * The light's color node. Points to `colorNode` of the light source, if set. Otherwise
       * it creates a uniform node based on {@link AnalyticLightNode#color}.
       *
       * @type {Node}
       */
      _this165.colorNode = light && light.colorNode || uniform(_this165.color).setGroup(renderGroup);

      /**
       * This property is used to retain a reference to the original value of {@link AnalyticLightNode#colorNode}.
       * The final color node is represented by a different node when using shadows.
       *
       * @type {Node?}
       * @default null
       */
      _this165.baseColorNode = null;

      /**
       * Represents the light's shadow.
       *
       * @type {ShadowNode?}
       		 * @default null
       */
      _this165.shadowNode = null;

      /**
       * Represents the light's shadow color.
       *
       * @type {Node?}
       		 * @default null
       */
      _this165.shadowColorNode = null;

      /**
       * This flag can be used for type testing.
       *
       * @type {Boolean}
       * @readonly
       * @default true
       */
      _this165.isAnalyticLightNode = true;

      /**
       * Overwritten since analytic light nodes are updated
       * once per frame.
       *
       * @type {String}
       * @default 'frame'
       */
      _this165.updateType = NodeUpdateType.FRAME;
      return _this165;
    }

    /**
     * Overwrites the default {@link Node#customCacheKey} implementation by including the
     * `light.id` and `light.castShadow` into the cache key.
     *
     * @return {Number} The custom cache key.
     */
    (0, _inherits2.default)(AnalyticLightNode, _LightingNode6);
    return (0, _createClass2.default)(AnalyticLightNode, [{
      key: "customCacheKey",
      value: function customCacheKey() {
        return hash$1(this.light.id, this.light.castShadow ? 1 : 0);
      }
    }, {
      key: "getHash",
      value: function getHash() {
        return this.light.uuid;
      }

      /**
       * Setups the shadow node for this light. The method exists so concrete light classes
       * can setup different types of shadow nodes.
       *
       * @return {ShadowNode} The created shadow node.
       */
    }, {
      key: "setupShadowNode",
      value: function setupShadowNode() {
        return shadow(this.light);
      }

      /**
       * Setups the shadow for this light. This method is only executed if the light
       * cast shadows and the current build object receives shadows. It incorporates
       * shadows into the lighting computation.
       *
       * @param {NodeBuilder} builder - The current node builder.
       */
    }, {
      key: "setupShadow",
      value: function setupShadow(builder) {
        var renderer = builder.renderer;
        if (renderer.shadowMap.enabled === false) return;
        var shadowColorNode = this.shadowColorNode;
        if (shadowColorNode === null) {
          var customShadowNode = this.light.shadow.shadowNode;
          var shadowNode;
          if (customShadowNode !== undefined) {
            shadowNode = nodeObject(customShadowNode);
          } else {
            shadowNode = this.setupShadowNode(builder);
          }
          this.shadowNode = shadowNode;
          this.shadowColorNode = shadowColorNode = this.colorNode.mul(shadowNode);
          this.baseColorNode = this.colorNode;
        }

        //

        this.colorNode = shadowColorNode;
      }

      /**
       * Unlike most other nodes, lighting nodes do not return a output node in {@link Node#setup}.
       * The main purpose of lighting nodes is to configure the current {@link LightingModel} and/or
       * invocate the respective interface methods.
       *
       * @param {NodeBuilder} builder - The current node builder.
       */
    }, {
      key: "setup",
      value: function setup(builder) {
        this.colorNode = this.baseColorNode || this.colorNode;
        if (this.light.castShadow) {
          if (builder.object.receiveShadow) {
            this.setupShadow(builder);
          }
        } else if (this.shadowNode !== null) {
          this.shadowNode.dispose();
          this.shadowNode = null;
          this.shadowColorNode = null;
        }
      }

      /**
       * The update method is used to update light uniforms per frame.
       * Potentially overwritten in concrete light nodes to update light
       * specific uniforms.
       *
       * @param {NodeFrame} frame - A reference to the current node frame.
       */
    }, {
      key: "update",
      value: function update(/*frame*/
      ) {
        var light = this.light;
        this.color.copy(light.color).multiplyScalar(light.intensity);
      }
    }], [{
      key: "type",
      get: function get() {
        return 'AnalyticLightNode';
      }
    }]);
  }(LightingNode);
  /** @module LightUtils **/
  /**
   * Represents a `discard` shader operation in TSL.
   *
   * @method
   * @param {Object} inputs - The input parameter object.
   * @param {Node<float>} inputs.lightDistance - The distance of the light's position to the current fragment position.
   * @param {Node<float>} inputs.cutoffDistance - The light's cutoff distance.
   * @param {Node<float>} inputs.decayExponent - The light's decay exponent.
   * @return {Node<float>} The distance falloff.
   */
  var getDistanceAttenuation = /*@__PURE__*/Fn(function (inputs) {
    var lightDistance = inputs.lightDistance,
      cutoffDistance = inputs.cutoffDistance,
      decayExponent = inputs.decayExponent;

    // based upon Frostbite 3 Moving to Physically-based Rendering
    // page 32, equation 26: E[window1]
    // https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
    var distanceFalloff = lightDistance.pow(decayExponent).max(0.01).reciprocal();
    return cutoffDistance.greaterThan(0).select(distanceFalloff.mul(lightDistance.div(cutoffDistance).pow4().oneMinus().clamp().pow2()), distanceFalloff);
  }); // validated

  /** @module PointShadowNode **/

  var _clearColor$2 = /*@__PURE__*/new (_$$_REQUIRE(_dependencyMap[1], "./three.core.js").Color)();

  // cubeToUV() maps a 3D direction vector suitable for cube texture mapping to a 2D
  // vector suitable for 2D texture mapping. This code uses the following layout for the
  // 2D texture:
  //
  // xzXZ
  //  y Y
  //
  // Y - Positive y direction
  // y - Negative y direction
  // X - Positive x direction
  // x - Negative x direction
  // Z - Positive z direction
  // z - Negative z direction
  //
  // Source and test bed:
  // https://gist.github.com/tschw/da10c43c467ce8afd0c4

  var cubeToUV = /*@__PURE__*/Fn(function (_ref198) {
    var _ref199 = (0, _slicedToArray2.default)(_ref198, 2),
      pos = _ref199[0],
      texelSizeY = _ref199[1];
    var v = pos.toVar();

    // Number of texels to avoid at the edge of each square

    var absV = abs(v);

    // Intersect unit cube

    var scaleToCube = div(1.0, max$1(absV.x, max$1(absV.y, absV.z)));
    absV.mulAssign(scaleToCube);

    // Apply scale to avoid seams

    // two texels less per square (one texel will do for NEAREST)
    v.mulAssign(scaleToCube.mul(texelSizeY.mul(2).oneMinus()));

    // Unwrap

    // space: -1 ... 1 range for each square
    //
    // #X##		dim    := ( 4 , 2 )
    //  # #		center := ( 1 , 1 )

    var planar = vec2(v.xy).toVar();
    var almostATexel = texelSizeY.mul(1.5);
    var almostOne = almostATexel.oneMinus();
    If(absV.z.greaterThanEqual(almostOne), function () {
      If(v.z.greaterThan(0.0), function () {
        planar.x.assign(sub(4.0, v.x));
      });
    }).ElseIf(absV.x.greaterThanEqual(almostOne), function () {
      var signX = sign(v.x);
      planar.x.assign(v.z.mul(signX).add(signX.mul(2.0)));
    }).ElseIf(absV.y.greaterThanEqual(almostOne), function () {
      var signY = sign(v.y);
      planar.x.assign(v.x.add(signY.mul(2.0)).add(2.0));
      planar.y.assign(v.z.mul(signY).sub(2.0));
    });

    // Transform to UV space

    // scale := 0.5 / dim
    // translate := ( center + 0.5 ) / dim
    return vec2(0.125, 0.25).mul(planar).add(vec2(0.375, 0.75)).flipY();
  }).setLayout({
    name: 'cubeToUV',
    type: 'vec2',
    inputs: [{
      name: 'pos',
      type: 'vec3'
    }, {
      name: 'texelSizeY',
      type: 'float'
    }]
  });
  var BasicPointShadowFilter = /*@__PURE__*/Fn(function (_ref200) {
    var depthTexture = _ref200.depthTexture,
      bd3D = _ref200.bd3D,
      dp = _ref200.dp,
      texelSize = _ref200.texelSize;
    return texture(depthTexture, cubeToUV(bd3D, texelSize.y)).compare(dp);
  });
  var PointShadowFilter = /*@__PURE__*/Fn(function (_ref201) {
    var depthTexture = _ref201.depthTexture,
      bd3D = _ref201.bd3D,
      dp = _ref201.dp,
      texelSize = _ref201.texelSize,
      shadow = _ref201.shadow;
    var radius = reference('radius', 'float', shadow).setGroup(renderGroup);
    var offset = vec2(-1.0, 1.0).mul(radius).mul(texelSize.y);
    return texture(depthTexture, cubeToUV(bd3D.add(offset.xyy), texelSize.y)).compare(dp).add(texture(depthTexture, cubeToUV(bd3D.add(offset.yyy), texelSize.y)).compare(dp)).add(texture(depthTexture, cubeToUV(bd3D.add(offset.xyx), texelSize.y)).compare(dp)).add(texture(depthTexture, cubeToUV(bd3D.add(offset.yyx), texelSize.y)).compare(dp)).add(texture(depthTexture, cubeToUV(bd3D, texelSize.y)).compare(dp)).add(texture(depthTexture, cubeToUV(bd3D.add(offset.xxy), texelSize.y)).compare(dp)).add(texture(depthTexture, cubeToUV(bd3D.add(offset.yxy), texelSize.y)).compare(dp)).add(texture(depthTexture, cubeToUV(bd3D.add(offset.xxx), texelSize.y)).compare(dp)).add(texture(depthTexture, cubeToUV(bd3D.add(offset.yxx), texelSize.y)).compare(dp)).mul(1.0 / 9.0);
  });
  var pointShadowFilter = /*@__PURE__*/Fn(function (_ref202) {
    var filterFn = _ref202.filterFn,
      depthTexture = _ref202.depthTexture,
      shadowCoord = _ref202.shadowCoord,
      shadow = _ref202.shadow;
    // for point lights, the uniform @vShadowCoord is re-purposed to hold
    // the vector from the light to the world-space position of the fragment.
    var lightToPosition = shadowCoord.xyz.toVar();
    var lightToPositionLength = lightToPosition.length();
    var cameraNearLocal = uniform('float').setGroup(renderGroup).onRenderUpdate(function () {
      return shadow.camera.near;
    });
    var cameraFarLocal = uniform('float').setGroup(renderGroup).onRenderUpdate(function () {
      return shadow.camera.far;
    });
    var bias = reference('bias', 'float', shadow).setGroup(renderGroup);
    var mapSize = uniform(shadow.mapSize).setGroup(renderGroup);
    var result = float(1.0).toVar();
    If(lightToPositionLength.sub(cameraFarLocal).lessThanEqual(0.0).and(lightToPositionLength.sub(cameraNearLocal).greaterThanEqual(0.0)), function () {
      // dp = normalized distance from light to fragment position
      var dp = lightToPositionLength.sub(cameraNearLocal).div(cameraFarLocal.sub(cameraNearLocal)).toVar(); // need to clamp?
      dp.addAssign(bias);

      // bd3D = base direction 3D
      var bd3D = lightToPosition.normalize();
      var texelSize = vec2(1.0).div(mapSize.mul(vec2(4.0, 2.0)));

      // percentage-closer filtering
      result.assign(filterFn({
        depthTexture: depthTexture,
        bd3D: bd3D,
        dp: dp,
        texelSize: texelSize,
        shadow: shadow
      }));
    });
    return result;
  });
  var _viewport = /*@__PURE__*/new (_$$_REQUIRE(_dependencyMap[1], "./three.core.js").Vector4)();
  var _viewportSize = /*@__PURE__*/new (_$$_REQUIRE(_dependencyMap[1], "./three.core.js").Vector2)();
  var _shadowMapSize = /*@__PURE__*/new (_$$_REQUIRE(_dependencyMap[1], "./three.core.js").Vector2)();

  /**
   * Represents the shadow implementation for point light nodes.
   *
   * @augments module:ShadowNode~ShadowNode
   */
  var PointShadowNode = /*#__PURE__*/function (_ShadowNode) {
    /**
     * Constructs a new point shadow node.
     *
     * @param {PointLight} light - The shadow casting point light.
     * @param {PointLightShadow?} [shadow=null] - An optional point light shadow.
     */
    function PointShadowNode(light) {
      var shadow = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      (0, _classCallCheck2.default)(this, PointShadowNode);
      return _callSuper(this, PointShadowNode, [light, shadow]);
    }

    /**
     * Overwrites the default implementation to return point light shadow specific
     * filtering functions.
     *
     * @param {Number} type - The shadow type.
     * @return {Function} The filtering function.
     */
    (0, _inherits2.default)(PointShadowNode, _ShadowNode);
    return (0, _createClass2.default)(PointShadowNode, [{
      key: "getShadowFilterFn",
      value: function getShadowFilterFn(type) {
        return type === _$$_REQUIRE(_dependencyMap[1], "./three.core.js").BasicShadowMap ? BasicPointShadowFilter : PointShadowFilter;
      }

      /**
       * Overwrites the default implementation so the unaltered shadow position is used.
       *
       * @param {NodeBuilder} builder - A reference to the current node builder.
       * @param {Node<vec3>} shadowPosition - A node representing the shadow position.
       * @return {Node<vec3>} The shadow coordinates.
       */
    }, {
      key: "setupShadowCoord",
      value: function setupShadowCoord(builder, shadowPosition) {
        return shadowPosition;
      }

      /**
       * Overwrites the default implementation to only use point light specific
       * shadow filter functions.
       *
       * @param {NodeBuilder} builder - A reference to the current node builder.
       * @param {Object} inputs - A configuration object that defines the shadow filtering.
       * @param {Function} inputs.filterFn - This function defines the filtering type of the shadow map e.g. PCF.
       * @param {Texture} inputs.shadowTexture - A reference to the shadow map's texture.
       * @param {DepthTexture} inputs.depthTexture - A reference to the shadow map's texture data.
       * @param {Node<vec3>} inputs.shadowCoord - Shadow coordinates which are used to sample from the shadow map.
       * @param {LightShadow} inputs.shadow - The light shadow.
       * @return {Node<float>} The result node of the shadow filtering.
       */
    }, {
      key: "setupShadowFilter",
      value: function setupShadowFilter(builder, _ref203) {
        var filterFn = _ref203.filterFn,
          shadowTexture = _ref203.shadowTexture,
          depthTexture = _ref203.depthTexture,
          shadowCoord = _ref203.shadowCoord,
          shadow = _ref203.shadow;
        return pointShadowFilter({
          filterFn: filterFn,
          shadowTexture: shadowTexture,
          depthTexture: depthTexture,
          shadowCoord: shadowCoord,
          shadow: shadow
        });
      }

      /**
       * Overwrites the default implementation with point light specific
       * rendering code.
       *
       * @param {NodeFrame} frame - A reference to the current node frame.
       */
    }, {
      key: "renderShadow",
      value: function renderShadow(frame) {
        var shadow = this.shadow,
          shadowMap = this.shadowMap,
          light = this.light;
        var renderer = frame.renderer,
          scene = frame.scene;
        var shadowFrameExtents = shadow.getFrameExtents();
        _shadowMapSize.copy(shadow.mapSize);
        _shadowMapSize.multiply(shadowFrameExtents);
        shadowMap.setSize(_shadowMapSize.width, _shadowMapSize.height);
        _viewportSize.copy(shadow.mapSize);

        //

        var previousAutoClear = renderer.autoClear;
        var previousClearColor = renderer.getClearColor(_clearColor$2);
        var previousClearAlpha = renderer.getClearAlpha();
        renderer.autoClear = false;
        renderer.setClearColor(shadow.clearColor, shadow.clearAlpha);
        renderer.clear();
        var viewportCount = shadow.getViewportCount();
        for (var vp = 0; vp < viewportCount; vp++) {
          var _viewport2 = shadow.getViewport(vp);
          var x = _viewportSize.x * _viewport2.x;
          var y = _shadowMapSize.y - _viewportSize.y - _viewportSize.y * _viewport2.y;
          _viewport.set(x, y, _viewportSize.x * _viewport2.z, _viewportSize.y * _viewport2.w);
          shadowMap.viewport.copy(_viewport);
          shadow.updateMatrices(light, vp);
          renderer.render(scene, shadow.camera);
        }

        //

        renderer.autoClear = previousAutoClear;
        renderer.setClearColor(previousClearColor, previousClearAlpha);
      }
    }], [{
      key: "type",
      get: function get() {
        return 'PointShadowNode';
      }
    }]);
  }(ShadowNode);
  /**
   * TSL function for creating an instance of `PointShadowNode`.
   *
   * @function
   * @param {PointLight} light - The shadow casting point light.
   * @param {PointLightShadow?} [shadow=null] - An optional point light shadow.
   * @return {PointShadowNode} The created point shadow node.
   */
  var pointShadow = function pointShadow(light, shadow) {
    return nodeObject(new PointShadowNode(light, shadow));
  };
  var directPointLight = Fn(function (_ref204, builder) {
    var color = _ref204.color,
      lightViewPosition = _ref204.lightViewPosition,
      cutoffDistance = _ref204.cutoffDistance,
      decayExponent = _ref204.decayExponent;
    var lightingModel = builder.context.lightingModel;
    var lVector = lightViewPosition.sub(positionView); // @TODO: Add it into LightNode

    var lightDirection = lVector.normalize();
    var lightDistance = lVector.length();
    var lightAttenuation = getDistanceAttenuation({
      lightDistance: lightDistance,
      cutoffDistance: cutoffDistance,
      decayExponent: decayExponent
    });
    var lightColor = color.mul(lightAttenuation);
    var reflectedLight = builder.context.reflectedLight;
    lightingModel.direct({
      lightDirection: lightDirection,
      lightColor: lightColor,
      reflectedLight: reflectedLight
    }, builder.stack, builder);
  });

  /**
   * Module for representing point lights as nodes.
   *
   * @augments AnalyticLightNode
   */
  var PointLightNode = exports.PointLightNode = /*#__PURE__*/function (_AnalyticLightNode) {
    /**
     * Constructs a new point light node.
     *
     * @param {PointLight?} [light=null] - The point light source.
     */
    function PointLightNode() {
      var _this166;
      var light = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      (0, _classCallCheck2.default)(this, PointLightNode);
      _this166 = _callSuper(this, PointLightNode, [light]);

      /**
       * Uniform node representing the cutoff distance.
       *
       * @type {UniformNode<float>}
       */
      _this166.cutoffDistanceNode = uniform(0).setGroup(renderGroup);

      /**
       * Uniform node representing the decay exponent.
       *
       * @type {UniformNode<float>}
       */
      _this166.decayExponentNode = uniform(2).setGroup(renderGroup);
      return _this166;
    }

    /**
     * Overwritten to updated point light specific uniforms.
     *
     * @param {NodeFrame} frame - A reference to the current node frame.
     */
    (0, _inherits2.default)(PointLightNode, _AnalyticLightNode);
    return (0, _createClass2.default)(PointLightNode, [{
      key: "update",
      value: function update(frame) {
        var light = this.light;
        _superPropGet(PointLightNode, "update", this, 3)([frame]);
        this.cutoffDistanceNode.value = light.distance;
        this.decayExponentNode.value = light.decay;
      }

      /**
       * Overwritten to setup point light specific shadow.
       *
       * @return {PointShadowNode}
       */
    }, {
      key: "setupShadowNode",
      value: function setupShadowNode() {
        return pointShadow(this.light);
      }
    }, {
      key: "setup",
      value: function setup(builder) {
        _superPropGet(PointLightNode, "setup", this, 3)([builder]);
        directPointLight({
          color: this.colorNode,
          lightViewPosition: lightViewPosition(this.light),
          cutoffDistance: this.cutoffDistanceNode,
          decayExponent: this.decayExponentNode
        }).append();
      }
    }], [{
      key: "type",
      get: function get() {
        return 'PointLightNode';
      }
    }]);
  }(AnalyticLightNode);
  /** @module Procedural **/
  /**
   * Creates a 2x2 checkerboard pattern that can be used as procedural texture data.
   *
   * @method
   * @param {Node<vec2>} coord - The uv coordinates.
   * @return {Node<float>} The result data.
   */
  var checker = /*@__PURE__*/Fn(function (_ref205) {
    var _ref206 = (0, _slicedToArray2.default)(_ref205, 1),
      _ref206$ = _ref206[0],
      coord = _ref206$ === void 0 ? uv() : _ref206$;
    return function () {
      var uv = coord.mul(2.0);
      var cx = uv.x.floor();
      var cy = uv.y.floor();
      var result = cx.add(cy).mod(2.0);
      return result.sign();
    }();
  });

  // Three.js Transpiler
  // https://raw.githubusercontent.com/AcademySoftwareFoundation/MaterialX/main/libraries/stdlib/genglsl/lib/mx_noise.glsl

  var mx_select = /*@__PURE__*/Fn(function (_ref207) {
    var _ref208 = (0, _slicedToArray2.default)(_ref207, 3),
      b_immutable = _ref208[0],
      t_immutable = _ref208[1],
      f_immutable = _ref208[2];
    var f = float(f_immutable).toVar();
    var t = float(t_immutable).toVar();
    var b = bool(b_immutable).toVar();
    return select(b, t, f);
  }).setLayout({
    name: 'mx_select',
    type: 'float',
    inputs: [{
      name: 'b',
      type: 'bool'
    }, {
      name: 't',
      type: 'float'
    }, {
      name: 'f',
      type: 'float'
    }]
  });
  var mx_negate_if = /*@__PURE__*/Fn(function (_ref209) {
    var _ref210 = (0, _slicedToArray2.default)(_ref209, 2),
      val_immutable = _ref210[0],
      b_immutable = _ref210[1];
    var b = bool(b_immutable).toVar();
    var val = float(val_immutable).toVar();
    return select(b, val.negate(), val);
  }).setLayout({
    name: 'mx_negate_if',
    type: 'float',
    inputs: [{
      name: 'val',
      type: 'float'
    }, {
      name: 'b',
      type: 'bool'
    }]
  });
  var mx_floor = /*@__PURE__*/Fn(function (_ref211) {
    var _ref212 = (0, _slicedToArray2.default)(_ref211, 1),
      x_immutable = _ref212[0];
    var x = float(x_immutable).toVar();
    return int(floor(x));
  }).setLayout({
    name: 'mx_floor',
    type: 'int',
    inputs: [{
      name: 'x',
      type: 'float'
    }]
  });
  var mx_floorfrac = /*@__PURE__*/Fn(function (_ref213) {
    var _ref214 = (0, _slicedToArray2.default)(_ref213, 2),
      x_immutable = _ref214[0],
      i = _ref214[1];
    var x = float(x_immutable).toVar();
    i.assign(mx_floor(x));
    return x.sub(float(i));
  });
  var mx_bilerp_0 = /*@__PURE__*/Fn(function (_ref215) {
    var _ref216 = (0, _slicedToArray2.default)(_ref215, 6),
      v0_immutable = _ref216[0],
      v1_immutable = _ref216[1],
      v2_immutable = _ref216[2],
      v3_immutable = _ref216[3],
      s_immutable = _ref216[4],
      t_immutable = _ref216[5];
    var t = float(t_immutable).toVar();
    var s = float(s_immutable).toVar();
    var v3 = float(v3_immutable).toVar();
    var v2 = float(v2_immutable).toVar();
    var v1 = float(v1_immutable).toVar();
    var v0 = float(v0_immutable).toVar();
    var s1 = float(sub(1.0, s)).toVar();
    return sub(1.0, t).mul(v0.mul(s1).add(v1.mul(s))).add(t.mul(v2.mul(s1).add(v3.mul(s))));
  }).setLayout({
    name: 'mx_bilerp_0',
    type: 'float',
    inputs: [{
      name: 'v0',
      type: 'float'
    }, {
      name: 'v1',
      type: 'float'
    }, {
      name: 'v2',
      type: 'float'
    }, {
      name: 'v3',
      type: 'float'
    }, {
      name: 's',
      type: 'float'
    }, {
      name: 't',
      type: 'float'
    }]
  });
  var mx_bilerp_1 = /*@__PURE__*/Fn(function (_ref217) {
    var _ref218 = (0, _slicedToArray2.default)(_ref217, 6),
      v0_immutable = _ref218[0],
      v1_immutable = _ref218[1],
      v2_immutable = _ref218[2],
      v3_immutable = _ref218[3],
      s_immutable = _ref218[4],
      t_immutable = _ref218[5];
    var t = float(t_immutable).toVar();
    var s = float(s_immutable).toVar();
    var v3 = vec3(v3_immutable).toVar();
    var v2 = vec3(v2_immutable).toVar();
    var v1 = vec3(v1_immutable).toVar();
    var v0 = vec3(v0_immutable).toVar();
    var s1 = float(sub(1.0, s)).toVar();
    return sub(1.0, t).mul(v0.mul(s1).add(v1.mul(s))).add(t.mul(v2.mul(s1).add(v3.mul(s))));
  }).setLayout({
    name: 'mx_bilerp_1',
    type: 'vec3',
    inputs: [{
      name: 'v0',
      type: 'vec3'
    }, {
      name: 'v1',
      type: 'vec3'
    }, {
      name: 'v2',
      type: 'vec3'
    }, {
      name: 'v3',
      type: 'vec3'
    }, {
      name: 's',
      type: 'float'
    }, {
      name: 't',
      type: 'float'
    }]
  });
  var mx_bilerp = /*@__PURE__*/overloadingFn([mx_bilerp_0, mx_bilerp_1]);
  var mx_trilerp_0 = /*@__PURE__*/Fn(function (_ref219) {
    var _ref220 = (0, _slicedToArray2.default)(_ref219, 11),
      v0_immutable = _ref220[0],
      v1_immutable = _ref220[1],
      v2_immutable = _ref220[2],
      v3_immutable = _ref220[3],
      v4_immutable = _ref220[4],
      v5_immutable = _ref220[5],
      v6_immutable = _ref220[6],
      v7_immutable = _ref220[7],
      s_immutable = _ref220[8],
      t_immutable = _ref220[9],
      r_immutable = _ref220[10];
    var r = float(r_immutable).toVar();
    var t = float(t_immutable).toVar();
    var s = float(s_immutable).toVar();
    var v7 = float(v7_immutable).toVar();
    var v6 = float(v6_immutable).toVar();
    var v5 = float(v5_immutable).toVar();
    var v4 = float(v4_immutable).toVar();
    var v3 = float(v3_immutable).toVar();
    var v2 = float(v2_immutable).toVar();
    var v1 = float(v1_immutable).toVar();
    var v0 = float(v0_immutable).toVar();
    var s1 = float(sub(1.0, s)).toVar();
    var t1 = float(sub(1.0, t)).toVar();
    var r1 = float(sub(1.0, r)).toVar();
    return r1.mul(t1.mul(v0.mul(s1).add(v1.mul(s))).add(t.mul(v2.mul(s1).add(v3.mul(s))))).add(r.mul(t1.mul(v4.mul(s1).add(v5.mul(s))).add(t.mul(v6.mul(s1).add(v7.mul(s))))));
  }).setLayout({
    name: 'mx_trilerp_0',
    type: 'float',
    inputs: [{
      name: 'v0',
      type: 'float'
    }, {
      name: 'v1',
      type: 'float'
    }, {
      name: 'v2',
      type: 'float'
    }, {
      name: 'v3',
      type: 'float'
    }, {
      name: 'v4',
      type: 'float'
    }, {
      name: 'v5',
      type: 'float'
    }, {
      name: 'v6',
      type: 'float'
    }, {
      name: 'v7',
      type: 'float'
    }, {
      name: 's',
      type: 'float'
    }, {
      name: 't',
      type: 'float'
    }, {
      name: 'r',
      type: 'float'
    }]
  });
  var mx_trilerp_1 = /*@__PURE__*/Fn(function (_ref221) {
    var _ref222 = (0, _slicedToArray2.default)(_ref221, 11),
      v0_immutable = _ref222[0],
      v1_immutable = _ref222[1],
      v2_immutable = _ref222[2],
      v3_immutable = _ref222[3],
      v4_immutable = _ref222[4],
      v5_immutable = _ref222[5],
      v6_immutable = _ref222[6],
      v7_immutable = _ref222[7],
      s_immutable = _ref222[8],
      t_immutable = _ref222[9],
      r_immutable = _ref222[10];
    var r = float(r_immutable).toVar();
    var t = float(t_immutable).toVar();
    var s = float(s_immutable).toVar();
    var v7 = vec3(v7_immutable).toVar();
    var v6 = vec3(v6_immutable).toVar();
    var v5 = vec3(v5_immutable).toVar();
    var v4 = vec3(v4_immutable).toVar();
    var v3 = vec3(v3_immutable).toVar();
    var v2 = vec3(v2_immutable).toVar();
    var v1 = vec3(v1_immutable).toVar();
    var v0 = vec3(v0_immutable).toVar();
    var s1 = float(sub(1.0, s)).toVar();
    var t1 = float(sub(1.0, t)).toVar();
    var r1 = float(sub(1.0, r)).toVar();
    return r1.mul(t1.mul(v0.mul(s1).add(v1.mul(s))).add(t.mul(v2.mul(s1).add(v3.mul(s))))).add(r.mul(t1.mul(v4.mul(s1).add(v5.mul(s))).add(t.mul(v6.mul(s1).add(v7.mul(s))))));
  }).setLayout({
    name: 'mx_trilerp_1',
    type: 'vec3',
    inputs: [{
      name: 'v0',
      type: 'vec3'
    }, {
      name: 'v1',
      type: 'vec3'
    }, {
      name: 'v2',
      type: 'vec3'
    }, {
      name: 'v3',
      type: 'vec3'
    }, {
      name: 'v4',
      type: 'vec3'
    }, {
      name: 'v5',
      type: 'vec3'
    }, {
      name: 'v6',
      type: 'vec3'
    }, {
      name: 'v7',
      type: 'vec3'
    }, {
      name: 's',
      type: 'float'
    }, {
      name: 't',
      type: 'float'
    }, {
      name: 'r',
      type: 'float'
    }]
  });
  var mx_trilerp = /*@__PURE__*/overloadingFn([mx_trilerp_0, mx_trilerp_1]);
  var mx_gradient_float_0 = /*@__PURE__*/Fn(function (_ref223) {
    var _ref224 = (0, _slicedToArray2.default)(_ref223, 3),
      hash_immutable = _ref224[0],
      x_immutable = _ref224[1],
      y_immutable = _ref224[2];
    var y = float(y_immutable).toVar();
    var x = float(x_immutable).toVar();
    var hash = uint(hash_immutable).toVar();
    var h = uint(hash.bitAnd(uint(7))).toVar();
    var u = float(mx_select(h.lessThan(uint(4)), x, y)).toVar();
    var v = float(mul(2.0, mx_select(h.lessThan(uint(4)), y, x))).toVar();
    return mx_negate_if(u, bool(h.bitAnd(uint(1)))).add(mx_negate_if(v, bool(h.bitAnd(uint(2)))));
  }).setLayout({
    name: 'mx_gradient_float_0',
    type: 'float',
    inputs: [{
      name: 'hash',
      type: 'uint'
    }, {
      name: 'x',
      type: 'float'
    }, {
      name: 'y',
      type: 'float'
    }]
  });
  var mx_gradient_float_1 = /*@__PURE__*/Fn(function (_ref225) {
    var _ref226 = (0, _slicedToArray2.default)(_ref225, 4),
      hash_immutable = _ref226[0],
      x_immutable = _ref226[1],
      y_immutable = _ref226[2],
      z_immutable = _ref226[3];
    var z = float(z_immutable).toVar();
    var y = float(y_immutable).toVar();
    var x = float(x_immutable).toVar();
    var hash = uint(hash_immutable).toVar();
    var h = uint(hash.bitAnd(uint(15))).toVar();
    var u = float(mx_select(h.lessThan(uint(8)), x, y)).toVar();
    var v = float(mx_select(h.lessThan(uint(4)), y, mx_select(h.equal(uint(12)).or(h.equal(uint(14))), x, z))).toVar();
    return mx_negate_if(u, bool(h.bitAnd(uint(1)))).add(mx_negate_if(v, bool(h.bitAnd(uint(2)))));
  }).setLayout({
    name: 'mx_gradient_float_1',
    type: 'float',
    inputs: [{
      name: 'hash',
      type: 'uint'
    }, {
      name: 'x',
      type: 'float'
    }, {
      name: 'y',
      type: 'float'
    }, {
      name: 'z',
      type: 'float'
    }]
  });
  var mx_gradient_float = /*@__PURE__*/overloadingFn([mx_gradient_float_0, mx_gradient_float_1]);
  var mx_gradient_vec3_0 = /*@__PURE__*/Fn(function (_ref227) {
    var _ref228 = (0, _slicedToArray2.default)(_ref227, 3),
      hash_immutable = _ref228[0],
      x_immutable = _ref228[1],
      y_immutable = _ref228[2];
    var y = float(y_immutable).toVar();
    var x = float(x_immutable).toVar();
    var hash = uvec3(hash_immutable).toVar();
    return vec3(mx_gradient_float(hash.x, x, y), mx_gradient_float(hash.y, x, y), mx_gradient_float(hash.z, x, y));
  }).setLayout({
    name: 'mx_gradient_vec3_0',
    type: 'vec3',
    inputs: [{
      name: 'hash',
      type: 'uvec3'
    }, {
      name: 'x',
      type: 'float'
    }, {
      name: 'y',
      type: 'float'
    }]
  });
  var mx_gradient_vec3_1 = /*@__PURE__*/Fn(function (_ref229) {
    var _ref230 = (0, _slicedToArray2.default)(_ref229, 4),
      hash_immutable = _ref230[0],
      x_immutable = _ref230[1],
      y_immutable = _ref230[2],
      z_immutable = _ref230[3];
    var z = float(z_immutable).toVar();
    var y = float(y_immutable).toVar();
    var x = float(x_immutable).toVar();
    var hash = uvec3(hash_immutable).toVar();
    return vec3(mx_gradient_float(hash.x, x, y, z), mx_gradient_float(hash.y, x, y, z), mx_gradient_float(hash.z, x, y, z));
  }).setLayout({
    name: 'mx_gradient_vec3_1',
    type: 'vec3',
    inputs: [{
      name: 'hash',
      type: 'uvec3'
    }, {
      name: 'x',
      type: 'float'
    }, {
      name: 'y',
      type: 'float'
    }, {
      name: 'z',
      type: 'float'
    }]
  });
  var mx_gradient_vec3 = /*@__PURE__*/overloadingFn([mx_gradient_vec3_0, mx_gradient_vec3_1]);
  var mx_gradient_scale2d_0 = /*@__PURE__*/Fn(function (_ref231) {
    var _ref232 = (0, _slicedToArray2.default)(_ref231, 1),
      v_immutable = _ref232[0];
    var v = float(v_immutable).toVar();
    return mul(0.6616, v);
  }).setLayout({
    name: 'mx_gradient_scale2d_0',
    type: 'float',
    inputs: [{
      name: 'v',
      type: 'float'
    }]
  });
  var mx_gradient_scale3d_0 = /*@__PURE__*/Fn(function (_ref233) {
    var _ref234 = (0, _slicedToArray2.default)(_ref233, 1),
      v_immutable = _ref234[0];
    var v = float(v_immutable).toVar();
    return mul(0.9820, v);
  }).setLayout({
    name: 'mx_gradient_scale3d_0',
    type: 'float',
    inputs: [{
      name: 'v',
      type: 'float'
    }]
  });
  var mx_gradient_scale2d_1 = /*@__PURE__*/Fn(function (_ref235) {
    var _ref236 = (0, _slicedToArray2.default)(_ref235, 1),
      v_immutable = _ref236[0];
    var v = vec3(v_immutable).toVar();
    return mul(0.6616, v);
  }).setLayout({
    name: 'mx_gradient_scale2d_1',
    type: 'vec3',
    inputs: [{
      name: 'v',
      type: 'vec3'
    }]
  });
  var mx_gradient_scale2d = /*@__PURE__*/overloadingFn([mx_gradient_scale2d_0, mx_gradient_scale2d_1]);
  var mx_gradient_scale3d_1 = /*@__PURE__*/Fn(function (_ref237) {
    var _ref238 = (0, _slicedToArray2.default)(_ref237, 1),
      v_immutable = _ref238[0];
    var v = vec3(v_immutable).toVar();
    return mul(0.9820, v);
  }).setLayout({
    name: 'mx_gradient_scale3d_1',
    type: 'vec3',
    inputs: [{
      name: 'v',
      type: 'vec3'
    }]
  });
  var mx_gradient_scale3d = /*@__PURE__*/overloadingFn([mx_gradient_scale3d_0, mx_gradient_scale3d_1]);
  var mx_rotl32 = /*@__PURE__*/Fn(function (_ref239) {
    var _ref240 = (0, _slicedToArray2.default)(_ref239, 2),
      x_immutable = _ref240[0],
      k_immutable = _ref240[1];
    var k = int(k_immutable).toVar();
    var x = uint(x_immutable).toVar();
    return x.shiftLeft(k).bitOr(x.shiftRight(int(32).sub(k)));
  }).setLayout({
    name: 'mx_rotl32',
    type: 'uint',
    inputs: [{
      name: 'x',
      type: 'uint'
    }, {
      name: 'k',
      type: 'int'
    }]
  });
  var mx_bjmix = /*@__PURE__*/Fn(function (_ref241) {
    var _ref242 = (0, _slicedToArray2.default)(_ref241, 3),
      a = _ref242[0],
      b = _ref242[1],
      c = _ref242[2];
    a.subAssign(c);
    a.bitXorAssign(mx_rotl32(c, int(4)));
    c.addAssign(b);
    b.subAssign(a);
    b.bitXorAssign(mx_rotl32(a, int(6)));
    a.addAssign(c);
    c.subAssign(b);
    c.bitXorAssign(mx_rotl32(b, int(8)));
    b.addAssign(a);
    a.subAssign(c);
    a.bitXorAssign(mx_rotl32(c, int(16)));
    c.addAssign(b);
    b.subAssign(a);
    b.bitXorAssign(mx_rotl32(a, int(19)));
    a.addAssign(c);
    c.subAssign(b);
    c.bitXorAssign(mx_rotl32(b, int(4)));
    b.addAssign(a);
  });
  var mx_bjfinal = /*@__PURE__*/Fn(function (_ref243) {
    var _ref244 = (0, _slicedToArray2.default)(_ref243, 3),
      a_immutable = _ref244[0],
      b_immutable = _ref244[1],
      c_immutable = _ref244[2];
    var c = uint(c_immutable).toVar();
    var b = uint(b_immutable).toVar();
    var a = uint(a_immutable).toVar();
    c.bitXorAssign(b);
    c.subAssign(mx_rotl32(b, int(14)));
    a.bitXorAssign(c);
    a.subAssign(mx_rotl32(c, int(11)));
    b.bitXorAssign(a);
    b.subAssign(mx_rotl32(a, int(25)));
    c.bitXorAssign(b);
    c.subAssign(mx_rotl32(b, int(16)));
    a.bitXorAssign(c);
    a.subAssign(mx_rotl32(c, int(4)));
    b.bitXorAssign(a);
    b.subAssign(mx_rotl32(a, int(14)));
    c.bitXorAssign(b);
    c.subAssign(mx_rotl32(b, int(24)));
    return c;
  }).setLayout({
    name: 'mx_bjfinal',
    type: 'uint',
    inputs: [{
      name: 'a',
      type: 'uint'
    }, {
      name: 'b',
      type: 'uint'
    }, {
      name: 'c',
      type: 'uint'
    }]
  });
  var mx_bits_to_01 = /*@__PURE__*/Fn(function (_ref245) {
    var _ref246 = (0, _slicedToArray2.default)(_ref245, 1),
      bits_immutable = _ref246[0];
    var bits = uint(bits_immutable).toVar();
    return float(bits).div(float(uint(int(0xffffffff))));
  }).setLayout({
    name: 'mx_bits_to_01',
    type: 'float',
    inputs: [{
      name: 'bits',
      type: 'uint'
    }]
  });
  var mx_fade = /*@__PURE__*/Fn(function (_ref247) {
    var _ref248 = (0, _slicedToArray2.default)(_ref247, 1),
      t_immutable = _ref248[0];
    var t = float(t_immutable).toVar();
    return t.mul(t).mul(t).mul(t.mul(t.mul(6.0).sub(15.0)).add(10.0));
  }).setLayout({
    name: 'mx_fade',
    type: 'float',
    inputs: [{
      name: 't',
      type: 'float'
    }]
  });
  var mx_hash_int_0 = /*@__PURE__*/Fn(function (_ref249) {
    var _ref250 = (0, _slicedToArray2.default)(_ref249, 1),
      x_immutable = _ref250[0];
    var x = int(x_immutable).toVar();
    var len = uint(uint(1)).toVar();
    var seed = uint(uint(int(0xdeadbeef)).add(len.shiftLeft(uint(2))).add(uint(13))).toVar();
    return mx_bjfinal(seed.add(uint(x)), seed, seed);
  }).setLayout({
    name: 'mx_hash_int_0',
    type: 'uint',
    inputs: [{
      name: 'x',
      type: 'int'
    }]
  });
  var mx_hash_int_1 = /*@__PURE__*/Fn(function (_ref251) {
    var _ref252 = (0, _slicedToArray2.default)(_ref251, 2),
      x_immutable = _ref252[0],
      y_immutable = _ref252[1];
    var y = int(y_immutable).toVar();
    var x = int(x_immutable).toVar();
    var len = uint(uint(2)).toVar();
    var a = uint().toVar(),
      b = uint().toVar(),
      c = uint().toVar();
    a.assign(b.assign(c.assign(uint(int(0xdeadbeef)).add(len.shiftLeft(uint(2))).add(uint(13)))));
    a.addAssign(uint(x));
    b.addAssign(uint(y));
    return mx_bjfinal(a, b, c);
  }).setLayout({
    name: 'mx_hash_int_1',
    type: 'uint',
    inputs: [{
      name: 'x',
      type: 'int'
    }, {
      name: 'y',
      type: 'int'
    }]
  });
  var mx_hash_int_2 = /*@__PURE__*/Fn(function (_ref253) {
    var _ref254 = (0, _slicedToArray2.default)(_ref253, 3),
      x_immutable = _ref254[0],
      y_immutable = _ref254[1],
      z_immutable = _ref254[2];
    var z = int(z_immutable).toVar();
    var y = int(y_immutable).toVar();
    var x = int(x_immutable).toVar();
    var len = uint(uint(3)).toVar();
    var a = uint().toVar(),
      b = uint().toVar(),
      c = uint().toVar();
    a.assign(b.assign(c.assign(uint(int(0xdeadbeef)).add(len.shiftLeft(uint(2))).add(uint(13)))));
    a.addAssign(uint(x));
    b.addAssign(uint(y));
    c.addAssign(uint(z));
    return mx_bjfinal(a, b, c);
  }).setLayout({
    name: 'mx_hash_int_2',
    type: 'uint',
    inputs: [{
      name: 'x',
      type: 'int'
    }, {
      name: 'y',
      type: 'int'
    }, {
      name: 'z',
      type: 'int'
    }]
  });
  var mx_hash_int_3 = /*@__PURE__*/Fn(function (_ref255) {
    var _ref256 = (0, _slicedToArray2.default)(_ref255, 4),
      x_immutable = _ref256[0],
      y_immutable = _ref256[1],
      z_immutable = _ref256[2],
      xx_immutable = _ref256[3];
    var xx = int(xx_immutable).toVar();
    var z = int(z_immutable).toVar();
    var y = int(y_immutable).toVar();
    var x = int(x_immutable).toVar();
    var len = uint(uint(4)).toVar();
    var a = uint().toVar(),
      b = uint().toVar(),
      c = uint().toVar();
    a.assign(b.assign(c.assign(uint(int(0xdeadbeef)).add(len.shiftLeft(uint(2))).add(uint(13)))));
    a.addAssign(uint(x));
    b.addAssign(uint(y));
    c.addAssign(uint(z));
    mx_bjmix(a, b, c);
    a.addAssign(uint(xx));
    return mx_bjfinal(a, b, c);
  }).setLayout({
    name: 'mx_hash_int_3',
    type: 'uint',
    inputs: [{
      name: 'x',
      type: 'int'
    }, {
      name: 'y',
      type: 'int'
    }, {
      name: 'z',
      type: 'int'
    }, {
      name: 'xx',
      type: 'int'
    }]
  });
  var mx_hash_int_4 = /*@__PURE__*/Fn(function (_ref257) {
    var _ref258 = (0, _slicedToArray2.default)(_ref257, 5),
      x_immutable = _ref258[0],
      y_immutable = _ref258[1],
      z_immutable = _ref258[2],
      xx_immutable = _ref258[3],
      yy_immutable = _ref258[4];
    var yy = int(yy_immutable).toVar();
    var xx = int(xx_immutable).toVar();
    var z = int(z_immutable).toVar();
    var y = int(y_immutable).toVar();
    var x = int(x_immutable).toVar();
    var len = uint(uint(5)).toVar();
    var a = uint().toVar(),
      b = uint().toVar(),
      c = uint().toVar();
    a.assign(b.assign(c.assign(uint(int(0xdeadbeef)).add(len.shiftLeft(uint(2))).add(uint(13)))));
    a.addAssign(uint(x));
    b.addAssign(uint(y));
    c.addAssign(uint(z));
    mx_bjmix(a, b, c);
    a.addAssign(uint(xx));
    b.addAssign(uint(yy));
    return mx_bjfinal(a, b, c);
  }).setLayout({
    name: 'mx_hash_int_4',
    type: 'uint',
    inputs: [{
      name: 'x',
      type: 'int'
    }, {
      name: 'y',
      type: 'int'
    }, {
      name: 'z',
      type: 'int'
    }, {
      name: 'xx',
      type: 'int'
    }, {
      name: 'yy',
      type: 'int'
    }]
  });
  var mx_hash_int = /*@__PURE__*/overloadingFn([mx_hash_int_0, mx_hash_int_1, mx_hash_int_2, mx_hash_int_3, mx_hash_int_4]);
  var mx_hash_vec3_0 = /*@__PURE__*/Fn(function (_ref259) {
    var _ref260 = (0, _slicedToArray2.default)(_ref259, 2),
      x_immutable = _ref260[0],
      y_immutable = _ref260[1];
    var y = int(y_immutable).toVar();
    var x = int(x_immutable).toVar();
    var h = uint(mx_hash_int(x, y)).toVar();
    var result = uvec3().toVar();
    result.x.assign(h.bitAnd(int(0xFF)));
    result.y.assign(h.shiftRight(int(8)).bitAnd(int(0xFF)));
    result.z.assign(h.shiftRight(int(16)).bitAnd(int(0xFF)));
    return result;
  }).setLayout({
    name: 'mx_hash_vec3_0',
    type: 'uvec3',
    inputs: [{
      name: 'x',
      type: 'int'
    }, {
      name: 'y',
      type: 'int'
    }]
  });
  var mx_hash_vec3_1 = /*@__PURE__*/Fn(function (_ref261) {
    var _ref262 = (0, _slicedToArray2.default)(_ref261, 3),
      x_immutable = _ref262[0],
      y_immutable = _ref262[1],
      z_immutable = _ref262[2];
    var z = int(z_immutable).toVar();
    var y = int(y_immutable).toVar();
    var x = int(x_immutable).toVar();
    var h = uint(mx_hash_int(x, y, z)).toVar();
    var result = uvec3().toVar();
    result.x.assign(h.bitAnd(int(0xFF)));
    result.y.assign(h.shiftRight(int(8)).bitAnd(int(0xFF)));
    result.z.assign(h.shiftRight(int(16)).bitAnd(int(0xFF)));
    return result;
  }).setLayout({
    name: 'mx_hash_vec3_1',
    type: 'uvec3',
    inputs: [{
      name: 'x',
      type: 'int'
    }, {
      name: 'y',
      type: 'int'
    }, {
      name: 'z',
      type: 'int'
    }]
  });
  var mx_hash_vec3 = /*@__PURE__*/overloadingFn([mx_hash_vec3_0, mx_hash_vec3_1]);
  var mx_perlin_noise_float_0 = /*@__PURE__*/Fn(function (_ref263) {
    var _ref264 = (0, _slicedToArray2.default)(_ref263, 1),
      p_immutable = _ref264[0];
    var p = vec2(p_immutable).toVar();
    var X = int().toVar(),
      Y = int().toVar();
    var fx = float(mx_floorfrac(p.x, X)).toVar();
    var fy = float(mx_floorfrac(p.y, Y)).toVar();
    var u = float(mx_fade(fx)).toVar();
    var v = float(mx_fade(fy)).toVar();
    var result = float(mx_bilerp(mx_gradient_float(mx_hash_int(X, Y), fx, fy), mx_gradient_float(mx_hash_int(X.add(int(1)), Y), fx.sub(1.0), fy), mx_gradient_float(mx_hash_int(X, Y.add(int(1))), fx, fy.sub(1.0)), mx_gradient_float(mx_hash_int(X.add(int(1)), Y.add(int(1))), fx.sub(1.0), fy.sub(1.0)), u, v)).toVar();
    return mx_gradient_scale2d(result);
  }).setLayout({
    name: 'mx_perlin_noise_float_0',
    type: 'float',
    inputs: [{
      name: 'p',
      type: 'vec2'
    }]
  });
  var mx_perlin_noise_float_1 = /*@__PURE__*/Fn(function (_ref265) {
    var _ref266 = (0, _slicedToArray2.default)(_ref265, 1),
      p_immutable = _ref266[0];
    var p = vec3(p_immutable).toVar();
    var X = int().toVar(),
      Y = int().toVar(),
      Z = int().toVar();
    var fx = float(mx_floorfrac(p.x, X)).toVar();
    var fy = float(mx_floorfrac(p.y, Y)).toVar();
    var fz = float(mx_floorfrac(p.z, Z)).toVar();
    var u = float(mx_fade(fx)).toVar();
    var v = float(mx_fade(fy)).toVar();
    var w = float(mx_fade(fz)).toVar();
    var result = float(mx_trilerp(mx_gradient_float(mx_hash_int(X, Y, Z), fx, fy, fz), mx_gradient_float(mx_hash_int(X.add(int(1)), Y, Z), fx.sub(1.0), fy, fz), mx_gradient_float(mx_hash_int(X, Y.add(int(1)), Z), fx, fy.sub(1.0), fz), mx_gradient_float(mx_hash_int(X.add(int(1)), Y.add(int(1)), Z), fx.sub(1.0), fy.sub(1.0), fz), mx_gradient_float(mx_hash_int(X, Y, Z.add(int(1))), fx, fy, fz.sub(1.0)), mx_gradient_float(mx_hash_int(X.add(int(1)), Y, Z.add(int(1))), fx.sub(1.0), fy, fz.sub(1.0)), mx_gradient_float(mx_hash_int(X, Y.add(int(1)), Z.add(int(1))), fx, fy.sub(1.0), fz.sub(1.0)), mx_gradient_float(mx_hash_int(X.add(int(1)), Y.add(int(1)), Z.add(int(1))), fx.sub(1.0), fy.sub(1.0), fz.sub(1.0)), u, v, w)).toVar();
    return mx_gradient_scale3d(result);
  }).setLayout({
    name: 'mx_perlin_noise_float_1',
    type: 'float',
    inputs: [{
      name: 'p',
      type: 'vec3'
    }]
  });
  var mx_perlin_noise_float = /*@__PURE__*/overloadingFn([mx_perlin_noise_float_0, mx_perlin_noise_float_1]);
  var mx_perlin_noise_vec3_0 = /*@__PURE__*/Fn(function (_ref267) {
    var _ref268 = (0, _slicedToArray2.default)(_ref267, 1),
      p_immutable = _ref268[0];
    var p = vec2(p_immutable).toVar();
    var X = int().toVar(),
      Y = int().toVar();
    var fx = float(mx_floorfrac(p.x, X)).toVar();
    var fy = float(mx_floorfrac(p.y, Y)).toVar();
    var u = float(mx_fade(fx)).toVar();
    var v = float(mx_fade(fy)).toVar();
    var result = vec3(mx_bilerp(mx_gradient_vec3(mx_hash_vec3(X, Y), fx, fy), mx_gradient_vec3(mx_hash_vec3(X.add(int(1)), Y), fx.sub(1.0), fy), mx_gradient_vec3(mx_hash_vec3(X, Y.add(int(1))), fx, fy.sub(1.0)), mx_gradient_vec3(mx_hash_vec3(X.add(int(1)), Y.add(int(1))), fx.sub(1.0), fy.sub(1.0)), u, v)).toVar();
    return mx_gradient_scale2d(result);
  }).setLayout({
    name: 'mx_perlin_noise_vec3_0',
    type: 'vec3',
    inputs: [{
      name: 'p',
      type: 'vec2'
    }]
  });
  var mx_perlin_noise_vec3_1 = /*@__PURE__*/Fn(function (_ref269) {
    var _ref270 = (0, _slicedToArray2.default)(_ref269, 1),
      p_immutable = _ref270[0];
    var p = vec3(p_immutable).toVar();
    var X = int().toVar(),
      Y = int().toVar(),
      Z = int().toVar();
    var fx = float(mx_floorfrac(p.x, X)).toVar();
    var fy = float(mx_floorfrac(p.y, Y)).toVar();
    var fz = float(mx_floorfrac(p.z, Z)).toVar();
    var u = float(mx_fade(fx)).toVar();
    var v = float(mx_fade(fy)).toVar();
    var w = float(mx_fade(fz)).toVar();
    var result = vec3(mx_trilerp(mx_gradient_vec3(mx_hash_vec3(X, Y, Z), fx, fy, fz), mx_gradient_vec3(mx_hash_vec3(X.add(int(1)), Y, Z), fx.sub(1.0), fy, fz), mx_gradient_vec3(mx_hash_vec3(X, Y.add(int(1)), Z), fx, fy.sub(1.0), fz), mx_gradient_vec3(mx_hash_vec3(X.add(int(1)), Y.add(int(1)), Z), fx.sub(1.0), fy.sub(1.0), fz), mx_gradient_vec3(mx_hash_vec3(X, Y, Z.add(int(1))), fx, fy, fz.sub(1.0)), mx_gradient_vec3(mx_hash_vec3(X.add(int(1)), Y, Z.add(int(1))), fx.sub(1.0), fy, fz.sub(1.0)), mx_gradient_vec3(mx_hash_vec3(X, Y.add(int(1)), Z.add(int(1))), fx, fy.sub(1.0), fz.sub(1.0)), mx_gradient_vec3(mx_hash_vec3(X.add(int(1)), Y.add(int(1)), Z.add(int(1))), fx.sub(1.0), fy.sub(1.0), fz.sub(1.0)), u, v, w)).toVar();
    return mx_gradient_scale3d(result);
  }).setLayout({
    name: 'mx_perlin_noise_vec3_1',
    type: 'vec3',
    inputs: [{
      name: 'p',
      type: 'vec3'
    }]
  });
  var mx_perlin_noise_vec3 = /*@__PURE__*/overloadingFn([mx_perlin_noise_vec3_0, mx_perlin_noise_vec3_1]);
  var mx_cell_noise_float_0 = /*@__PURE__*/Fn(function (_ref271) {
    var _ref272 = (0, _slicedToArray2.default)(_ref271, 1),
      p_immutable = _ref272[0];
    var p = float(p_immutable).toVar();
    var ix = int(mx_floor(p)).toVar();
    return mx_bits_to_01(mx_hash_int(ix));
  }).setLayout({
    name: 'mx_cell_noise_float_0',
    type: 'float',
    inputs: [{
      name: 'p',
      type: 'float'
    }]
  });
  var mx_cell_noise_float_1 = /*@__PURE__*/Fn(function (_ref273) {
    var _ref274 = (0, _slicedToArray2.default)(_ref273, 1),
      p_immutable = _ref274[0];
    var p = vec2(p_immutable).toVar();
    var ix = int(mx_floor(p.x)).toVar();
    var iy = int(mx_floor(p.y)).toVar();
    return mx_bits_to_01(mx_hash_int(ix, iy));
  }).setLayout({
    name: 'mx_cell_noise_float_1',
    type: 'float',
    inputs: [{
      name: 'p',
      type: 'vec2'
    }]
  });
  var mx_cell_noise_float_2 = /*@__PURE__*/Fn(function (_ref275) {
    var _ref276 = (0, _slicedToArray2.default)(_ref275, 1),
      p_immutable = _ref276[0];
    var p = vec3(p_immutable).toVar();
    var ix = int(mx_floor(p.x)).toVar();
    var iy = int(mx_floor(p.y)).toVar();
    var iz = int(mx_floor(p.z)).toVar();
    return mx_bits_to_01(mx_hash_int(ix, iy, iz));
  }).setLayout({
    name: 'mx_cell_noise_float_2',
    type: 'float',
    inputs: [{
      name: 'p',
      type: 'vec3'
    }]
  });
  var mx_cell_noise_float_3 = /*@__PURE__*/Fn(function (_ref277) {
    var _ref278 = (0, _slicedToArray2.default)(_ref277, 1),
      p_immutable = _ref278[0];
    var p = vec4(p_immutable).toVar();
    var ix = int(mx_floor(p.x)).toVar();
    var iy = int(mx_floor(p.y)).toVar();
    var iz = int(mx_floor(p.z)).toVar();
    var iw = int(mx_floor(p.w)).toVar();
    return mx_bits_to_01(mx_hash_int(ix, iy, iz, iw));
  }).setLayout({
    name: 'mx_cell_noise_float_3',
    type: 'float',
    inputs: [{
      name: 'p',
      type: 'vec4'
    }]
  });
  var mx_cell_noise_float$1 = /*@__PURE__*/overloadingFn([mx_cell_noise_float_0, mx_cell_noise_float_1, mx_cell_noise_float_2, mx_cell_noise_float_3]);
  var mx_cell_noise_vec3_0 = /*@__PURE__*/Fn(function (_ref279) {
    var _ref280 = (0, _slicedToArray2.default)(_ref279, 1),
      p_immutable = _ref280[0];
    var p = float(p_immutable).toVar();
    var ix = int(mx_floor(p)).toVar();
    return vec3(mx_bits_to_01(mx_hash_int(ix, int(0))), mx_bits_to_01(mx_hash_int(ix, int(1))), mx_bits_to_01(mx_hash_int(ix, int(2))));
  }).setLayout({
    name: 'mx_cell_noise_vec3_0',
    type: 'vec3',
    inputs: [{
      name: 'p',
      type: 'float'
    }]
  });
  var mx_cell_noise_vec3_1 = /*@__PURE__*/Fn(function (_ref281) {
    var _ref282 = (0, _slicedToArray2.default)(_ref281, 1),
      p_immutable = _ref282[0];
    var p = vec2(p_immutable).toVar();
    var ix = int(mx_floor(p.x)).toVar();
    var iy = int(mx_floor(p.y)).toVar();
    return vec3(mx_bits_to_01(mx_hash_int(ix, iy, int(0))), mx_bits_to_01(mx_hash_int(ix, iy, int(1))), mx_bits_to_01(mx_hash_int(ix, iy, int(2))));
  }).setLayout({
    name: 'mx_cell_noise_vec3_1',
    type: 'vec3',
    inputs: [{
      name: 'p',
      type: 'vec2'
    }]
  });
  var mx_cell_noise_vec3_2 = /*@__PURE__*/Fn(function (_ref283) {
    var _ref284 = (0, _slicedToArray2.default)(_ref283, 1),
      p_immutable = _ref284[0];
    var p = vec3(p_immutable).toVar();
    var ix = int(mx_floor(p.x)).toVar();
    var iy = int(mx_floor(p.y)).toVar();
    var iz = int(mx_floor(p.z)).toVar();
    return vec3(mx_bits_to_01(mx_hash_int(ix, iy, iz, int(0))), mx_bits_to_01(mx_hash_int(ix, iy, iz, int(1))), mx_bits_to_01(mx_hash_int(ix, iy, iz, int(2))));
  }).setLayout({
    name: 'mx_cell_noise_vec3_2',
    type: 'vec3',
    inputs: [{
      name: 'p',
      type: 'vec3'
    }]
  });
  var mx_cell_noise_vec3_3 = /*@__PURE__*/Fn(function (_ref285) {
    var _ref286 = (0, _slicedToArray2.default)(_ref285, 1),
      p_immutable = _ref286[0];
    var p = vec4(p_immutable).toVar();
    var ix = int(mx_floor(p.x)).toVar();
    var iy = int(mx_floor(p.y)).toVar();
    var iz = int(mx_floor(p.z)).toVar();
    var iw = int(mx_floor(p.w)).toVar();
    return vec3(mx_bits_to_01(mx_hash_int(ix, iy, iz, iw, int(0))), mx_bits_to_01(mx_hash_int(ix, iy, iz, iw, int(1))), mx_bits_to_01(mx_hash_int(ix, iy, iz, iw, int(2))));
  }).setLayout({
    name: 'mx_cell_noise_vec3_3',
    type: 'vec3',
    inputs: [{
      name: 'p',
      type: 'vec4'
    }]
  });
  var mx_cell_noise_vec3 = /*@__PURE__*/overloadingFn([mx_cell_noise_vec3_0, mx_cell_noise_vec3_1, mx_cell_noise_vec3_2, mx_cell_noise_vec3_3]);
  var mx_fractal_noise_float$1 = /*@__PURE__*/Fn(function (_ref287) {
    var _ref288 = (0, _slicedToArray2.default)(_ref287, 4),
      p_immutable = _ref288[0],
      octaves_immutable = _ref288[1],
      lacunarity_immutable = _ref288[2],
      diminish_immutable = _ref288[3];
    var diminish = float(diminish_immutable).toVar();
    var lacunarity = float(lacunarity_immutable).toVar();
    var octaves = int(octaves_immutable).toVar();
    var p = vec3(p_immutable).toVar();
    var result = float(0.0).toVar();
    var amplitude = float(1.0).toVar();
    Loop(octaves, function () {
      result.addAssign(amplitude.mul(mx_perlin_noise_float(p)));
      amplitude.mulAssign(diminish);
      p.mulAssign(lacunarity);
    });
    return result;
  }).setLayout({
    name: 'mx_fractal_noise_float',
    type: 'float',
    inputs: [{
      name: 'p',
      type: 'vec3'
    }, {
      name: 'octaves',
      type: 'int'
    }, {
      name: 'lacunarity',
      type: 'float'
    }, {
      name: 'diminish',
      type: 'float'
    }]
  });
  var mx_fractal_noise_vec3$1 = /*@__PURE__*/Fn(function (_ref289) {
    var _ref290 = (0, _slicedToArray2.default)(_ref289, 4),
      p_immutable = _ref290[0],
      octaves_immutable = _ref290[1],
      lacunarity_immutable = _ref290[2],
      diminish_immutable = _ref290[3];
    var diminish = float(diminish_immutable).toVar();
    var lacunarity = float(lacunarity_immutable).toVar();
    var octaves = int(octaves_immutable).toVar();
    var p = vec3(p_immutable).toVar();
    var result = vec3(0.0).toVar();
    var amplitude = float(1.0).toVar();
    Loop(octaves, function () {
      result.addAssign(amplitude.mul(mx_perlin_noise_vec3(p)));
      amplitude.mulAssign(diminish);
      p.mulAssign(lacunarity);
    });
    return result;
  }).setLayout({
    name: 'mx_fractal_noise_vec3',
    type: 'vec3',
    inputs: [{
      name: 'p',
      type: 'vec3'
    }, {
      name: 'octaves',
      type: 'int'
    }, {
      name: 'lacunarity',
      type: 'float'
    }, {
      name: 'diminish',
      type: 'float'
    }]
  });
  var mx_fractal_noise_vec2$1 = /*@__PURE__*/Fn(function (_ref291) {
    var _ref292 = (0, _slicedToArray2.default)(_ref291, 4),
      p_immutable = _ref292[0],
      octaves_immutable = _ref292[1],
      lacunarity_immutable = _ref292[2],
      diminish_immutable = _ref292[3];
    var diminish = float(diminish_immutable).toVar();
    var lacunarity = float(lacunarity_immutable).toVar();
    var octaves = int(octaves_immutable).toVar();
    var p = vec3(p_immutable).toVar();
    return vec2(mx_fractal_noise_float$1(p, octaves, lacunarity, diminish), mx_fractal_noise_float$1(p.add(vec3(int(19), int(193), int(17))), octaves, lacunarity, diminish));
  }).setLayout({
    name: 'mx_fractal_noise_vec2',
    type: 'vec2',
    inputs: [{
      name: 'p',
      type: 'vec3'
    }, {
      name: 'octaves',
      type: 'int'
    }, {
      name: 'lacunarity',
      type: 'float'
    }, {
      name: 'diminish',
      type: 'float'
    }]
  });
  var mx_fractal_noise_vec4$1 = /*@__PURE__*/Fn(function (_ref293) {
    var _ref294 = (0, _slicedToArray2.default)(_ref293, 4),
      p_immutable = _ref294[0],
      octaves_immutable = _ref294[1],
      lacunarity_immutable = _ref294[2],
      diminish_immutable = _ref294[3];
    var diminish = float(diminish_immutable).toVar();
    var lacunarity = float(lacunarity_immutable).toVar();
    var octaves = int(octaves_immutable).toVar();
    var p = vec3(p_immutable).toVar();
    var c = vec3(mx_fractal_noise_vec3$1(p, octaves, lacunarity, diminish)).toVar();
    var f = float(mx_fractal_noise_float$1(p.add(vec3(int(19), int(193), int(17))), octaves, lacunarity, diminish)).toVar();
    return vec4(c, f);
  }).setLayout({
    name: 'mx_fractal_noise_vec4',
    type: 'vec4',
    inputs: [{
      name: 'p',
      type: 'vec3'
    }, {
      name: 'octaves',
      type: 'int'
    }, {
      name: 'lacunarity',
      type: 'float'
    }, {
      name: 'diminish',
      type: 'float'
    }]
  });
  var mx_worley_distance_0 = /*@__PURE__*/Fn(function (_ref295) {
    var _ref296 = (0, _slicedToArray2.default)(_ref295, 7),
      p_immutable = _ref296[0],
      x_immutable = _ref296[1],
      y_immutable = _ref296[2],
      xoff_immutable = _ref296[3],
      yoff_immutable = _ref296[4],
      jitter_immutable = _ref296[5],
      metric_immutable = _ref296[6];
    var metric = int(metric_immutable).toVar();
    var jitter = float(jitter_immutable).toVar();
    var yoff = int(yoff_immutable).toVar();
    var xoff = int(xoff_immutable).toVar();
    var y = int(y_immutable).toVar();
    var x = int(x_immutable).toVar();
    var p = vec2(p_immutable).toVar();
    var tmp = vec3(mx_cell_noise_vec3(vec2(x.add(xoff), y.add(yoff)))).toVar();
    var off = vec2(tmp.x, tmp.y).toVar();
    off.subAssign(0.5);
    off.mulAssign(jitter);
    off.addAssign(0.5);
    var cellpos = vec2(vec2(float(x), float(y)).add(off)).toVar();
    var diff = vec2(cellpos.sub(p)).toVar();
    If(metric.equal(int(2)), function () {
      return abs(diff.x).add(abs(diff.y));
    });
    If(metric.equal(int(3)), function () {
      return max$1(abs(diff.x), abs(diff.y));
    });
    return dot(diff, diff);
  }).setLayout({
    name: 'mx_worley_distance_0',
    type: 'float',
    inputs: [{
      name: 'p',
      type: 'vec2'
    }, {
      name: 'x',
      type: 'int'
    }, {
      name: 'y',
      type: 'int'
    }, {
      name: 'xoff',
      type: 'int'
    }, {
      name: 'yoff',
      type: 'int'
    }, {
      name: 'jitter',
      type: 'float'
    }, {
      name: 'metric',
      type: 'int'
    }]
  });
  var mx_worley_distance_1 = /*@__PURE__*/Fn(function (_ref297) {
    var _ref298 = (0, _slicedToArray2.default)(_ref297, 9),
      p_immutable = _ref298[0],
      x_immutable = _ref298[1],
      y_immutable = _ref298[2],
      z_immutable = _ref298[3],
      xoff_immutable = _ref298[4],
      yoff_immutable = _ref298[5],
      zoff_immutable = _ref298[6],
      jitter_immutable = _ref298[7],
      metric_immutable = _ref298[8];
    var metric = int(metric_immutable).toVar();
    var jitter = float(jitter_immutable).toVar();
    var zoff = int(zoff_immutable).toVar();
    var yoff = int(yoff_immutable).toVar();
    var xoff = int(xoff_immutable).toVar();
    var z = int(z_immutable).toVar();
    var y = int(y_immutable).toVar();
    var x = int(x_immutable).toVar();
    var p = vec3(p_immutable).toVar();
    var off = vec3(mx_cell_noise_vec3(vec3(x.add(xoff), y.add(yoff), z.add(zoff)))).toVar();
    off.subAssign(0.5);
    off.mulAssign(jitter);
    off.addAssign(0.5);
    var cellpos = vec3(vec3(float(x), float(y), float(z)).add(off)).toVar();
    var diff = vec3(cellpos.sub(p)).toVar();
    If(metric.equal(int(2)), function () {
      return abs(diff.x).add(abs(diff.y)).add(abs(diff.z));
    });
    If(metric.equal(int(3)), function () {
      return max$1(max$1(abs(diff.x), abs(diff.y)), abs(diff.z));
    });
    return dot(diff, diff);
  }).setLayout({
    name: 'mx_worley_distance_1',
    type: 'float',
    inputs: [{
      name: 'p',
      type: 'vec3'
    }, {
      name: 'x',
      type: 'int'
    }, {
      name: 'y',
      type: 'int'
    }, {
      name: 'z',
      type: 'int'
    }, {
      name: 'xoff',
      type: 'int'
    }, {
      name: 'yoff',
      type: 'int'
    }, {
      name: 'zoff',
      type: 'int'
    }, {
      name: 'jitter',
      type: 'float'
    }, {
      name: 'metric',
      type: 'int'
    }]
  });
  var mx_worley_distance = /*@__PURE__*/overloadingFn([mx_worley_distance_0, mx_worley_distance_1]);
  var mx_worley_noise_float_0 = /*@__PURE__*/Fn(function (_ref299) {
    var _ref300 = (0, _slicedToArray2.default)(_ref299, 3),
      p_immutable = _ref300[0],
      jitter_immutable = _ref300[1],
      metric_immutable = _ref300[2];
    var metric = int(metric_immutable).toVar();
    var jitter = float(jitter_immutable).toVar();
    var p = vec2(p_immutable).toVar();
    var X = int().toVar(),
      Y = int().toVar();
    var localpos = vec2(mx_floorfrac(p.x, X), mx_floorfrac(p.y, Y)).toVar();
    var sqdist = float(1e6).toVar();
    Loop({
      start: -1,
      end: int(1),
      name: 'x',
      condition: '<='
    }, function (_ref301) {
      var x = _ref301.x;
      Loop({
        start: -1,
        end: int(1),
        name: 'y',
        condition: '<='
      }, function (_ref302) {
        var y = _ref302.y;
        var dist = float(mx_worley_distance(localpos, x, y, X, Y, jitter, metric)).toVar();
        sqdist.assign(min$1(sqdist, dist));
      });
    });
    If(metric.equal(int(0)), function () {
      sqdist.assign(sqrt(sqdist));
    });
    return sqdist;
  }).setLayout({
    name: 'mx_worley_noise_float_0',
    type: 'float',
    inputs: [{
      name: 'p',
      type: 'vec2'
    }, {
      name: 'jitter',
      type: 'float'
    }, {
      name: 'metric',
      type: 'int'
    }]
  });
  var mx_worley_noise_vec2_0 = /*@__PURE__*/Fn(function (_ref303) {
    var _ref304 = (0, _slicedToArray2.default)(_ref303, 3),
      p_immutable = _ref304[0],
      jitter_immutable = _ref304[1],
      metric_immutable = _ref304[2];
    var metric = int(metric_immutable).toVar();
    var jitter = float(jitter_immutable).toVar();
    var p = vec2(p_immutable).toVar();
    var X = int().toVar(),
      Y = int().toVar();
    var localpos = vec2(mx_floorfrac(p.x, X), mx_floorfrac(p.y, Y)).toVar();
    var sqdist = vec2(1e6, 1e6).toVar();
    Loop({
      start: -1,
      end: int(1),
      name: 'x',
      condition: '<='
    }, function (_ref305) {
      var x = _ref305.x;
      Loop({
        start: -1,
        end: int(1),
        name: 'y',
        condition: '<='
      }, function (_ref306) {
        var y = _ref306.y;
        var dist = float(mx_worley_distance(localpos, x, y, X, Y, jitter, metric)).toVar();
        If(dist.lessThan(sqdist.x), function () {
          sqdist.y.assign(sqdist.x);
          sqdist.x.assign(dist);
        }).ElseIf(dist.lessThan(sqdist.y), function () {
          sqdist.y.assign(dist);
        });
      });
    });
    If(metric.equal(int(0)), function () {
      sqdist.assign(sqrt(sqdist));
    });
    return sqdist;
  }).setLayout({
    name: 'mx_worley_noise_vec2_0',
    type: 'vec2',
    inputs: [{
      name: 'p',
      type: 'vec2'
    }, {
      name: 'jitter',
      type: 'float'
    }, {
      name: 'metric',
      type: 'int'
    }]
  });
  var mx_worley_noise_vec3_0 = /*@__PURE__*/Fn(function (_ref307) {
    var _ref308 = (0, _slicedToArray2.default)(_ref307, 3),
      p_immutable = _ref308[0],
      jitter_immutable = _ref308[1],
      metric_immutable = _ref308[2];
    var metric = int(metric_immutable).toVar();
    var jitter = float(jitter_immutable).toVar();
    var p = vec2(p_immutable).toVar();
    var X = int().toVar(),
      Y = int().toVar();
    var localpos = vec2(mx_floorfrac(p.x, X), mx_floorfrac(p.y, Y)).toVar();
    var sqdist = vec3(1e6, 1e6, 1e6).toVar();
    Loop({
      start: -1,
      end: int(1),
      name: 'x',
      condition: '<='
    }, function (_ref309) {
      var x = _ref309.x;
      Loop({
        start: -1,
        end: int(1),
        name: 'y',
        condition: '<='
      }, function (_ref310) {
        var y = _ref310.y;
        var dist = float(mx_worley_distance(localpos, x, y, X, Y, jitter, metric)).toVar();
        If(dist.lessThan(sqdist.x), function () {
          sqdist.z.assign(sqdist.y);
          sqdist.y.assign(sqdist.x);
          sqdist.x.assign(dist);
        }).ElseIf(dist.lessThan(sqdist.y), function () {
          sqdist.z.assign(sqdist.y);
          sqdist.y.assign(dist);
        }).ElseIf(dist.lessThan(sqdist.z), function () {
          sqdist.z.assign(dist);
        });
      });
    });
    If(metric.equal(int(0)), function () {
      sqdist.assign(sqrt(sqdist));
    });
    return sqdist;
  }).setLayout({
    name: 'mx_worley_noise_vec3_0',
    type: 'vec3',
    inputs: [{
      name: 'p',
      type: 'vec2'
    }, {
      name: 'jitter',
      type: 'float'
    }, {
      name: 'metric',
      type: 'int'
    }]
  });
  var mx_worley_noise_float_1 = /*@__PURE__*/Fn(function (_ref311) {
    var _ref312 = (0, _slicedToArray2.default)(_ref311, 3),
      p_immutable = _ref312[0],
      jitter_immutable = _ref312[1],
      metric_immutable = _ref312[2];
    var metric = int(metric_immutable).toVar();
    var jitter = float(jitter_immutable).toVar();
    var p = vec3(p_immutable).toVar();
    var X = int().toVar(),
      Y = int().toVar(),
      Z = int().toVar();
    var localpos = vec3(mx_floorfrac(p.x, X), mx_floorfrac(p.y, Y), mx_floorfrac(p.z, Z)).toVar();
    var sqdist = float(1e6).toVar();
    Loop({
      start: -1,
      end: int(1),
      name: 'x',
      condition: '<='
    }, function (_ref313) {
      var x = _ref313.x;
      Loop({
        start: -1,
        end: int(1),
        name: 'y',
        condition: '<='
      }, function (_ref314) {
        var y = _ref314.y;
        Loop({
          start: -1,
          end: int(1),
          name: 'z',
          condition: '<='
        }, function (_ref315) {
          var z = _ref315.z;
          var dist = float(mx_worley_distance(localpos, x, y, z, X, Y, Z, jitter, metric)).toVar();
          sqdist.assign(min$1(sqdist, dist));
        });
      });
    });
    If(metric.equal(int(0)), function () {
      sqdist.assign(sqrt(sqdist));
    });
    return sqdist;
  }).setLayout({
    name: 'mx_worley_noise_float_1',
    type: 'float',
    inputs: [{
      name: 'p',
      type: 'vec3'
    }, {
      name: 'jitter',
      type: 'float'
    }, {
      name: 'metric',
      type: 'int'
    }]
  });
  var mx_worley_noise_float$1 = /*@__PURE__*/overloadingFn([mx_worley_noise_float_0, mx_worley_noise_float_1]);
  var mx_worley_noise_vec2_1 = /*@__PURE__*/Fn(function (_ref316) {
    var _ref317 = (0, _slicedToArray2.default)(_ref316, 3),
      p_immutable = _ref317[0],
      jitter_immutable = _ref317[1],
      metric_immutable = _ref317[2];
    var metric = int(metric_immutable).toVar();
    var jitter = float(jitter_immutable).toVar();
    var p = vec3(p_immutable).toVar();
    var X = int().toVar(),
      Y = int().toVar(),
      Z = int().toVar();
    var localpos = vec3(mx_floorfrac(p.x, X), mx_floorfrac(p.y, Y), mx_floorfrac(p.z, Z)).toVar();
    var sqdist = vec2(1e6, 1e6).toVar();
    Loop({
      start: -1,
      end: int(1),
      name: 'x',
      condition: '<='
    }, function (_ref318) {
      var x = _ref318.x;
      Loop({
        start: -1,
        end: int(1),
        name: 'y',
        condition: '<='
      }, function (_ref319) {
        var y = _ref319.y;
        Loop({
          start: -1,
          end: int(1),
          name: 'z',
          condition: '<='
        }, function (_ref320) {
          var z = _ref320.z;
          var dist = float(mx_worley_distance(localpos, x, y, z, X, Y, Z, jitter, metric)).toVar();
          If(dist.lessThan(sqdist.x), function () {
            sqdist.y.assign(sqdist.x);
            sqdist.x.assign(dist);
          }).ElseIf(dist.lessThan(sqdist.y), function () {
            sqdist.y.assign(dist);
          });
        });
      });
    });
    If(metric.equal(int(0)), function () {
      sqdist.assign(sqrt(sqdist));
    });
    return sqdist;
  }).setLayout({
    name: 'mx_worley_noise_vec2_1',
    type: 'vec2',
    inputs: [{
      name: 'p',
      type: 'vec3'
    }, {
      name: 'jitter',
      type: 'float'
    }, {
      name: 'metric',
      type: 'int'
    }]
  });
  var mx_worley_noise_vec2$1 = /*@__PURE__*/overloadingFn([mx_worley_noise_vec2_0, mx_worley_noise_vec2_1]);
  var mx_worley_noise_vec3_1 = /*@__PURE__*/Fn(function (_ref321) {
    var _ref322 = (0, _slicedToArray2.default)(_ref321, 3),
      p_immutable = _ref322[0],
      jitter_immutable = _ref322[1],
      metric_immutable = _ref322[2];
    var metric = int(metric_immutable).toVar();
    var jitter = float(jitter_immutable).toVar();
    var p = vec3(p_immutable).toVar();
    var X = int().toVar(),
      Y = int().toVar(),
      Z = int().toVar();
    var localpos = vec3(mx_floorfrac(p.x, X), mx_floorfrac(p.y, Y), mx_floorfrac(p.z, Z)).toVar();
    var sqdist = vec3(1e6, 1e6, 1e6).toVar();
    Loop({
      start: -1,
      end: int(1),
      name: 'x',
      condition: '<='
    }, function (_ref323) {
      var x = _ref323.x;
      Loop({
        start: -1,
        end: int(1),
        name: 'y',
        condition: '<='
      }, function (_ref324) {
        var y = _ref324.y;
        Loop({
          start: -1,
          end: int(1),
          name: 'z',
          condition: '<='
        }, function (_ref325) {
          var z = _ref325.z;
          var dist = float(mx_worley_distance(localpos, x, y, z, X, Y, Z, jitter, metric)).toVar();
          If(dist.lessThan(sqdist.x), function () {
            sqdist.z.assign(sqdist.y);
            sqdist.y.assign(sqdist.x);
            sqdist.x.assign(dist);
          }).ElseIf(dist.lessThan(sqdist.y), function () {
            sqdist.z.assign(sqdist.y);
            sqdist.y.assign(dist);
          }).ElseIf(dist.lessThan(sqdist.z), function () {
            sqdist.z.assign(dist);
          });
        });
      });
    });
    If(metric.equal(int(0)), function () {
      sqdist.assign(sqrt(sqdist));
    });
    return sqdist;
  }).setLayout({
    name: 'mx_worley_noise_vec3_1',
    type: 'vec3',
    inputs: [{
      name: 'p',
      type: 'vec3'
    }, {
      name: 'jitter',
      type: 'float'
    }, {
      name: 'metric',
      type: 'int'
    }]
  });
  var mx_worley_noise_vec3$1 = /*@__PURE__*/overloadingFn([mx_worley_noise_vec3_0, mx_worley_noise_vec3_1]);

  // Three.js Transpiler
  // https://github.com/AcademySoftwareFoundation/MaterialX/blob/main/libraries/stdlib/genglsl/lib/mx_hsv.glsl

  var mx_hsvtorgb = /*@__PURE__*/Fn(function (_ref326) {
    var _ref327 = (0, _slicedToArray2.default)(_ref326, 1),
      hsv = _ref327[0];
    var s = hsv.y;
    var v = hsv.z;
    var result = vec3().toVar();
    If(s.lessThan(0.0001), function () {
      result.assign(vec3(v, v, v));
    }).Else(function () {
      var h = hsv.x;
      h = h.sub(floor(h)).mul(6.0).toVar(); // TODO: check what .toVar() is needed in node system cache
      var hi = int(trunc(h));
      var f = h.sub(float(hi));
      var p = v.mul(s.oneMinus());
      var q = v.mul(s.mul(f).oneMinus());
      var t = v.mul(s.mul(f.oneMinus()).oneMinus());
      If(hi.equal(int(0)), function () {
        result.assign(vec3(v, t, p));
      }).ElseIf(hi.equal(int(1)), function () {
        result.assign(vec3(q, v, p));
      }).ElseIf(hi.equal(int(2)), function () {
        result.assign(vec3(p, v, t));
      }).ElseIf(hi.equal(int(3)), function () {
        result.assign(vec3(p, q, v));
      }).ElseIf(hi.equal(int(4)), function () {
        result.assign(vec3(t, p, v));
      }).Else(function () {
        result.assign(vec3(v, p, q));
      });
    });
    return result;
  }).setLayout({
    name: 'mx_hsvtorgb',
    type: 'vec3',
    inputs: [{
      name: 'hsv',
      type: 'vec3'
    }]
  });
  var mx_rgbtohsv = /*@__PURE__*/Fn(function (_ref328) {
    var _ref329 = (0, _slicedToArray2.default)(_ref328, 1),
      c_immutable = _ref329[0];
    var c = vec3(c_immutable).toVar();
    var r = float(c.x).toVar();
    var g = float(c.y).toVar();
    var b = float(c.z).toVar();
    var mincomp = float(min$1(r, min$1(g, b))).toVar();
    var maxcomp = float(max$1(r, max$1(g, b))).toVar();
    var delta = float(maxcomp.sub(mincomp)).toVar();
    var h = float().toVar(),
      s = float().toVar(),
      v = float().toVar();
    v.assign(maxcomp);
    If(maxcomp.greaterThan(0.0), function () {
      s.assign(delta.div(maxcomp));
    }).Else(function () {
      s.assign(0.0);
    });
    If(s.lessThanEqual(0.0), function () {
      h.assign(0.0);
    }).Else(function () {
      If(r.greaterThanEqual(maxcomp), function () {
        h.assign(g.sub(b).div(delta));
      }).ElseIf(g.greaterThanEqual(maxcomp), function () {
        h.assign(add(2.0, b.sub(r).div(delta)));
      }).Else(function () {
        h.assign(add(4.0, r.sub(g).div(delta)));
      });
      h.mulAssign(1.0 / 6.0);
      If(h.lessThan(0.0), function () {
        h.addAssign(1.0);
      });
    });
    return vec3(h, s, v);
  }).setLayout({
    name: 'mx_rgbtohsv',
    type: 'vec3',
    inputs: [{
      name: 'c',
      type: 'vec3'
    }]
  });

  // Three.js Transpiler
  // https://github.com/AcademySoftwareFoundation/MaterialX/blob/main/libraries/stdlib/genglsl/lib/mx_transform_color.glsl

  var mx_srgb_texture_to_lin_rec709 = /*@__PURE__*/Fn(function (_ref330) {
    var _ref331 = (0, _slicedToArray2.default)(_ref330, 1),
      color_immutable = _ref331[0];
    var color = vec3(color_immutable).toVar();
    var isAbove = bvec3(greaterThan(color, vec3(0.04045))).toVar();
    var linSeg = vec3(color.div(12.92)).toVar();
    var powSeg = vec3(pow(max$1(color.add(vec3(0.055)), vec3(0.0)).div(1.055), vec3(2.4))).toVar();
    return mix(linSeg, powSeg, isAbove);
  }).setLayout({
    name: 'mx_srgb_texture_to_lin_rec709',
    type: 'vec3',
    inputs: [{
      name: 'color',
      type: 'vec3'
    }]
  });
  var mx_aastep = function mx_aastep(threshold, value) {
    threshold = float(threshold);
    value = float(value);
    var afwidth = vec2(value.dFdx(), value.dFdy()).length().mul(0.70710678118654757);
    return smoothstep(threshold.sub(afwidth), threshold.add(afwidth), value);
  };
  var _ramp = function _ramp(a, b, uv, p) {
    return mix(a, b, uv[p].clamp());
  };
  var mx_ramplr = function mx_ramplr(valuel, valuer) {
    var texcoord = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : uv();
    return _ramp(valuel, valuer, texcoord, 'x');
  };
  var mx_ramptb = function mx_ramptb(valuet, valueb) {
    var texcoord = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : uv();
    return _ramp(valuet, valueb, texcoord, 'y');
  };
  var _split = function _split(a, b, center, uv, p) {
    return mix(a, b, mx_aastep(center, uv[p]));
  };
  var mx_splitlr = function mx_splitlr(valuel, valuer, center) {
    var texcoord = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : uv();
    return _split(valuel, valuer, center, texcoord, 'x');
  };
  var mx_splittb = function mx_splittb(valuet, valueb, center) {
    var texcoord = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : uv();
    return _split(valuet, valueb, center, texcoord, 'y');
  };
  var mx_transform_uv = function mx_transform_uv() {
    var uv_scale = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
    var uv_offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var uv_geo = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : uv();
    return uv_geo.mul(uv_scale).add(uv_offset);
  };
  var mx_safepower = function mx_safepower(in1) {
    var in2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
    in1 = float(in1);
    return in1.abs().pow(in2).mul(in1.sign());
  };
  var mx_contrast = function mx_contrast(input) {
    var amount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
    var pivot = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : .5;
    return float(input).sub(pivot).mul(amount).add(pivot);
  };
  var mx_noise_float = function mx_noise_float() {
    var texcoord = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : uv();
    var amplitude = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
    var pivot = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
    return mx_perlin_noise_float(texcoord.convert('vec2|vec3')).mul(amplitude).add(pivot);
  };
  //export const mx_noise_vec2 = ( texcoord = uv(), amplitude = 1, pivot = 0 ) => mx_perlin_noise_vec3( texcoord.convert( 'vec2|vec3' ) ).mul( amplitude ).add( pivot );
  var mx_noise_vec3 = function mx_noise_vec3() {
    var texcoord = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : uv();
    var amplitude = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
    var pivot = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
    return mx_perlin_noise_vec3(texcoord.convert('vec2|vec3')).mul(amplitude).add(pivot);
  };
  var mx_noise_vec4 = function mx_noise_vec4() {
    var texcoord = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : uv();
    var amplitude = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
    var pivot = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
    texcoord = texcoord.convert('vec2|vec3'); // overloading type

    var noise_vec4 = vec4(mx_perlin_noise_vec3(texcoord), mx_perlin_noise_float(texcoord.add(vec2(19, 73))));
    return noise_vec4.mul(amplitude).add(pivot);
  };
  var mx_worley_noise_float = function mx_worley_noise_float() {
    var texcoord = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : uv();
    var jitter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
    return mx_worley_noise_float$1(texcoord.convert('vec2|vec3'), jitter, int(1));
  };
  var mx_worley_noise_vec2 = function mx_worley_noise_vec2() {
    var texcoord = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : uv();
    var jitter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
    return mx_worley_noise_vec2$1(texcoord.convert('vec2|vec3'), jitter, int(1));
  };
  var mx_worley_noise_vec3 = function mx_worley_noise_vec3() {
    var texcoord = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : uv();
    var jitter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
    return mx_worley_noise_vec3$1(texcoord.convert('vec2|vec3'), jitter, int(1));
  };
  var mx_cell_noise_float = function mx_cell_noise_float() {
    var texcoord = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : uv();
    return mx_cell_noise_float$1(texcoord.convert('vec2|vec3'));
  };
  var mx_fractal_noise_float = function mx_fractal_noise_float() {
    var position = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : uv();
    var octaves = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 3;
    var lacunarity = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 2;
    var diminish = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : .5;
    var amplitude = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 1;
    return mx_fractal_noise_float$1(position, int(octaves), lacunarity, diminish).mul(amplitude);
  };
  var mx_fractal_noise_vec2 = function mx_fractal_noise_vec2() {
    var position = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : uv();
    var octaves = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 3;
    var lacunarity = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 2;
    var diminish = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : .5;
    var amplitude = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 1;
    return mx_fractal_noise_vec2$1(position, int(octaves), lacunarity, diminish).mul(amplitude);
  };
  var mx_fractal_noise_vec3 = function mx_fractal_noise_vec3() {
    var position = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : uv();
    var octaves = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 3;
    var lacunarity = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 2;
    var diminish = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : .5;
    var amplitude = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 1;
    return mx_fractal_noise_vec3$1(position, int(octaves), lacunarity, diminish).mul(amplitude);
  };
  var mx_fractal_noise_vec4 = function mx_fractal_noise_vec4() {
    var position = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : uv();
    var octaves = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 3;
    var lacunarity = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 2;
    var diminish = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : .5;
    var amplitude = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 1;
    return mx_fractal_noise_vec4$1(position, int(octaves), lacunarity, diminish).mul(amplitude);
  };

  /** @module getParallaxCorrectNormal **/

  /**
   * This computes a parallax corrected normal which is used for box-projected cube mapping (BPCEM).
   *
   * Reference: {@link https://devlog-martinsh.blogspot.com/2011/09/box-projected-cube-environment-mapping.html}
   *
   * ```js
   * const uvNode = getParallaxCorrectNormal( reflectVector, vec3( 200, 100, 100 ), vec3( 0, - 50, 0 ) );
   * material.envNode = pmremTexture( renderTarget.texture, uvNode );
   * ```
   * @function
   * @param {Node<vec3>} normal - The normal to correct.
   * @param {Node<vec3>} cubeSize - The cube size should reflect the size of the environment (BPCEM is usually applied in closed environments like rooms).
   * @param {Node<vec3>} cubePos - The cube position.
   * @return {Node<vec3>} The parallax corrected normal.
   */
  var getParallaxCorrectNormal = /*@__PURE__*/Fn(function (_ref332) {
    var _ref333 = (0, _slicedToArray2.default)(_ref332, 3),
      normal = _ref333[0],
      cubeSize = _ref333[1],
      cubePos = _ref333[2];
    var nDir = normalize(normal).toVar('nDir');
    var rbmax = sub(float(0.5).mul(cubeSize.sub(cubePos)), positionWorld).div(nDir).toVar('rbmax');
    var rbmin = sub(float(-0.5).mul(cubeSize.sub(cubePos)), positionWorld).div(nDir).toVar('rbmin');
    var rbminmax = vec3().toVar('rbminmax');
    rbminmax.x = nDir.x.greaterThan(float(0)).select(rbmax.x, rbmin.x);
    rbminmax.y = nDir.y.greaterThan(float(0)).select(rbmax.y, rbmin.y);
    rbminmax.z = nDir.z.greaterThan(float(0)).select(rbmax.z, rbmin.z);
    var correction = min$1(min$1(rbminmax.x, rbminmax.y), rbminmax.z).toVar('correction');
    var boxIntersection = positionWorld.add(nDir.mul(correction)).toVar('boxIntersection');
    return boxIntersection.sub(cubePos);
  });
  var getShIrradianceAt = /*@__PURE__*/Fn(function (_ref334) {
    var _ref335 = (0, _slicedToArray2.default)(_ref334, 2),
      normal = _ref335[0],
      shCoefficients = _ref335[1];
    // normal is assumed to have unit length

    var x = normal.x,
      y = normal.y,
      z = normal.z;

    // band 0
    var result = shCoefficients.element(0).mul(0.886227);

    // band 1
    result = result.add(shCoefficients.element(1).mul(2.0 * 0.511664).mul(y));
    result = result.add(shCoefficients.element(2).mul(2.0 * 0.511664).mul(z));
    result = result.add(shCoefficients.element(3).mul(2.0 * 0.511664).mul(x));

    // band 2
    result = result.add(shCoefficients.element(4).mul(2.0 * 0.429043).mul(x).mul(y));
    result = result.add(shCoefficients.element(5).mul(2.0 * 0.429043).mul(y).mul(z));
    result = result.add(shCoefficients.element(6).mul(z.mul(z).mul(0.743125).sub(0.247708)));
    result = result.add(shCoefficients.element(7).mul(2.0 * 0.429043).mul(x).mul(z));
    result = result.add(shCoefficients.element(8).mul(0.429043).mul(mul(x, x).sub(mul(y, y))));
    return result;
  });

  // constants

  var TSL = exports.TSL = /*#__PURE__*/Object.freeze({
    __proto__: null,
    BRDF_GGX: BRDF_GGX,
    BRDF_Lambert: BRDF_Lambert,
    BasicShadowFilter: BasicShadowFilter,
    Break: Break,
    Continue: Continue,
    DFGApprox: DFGApprox,
    D_GGX: D_GGX,
    Discard: Discard,
    EPSILON: EPSILON,
    F_Schlick: F_Schlick,
    Fn: Fn,
    INFINITY: INFINITY,
    If: If,
    Loop: Loop,
    NodeAccess: NodeAccess,
    NodeShaderStage: NodeShaderStage,
    NodeType: NodeType,
    NodeUpdateType: NodeUpdateType,
    PCFShadowFilter: PCFShadowFilter,
    PCFSoftShadowFilter: PCFSoftShadowFilter,
    PI: PI,
    PI2: PI2,
    Return: Return,
    Schlick_to_F0: Schlick_to_F0,
    ScriptableNodeResources: ScriptableNodeResources,
    ShaderNode: ShaderNode,
    TBNViewMatrix: TBNViewMatrix,
    VSMShadowFilter: VSMShadowFilter,
    V_GGX_SmithCorrelated: V_GGX_SmithCorrelated,
    abs: abs,
    acesFilmicToneMapping: acesFilmicToneMapping,
    acos: acos,
    add: add,
    addMethodChaining: addMethodChaining,
    addNodeElement: addNodeElement,
    agxToneMapping: agxToneMapping,
    all: all,
    alphaT: alphaT,
    and: and,
    anisotropy: anisotropy,
    anisotropyB: anisotropyB,
    anisotropyT: anisotropyT,
    any: any,
    append: append,
    arrayBuffer: arrayBuffer,
    asin: asin,
    assign: assign,
    atan: atan,
    atan2: atan2,
    atomicAdd: atomicAdd,
    atomicAnd: atomicAnd,
    atomicFunc: atomicFunc,
    atomicMax: atomicMax,
    atomicMin: atomicMin,
    atomicOr: atomicOr,
    atomicStore: atomicStore,
    atomicSub: atomicSub,
    atomicXor: atomicXor,
    attenuationColor: attenuationColor,
    attenuationDistance: attenuationDistance,
    attribute: attribute,
    attributeArray: attributeArray,
    backgroundBlurriness: backgroundBlurriness,
    backgroundIntensity: backgroundIntensity,
    backgroundRotation: backgroundRotation,
    batch: batch,
    billboarding: billboarding,
    bitAnd: bitAnd,
    bitNot: bitNot,
    bitOr: bitOr,
    bitXor: bitXor,
    bitangentGeometry: bitangentGeometry,
    bitangentLocal: bitangentLocal,
    bitangentView: bitangentView,
    bitangentWorld: bitangentWorld,
    bitcast: bitcast,
    blendBurn: blendBurn,
    blendColor: blendColor,
    blendDodge: blendDodge,
    blendOverlay: blendOverlay,
    blendScreen: blendScreen,
    blur: blur,
    bool: bool,
    buffer: buffer,
    bufferAttribute: bufferAttribute,
    bumpMap: bumpMap,
    burn: burn,
    bvec2: bvec2,
    bvec3: bvec3,
    bvec4: bvec4,
    bypass: bypass,
    cache: cache,
    call: call,
    cameraFar: cameraFar,
    cameraNear: cameraNear,
    cameraNormalMatrix: cameraNormalMatrix,
    cameraPosition: cameraPosition,
    cameraProjectionMatrix: cameraProjectionMatrix,
    cameraProjectionMatrixInverse: cameraProjectionMatrixInverse,
    cameraViewMatrix: cameraViewMatrix,
    cameraWorldMatrix: cameraWorldMatrix,
    cbrt: cbrt,
    cdl: cdl,
    ceil: ceil,
    checker: checker,
    cineonToneMapping: cineonToneMapping,
    clamp: clamp,
    clearcoat: clearcoat,
    clearcoatRoughness: clearcoatRoughness,
    code: code,
    color: color,
    colorSpaceToWorking: colorSpaceToWorking,
    colorToDirection: colorToDirection,
    compute: compute,
    cond: cond,
    context: context,
    convert: convert,
    convertColorSpace: convertColorSpace,
    convertToTexture: convertToTexture,
    cos: cos,
    cross: cross,
    cubeTexture: cubeTexture,
    dFdx: dFdx,
    dFdy: dFdy,
    dashSize: dashSize,
    defaultBuildStages: defaultBuildStages,
    defaultShaderStages: defaultShaderStages,
    defined: defined,
    degrees: degrees,
    deltaTime: deltaTime,
    densityFog: densityFog,
    densityFogFactor: densityFogFactor,
    depth: depth,
    depthPass: depthPass,
    difference: difference,
    diffuseColor: diffuseColor,
    directPointLight: directPointLight,
    directionToColor: directionToColor,
    dispersion: dispersion,
    distance: distance,
    div: div,
    dodge: dodge,
    dot: dot,
    drawIndex: drawIndex,
    dynamicBufferAttribute: dynamicBufferAttribute,
    element: element,
    emissive: emissive,
    equal: equal,
    equals: equals,
    equirectUV: equirectUV,
    exp: exp,
    exp2: exp2,
    expression: expression,
    faceDirection: faceDirection,
    faceForward: faceForward,
    faceforward: faceforward,
    float: float,
    floor: floor,
    fog: fog,
    fract: fract,
    frameGroup: frameGroup,
    frameId: frameId,
    frontFacing: frontFacing,
    fwidth: fwidth,
    gain: gain,
    gapSize: gapSize,
    getConstNodeType: getConstNodeType,
    getCurrentStack: getCurrentStack,
    getDirection: getDirection,
    getDistanceAttenuation: getDistanceAttenuation,
    getGeometryRoughness: getGeometryRoughness,
    getNormalFromDepth: getNormalFromDepth,
    getParallaxCorrectNormal: getParallaxCorrectNormal,
    getRoughness: getRoughness,
    getScreenPosition: getScreenPosition,
    getShIrradianceAt: getShIrradianceAt,
    getTextureIndex: getTextureIndex,
    getViewPosition: getViewPosition,
    glsl: glsl,
    glslFn: glslFn,
    grayscale: grayscale,
    greaterThan: greaterThan,
    greaterThanEqual: greaterThanEqual,
    hash: hash,
    highpModelNormalViewMatrix: highpModelNormalViewMatrix,
    highpModelViewMatrix: highpModelViewMatrix,
    hue: hue,
    instance: instance,
    instanceIndex: instanceIndex,
    instancedArray: instancedArray,
    instancedBufferAttribute: instancedBufferAttribute,
    instancedDynamicBufferAttribute: instancedDynamicBufferAttribute,
    instancedMesh: instancedMesh,
    int: int,
    inverseSqrt: inverseSqrt,
    inversesqrt: inversesqrt,
    invocationLocalIndex: invocationLocalIndex,
    invocationSubgroupIndex: invocationSubgroupIndex,
    ior: ior,
    iridescence: iridescence,
    iridescenceIOR: iridescenceIOR,
    iridescenceThickness: iridescenceThickness,
    ivec2: ivec2,
    ivec3: ivec3,
    ivec4: ivec4,
    js: js,
    label: label,
    length: length,
    lengthSq: lengthSq,
    lessThan: lessThan,
    lessThanEqual: lessThanEqual,
    lightPosition: lightPosition,
    lightProjectionUV: lightProjectionUV,
    lightShadowMatrix: lightShadowMatrix,
    lightTargetDirection: lightTargetDirection,
    lightTargetPosition: lightTargetPosition,
    lightViewPosition: lightViewPosition,
    lightingContext: lightingContext,
    lights: lights,
    linearDepth: linearDepth,
    linearToneMapping: linearToneMapping,
    localId: localId,
    log: log,
    log2: log2,
    logarithmicDepthToViewZ: logarithmicDepthToViewZ,
    loop: loop,
    luminance: luminance,
    mat2: mat2,
    mat3: mat3,
    mat4: mat4,
    matcapUV: matcapUV,
    materialAO: materialAO,
    materialAlphaTest: materialAlphaTest,
    materialAnisotropy: materialAnisotropy,
    materialAnisotropyVector: materialAnisotropyVector,
    materialAttenuationColor: materialAttenuationColor,
    materialAttenuationDistance: materialAttenuationDistance,
    materialClearcoat: materialClearcoat,
    materialClearcoatNormal: materialClearcoatNormal,
    materialClearcoatRoughness: materialClearcoatRoughness,
    materialColor: materialColor,
    materialDispersion: materialDispersion,
    materialEmissive: materialEmissive,
    materialIOR: materialIOR,
    materialIridescence: materialIridescence,
    materialIridescenceIOR: materialIridescenceIOR,
    materialIridescenceThickness: materialIridescenceThickness,
    materialLightMap: materialLightMap,
    materialLineDashOffset: materialLineDashOffset,
    materialLineDashSize: materialLineDashSize,
    materialLineGapSize: materialLineGapSize,
    materialLineScale: materialLineScale,
    materialLineWidth: materialLineWidth,
    materialMetalness: materialMetalness,
    materialNormal: materialNormal,
    materialOpacity: materialOpacity,
    materialPointWidth: materialPointWidth,
    materialReference: materialReference,
    materialReflectivity: materialReflectivity,
    materialRefractionRatio: materialRefractionRatio,
    materialRotation: materialRotation,
    materialRoughness: materialRoughness,
    materialSheen: materialSheen,
    materialSheenRoughness: materialSheenRoughness,
    materialShininess: materialShininess,
    materialSpecular: materialSpecular,
    materialSpecularColor: materialSpecularColor,
    materialSpecularIntensity: materialSpecularIntensity,
    materialSpecularStrength: materialSpecularStrength,
    materialThickness: materialThickness,
    materialTransmission: materialTransmission,
    max: max$1,
    maxMipLevel: maxMipLevel,
    mediumpModelViewMatrix: mediumpModelViewMatrix,
    metalness: metalness,
    min: min$1,
    mix: mix,
    mixElement: mixElement,
    mod: mod,
    modInt: modInt,
    modelDirection: modelDirection,
    modelNormalMatrix: modelNormalMatrix,
    modelPosition: modelPosition,
    modelScale: modelScale,
    modelViewMatrix: modelViewMatrix,
    modelViewPosition: modelViewPosition,
    modelViewProjection: modelViewProjection,
    modelWorldMatrix: modelWorldMatrix,
    modelWorldMatrixInverse: modelWorldMatrixInverse,
    morphReference: morphReference,
    mrt: mrt,
    mul: mul,
    mx_aastep: mx_aastep,
    mx_cell_noise_float: mx_cell_noise_float,
    mx_contrast: mx_contrast,
    mx_fractal_noise_float: mx_fractal_noise_float,
    mx_fractal_noise_vec2: mx_fractal_noise_vec2,
    mx_fractal_noise_vec3: mx_fractal_noise_vec3,
    mx_fractal_noise_vec4: mx_fractal_noise_vec4,
    mx_hsvtorgb: mx_hsvtorgb,
    mx_noise_float: mx_noise_float,
    mx_noise_vec3: mx_noise_vec3,
    mx_noise_vec4: mx_noise_vec4,
    mx_ramplr: mx_ramplr,
    mx_ramptb: mx_ramptb,
    mx_rgbtohsv: mx_rgbtohsv,
    mx_safepower: mx_safepower,
    mx_splitlr: mx_splitlr,
    mx_splittb: mx_splittb,
    mx_srgb_texture_to_lin_rec709: mx_srgb_texture_to_lin_rec709,
    mx_transform_uv: mx_transform_uv,
    mx_worley_noise_float: mx_worley_noise_float,
    mx_worley_noise_vec2: mx_worley_noise_vec2,
    mx_worley_noise_vec3: mx_worley_noise_vec3,
    negate: negate,
    neutralToneMapping: neutralToneMapping,
    nodeArray: nodeArray,
    nodeImmutable: nodeImmutable,
    nodeObject: nodeObject,
    nodeObjects: nodeObjects,
    nodeProxy: nodeProxy,
    normalFlat: normalFlat,
    normalGeometry: normalGeometry,
    normalLocal: normalLocal,
    normalMap: normalMap,
    normalView: normalView,
    normalWorld: normalWorld,
    normalize: normalize,
    not: not,
    notEqual: notEqual,
    numWorkgroups: numWorkgroups,
    objectDirection: objectDirection,
    objectGroup: objectGroup,
    objectPosition: objectPosition,
    objectScale: objectScale,
    objectViewPosition: objectViewPosition,
    objectWorldMatrix: objectWorldMatrix,
    oneMinus: oneMinus,
    or: or,
    orthographicDepthToViewZ: orthographicDepthToViewZ,
    oscSawtooth: oscSawtooth,
    oscSine: oscSine,
    oscSquare: oscSquare,
    oscTriangle: oscTriangle,
    output: output,
    outputStruct: outputStruct,
    overlay: overlay,
    overloadingFn: overloadingFn,
    parabola: parabola,
    parallaxDirection: parallaxDirection,
    parallaxUV: parallaxUV,
    parameter: parameter,
    pass: pass,
    passTexture: passTexture,
    pcurve: pcurve,
    perspectiveDepthToViewZ: perspectiveDepthToViewZ,
    pmremTexture: pmremTexture,
    pointUV: pointUV,
    pointWidth: pointWidth,
    positionGeometry: positionGeometry,
    positionLocal: positionLocal,
    positionPrevious: positionPrevious,
    positionView: positionView,
    positionViewDirection: positionViewDirection,
    positionWorld: positionWorld,
    positionWorldDirection: positionWorldDirection,
    posterize: posterize,
    pow: pow,
    pow2: pow2,
    pow3: pow3,
    pow4: pow4,
    property: property,
    radians: radians,
    rand: rand,
    range: range,
    rangeFog: rangeFog,
    rangeFogFactor: rangeFogFactor,
    reciprocal: reciprocal,
    reference: reference,
    referenceBuffer: referenceBuffer,
    reflect: reflect,
    reflectVector: reflectVector,
    reflectView: reflectView,
    reflector: reflector,
    refract: refract,
    refractVector: refractVector,
    refractView: refractView,
    reinhardToneMapping: reinhardToneMapping,
    remainder: remainder,
    remap: remap,
    remapClamp: remapClamp,
    renderGroup: renderGroup,
    renderOutput: renderOutput,
    rendererReference: rendererReference,
    rotate: rotate,
    rotateUV: rotateUV,
    roughness: roughness,
    round: round,
    rtt: rtt,
    sRGBTransferEOTF: sRGBTransferEOTF,
    sRGBTransferOETF: sRGBTransferOETF,
    sampler: sampler,
    saturate: saturate,
    saturation: saturation,
    screen: screen,
    screenCoordinate: screenCoordinate,
    screenSize: screenSize,
    screenUV: screenUV,
    scriptable: scriptable,
    scriptableValue: scriptableValue,
    select: select,
    setCurrentStack: setCurrentStack,
    shaderStages: shaderStages,
    shadow: shadow,
    shadowPositionWorld: shadowPositionWorld,
    sharedUniformGroup: sharedUniformGroup,
    sheen: sheen,
    sheenRoughness: sheenRoughness,
    shiftLeft: shiftLeft,
    shiftRight: shiftRight,
    shininess: shininess,
    sign: sign,
    sin: sin,
    sinc: sinc,
    skinning: skinning,
    skinningReference: skinningReference,
    smoothstep: smoothstep,
    smoothstepElement: smoothstepElement,
    specularColor: specularColor,
    specularF90: specularF90,
    spherizeUV: spherizeUV,
    split: split,
    spritesheetUV: spritesheetUV,
    sqrt: sqrt,
    stack: stack,
    step: step,
    storage: storage,
    storageBarrier: storageBarrier,
    storageObject: storageObject,
    storageTexture: storageTexture,
    string: string,
    sub: sub,
    subgroupIndex: subgroupIndex,
    subgroupSize: subgroupSize,
    tan: tan,
    tangentGeometry: tangentGeometry,
    tangentLocal: tangentLocal,
    tangentView: tangentView,
    tangentWorld: tangentWorld,
    temp: temp,
    texture: texture,
    texture3D: texture3D,
    textureBarrier: textureBarrier,
    textureBicubic: textureBicubic,
    textureCubeUV: textureCubeUV,
    textureLoad: textureLoad,
    textureSize: textureSize,
    textureStore: textureStore,
    thickness: thickness,
    time: time,
    timerDelta: timerDelta,
    timerGlobal: timerGlobal,
    timerLocal: timerLocal,
    toOutputColorSpace: toOutputColorSpace,
    toWorkingColorSpace: toWorkingColorSpace,
    toneMapping: toneMapping,
    toneMappingExposure: toneMappingExposure,
    toonOutlinePass: toonOutlinePass,
    transformDirection: transformDirection,
    transformNormal: transformNormal,
    transformNormalToView: transformNormalToView,
    transformedBentNormalView: transformedBentNormalView,
    transformedBitangentView: transformedBitangentView,
    transformedBitangentWorld: transformedBitangentWorld,
    transformedClearcoatNormalView: transformedClearcoatNormalView,
    transformedNormalView: transformedNormalView,
    transformedNormalWorld: transformedNormalWorld,
    transformedTangentView: transformedTangentView,
    transformedTangentWorld: transformedTangentWorld,
    transmission: transmission,
    transpose: transpose,
    triNoise3D: triNoise3D,
    triplanarTexture: triplanarTexture,
    triplanarTextures: triplanarTextures,
    trunc: trunc,
    tslFn: tslFn,
    uint: uint,
    uniform: uniform,
    uniformArray: uniformArray,
    uniformGroup: uniformGroup,
    uniforms: uniforms,
    userData: userData,
    uv: uv,
    uvec2: uvec2,
    uvec3: uvec3,
    uvec4: uvec4,
    varying: varying,
    varyingProperty: varyingProperty,
    vec2: vec2,
    vec3: vec3,
    vec4: vec4,
    vectorComponents: vectorComponents,
    velocity: velocity,
    vertexColor: vertexColor,
    vertexIndex: vertexIndex,
    vertexStage: vertexStage,
    vibrance: vibrance,
    viewZToLogarithmicDepth: viewZToLogarithmicDepth,
    viewZToOrthographicDepth: viewZToOrthographicDepth,
    viewZToPerspectiveDepth: viewZToPerspectiveDepth,
    viewport: viewport,
    viewportBottomLeft: viewportBottomLeft,
    viewportCoordinate: viewportCoordinate,
    viewportDepthTexture: viewportDepthTexture,
    viewportLinearDepth: viewportLinearDepth,
    viewportMipTexture: viewportMipTexture,
    viewportResolution: viewportResolution,
    viewportSafeUV: viewportSafeUV,
    viewportSharedTexture: viewportSharedTexture,
    viewportSize: viewportSize,
    viewportTexture: viewportTexture,
    viewportTopLeft: viewportTopLeft,
    viewportUV: viewportUV,
    wgsl: wgsl,
    wgslFn: wgslFn,
    workgroupArray: workgroupArray,
    workgroupBarrier: workgroupBarrier,
    workgroupId: workgroupId,
    workingToColorSpace: workingToColorSpace,
    xor: xor
  });
  var _clearColor$1 = /*@__PURE__*/new Color4();

  /**
   * This renderer module manages the background.
   *
   * @private
   * @augments DataMap
   */
  var Background = /*#__PURE__*/function (_DataMap6) {
    /**
     * Constructs a new background management component.
     *
     * @param {Renderer} renderer - The renderer.
     * @param {Nodes} nodes - Renderer component for managing nodes related logic.
     */
    function Background(renderer, nodes) {
      var _this167;
      (0, _classCallCheck2.default)(this, Background);
      _this167 = _callSuper(this, Background);

      /**
       * The renderer.
       *
       * @type {Renderer}
       */
      _this167.renderer = renderer;

      /**
       * Renderer component for managing nodes related logic.
       *
       * @type {Nodes}
       */
      _this167.nodes = nodes;
      return _this167;
    }

    /**
     * Updates the background for the given scene. Depending on how `Scene.background`
     * or `Scene.backgroundNode` are configured, this method might configure a simple clear
     * or add a mesh to the render list for rendering the background as a textured plane
     * or skybox.
     *
     * @param {Scene} scene - The scene.
     * @param {RenderList} renderList - The current render list.
     * @param {RenderContext} renderContext - The current render context.
     */
    (0, _inherits2.default)(Background, _DataMap6);
    return (0, _createClass2.default)(Background, [{
      key: "update",
      value: function update(scene, renderList, renderContext) {
        var renderer = this.renderer;
        var background = this.nodes.getBackgroundNode(scene) || scene.background;
        var forceClear = false;
        if (background === null) {
          // no background settings, use clear color configuration from the renderer

          renderer._clearColor.getRGB(_clearColor$1, _$$_REQUIRE(_dependencyMap[1], "./three.core.js").LinearSRGBColorSpace);
          _clearColor$1.a = renderer._clearColor.a;
        } else if (background.isColor === true) {
          // background is an opaque color

          background.getRGB(_clearColor$1, _$$_REQUIRE(_dependencyMap[1], "./three.core.js").LinearSRGBColorSpace);
          _clearColor$1.a = 1;
          forceClear = true;
        } else if (background.isNode === true) {
          var sceneData = this.get(scene);
          var backgroundNode = background;
          _clearColor$1.copy(renderer._clearColor);
          var backgroundMesh = sceneData.backgroundMesh;
          if (backgroundMesh === undefined) {
            var backgroundMeshNode = context(vec4(backgroundNode).mul(backgroundIntensity), {
              // @TODO: Add Texture2D support using node context
              getUV: function getUV() {
                return backgroundRotation.mul(normalWorld);
              },
              getTextureLevel: function getTextureLevel() {
                return backgroundBlurriness;
              }
            });
            var viewProj = modelViewProjection;
            viewProj = viewProj.setZ(viewProj.w);
            var nodeMaterial = new NodeMaterial();
            nodeMaterial.name = 'Background.material';
            nodeMaterial.side = _$$_REQUIRE(_dependencyMap[1], "./three.core.js").BackSide;
            nodeMaterial.depthTest = false;
            nodeMaterial.depthWrite = false;
            nodeMaterial.fog = false;
            nodeMaterial.lights = false;
            nodeMaterial.vertexNode = viewProj;
            nodeMaterial.colorNode = backgroundMeshNode;
            sceneData.backgroundMeshNode = backgroundMeshNode;
            sceneData.backgroundMesh = backgroundMesh = new (_$$_REQUIRE(_dependencyMap[1], "./three.core.js").Mesh)(new (_$$_REQUIRE(_dependencyMap[1], "./three.core.js").SphereGeometry)(1, 32, 32), nodeMaterial);
            backgroundMesh.frustumCulled = false;
            backgroundMesh.name = 'Background.mesh';
            backgroundMesh.onBeforeRender = function (renderer, scene, camera) {
              this.matrixWorld.copyPosition(camera.matrixWorld);
            };
          }
          var backgroundCacheKey = backgroundNode.getCacheKey();
          if (sceneData.backgroundCacheKey !== backgroundCacheKey) {
            sceneData.backgroundMeshNode.node = vec4(backgroundNode).mul(backgroundIntensity);
            sceneData.backgroundMeshNode.needsUpdate = true;
            backgroundMesh.material.needsUpdate = true;
            sceneData.backgroundCacheKey = backgroundCacheKey;
          }
          renderList.unshift(backgroundMesh, backgroundMesh.geometry, backgroundMesh.material, 0, 0, null, null);
        } else {
          console.error('THREE.Renderer: Unsupported background configuration.', background);
        }

        //

        if (renderer.autoClear === true || forceClear === true) {
          var clearColorValue = renderContext.clearColorValue;
          clearColorValue.r = _clearColor$1.r;
          clearColorValue.g = _clearColor$1.g;
          clearColorValue.b = _clearColor$1.b;
          clearColorValue.a = _clearColor$1.a;

          // premultiply alpha

          if (renderer.backend.isWebGLBackend === true || renderer.alpha === true) {
            clearColorValue.r *= clearColorValue.a;
            clearColorValue.g *= clearColorValue.a;
            clearColorValue.b *= clearColorValue.a;
          }

          //

          renderContext.depthClearValue = renderer._clearDepth;
          renderContext.stencilClearValue = renderer._clearStencil;
          renderContext.clearColor = renderer.autoClearColor === true;
          renderContext.clearDepth = renderer.autoClearDepth === true;
          renderContext.clearStencil = renderer.autoClearStencil === true;
        } else {
          renderContext.clearColor = false;
          renderContext.clearDepth = false;
          renderContext.clearStencil = false;
        }
      }
    }]);
  }(DataMap);
  var _id$6 = 0;

  /**
   * A bind group represents a collection of bindings and thus a collection
   * or resources. Bind groups are assigned to pipelines to provide them
   * with the required resources (like uniform buffers or textures).
   *
   * @private
   */
  var BindGroup = /*#__PURE__*/(0, _createClass2.default)(
  /**
   * Constructs a new bind group.
   *
   * @param {String} name - The bind group's name.
   * @param {Array<Binding>} bindings - An array of bindings.
   * @param {Number} index - The group index.
   * @param {Array<Binding>} bindingsReference - An array of reference bindings.
   */
  function BindGroup() {
    var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
    var bindings = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
    var index = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
    var bindingsReference = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];
    (0, _classCallCheck2.default)(this, BindGroup);
    /**
     * The bind group's name.
     *
     * @type {String}
     */
    this.name = name;

    /**
     * An array of bindings.
     *
     * @type {Array<Binding>}
     */
    this.bindings = bindings;

    /**
     * The group index.
     *
     * @type {Number}
     */
    this.index = index;

    /**
     * An array of reference bindings.
     *
     * @type {Array<Binding>}
     */
    this.bindingsReference = bindingsReference;

    /**
     * The group's ID.
     *
     * @type {Number}
     */
    this.id = _id$6++;
  });
  /**
   * This module represents the state of a node builder after it was
   * used to build the nodes for a render object. The state holds the
   * results of the build for further processing in the renderer.
   *
   * Render objects with identical cache keys share the same node builder state.
   *
   * @private
   */
  var NodeBuilderState = /*#__PURE__*/function () {
    /**
     * Constructs a new node builder state.
     *
     * @param {String?} vertexShader - The native vertex shader code.
     * @param {String?} fragmentShader - The native fragment shader code.
     * @param {String?} computeShader - The native compute shader code.
     * @param {Array<NodeAttribute>} nodeAttributes - An array of node attributes.
     * @param {Array<BindGroup>} bindings - An array of bind groups.
     * @param {Array<Node>} updateNodes - An array of nodes that implement their `update()` method.
     * @param {Array<Node>} updateBeforeNodes - An array of nodes that implement their `updateBefore()` method.
     * @param {Array<Node>} updateAfterNodes - An array of nodes that implement their `updateAfter()` method.
     * @param {NodeMaterialObserver} monitor - A node material observer.
     * @param {Array<Object>} transforms - An array with transform attribute objects. Only relevant when using compute shaders with WebGL 2.
     */
    function NodeBuilderState(vertexShader, fragmentShader, computeShader, nodeAttributes, bindings, updateNodes, updateBeforeNodes, updateAfterNodes, monitor) {
      var transforms = arguments.length > 9 && arguments[9] !== undefined ? arguments[9] : [];
      (0, _classCallCheck2.default)(this, NodeBuilderState);
      /**
       * The native vertex shader code.
       *
       * @type {String}
       */
      this.vertexShader = vertexShader;

      /**
       * The native fragment shader code.
       *
       * @type {String}
       */
      this.fragmentShader = fragmentShader;

      /**
       * The native compute shader code.
       *
       * @type {String}
       */
      this.computeShader = computeShader;

      /**
       * An array with transform attribute objects.
       * Only relevant when using compute shaders with WebGL 2.
       *
       * @type {Array<Object>}
       */
      this.transforms = transforms;

      /**
       * An array of node attributes representing
       * the attributes of the shaders.
       *
       * @type {Array<NodeAttribute>}
       */
      this.nodeAttributes = nodeAttributes;

      /**
       * An array of bind groups representing the uniform or storage
       * buffers, texture or samplers of the shader.
       *
       * @type {Array<BindGroup>}
       */
      this.bindings = bindings;

      /**
       * An array of nodes that implement their `update()` method.
       *
       * @type {Array<Node>}
       */
      this.updateNodes = updateNodes;

      /**
       * An array of nodes that implement their `updateBefore()` method.
       *
       * @type {Array<Node>}
       */
      this.updateBeforeNodes = updateBeforeNodes;

      /**
       * An array of nodes that implement their `updateAfter()` method.
       *
       * @type {Array<Node>}
       */
      this.updateAfterNodes = updateAfterNodes;

      /**
       * A node material observer.
       *
       * @type {NodeMaterialObserver}
       */
      this.monitor = monitor;

      /**
       * How often this state is used by render objects.
       *
       * @type {Number}
       */
      this.usedTimes = 0;
    }

    /**
     * This method is used to create a array of bind groups based
     * on the existing bind groups of this state. Shared groups are
     * not cloned.
     *
     * @return {Array<BindGroup>} A array of bind groups.
     */
    return (0, _createClass2.default)(NodeBuilderState, [{
      key: "createBindings",
      value: function createBindings() {
        var bindings = [];
        for (var instanceGroup of this.bindings) {
          var shared = instanceGroup.bindings[0].groupNode.shared; // TODO: Is it safe to always check the first binding in the group?

          if (shared !== true) {
            var bindingsGroup = new BindGroup(instanceGroup.name, [], instanceGroup.index, instanceGroup);
            bindings.push(bindingsGroup);
            for (var instanceBinding of instanceGroup.bindings) {
              bindingsGroup.bindings.push(instanceBinding.clone());
            }
          } else {
            bindings.push(instanceGroup);
          }
        }
        return bindings;
      }
    }]);
  }();
  /**
   * {@link NodeBuilder} is going to create instances of this class during the build process
   * of nodes. They represent the final shader attributes that are going to be generated
   * by the builder. Arrays of node attributes is maintained in {@link NodeBuilder#attributes}
   * and {@link NodeBuilder#bufferAttributes} for this purpose.
   */
  var NodeAttribute = exports.NodeAttribute = /*#__PURE__*/(0, _createClass2.default)(
  /**
   * Constructs a new node attribute.
   *
   * @param {String} name - The name of the attribute.
   * @param {String} type - The type of the attribute.
   * @param {Node?} node - An optional reference to the node.
   */
  function NodeAttribute(name, type) {
    var node = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
    (0, _classCallCheck2.default)(this, NodeAttribute);
    /**
     * This flag can be used for type testing.
     *
     * @type {Boolean}
     * @readonly
     * @default true
     */
    this.isNodeAttribute = true;

    /**
     * The name of the attribute.
     *
     * @type {String}
     */
    this.name = name;

    /**
     * The type of the attribute.
     *
     * @type {String}
     */
    this.type = type;

    /**
     * An optional reference to the node.
     *
     * @type {Node?}
     * @default null
     */
    this.node = node;
  });
  /**
   * {@link NodeBuilder} is going to create instances of this class during the build process
   * of nodes. They represent the final shader uniforms that are going to be generated
   * by the builder. A dictionary of node uniforms is maintained in {@link NodeBuilder#uniforms}
   * for this purpose.
   */
  var NodeUniform = exports.NodeUniform = /*#__PURE__*/function () {
    /**
     * Constructs a new node uniform.
     *
     * @param {String} name - The name of the uniform.
     * @param {String} type - The type of the uniform.
     * @param {UniformNode} node - An reference to the node.
     */
    function NodeUniform(name, type, node) {
      (0, _classCallCheck2.default)(this, NodeUniform);
      /**
       * This flag can be used for type testing.
       *
       * @type {Boolean}
       * @readonly
       * @default true
       */
      this.isNodeUniform = true;

      /**
       * The name of the uniform.
       *
       * @type {String}
       */
      this.name = name;

      /**
       * The type of the uniform.
       *
       * @type {String}
       */
      this.type = type;

      /**
       * An reference to the node.
       *
       * @type {UniformNode}
       */
      this.node = node.getSelf();
    }

    /**
     * The value of the uniform node.
     *
     * @type {Any}
     */
    return (0, _createClass2.default)(NodeUniform, [{
      key: "value",
      get: function get() {
        return this.node.value;
      },
      set: function set(val) {
        this.node.value = val;
      }

      /**
       * The id of the uniform node.
       *
       * @type {Number}
       */
    }, {
      key: "id",
      get: function get() {
        return this.node.id;
      }

      /**
       * The uniform node's group.
       *
       * @type {UniformGroupNode}
       */
    }, {
      key: "groupNode",
      get: function get() {
        return this.node.groupNode;
      }
    }]);
  }();
  /**
   * {@link NodeBuilder} is going to create instances of this class during the build process
   * of nodes. They represent the final shader variables that are going to be generated
   * by the builder. A dictionary of node variables is maintained in {@link NodeBuilder#vars} for
   * this purpose.
   */
  var NodeVar = exports.NodeVar = /*#__PURE__*/(0, _createClass2.default)(
  /**
   * Constructs a new node variable.
   *
   * @param {String} name - The name of the variable.
   * @param {String} type - The type of the variable.
   */
  function NodeVar(name, type) {
    (0, _classCallCheck2.default)(this, NodeVar);
    /**
     * This flag can be used for type testing.
     *
     * @type {Boolean}
     * @readonly
     * @default true
     */
    this.isNodeVar = true;

    /**
     * The name of the variable.
     *
     * @type {String}
     */
    this.name = name;

    /**
     * The type of the variable.
     *
     * @type {String}
     */
    this.type = type;
  });
  /**
   * {@link NodeBuilder} is going to create instances of this class during the build process
   * of nodes. They represent the final shader varyings that are going to be generated
   * by the builder. An array of node varyings is maintained in {@link NodeBuilder#varyings} for
   * this purpose.
   *
   * @augments NodeVar
   */
  var NodeVarying = exports.NodeVarying = /*#__PURE__*/function (_NodeVar) {
    /**
     * Constructs a new node varying.
     *
     * @param {String} name - The name of the varying.
     * @param {String} type - The type of the varying.
     */
    function NodeVarying(name, type) {
      var _this168;
      (0, _classCallCheck2.default)(this, NodeVarying);
      _this168 = _callSuper(this, NodeVarying, [name, type]);

      /**
       * Whether this varying requires interpolation or not. This property can be used
       * to check if the varying can be optimized for a variable.
       *
       * @type {Boolean}
       * @default false
       */
      _this168.needsInterpolation = false;

      /**
       * This flag can be used for type testing.
       *
       * @type {Boolean}
       * @readonly
       * @default true
       */
      _this168.isNodeVarying = true;
      return _this168;
    }
    (0, _inherits2.default)(NodeVarying, _NodeVar);
    return (0, _createClass2.default)(NodeVarying);
  }(NodeVar);
  /**
   * {@link NodeBuilder} is going to create instances of this class during the build process
   * of nodes. They represent user-defined, native shader code portions that are going to be
   * injected by the builder. A dictionary of node codes is maintained in {@link NodeBuilder#codes}
   * for this purpose.
   */
  var NodeCode = exports.NodeCode = /*#__PURE__*/(0, _createClass2.default)(
  /**
   * Constructs a new code node.
   *
   * @param {String} name - The name of the code.
   * @param {String} type - The node type.
   * @param {String} [code=''] - The native shader code.
   */
  function NodeCode(name, type) {
    var code = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';
    (0, _classCallCheck2.default)(this, NodeCode);
    /**
     * The name of the code.
     *
     * @type {String}
     */
    this.name = name;

    /**
     * The node type.
     *
     * @type {String}
     */
    this.type = type;

    /**
     * The native shader code.
     *
     * @type {String}
     * @default ''
     */
    this.code = code;
    Object.defineProperty(this, 'isNodeCode', {
      value: true
    });
  });
  var _id$5 = 0;

  /**
   * This utility class is used in {@link NodeBuilder} as an internal
   * cache data structure for node data.
   */
  var NodeCache = exports.NodeCache = /*#__PURE__*/function () {
    /**
     * Constructs a new node cache.
     *
     * @param {NodeCache?} parent - A reference to a parent cache.
     */
    function NodeCache() {
      var parent = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      (0, _classCallCheck2.default)(this, NodeCache);
      /**
       * The id of the cache.
       *
       * @type {Number}
       * @readonly
       */
      this.id = _id$5++;

      /**
       * A weak map for managing node data.
       *
       * @type {WeakMap<Node, Object>}
       */
      this.nodesData = new WeakMap();

      /**
       * Reference to a parent node cache.
       *
       * @type {NodeCache?}
       * @default null
       */
      this.parent = parent;
    }

    /**
     * Returns the data for the given node.
     *
     * @param {Node} node - The node.
     * @return {Object?} The data for the node.
     */
    return (0, _createClass2.default)(NodeCache, [{
      key: "getData",
      value: function getData(node) {
        var data = this.nodesData.get(node);
        if (data === undefined && this.parent !== null) {
          data = this.parent.getData(node);
        }
        return data;
      }

      /**
       * Sets the data for a given node.
       *
       * @param {Node} node - The node.
       * @param {Object} data - The data that should be cached.
       */
    }, {
      key: "setData",
      value: function setData(node, data) {
        this.nodesData.set(node, data);
      }
    }]);
  }();
  /**
   * {@link NodeBuilder} is going to create instances of this class during the build process
   * of nodes. They represent the final shader struct data that are going to be generated
   * by the builder. A dictionary of struct types is maintained in {@link NodeBuilder#structs}
   * for this purpose.
   */
  var StructTypeNode = /*#__PURE__*/function (_Node54) {
    /**
     * Constructs a new struct type node.
     *
     * @param {String} name - The name of the struct.
     * @param {Array<String>} types - An array of types.
     */
    function StructTypeNode(name, types) {
      var _this169;
      (0, _classCallCheck2.default)(this, StructTypeNode);
      _this169 = _callSuper(this, StructTypeNode);

      /**
       * The name of the struct.
       *
       * @type {String}
       */
      _this169.name = name;

      /**
       * An array of types.
       *
       * @type {Array<String>}
       */
      _this169.types = types;

      /**
       * This flag can be used for type testing.
       *
       * @type {Boolean}
       * @readonly
       * @default true
       */
      _this169.isStructTypeNode = true;
      return _this169;
    }

    /**
     * Returns the member types.
     *
     * @return {Array<String>} The types.
     */
    (0, _inherits2.default)(StructTypeNode, _Node54);
    return (0, _createClass2.default)(StructTypeNode, [{
      key: "getMemberTypes",
      value: function getMemberTypes() {
        return this.types;
      }
    }], [{
      key: "type",
      get: function get() {
        return 'StructTypeNode';
      }
    }]);
  }(Node);
  /**
   * Abstract base class for uniforms.
   *
   * @abstract
   * @private
   */
  var Uniform = /*#__PURE__*/function () {
    /**
     * Constructs a new uniform.
     *
     * @param {String} name - The uniform's name.
     * @param {Any} value - The uniform's value.
     */
    function Uniform(name, value) {
      (0, _classCallCheck2.default)(this, Uniform);
      /**
       * The uniform's name.
       *
       * @type {String}
       */
      this.name = name;

      /**
       * The uniform's value.
       *
       * @type {Any}
       */
      this.value = value;

      /**
       * Used to build the uniform buffer according to the STD140 layout.
       * Derived uniforms will set this property to a data type specific
       * value.
       *
       * @type {Number}
       */
      this.boundary = 0;

      /**
       * The item size. Derived uniforms will set this property to a data
       * type specific value.
       *
       * @type {Number}
       */
      this.itemSize = 0;

      /**
       * This property is set by {@link UniformsGroup} and marks
       * the start position in the uniform buffer.
       *
       * @type {Number}
       */
      this.offset = 0;
    }

    /**
     * Sets the uniform's value.
     *
     * @param {Any} value - The value to set.
     */
    return (0, _createClass2.default)(Uniform, [{
      key: "setValue",
      value: function setValue(value) {
        this.value = value;
      }

      /**
       * Returns the uniform's value.
       *
       * @return {Any} The value.
       */
    }, {
      key: "getValue",
      value: function getValue() {
        return this.value;
      }
    }]);
  }();
  /**
   * Represents a Number uniform.
   *
   * @private
   * @augments Uniform
   */
  var NumberUniform = /*#__PURE__*/function (_Uniform) {
    /**
     * Constructs a new Number uniform.
     *
     * @param {String} name - The uniform's name.
     * @param {Number} value - The uniform's value.
     */
    function NumberUniform(name) {
      var _this170;
      var value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      (0, _classCallCheck2.default)(this, NumberUniform);
      _this170 = _callSuper(this, NumberUniform, [name, value]);

      /**
       * This flag can be used for type testing.
       *
       * @type {Boolean}
       * @readonly
       * @default true
       */
      _this170.isNumberUniform = true;
      _this170.boundary = 4;
      _this170.itemSize = 1;
      return _this170;
    }
    (0, _inherits2.default)(NumberUniform, _Uniform);
    return (0, _createClass2.default)(NumberUniform);
  }(Uniform);
  /**
   * Represents a Vector2 uniform.
   *
   * @private
   * @augments Uniform
   */
  var Vector2Uniform = /*#__PURE__*/function (_Uniform2) {
    /**
     * Constructs a new Number uniform.
     *
     * @param {String} name - The uniform's name.
     * @param {Vector2} value - The uniform's value.
     */
    function Vector2Uniform(name) {
      var _this171;
      var value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new (_$$_REQUIRE(_dependencyMap[1], "./three.core.js").Vector2)();
      (0, _classCallCheck2.default)(this, Vector2Uniform);
      _this171 = _callSuper(this, Vector2Uniform, [name, value]);

      /**
       * This flag can be used for type testing.
       *
       * @type {Boolean}
       * @readonly
       * @default true
       */
      _this171.isVector2Uniform = true;
      _this171.boundary = 8;
      _this171.itemSize = 2;
      return _this171;
    }
    (0, _inherits2.default)(Vector2Uniform, _Uniform2);
    return (0, _createClass2.default)(Vector2Uniform);
  }(Uniform);
  /**
   * Represents a Vector3 uniform.
   *
   * @private
   * @augments Uniform
   */
  var Vector3Uniform = /*#__PURE__*/function (_Uniform3) {
    /**
     * Constructs a new Number uniform.
     *
     * @param {String} name - The uniform's name.
     * @param {Vector3} value - The uniform's value.
     */
    function Vector3Uniform(name) {
      var _this172;
      var value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new (_$$_REQUIRE(_dependencyMap[1], "./three.core.js").Vector3)();
      (0, _classCallCheck2.default)(this, Vector3Uniform);
      _this172 = _callSuper(this, Vector3Uniform, [name, value]);

      /**
       * This flag can be used for type testing.
       *
       * @type {Boolean}
       * @readonly
       * @default true
       */
      _this172.isVector3Uniform = true;
      _this172.boundary = 16;
      _this172.itemSize = 3;
      return _this172;
    }
    (0, _inherits2.default)(Vector3Uniform, _Uniform3);
    return (0, _createClass2.default)(Vector3Uniform);
  }(Uniform);
  /**
   * Represents a Vector4 uniform.
   *
   * @private
   * @augments Uniform
   */
  var Vector4Uniform = /*#__PURE__*/function (_Uniform4) {
    /**
     * Constructs a new Number uniform.
     *
     * @param {String} name - The uniform's name.
     * @param {Vector4} value - The uniform's value.
     */
    function Vector4Uniform(name) {
      var _this173;
      var value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new (_$$_REQUIRE(_dependencyMap[1], "./three.core.js").Vector4)();
      (0, _classCallCheck2.default)(this, Vector4Uniform);
      _this173 = _callSuper(this, Vector4Uniform, [name, value]);

      /**
       * This flag can be used for type testing.
       *
       * @type {Boolean}
       * @readonly
       * @default true
       */
      _this173.isVector4Uniform = true;
      _this173.boundary = 16;
      _this173.itemSize = 4;
      return _this173;
    }
    (0, _inherits2.default)(Vector4Uniform, _Uniform4);
    return (0, _createClass2.default)(Vector4Uniform);
  }(Uniform);
  /**
   * Represents a Color uniform.
   *
   * @private
   * @augments Uniform
   */
  var ColorUniform = /*#__PURE__*/function (_Uniform5) {
    /**
     * Constructs a new Number uniform.
     *
     * @param {String} name - The uniform's name.
     * @param {Color} value - The uniform's value.
     */
    function ColorUniform(name) {
      var _this174;
      var value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new (_$$_REQUIRE(_dependencyMap[1], "./three.core.js").Color)();
      (0, _classCallCheck2.default)(this, ColorUniform);
      _this174 = _callSuper(this, ColorUniform, [name, value]);

      /**
       * This flag can be used for type testing.
       *
       * @type {Boolean}
       * @readonly
       * @default true
       */
      _this174.isColorUniform = true;
      _this174.boundary = 16;
      _this174.itemSize = 3;
      return _this174;
    }
    (0, _inherits2.default)(ColorUniform, _Uniform5);
    return (0, _createClass2.default)(ColorUniform);
  }(Uniform);
  /**
   * Represents a Matrix3 uniform.
   *
   * @private
   * @augments Uniform
   */
  var Matrix3Uniform = /*#__PURE__*/function (_Uniform6) {
    /**
     * Constructs a new Number uniform.
     *
     * @param {String} name - The uniform's name.
     * @param {Matrix3} value - The uniform's value.
     */
    function Matrix3Uniform(name) {
      var _this175;
      var value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new (_$$_REQUIRE(_dependencyMap[1], "./three.core.js").Matrix3)();
      (0, _classCallCheck2.default)(this, Matrix3Uniform);
      _this175 = _callSuper(this, Matrix3Uniform, [name, value]);

      /**
       * This flag can be used for type testing.
       *
       * @type {Boolean}
       * @readonly
       * @default true
       */
      _this175.isMatrix3Uniform = true;
      _this175.boundary = 48;
      _this175.itemSize = 12;
      return _this175;
    }
    (0, _inherits2.default)(Matrix3Uniform, _Uniform6);
    return (0, _createClass2.default)(Matrix3Uniform);
  }(Uniform);
  /**
   * Represents a Matrix4 uniform.
   *
   * @private
   * @augments Uniform
   */
  var Matrix4Uniform = /*#__PURE__*/function (_Uniform7) {
    /**
     * Constructs a new Number uniform.
     *
     * @param {String} name - The uniform's name.
     * @param {Matrix4} value - The uniform's value.
     */
    function Matrix4Uniform(name) {
      var _this176;
      var value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new (_$$_REQUIRE(_dependencyMap[1], "./three.core.js").Matrix4)();
      (0, _classCallCheck2.default)(this, Matrix4Uniform);
      _this176 = _callSuper(this, Matrix4Uniform, [name, value]);

      /**
       * This flag can be used for type testing.
       *
       * @type {Boolean}
       * @readonly
       * @default true
       */
      _this176.isMatrix4Uniform = true;
      _this176.boundary = 64;
      _this176.itemSize = 16;
      return _this176;
    }
    (0, _inherits2.default)(Matrix4Uniform, _Uniform7);
    return (0, _createClass2.default)(Matrix4Uniform);
  }(Uniform);
  /**
   * A special form of Number uniform binding type.
   * It's value is managed by a node object.
   *
   * @private
   * @augments NumberUniform
   */
  var NumberNodeUniform = /*#__PURE__*/function (_NumberUniform) {
    /**
     * Constructs a new node-based Number uniform.
     *
     * @param {NodeUniform} nodeUniform - The node uniform.
     */
    function NumberNodeUniform(nodeUniform) {
      var _this177;
      (0, _classCallCheck2.default)(this, NumberNodeUniform);
      _this177 = _callSuper(this, NumberNodeUniform, [nodeUniform.name, nodeUniform.value]);

      /**
       * The node uniform.
       *
       * @type {NodeUniform}
       */
      _this177.nodeUniform = nodeUniform;
      return _this177;
    }

    /**
     * Overwritten to return the value of the node uniform.
     *
     * @return {Number} The value.
     */
    (0, _inherits2.default)(NumberNodeUniform, _NumberUniform);
    return (0, _createClass2.default)(NumberNodeUniform, [{
      key: "getValue",
      value: function getValue() {
        return this.nodeUniform.value;
      }

      /**
       * Returns the node uniform data type.
       *
       * @return {String} The data type.
       */
    }, {
      key: "getType",
      value: function getType() {
        return this.nodeUniform.type;
      }
    }]);
  }(NumberUniform);
  /**
   * A special form of Vector2 uniform binding type.
   * It's value is managed by a node object.
   *
   * @private
   * @augments Vector2Uniform
   */
  var Vector2NodeUniform = /*#__PURE__*/function (_Vector2Uniform) {
    /**
     * Constructs a new node-based Vector2 uniform.
     *
     * @param {NodeUniform} nodeUniform - The node uniform.
     */
    function Vector2NodeUniform(nodeUniform) {
      var _this178;
      (0, _classCallCheck2.default)(this, Vector2NodeUniform);
      _this178 = _callSuper(this, Vector2NodeUniform, [nodeUniform.name, nodeUniform.value]);

      /**
       * The node uniform.
       *
       * @type {NodeUniform}
       */
      _this178.nodeUniform = nodeUniform;
      return _this178;
    }

    /**
     * Overwritten to return the value of the node uniform.
     *
     * @return {Vector2} The value.
     */
    (0, _inherits2.default)(Vector2NodeUniform, _Vector2Uniform);
    return (0, _createClass2.default)(Vector2NodeUniform, [{
      key: "getValue",
      value: function getValue() {
        return this.nodeUniform.value;
      }

      /**
       * Returns the node uniform data type.
       *
       * @return {String} The data type.
       */
    }, {
      key: "getType",
      value: function getType() {
        return this.nodeUniform.type;
      }
    }]);
  }(Vector2Uniform);
  /**
   * A special form of Vector3 uniform binding type.
   * It's value is managed by a node object.
   *
   * @private
   * @augments Vector3Uniform
   */
  var Vector3NodeUniform = /*#__PURE__*/function (_Vector3Uniform) {
    /**
     * Constructs a new node-based Vector3 uniform.
     *
     * @param {NodeUniform} nodeUniform - The node uniform.
     */
    function Vector3NodeUniform(nodeUniform) {
      var _this179;
      (0, _classCallCheck2.default)(this, Vector3NodeUniform);
      _this179 = _callSuper(this, Vector3NodeUniform, [nodeUniform.name, nodeUniform.value]);

      /**
       * The node uniform.
       *
       * @type {NodeUniform}
       */
      _this179.nodeUniform = nodeUniform;
      return _this179;
    }

    /**
     * Overwritten to return the value of the node uniform.
     *
     * @return {Vector3} The value.
     */
    (0, _inherits2.default)(Vector3NodeUniform, _Vector3Uniform);
    return (0, _createClass2.default)(Vector3NodeUniform, [{
      key: "getValue",
      value: function getValue() {
        return this.nodeUniform.value;
      }

      /**
       * Returns the node uniform data type.
       *
       * @return {String} The data type.
       */
    }, {
      key: "getType",
      value: function getType() {
        return this.nodeUniform.type;
      }
    }]);
  }(Vector3Uniform);
  /**
   * A special form of Vector4 uniform binding type.
   * It's value is managed by a node object.
   *
   * @private
   * @augments Vector4Uniform
   */
  var Vector4NodeUniform = /*#__PURE__*/function (_Vector4Uniform) {
    /**
     * Constructs a new node-based Vector4 uniform.
     *
     * @param {NodeUniform} nodeUniform - The node uniform.
     */
    function Vector4NodeUniform(nodeUniform) {
      var _this180;
      (0, _classCallCheck2.default)(this, Vector4NodeUniform);
      _this180 = _callSuper(this, Vector4NodeUniform, [nodeUniform.name, nodeUniform.value]);

      /**
       * The node uniform.
       *
       * @type {NodeUniform}
       */
      _this180.nodeUniform = nodeUniform;
      return _this180;
    }

    /**
     * Overwritten to return the value of the node uniform.
     *
     * @return {Vector4} The value.
     */
    (0, _inherits2.default)(Vector4NodeUniform, _Vector4Uniform);
    return (0, _createClass2.default)(Vector4NodeUniform, [{
      key: "getValue",
      value: function getValue() {
        return this.nodeUniform.value;
      }

      /**
       * Returns the node uniform data type.
       *
       * @return {String} The data type.
       */
    }, {
      key: "getType",
      value: function getType() {
        return this.nodeUniform.type;
      }
    }]);
  }(Vector4Uniform);
  /**
   * A special form of Color uniform binding type.
   * It's value is managed by a node object.
   *
   * @private
   * @augments ColorUniform
   */
  var ColorNodeUniform = /*#__PURE__*/function (_ColorUniform) {
    /**
     * Constructs a new node-based Color uniform.
     *
     * @param {NodeUniform} nodeUniform - The node uniform.
     */
    function ColorNodeUniform(nodeUniform) {
      var _this181;
      (0, _classCallCheck2.default)(this, ColorNodeUniform);
      _this181 = _callSuper(this, ColorNodeUniform, [nodeUniform.name, nodeUniform.value]);

      /**
       * The node uniform.
       *
       * @type {NodeUniform}
       */
      _this181.nodeUniform = nodeUniform;
      return _this181;
    }

    /**
     * Overwritten to return the value of the node uniform.
     *
     * @return {Color} The value.
     */
    (0, _inherits2.default)(ColorNodeUniform, _ColorUniform);
    return (0, _createClass2.default)(ColorNodeUniform, [{
      key: "getValue",
      value: function getValue() {
        return this.nodeUniform.value;
      }

      /**
       * Returns the node uniform data type.
       *
       * @return {String} The data type.
       */
    }, {
      key: "getType",
      value: function getType() {
        return this.nodeUniform.type;
      }
    }]);
  }(ColorUniform);
  /**
   * A special form of Matrix3 uniform binding type.
   * It's value is managed by a node object.
   *
   * @private
   * @augments Matrix3Uniform
   */
  var Matrix3NodeUniform = /*#__PURE__*/function (_Matrix3Uniform) {
    /**
     * Constructs a new node-based Matrix3 uniform.
     *
     * @param {NodeUniform} nodeUniform - The node uniform.
     */
    function Matrix3NodeUniform(nodeUniform) {
      var _this182;
      (0, _classCallCheck2.default)(this, Matrix3NodeUniform);
      _this182 = _callSuper(this, Matrix3NodeUniform, [nodeUniform.name, nodeUniform.value]);

      /**
       * The node uniform.
       *
       * @type {NodeUniform}
       */
      _this182.nodeUniform = nodeUniform;
      return _this182;
    }

    /**
     * Overwritten to return the value of the node uniform.
     *
     * @return {Matrix3} The value.
     */
    (0, _inherits2.default)(Matrix3NodeUniform, _Matrix3Uniform);
    return (0, _createClass2.default)(Matrix3NodeUniform, [{
      key: "getValue",
      value: function getValue() {
        return this.nodeUniform.value;
      }

      /**
       * Returns the node uniform data type.
       *
       * @return {String} The data type.
       */
    }, {
      key: "getType",
      value: function getType() {
        return this.nodeUniform.type;
      }
    }]);
  }(Matrix3Uniform);
  /**
   * A special form of Matrix4 uniform binding type.
   * It's value is managed by a node object.
   *
   * @private
   * @augments Matrix4Uniform
   */
  var Matrix4NodeUniform = /*#__PURE__*/function (_Matrix4Uniform) {
    /**
     * Constructs a new node-based Matrix4 uniform.
     *
     * @param {NodeUniform} nodeUniform - The node uniform.
     */
    function Matrix4NodeUniform(nodeUniform) {
      var _this183;
      (0, _classCallCheck2.default)(this, Matrix4NodeUniform);
      _this183 = _callSuper(this, Matrix4NodeUniform, [nodeUniform.name, nodeUniform.value]);

      /**
       * The node uniform.
       *
       * @type {NodeUniform}
       */
      _this183.nodeUniform = nodeUniform;
      return _this183;
    }

    /**
     * Overwritten to return the value of the node uniform.
     *
     * @return {Matrix4} The value.
     */
    (0, _inherits2.default)(Matrix4NodeUniform, _Matrix4Uniform);
    return (0, _createClass2.default)(Matrix4NodeUniform, [{
      key: "getValue",
      value: function getValue() {
        return this.nodeUniform.value;
      }

      /**
       * Returns the node uniform data type.
       *
       * @return {String} The data type.
       */
    }, {
      key: "getType",
      value: function getType() {
        return this.nodeUniform.type;
      }
    }]);
  }(Matrix4Uniform);
  var LOD_MIN = 4;

  // The standard deviations (radians) associated with the extra mips. These are
  // chosen to approximate a Trowbridge-Reitz distribution function times the
  // geometric shadowing function. These sigma values squared must match the
  // variance #defines in cube_uv_reflection_fragment.glsl.js.
  var EXTRA_LOD_SIGMA = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582];

  // The maximum length of the blur for loop. Smaller sigmas will use fewer
  // samples and exit early, but not recompile the shader.
  var MAX_SAMPLES = 20;
  var _flatCamera = /*@__PURE__*/new (_$$_REQUIRE(_dependencyMap[1], "./three.core.js").OrthographicCamera)(-1, 1, 1, -1, 0, 1);
  var _cubeCamera = /*@__PURE__*/new (_$$_REQUIRE(_dependencyMap[1], "./three.core.js").PerspectiveCamera)(90, 1);
  var _clearColor = /*@__PURE__*/new (_$$_REQUIRE(_dependencyMap[1], "./three.core.js").Color)();
  var _oldTarget = null;
  var _oldActiveCubeFace = 0;
  var _oldActiveMipmapLevel = 0;

  // Golden Ratio
  var PHI = (1 + Math.sqrt(5)) / 2;
  var INV_PHI = 1 / PHI;

  // Vertices of a dodecahedron (except the opposites, which represent the
  // same axis), used as axis directions evenly spread on a sphere.
  var _axisDirections = [/*@__PURE__*/new (_$$_REQUIRE(_dependencyMap[1], "./three.core.js").Vector3)(-PHI, INV_PHI, 0), /*@__PURE__*/new (_$$_REQUIRE(_dependencyMap[1], "./three.core.js").Vector3)(PHI, INV_PHI, 0), /*@__PURE__*/new (_$$_REQUIRE(_dependencyMap[1], "./three.core.js").Vector3)(-INV_PHI, 0, PHI), /*@__PURE__*/new (_$$_REQUIRE(_dependencyMap[1], "./three.core.js").Vector3)(INV_PHI, 0, PHI), /*@__PURE__*/new (_$$_REQUIRE(_dependencyMap[1], "./three.core.js").Vector3)(0, PHI, -INV_PHI), /*@__PURE__*/new (_$$_REQUIRE(_dependencyMap[1], "./three.core.js").Vector3)(0, PHI, INV_PHI), /*@__PURE__*/new (_$$_REQUIRE(_dependencyMap[1], "./three.core.js").Vector3)(-1, 1, -1), /*@__PURE__*/new (_$$_REQUIRE(_dependencyMap[1], "./three.core.js").Vector3)(1, 1, -1), /*@__PURE__*/new (_$$_REQUIRE(_dependencyMap[1], "./three.core.js").Vector3)(-1, 1, 1), /*@__PURE__*/new (_$$_REQUIRE(_dependencyMap[1], "./three.core.js").Vector3)(1, 1, 1)];

  //

  // WebGPU Face indices
  var _faceLib = [3, 1, 5, 0, 4, 2];
  var direction = getDirection(uv(), attribute('faceIndex')).normalize();
  var outputDirection = vec3(direction.x, direction.y, direction.z);

  /**
   * This class generates a Prefiltered, Mipmapped Radiance Environment Map
   * (PMREM) from a cubeMap environment texture. This allows different levels of
   * blur to be quickly accessed based on material roughness. It is packed into a
   * special CubeUV format that allows us to perform custom interpolation so that
   * we can support nonlinear formats such as RGBE. Unlike a traditional mipmap
   * chain, it only goes down to the LOD_MIN level (above), and then creates extra
   * even more filtered 'mips' at the same LOD_MIN resolution, associated with
   * higher roughness levels. In this way we maintain resolution to smoothly
   * interpolate diffuse lighting while limiting sampling computation.
   *
   * Paper: Fast, Accurate Image-Based Lighting
   * https://drive.google.com/file/d/15y8r_UpKlU9SvV4ILb0C3qCPecS8pvLz/view
  */
  var PMREMGenerator = exports.PMREMGenerator = /*#__PURE__*/function () {
    function PMREMGenerator(renderer) {
      (0, _classCallCheck2.default)(this, PMREMGenerator);
      this._renderer = renderer;
      this._pingPongRenderTarget = null;
      this._lodMax = 0;
      this._cubeSize = 0;
      this._lodPlanes = [];
      this._sizeLods = [];
      this._sigmas = [];
      this._lodMeshes = [];
      this._blurMaterial = null;
      this._cubemapMaterial = null;
      this._equirectMaterial = null;
      this._backgroundBox = null;
    }
    return (0, _createClass2.default)(PMREMGenerator, [{
      key: "_hasInitialized",
      get: function get() {
        return this._renderer.hasInitialized();
      }

      /**
       * Generates a PMREM from a supplied Scene, which can be faster than using an
       * image if networking bandwidth is low. Optional sigma specifies a blur radius
       * in radians to be applied to the scene before PMREM generation. Optional near
       * and far planes ensure the scene is rendered in its entirety (the cubeCamera
       * is placed at the origin).
       *
       * @param {Scene} scene - The scene to be captured.
       * @param {Number} [sigma=0] - The blur radius in radians.
       * @param {Number} [near=0.1] - The near plane distance.
       * @param {Number} [far=100] - The far plane distance.
       * @param {RenderTarget?} [renderTarget=null] - The render target to use.
       * @return {RenderTarget} The resulting PMREM.
       */
    }, {
      key: "fromScene",
      value: function fromScene(scene) {
        var sigma = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        var near = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0.1;
        var far = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 100;
        var renderTarget = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;
        this._setSize(256);
        if (this._hasInitialized === false) {
          console.warn('THREE.PMREMGenerator: .fromScene() called before the backend is initialized. Try using .fromSceneAsync() instead.');
          var _cubeUVRenderTarget = renderTarget || this._allocateTargets();
          this.fromSceneAsync(scene, sigma, near, far, _cubeUVRenderTarget);
          return _cubeUVRenderTarget;
        }
        _oldTarget = this._renderer.getRenderTarget();
        _oldActiveCubeFace = this._renderer.getActiveCubeFace();
        _oldActiveMipmapLevel = this._renderer.getActiveMipmapLevel();
        var cubeUVRenderTarget = renderTarget || this._allocateTargets();
        cubeUVRenderTarget.depthBuffer = true;
        this._sceneToCubeUV(scene, near, far, cubeUVRenderTarget);
        if (sigma > 0) {
          this._blur(cubeUVRenderTarget, 0, 0, sigma);
        }
        this._applyPMREM(cubeUVRenderTarget);
        this._cleanup(cubeUVRenderTarget);
        return cubeUVRenderTarget;
      }
    }, {
      key: "fromSceneAsync",
      value: function () {
        var _fromSceneAsync = (0, _asyncToGenerator2.default)(function* (scene) {
          var sigma = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
          var near = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0.1;
          var far = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 100;
          var renderTarget = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;
          if (this._hasInitialized === false) yield this._renderer.init();
          return this.fromScene(scene, sigma, near, far, renderTarget);
        });
        function fromSceneAsync(_x3) {
          return _fromSceneAsync.apply(this, arguments);
        }
        return fromSceneAsync;
      }()
      /**
       * Generates a PMREM from an equirectangular texture, which can be either LDR
       * or HDR. The ideal input image size is 1k (1024 x 512),
       * as this matches best with the 256 x 256 cubemap output.
       *
       * @param {Texture} equirectangular - The equirectangular texture to be converted.
       * @param {RenderTarget?} [renderTarget=null] - The render target to use.
       * @return {RenderTarget} The resulting PMREM.
       */
    }, {
      key: "fromEquirectangular",
      value: function fromEquirectangular(equirectangular) {
        var renderTarget = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
        if (this._hasInitialized === false) {
          console.warn('THREE.PMREMGenerator: .fromEquirectangular() called before the backend is initialized. Try using .fromEquirectangularAsync() instead.');
          this._setSizeFromTexture(equirectangular);
          var cubeUVRenderTarget = renderTarget || this._allocateTargets();
          this.fromEquirectangularAsync(equirectangular, cubeUVRenderTarget);
          return cubeUVRenderTarget;
        }
        return this._fromTexture(equirectangular, renderTarget);
      }
    }, {
      key: "fromEquirectangularAsync",
      value: function () {
        var _fromEquirectangularAsync = (0, _asyncToGenerator2.default)(function* (equirectangular) {
          var renderTarget = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
          if (this._hasInitialized === false) yield this._renderer.init();
          return this._fromTexture(equirectangular, renderTarget);
        });
        function fromEquirectangularAsync(_x4) {
          return _fromEquirectangularAsync.apply(this, arguments);
        }
        return fromEquirectangularAsync;
      }()
      /**
       * Generates a PMREM from an cubemap texture, which can be either LDR
       * or HDR. The ideal input cube size is 256 x 256,
       * as this matches best with the 256 x 256 cubemap output.
       *
       * @param {Texture} cubemap - The cubemap texture to be converted.
       * @param {RenderTarget?} [renderTarget=null] - The render target to use.
       * @return {RenderTarget} The resulting PMREM.
       */
    }, {
      key: "fromCubemap",
      value: function fromCubemap(cubemap) {
        var renderTarget = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
        if (this._hasInitialized === false) {
          console.warn('THREE.PMREMGenerator: .fromCubemap() called before the backend is initialized. Try using .fromCubemapAsync() instead.');
          this._setSizeFromTexture(cubemap);
          var cubeUVRenderTarget = renderTarget || this._allocateTargets();
          this.fromCubemapAsync(cubemap, renderTarget);
          return cubeUVRenderTarget;
        }
        return this._fromTexture(cubemap, renderTarget);
      }
    }, {
      key: "fromCubemapAsync",
      value: function () {
        var _fromCubemapAsync = (0, _asyncToGenerator2.default)(function* (cubemap) {
          var renderTarget = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
          if (this._hasInitialized === false) yield this._renderer.init();
          return this._fromTexture(cubemap, renderTarget);
        });
        function fromCubemapAsync(_x5) {
          return _fromCubemapAsync.apply(this, arguments);
        }
        return fromCubemapAsync;
      }()
      /**
       * Pre-compiles the cubemap shader. You can get faster start-up by invoking this method during
       * your texture's network fetch for increased concurrency.
       */
    }, {
      key: "compileCubemapShader",
      value: (function () {
        var _compileCubemapShader = (0, _asyncToGenerator2.default)(function* () {
          if (this._cubemapMaterial === null) {
            this._cubemapMaterial = _getCubemapMaterial();
            yield this._compileMaterial(this._cubemapMaterial);
          }
        });
        function compileCubemapShader() {
          return _compileCubemapShader.apply(this, arguments);
        }
        return compileCubemapShader;
      }()
      /**
       * Pre-compiles the equirectangular shader. You can get faster start-up by invoking this method during
       * your texture's network fetch for increased concurrency.
       */
      )
    }, {
      key: "compileEquirectangularShader",
      value: (function () {
        var _compileEquirectangularShader = (0, _asyncToGenerator2.default)(function* () {
          if (this._equirectMaterial === null) {
            this._equirectMaterial = _getEquirectMaterial();
            yield this._compileMaterial(this._equirectMaterial);
          }
        });
        function compileEquirectangularShader() {
          return _compileEquirectangularShader.apply(this, arguments);
        }
        return compileEquirectangularShader;
      }()
      /**
       * Disposes of the PMREMGenerator's internal memory. Note that PMREMGenerator is a static class,
       * so you should not need more than one PMREMGenerator object. If you do, calling dispose() on
       * one of them will cause any others to also become unusable.
       */
      )
    }, {
      key: "dispose",
      value: function dispose() {
        this._dispose();
        if (this._cubemapMaterial !== null) this._cubemapMaterial.dispose();
        if (this._equirectMaterial !== null) this._equirectMaterial.dispose();
        if (this._backgroundBox !== null) {
          this._backgroundBox.geometry.dispose();
          this._backgroundBox.material.dispose();
        }
      }

      // private interface
    }, {
      key: "_setSizeFromTexture",
      value: function _setSizeFromTexture(texture) {
        if (texture.mapping === _$$_REQUIRE(_dependencyMap[1], "./three.core.js").CubeReflectionMapping || texture.mapping === _$$_REQUIRE(_dependencyMap[1], "./three.core.js").CubeRefractionMapping) {
          this._setSize(texture.image.length === 0 ? 16 : texture.image[0].width || texture.image[0].image.width);
        } else {
          // Equirectangular

          this._setSize(texture.image.width / 4);
        }
      }
    }, {
      key: "_setSize",
      value: function _setSize(cubeSize) {
        this._lodMax = Math.floor(Math.log2(cubeSize));
        this._cubeSize = Math.pow(2, this._lodMax);
      }
    }, {
      key: "_dispose",
      value: function _dispose() {
        if (this._blurMaterial !== null) this._blurMaterial.dispose();
        if (this._pingPongRenderTarget !== null) this._pingPongRenderTarget.dispose();
        for (var i = 0; i < this._lodPlanes.length; i++) {
          this._lodPlanes[i].dispose();
        }
      }
    }, {
      key: "_cleanup",
      value: function _cleanup(outputTarget) {
        this._renderer.setRenderTarget(_oldTarget, _oldActiveCubeFace, _oldActiveMipmapLevel);
        outputTarget.scissorTest = false;
        _setViewport(outputTarget, 0, 0, outputTarget.width, outputTarget.height);
      }
    }, {
      key: "_fromTexture",
      value: function _fromTexture(texture, renderTarget) {
        this._setSizeFromTexture(texture);
        _oldTarget = this._renderer.getRenderTarget();
        _oldActiveCubeFace = this._renderer.getActiveCubeFace();
        _oldActiveMipmapLevel = this._renderer.getActiveMipmapLevel();
        var cubeUVRenderTarget = renderTarget || this._allocateTargets();
        this._textureToCubeUV(texture, cubeUVRenderTarget);
        this._applyPMREM(cubeUVRenderTarget);
        this._cleanup(cubeUVRenderTarget);
        return cubeUVRenderTarget;
      }
    }, {
      key: "_allocateTargets",
      value: function _allocateTargets() {
        var width = 3 * Math.max(this._cubeSize, 16 * 7);
        var height = 4 * this._cubeSize;
        var params = {
          magFilter: _$$_REQUIRE(_dependencyMap[1], "./three.core.js").LinearFilter,
          minFilter: _$$_REQUIRE(_dependencyMap[1], "./three.core.js").LinearFilter,
          generateMipmaps: false,
          type: _$$_REQUIRE(_dependencyMap[1], "./three.core.js").HalfFloatType,
          format: _$$_REQUIRE(_dependencyMap[1], "./three.core.js").RGBAFormat,
          colorSpace: _$$_REQUIRE(_dependencyMap[1], "./three.core.js").LinearSRGBColorSpace
          //depthBuffer: false
        };
        var cubeUVRenderTarget = _createRenderTarget(width, height, params);
        if (this._pingPongRenderTarget === null || this._pingPongRenderTarget.width !== width || this._pingPongRenderTarget.height !== height) {
          if (this._pingPongRenderTarget !== null) {
            this._dispose();
          }
          this._pingPongRenderTarget = _createRenderTarget(width, height, params);
          var _lodMax = this._lodMax;
          var _createPlanes2 = _createPlanes(_lodMax);
          this._sizeLods = _createPlanes2.sizeLods;
          this._lodPlanes = _createPlanes2.lodPlanes;
          this._sigmas = _createPlanes2.sigmas;
          this._lodMeshes = _createPlanes2.lodMeshes;
          this._blurMaterial = _getBlurShader(_lodMax, width, height);
        }
        return cubeUVRenderTarget;
      }
    }, {
      key: "_compileMaterial",
      value: function () {
        var _compileMaterial2 = (0, _asyncToGenerator2.default)(function* (material) {
          var tmpMesh = new (_$$_REQUIRE(_dependencyMap[1], "./three.core.js").Mesh)(this._lodPlanes[0], material);
          yield this._renderer.compile(tmpMesh, _flatCamera);
        });
        function _compileMaterial(_x6) {
          return _compileMaterial2.apply(this, arguments);
        }
        return _compileMaterial;
      }()
    }, {
      key: "_sceneToCubeUV",
      value: function _sceneToCubeUV(scene, near, far, cubeUVRenderTarget) {
        var cubeCamera = _cubeCamera;
        cubeCamera.near = near;
        cubeCamera.far = far;

        // px, py, pz, nx, ny, nz
        var upSign = [1, 1, 1, 1, -1, 1];
        var forwardSign = [1, -1, 1, -1, 1, -1];
        var renderer = this._renderer;
        var originalAutoClear = renderer.autoClear;
        renderer.getClearColor(_clearColor);
        renderer.autoClear = false;
        var backgroundBox = this._backgroundBox;
        if (backgroundBox === null) {
          var backgroundMaterial = new (_$$_REQUIRE(_dependencyMap[1], "./three.core.js").MeshBasicMaterial)({
            name: 'PMREM.Background',
            side: _$$_REQUIRE(_dependencyMap[1], "./three.core.js").BackSide,
            depthWrite: false,
            depthTest: false
          });
          backgroundBox = new (_$$_REQUIRE(_dependencyMap[1], "./three.core.js").Mesh)(new (_$$_REQUIRE(_dependencyMap[1], "./three.core.js").BoxGeometry)(), backgroundMaterial);
        }
        var useSolidColor = false;
        var background = scene.background;
        if (background) {
          if (background.isColor) {
            backgroundBox.material.color.copy(background);
            scene.background = null;
            useSolidColor = true;
          }
        } else {
          backgroundBox.material.color.copy(_clearColor);
          useSolidColor = true;
        }
        renderer.setRenderTarget(cubeUVRenderTarget);
        renderer.clear();
        if (useSolidColor) {
          renderer.render(backgroundBox, cubeCamera);
        }
        for (var i = 0; i < 6; i++) {
          var col = i % 3;
          if (col === 0) {
            cubeCamera.up.set(0, upSign[i], 0);
            cubeCamera.lookAt(forwardSign[i], 0, 0);
          } else if (col === 1) {
            cubeCamera.up.set(0, 0, upSign[i]);
            cubeCamera.lookAt(0, forwardSign[i], 0);
          } else {
            cubeCamera.up.set(0, upSign[i], 0);
            cubeCamera.lookAt(0, 0, forwardSign[i]);
          }
          var size = this._cubeSize;
          _setViewport(cubeUVRenderTarget, col * size, i > 2 ? size : 0, size, size);
          renderer.render(scene, cubeCamera);
        }
        renderer.autoClear = originalAutoClear;
        scene.background = background;
      }
    }, {
      key: "_textureToCubeUV",
      value: function _textureToCubeUV(texture, cubeUVRenderTarget) {
        var renderer = this._renderer;
        var isCubeTexture = texture.mapping === _$$_REQUIRE(_dependencyMap[1], "./three.core.js").CubeReflectionMapping || texture.mapping === _$$_REQUIRE(_dependencyMap[1], "./three.core.js").CubeRefractionMapping;
        if (isCubeTexture) {
          if (this._cubemapMaterial === null) {
            this._cubemapMaterial = _getCubemapMaterial(texture);
          }
        } else {
          if (this._equirectMaterial === null) {
            this._equirectMaterial = _getEquirectMaterial(texture);
          }
        }
        var material = isCubeTexture ? this._cubemapMaterial : this._equirectMaterial;
        material.fragmentNode.value = texture;
        var mesh = this._lodMeshes[0];
        mesh.material = material;
        var size = this._cubeSize;
        _setViewport(cubeUVRenderTarget, 0, 0, 3 * size, 2 * size);
        renderer.setRenderTarget(cubeUVRenderTarget);
        renderer.render(mesh, _flatCamera);
      }
    }, {
      key: "_applyPMREM",
      value: function _applyPMREM(cubeUVRenderTarget) {
        var renderer = this._renderer;
        var autoClear = renderer.autoClear;
        renderer.autoClear = false;
        var n = this._lodPlanes.length;
        for (var i = 1; i < n; i++) {
          var sigma = Math.sqrt(this._sigmas[i] * this._sigmas[i] - this._sigmas[i - 1] * this._sigmas[i - 1]);
          var poleAxis = _axisDirections[(n - i - 1) % _axisDirections.length];
          this._blur(cubeUVRenderTarget, i - 1, i, sigma, poleAxis);
        }
        renderer.autoClear = autoClear;
      }

      /**
       * This is a two-pass Gaussian blur for a cubemap. Normally this is done
       * vertically and horizontally, but this breaks down on a cube. Here we apply
       * the blur latitudinally (around the poles), and then longitudinally (towards
       * the poles) to approximate the orthogonally-separable blur. It is least
       * accurate at the poles, but still does a decent job.
       *
       * @param {RenderTarget} cubeUVRenderTarget - The cubemap render target.
       * @param {Number} lodIn - The input level-of-detail.
       * @param {Number} lodOut - The output level-of-detail.
       * @param {Number} sigma - The blur radius in radians.
       * @param {Vector3} [poleAxis] - The pole axis.
       */
    }, {
      key: "_blur",
      value: function _blur(cubeUVRenderTarget, lodIn, lodOut, sigma, poleAxis) {
        var pingPongRenderTarget = this._pingPongRenderTarget;
        this._halfBlur(cubeUVRenderTarget, pingPongRenderTarget, lodIn, lodOut, sigma, 'latitudinal', poleAxis);
        this._halfBlur(pingPongRenderTarget, cubeUVRenderTarget, lodOut, lodOut, sigma, 'longitudinal', poleAxis);
      }
    }, {
      key: "_halfBlur",
      value: function _halfBlur(targetIn, targetOut, lodIn, lodOut, sigmaRadians, direction, poleAxis) {
        var renderer = this._renderer;
        var blurMaterial = this._blurMaterial;
        if (direction !== 'latitudinal' && direction !== 'longitudinal') {
          console.error('blur direction must be either latitudinal or longitudinal!');
        }

        // Number of standard deviations at which to cut off the discrete approximation.
        var STANDARD_DEVIATIONS = 3;
        var blurMesh = this._lodMeshes[lodOut];
        blurMesh.material = blurMaterial;
        var blurUniforms = blurMaterial.uniforms;
        var pixels = this._sizeLods[lodIn] - 1;
        var radiansPerPixel = isFinite(sigmaRadians) ? Math.PI / (2 * pixels) : 2 * Math.PI / (2 * MAX_SAMPLES - 1);
        var sigmaPixels = sigmaRadians / radiansPerPixel;
        var samples = isFinite(sigmaRadians) ? 1 + Math.floor(STANDARD_DEVIATIONS * sigmaPixels) : MAX_SAMPLES;
        if (samples > MAX_SAMPLES) {
          console.warn(`sigmaRadians, ${sigmaRadians}, is too large and will clip, as it requested ${samples} samples when the maximum is set to ${MAX_SAMPLES}`);
        }
        var weights = [];
        var sum = 0;
        for (var i = 0; i < MAX_SAMPLES; ++i) {
          var _x7 = i / sigmaPixels;
          var weight = Math.exp(-_x7 * _x7 / 2);
          weights.push(weight);
          if (i === 0) {
            sum += weight;
          } else if (i < samples) {
            sum += 2 * weight;
          }
        }
        for (var _i11 = 0; _i11 < weights.length; _i11++) {
          weights[_i11] = weights[_i11] / sum;
        }
        targetIn.texture.frame = (targetIn.texture.frame || 0) + 1;
        blurUniforms.envMap.value = targetIn.texture;
        blurUniforms.samples.value = samples;
        blurUniforms.weights.array = weights;
        blurUniforms.latitudinal.value = direction === 'latitudinal' ? 1 : 0;
        if (poleAxis) {
          blurUniforms.poleAxis.value = poleAxis;
        }
        var _lodMax = this._lodMax;
        blurUniforms.dTheta.value = radiansPerPixel;
        blurUniforms.mipInt.value = _lodMax - lodIn;
        var outputSize = this._sizeLods[lodOut];
        var x = 3 * outputSize * (lodOut > _lodMax - LOD_MIN ? lodOut - _lodMax + LOD_MIN : 0);
        var y = 4 * (this._cubeSize - outputSize);
        _setViewport(targetOut, x, y, 3 * outputSize, 2 * outputSize);
        renderer.setRenderTarget(targetOut);
        renderer.render(blurMesh, _flatCamera);
      }
    }]);
  }();
  function _createPlanes(lodMax) {
    var lodPlanes = [];
    var sizeLods = [];
    var sigmas = [];
    var lodMeshes = [];
    var lod = lodMax;
    var totalLods = lodMax - LOD_MIN + 1 + EXTRA_LOD_SIGMA.length;
    for (var i = 0; i < totalLods; i++) {
      var sizeLod = Math.pow(2, lod);
      sizeLods.push(sizeLod);
      var sigma = 1.0 / sizeLod;
      if (i > lodMax - LOD_MIN) {
        sigma = EXTRA_LOD_SIGMA[i - lodMax + LOD_MIN - 1];
      } else if (i === 0) {
        sigma = 0;
      }
      sigmas.push(sigma);
      var texelSize = 1.0 / (sizeLod - 2);
      var _min = -texelSize;
      var _max = 1 + texelSize;
      var uv1 = [_min, _min, _max, _min, _max, _max, _min, _min, _max, _max, _min, _max];
      var cubeFaces = 6;
      var vertices = 6;
      var positionSize = 3;
      var uvSize = 2;
      var faceIndexSize = 1;
      var position = new Float32Array(positionSize * vertices * cubeFaces);
      var _uv = new Float32Array(uvSize * vertices * cubeFaces);
      var faceIndex = new Float32Array(faceIndexSize * vertices * cubeFaces);
      for (var face = 0; face < cubeFaces; face++) {
        var x = face % 3 * 2 / 3 - 1;
        var y = face > 2 ? 0 : -1;
        var coordinates = [x, y, 0, x + 2 / 3, y, 0, x + 2 / 3, y + 1, 0, x, y, 0, x + 2 / 3, y + 1, 0, x, y + 1, 0];
        var faceIdx = _faceLib[face];
        position.set(coordinates, positionSize * vertices * faceIdx);
        _uv.set(uv1, uvSize * vertices * faceIdx);
        var fill = [faceIdx, faceIdx, faceIdx, faceIdx, faceIdx, faceIdx];
        faceIndex.set(fill, faceIndexSize * vertices * faceIdx);
      }
      var planes = new (_$$_REQUIRE(_dependencyMap[1], "./three.core.js").BufferGeometry)();
      planes.setAttribute('position', new (_$$_REQUIRE(_dependencyMap[1], "./three.core.js").BufferAttribute)(position, positionSize));
      planes.setAttribute('uv', new (_$$_REQUIRE(_dependencyMap[1], "./three.core.js").BufferAttribute)(_uv, uvSize));
      planes.setAttribute('faceIndex', new (_$$_REQUIRE(_dependencyMap[1], "./three.core.js").BufferAttribute)(faceIndex, faceIndexSize));
      lodPlanes.push(planes);
      lodMeshes.push(new (_$$_REQUIRE(_dependencyMap[1], "./three.core.js").Mesh)(planes, null));
      if (lod > LOD_MIN) {
        lod--;
      }
    }
    return {
      lodPlanes: lodPlanes,
      sizeLods: sizeLods,
      sigmas: sigmas,
      lodMeshes: lodMeshes
    };
  }
  function _createRenderTarget(width, height, params) {
    var cubeUVRenderTarget = new (_$$_REQUIRE(_dependencyMap[1], "./three.core.js").RenderTarget)(width, height, params);
    cubeUVRenderTarget.texture.mapping = _$$_REQUIRE(_dependencyMap[1], "./three.core.js").CubeUVReflectionMapping;
    cubeUVRenderTarget.texture.name = 'PMREM.cubeUv';
    cubeUVRenderTarget.texture.isPMREMTexture = true;
    cubeUVRenderTarget.scissorTest = true;
    return cubeUVRenderTarget;
  }
  function _setViewport(target, x, y, width, height) {
    target.viewport.set(x, y, width, height);
    target.scissor.set(x, y, width, height);
  }
  function _getMaterial(type) {
    var material = new NodeMaterial();
    material.depthTest = false;
    material.depthWrite = false;
    material.blending = _$$_REQUIRE(_dependencyMap[1], "./three.core.js").NoBlending;
    material.name = `PMREM_${type}`;
    return material;
  }
  function _getBlurShader(lodMax, width, height) {
    var weights = uniformArray(new Array(MAX_SAMPLES).fill(0));
    var poleAxis = uniform(new (_$$_REQUIRE(_dependencyMap[1], "./three.core.js").Vector3)(0, 1, 0));
    var dTheta = uniform(0);
    var n = float(MAX_SAMPLES);
    var latitudinal = uniform(0); // false, bool
    var samples = uniform(1); // int
    var envMap = texture(null);
    var mipInt = uniform(0); // int
    var CUBEUV_TEXEL_WIDTH = float(1 / width);
    var CUBEUV_TEXEL_HEIGHT = float(1 / height);
    var CUBEUV_MAX_MIP = float(lodMax);
    var materialUniforms = {
      n: n,
      latitudinal: latitudinal,
      weights: weights,
      poleAxis: poleAxis,
      outputDirection: outputDirection,
      dTheta: dTheta,
      samples: samples,
      envMap: envMap,
      mipInt: mipInt,
      CUBEUV_TEXEL_WIDTH: CUBEUV_TEXEL_WIDTH,
      CUBEUV_TEXEL_HEIGHT: CUBEUV_TEXEL_HEIGHT,
      CUBEUV_MAX_MIP: CUBEUV_MAX_MIP
    };
    var material = _getMaterial('blur');
    material.uniforms = materialUniforms; // TODO: Move to outside of the material
    material.fragmentNode = blur(Object.assign({}, materialUniforms, {
      latitudinal: latitudinal.equal(1)
    }));
    return material;
  }
  function _getCubemapMaterial(envTexture) {
    var material = _getMaterial('cubemap');
    material.fragmentNode = cubeTexture(envTexture, outputDirection);
    return material;
  }
  function _getEquirectMaterial(envTexture) {
    var material = _getMaterial('equirect');
    material.fragmentNode = texture(envTexture, equirectUV(outputDirection), 0);
    return material;
  }
  var rendererCache = new WeakMap();
  var typeFromArray = new Map([[Int8Array, 'int'], [Int16Array, 'int'], [Int32Array, 'int'], [Uint8Array, 'uint'], [Uint16Array, 'uint'], [Uint32Array, 'uint'], [Float32Array, 'float']]);
  var toFloat = function toFloat(value) {
    if (/e/g.test(value)) {
      return String(value).replace(/\+/g, '');
    } else {
      value = Number(value);
      return value + (value % 1 ? '' : '.0');
    }
  };

  /**
   * Base class for builders which generate a shader program based
   * on a 3D object and its node material definition.
   */
  var NodeBuilder = exports.NodeBuilder = /*#__PURE__*/function () {
    /**
     * Constructs a new node builder.
     *
     * @param {Object3D} object - The 3D object.
     * @param {Renderer} renderer - The current renderer.
     * @param {NodeParser} parser - A reference to a node parser.
     */
    function NodeBuilder(object, renderer, parser) {
      (0, _classCallCheck2.default)(this, NodeBuilder);
      /**
       * The 3D object.
       *
       * @type {Object3D}
       */
      this.object = object;

      /**
       * The material of the 3D object.
       *
       * @type {Material?}
       */
      this.material = object && object.material || null;

      /**
       * The geometry of the 3D object.
       *
       * @type {BufferGeometry?}
       */
      this.geometry = object && object.geometry || null;

      /**
       * The current renderer.
       *
       * @type {Renderer}
       */
      this.renderer = renderer;

      /**
       * A reference to a node parser.
       *
       * @type {NodeParser}
       */
      this.parser = parser;

      /**
       * The scene the 3D object belongs to.
       *
       * @type {Scene?}
       * @default null
       */
      this.scene = null;

      /**
       * The camera the 3D object is rendered with.
       *
       * @type {Camera?}
       * @default null
       */
      this.camera = null;

      /**
       * A list of all nodes the builder is processing
       * for this 3D object.
       *
       * @type {Array<Node>}
       */
      this.nodes = [];

      /**
       * A list of all sequential nodes.
       *
       * @type {Array<Node>}
       */
      this.sequentialNodes = [];

      /**
       * A list of all nodes which {@link Node#update} method should be executed.
       *
       * @type {Array<Node>}
       */
      this.updateNodes = [];

      /**
       * A list of all nodes which {@link Node#updateBefore} method should be executed.
       *
       * @type {Array<Node>}
       */
      this.updateBeforeNodes = [];

      /**
       * A list of all nodes which {@link Node#updateAfter} method should be executed.
       *
       * @type {Array<Node>}
       */
      this.updateAfterNodes = [];

      /**
       * A dictionary that assigns each node to a unique hash.
       *
       * @type {Object<Number,Node>}
       */
      this.hashNodes = {};

      /**
       * A reference to a node material observer.
       *
       * @type {NodeMaterialObserver?}
       * @default null
       */
      this.monitor = null;

      /**
       * A reference to the current lights node.
       *
       * @type {LightsNode?}
       * @default null
       */
      this.lightsNode = null;

      /**
       * A reference to the current environment node.
       *
       * @type {Node?}
       * @default null
       */
      this.environmentNode = null;

      /**
       * A reference to the current fog node.
       *
       * @type {FogNode?}
       * @default null
       */
      this.fogNode = null;

      /**
       * The current clipping context.
       *
       * @type {ClippingContext?}
       */
      this.clippingContext = null;

      /**
       * The generated vertex shader.
       *
       * @type {String?}
       */
      this.vertexShader = null;

      /**
       * The generated fragment shader.
       *
       * @type {String?}
       */
      this.fragmentShader = null;

      /**
       * The generated compute shader.
       *
       * @type {String?}
       */
      this.computeShader = null;

      /**
       * Nodes used in the primary flow of code generation.
       *
       * @type {Object<String,Array<Node>>}
       */
      this.flowNodes = {
        vertex: [],
        fragment: [],
        compute: []
      };

      /**
       * Nodes code from `.flowNodes`.
       *
       * @type {Object<String,String>}
       */
      this.flowCode = {
        vertex: '',
        fragment: '',
        compute: ''
      };

      /**
       * This dictionary holds the node uniforms of the builder.
       * The uniforms are maintained in an array for each shader stage.
       *
       * @type {Object}
       */
      this.uniforms = {
        vertex: [],
        fragment: [],
        compute: [],
        index: 0
      };

      /**
       * This dictionary holds the output structs of the builder.
       * The structs are maintained in an array for each shader stage.
       *
       * @type {Object}
       */
      this.structs = {
        vertex: [],
        fragment: [],
        compute: [],
        index: 0
      };

      /**
       * This dictionary holds the bindings for each shader stage.
       *
       * @type {Object}
       */
      this.bindings = {
        vertex: {},
        fragment: {},
        compute: {}
      };

      /**
       * This dictionary maintains the binding indices per bind group.
       *
       * @type {Object}
       */
      this.bindingsIndexes = {};

      /**
       * Reference to the array of bind groups.
       *
       * @type {Array<BindGroup>?}
       */
      this.bindGroups = null;

      /**
       * This array holds the node attributes of this builder
       * created via {@link AttributeNode}.
       *
       * @type {Array<NodeAttribute>}
       */
      this.attributes = [];

      /**
       * This array holds the node attributes of this builder
       * created via {@link BufferAttributeNode}.
       *
       * @type {Array<NodeAttribute>}
       */
      this.bufferAttributes = [];

      /**
       * This array holds the node varyings of this builder.
       *
       * @type {Array<NodeVarying>}
       */
      this.varyings = [];

      /**
       * This dictionary holds the (native) node codes of this builder.
       * The codes are maintained in an array for each shader stage.
       *
       * @type {Object<String,Array<NodeCode>>}
       */
      this.codes = {};

      /**
       * This dictionary holds the node variables of this builder.
       * The variables are maintained in an array for each shader stage.
       *
       * @type {Object<String,Array<NodeVar>>}
       */
      this.vars = {};

      /**
       * Current code flow.
       * All code generated in this stack will be stored in `.flow`.
       *
       * @type {{code: String}}
       */
      this.flow = {
        code: ''
      };

      /**
       * A chain of nodes.
       * Used to check recursive calls in node-graph.
       *
       * @type {Array<Node>}
       */
      this.chaining = [];

      /**
       * The current stack.
       * This reflects the current process in the code block hierarchy,
       * it is useful to know if the current process is inside a conditional for example.
       *
       * @type {StackNode}
       */
      this.stack = stack();

      /**
       * List of stack nodes.
       * The current stack hierarchy is stored in an array.
       *
       * @type {Array<StackNode>}
       */
      this.stacks = [];

      /**
       * A tab value. Used for shader string generation.
       *
       * @type {String}
       * @default '\t'
       */
      this.tab = '\t';

      /**
       * Reference to the current function node.
       *
       * @type {FunctionNode?}
       * @default null
       */
      this.currentFunctionNode = null;

      /**
       * The builder's context.
       *
       * @type {Object}
       */
      this.context = {
        material: this.material
      };

      /**
       * The builder's cache.
       *
       * @type {NodeCache}
       */
      this.cache = new NodeCache();

      /**
       * Since the {@link NodeBuilder#cache} might be temporarily
       * overwritten by other caches, this member retains the reference
       * to the builder's own cache.
       *
       * @type {NodeCache}
       * @default this.cache
       */
      this.globalCache = this.cache;
      this.flowsData = new WeakMap();

      /**
       * The current shader stage.
       *
       * @type {('vertex'|'fragment'|'compute'|'any')?}
       */
      this.shaderStage = null;

      /**
       * The current build stage.
       *
       * @type {('setup'|'analyze'|'generate')?}
       */
      this.buildStage = null;

      /**
       * Whether comparison in shader code are generated with methods or not.
       *
       * @type {Boolean}
       * @default false
       */
      this.useComparisonMethod = false;
    }

    /**
     * Returns the bind groups of the current renderer.
     *
     * @return {ChainMap} The cache.
     */
    return (0, _createClass2.default)(NodeBuilder, [{
      key: "getBindGroupsCache",
      value: function getBindGroupsCache() {
        var bindGroupsCache = rendererCache.get(this.renderer);
        if (bindGroupsCache === undefined) {
          bindGroupsCache = new ChainMap();
          rendererCache.set(this.renderer, bindGroupsCache);
        }
        return bindGroupsCache;
      }

      /**
       * Factory method for creating an instance of {@link RenderTarget} with the given
       * dimensions and options.
       *
       * @param {Number} width - The width of the render target.
       * @param {Number} height - The height of the render target.
       * @param {Object} options - The options of the render target.
       * @return {RenderTarget} The render target.
       */
    }, {
      key: "createRenderTarget",
      value: function createRenderTarget(width, height, options) {
        return new (_$$_REQUIRE(_dependencyMap[1], "./three.core.js").RenderTarget)(width, height, options);
      }

      /**
       * Factory method for creating an instance of {@link CubeRenderTarget} with the given
       * dimensions and options.
       *
       * @param {Number} size - The size of the cube render target.
       * @param {Object} options - The options of the cube render target.
       * @return {CubeRenderTarget} The cube render target.
       */
    }, {
      key: "createCubeRenderTarget",
      value: function createCubeRenderTarget(size, options) {
        return new CubeRenderTarget(size, options);
      }

      /**
       * Factory method for creating an instance of {@link PMREMGenerator}.
       *
       * @return {PMREMGenerator} The PMREM generator.
       */
    }, {
      key: "createPMREMGenerator",
      value: function createPMREMGenerator() {
        // TODO: Move Materials.js to outside of the Nodes.js in order to remove this function and improve tree-shaking support

        return new PMREMGenerator(this.renderer);
      }

      /**
       * Whether the given node is included in the internal array of nodes or not.
       *
       * @param {Node} node - The node to test.
       * @return {Boolean} Whether the given node is included in the internal array of nodes or not.
       */
    }, {
      key: "includes",
      value: function includes(node) {
        return this.nodes.includes(node);
      }

      /**
       * Returns a bind group for the given group name and binding.
       *
       * @private
       * @param {String} groupName - The group name.
       * @param {Array<NodeUniformsGroup>} bindings - List of bindings.
       * @return {BindGroup} The bind group
       */
    }, {
      key: "_getBindGroup",
      value: function _getBindGroup(groupName, bindings) {
        var bindGroupsCache = this.getBindGroupsCache();

        //

        var bindingsArray = [];
        var sharedGroup = true;
        for (var binding of bindings) {
          bindingsArray.push(binding);
          sharedGroup = sharedGroup && binding.groupNode.shared !== true;
        }

        //

        var bindGroup;
        if (sharedGroup) {
          bindGroup = bindGroupsCache.get(bindingsArray);
          if (bindGroup === undefined) {
            bindGroup = new BindGroup(groupName, bindingsArray, this.bindingsIndexes[groupName].group, bindingsArray);
            bindGroupsCache.set(bindingsArray, bindGroup);
          }
        } else {
          bindGroup = new BindGroup(groupName, bindingsArray, this.bindingsIndexes[groupName].group, bindingsArray);
        }
        return bindGroup;
      }

      /**
       * Returns an array of node uniform groups for the given group name and shader stage.
       *
       * @param {String} groupName - The group name.
       * @param {('vertex'|'fragment'|'compute'|'any')} shaderStage - The shader stage.
       * @return {Array<NodeUniformsGroup>} The array of node uniform groups.
       */
    }, {
      key: "getBindGroupArray",
      value: function getBindGroupArray(groupName, shaderStage) {
        var bindings = this.bindings[shaderStage];
        var bindGroup = bindings[groupName];
        if (bindGroup === undefined) {
          if (this.bindingsIndexes[groupName] === undefined) {
            this.bindingsIndexes[groupName] = {
              binding: 0,
              group: Object.keys(this.bindingsIndexes).length
            };
          }
          bindings[groupName] = bindGroup = [];
        }
        return bindGroup;
      }

      /**
       * Returns a list bindings of all shader stages separated by groups.
       *
       * @return {Array<BindGroup>} The list of bindings.
       */
    }, {
      key: "getBindings",
      value: function getBindings() {
        var bindingsGroups = this.bindGroups;
        if (bindingsGroups === null) {
          var groups = {};
          var bindings = this.bindings;
          for (var shaderStage of shaderStages) {
            for (var groupName in bindings[shaderStage]) {
              var _uniforms = bindings[shaderStage][groupName];
              var groupUniforms = groups[groupName] || (groups[groupName] = []);
              groupUniforms.push.apply(groupUniforms, (0, _toConsumableArray2.default)(_uniforms));
            }
          }
          bindingsGroups = [];
          for (var _groupName in groups) {
            var group = groups[_groupName];
            var bindingsGroup = this._getBindGroup(_groupName, group);
            bindingsGroups.push(bindingsGroup);
          }
          this.bindGroups = bindingsGroups;
        }
        return bindingsGroups;
      }

      /**
       * Sorts the bind groups and updates {@link NodeBuilder#bindingsIndexes}.
       */
    }, {
      key: "sortBindingGroups",
      value: function sortBindingGroups() {
        var bindingsGroups = this.getBindings();
        bindingsGroups.sort(function (a, b) {
          return a.bindings[0].groupNode.order - b.bindings[0].groupNode.order;
        });
        for (var i = 0; i < bindingsGroups.length; i++) {
          var bindingGroup = bindingsGroups[i];
          this.bindingsIndexes[bindingGroup.name].group = i;
          bindingGroup.index = i;
        }
      }

      /**
       * The builder maintains each node in a hash-based dictionary.
       * This method sets the given node (value) with the given hash (key) into this dictionary.
       *
       * @param {Node} node - The node to add.
       * @param {Number} hash - The hash of the node.
       */
    }, {
      key: "setHashNode",
      value: function setHashNode(node, hash) {
        this.hashNodes[hash] = node;
      }

      /**
       * Adds a node to this builder.
       *
       * @param {Node} node - The node to add.
       */
    }, {
      key: "addNode",
      value: function addNode(node) {
        if (this.nodes.includes(node) === false) {
          this.nodes.push(node);
          this.setHashNode(node, node.getHash(this));
        }
      }

      /**
       * It is used to add Nodes that will be used as FRAME and RENDER events,
       * and need to follow a certain sequence in the calls to work correctly.
       * This function should be called after 'setup()' in the 'build()' process to ensure that the child nodes are processed first.
       *
       * @param {Node} node - The node to add.
       */
    }, {
      key: "addSequentialNode",
      value: function addSequentialNode(node) {
        if (this.sequentialNodes.includes(node) === false) {
          this.sequentialNodes.push(node);
        }
      }

      /**
       * Checks the update types of nodes
       */
    }, {
      key: "buildUpdateNodes",
      value: function buildUpdateNodes() {
        for (var node of this.nodes) {
          var updateType = node.getUpdateType();
          if (updateType !== NodeUpdateType.NONE) {
            this.updateNodes.push(node.getSelf());
          }
        }
        for (var _node of this.sequentialNodes) {
          var updateBeforeType = _node.getUpdateBeforeType();
          var updateAfterType = _node.getUpdateAfterType();
          if (updateBeforeType !== NodeUpdateType.NONE) {
            this.updateBeforeNodes.push(_node.getSelf());
          }
          if (updateAfterType !== NodeUpdateType.NONE) {
            this.updateAfterNodes.push(_node.getSelf());
          }
        }
      }

      /**
       * A reference the current node which is the
       * last node in the chain of nodes.
       *
       * @type {Node}
       */
    }, {
      key: "currentNode",
      get: function get() {
        return this.chaining[this.chaining.length - 1];
      }

      /**
       * Whether the given texture is filtered or not.
       *
       * @param {Texture} texture - The texture to check.
       * @return {Boolean} Whether the given texture is filtered or not.
       */
    }, {
      key: "isFilteredTexture",
      value: function isFilteredTexture(texture) {
        return texture.magFilter === _$$_REQUIRE(_dependencyMap[1], "./three.core.js").LinearFilter || texture.magFilter === _$$_REQUIRE(_dependencyMap[1], "./three.core.js").LinearMipmapNearestFilter || texture.magFilter === _$$_REQUIRE(_dependencyMap[1], "./three.core.js").NearestMipmapLinearFilter || texture.magFilter === _$$_REQUIRE(_dependencyMap[1], "./three.core.js").LinearMipmapLinearFilter || texture.minFilter === _$$_REQUIRE(_dependencyMap[1], "./three.core.js").LinearFilter || texture.minFilter === _$$_REQUIRE(_dependencyMap[1], "./three.core.js").LinearMipmapNearestFilter || texture.minFilter === _$$_REQUIRE(_dependencyMap[1], "./three.core.js").NearestMipmapLinearFilter || texture.minFilter === _$$_REQUIRE(_dependencyMap[1], "./three.core.js").LinearMipmapLinearFilter;
      }

      /**
       * Adds the given node to the internal node chain.
       * This is used to check recursive calls in node-graph.
       *
       * @param {Node} node - The node to add.
       */
    }, {
      key: "addChain",
      value: function addChain(node) {
        /*
        if ( this.chaining.indexOf( node ) !== - 1 ) {
        		console.warn( 'Recursive node: ', node );
        	}
        */

        this.chaining.push(node);
      }

      /**
       * Removes the given node from the internal node chain.
       *
       * @param {Node} node - The node to remove.
       */
    }, {
      key: "removeChain",
      value: function removeChain(node) {
        var lastChain = this.chaining.pop();
        if (lastChain !== node) {
          throw new Error('NodeBuilder: Invalid node chaining!');
        }
      }

      /**
       * Returns the native shader method name for a given generic name. E.g.
       * the method name `textureDimensions` matches the WGSL name but must be
       * resolved to `textureSize` in GLSL.
       *
       * @abstract
       * @param {String} method - The method name to resolve.
       * @return {String} The resolved method name.
       */
    }, {
      key: "getMethod",
      value: function getMethod(method) {
        return method;
      }

      /**
       * Returns a node for the given hash, see {@link NodeBuilder#setHashNode}.
       *
       * @param {Number} hash - The hash of the node.
       * @return {Node} The found node.
       */
    }, {
      key: "getNodeFromHash",
      value: function getNodeFromHash(hash) {
        return this.hashNodes[hash];
      }

      /**
       * Adds the Node to a target flow so that it can generate code in the 'generate' process.
       *
       * @param {('vertex'|'fragment'|'compute')} shaderStage - The shader stage.
       * @param {Node} node - The node to add.
       * @return {Node} The node.
       */
    }, {
      key: "addFlow",
      value: function addFlow(shaderStage, node) {
        this.flowNodes[shaderStage].push(node);
        return node;
      }

      /**
       * Sets builder's context.
       *
       * @param {Object} context - The context to set.
       */
    }, {
      key: "setContext",
      value: function setContext(context) {
        this.context = context;
      }

      /**
       * Returns the builder's current context.
       *
       * @return {Object} The builder's current context.
       */
    }, {
      key: "getContext",
      value: function getContext() {
        return this.context;
      }

      /**
       * Gets a context used in shader construction that can be shared across different materials.
       * This is necessary since the renderer cache can reuse shaders generated in one material and use them in another.
       *
       * @return {Object} The builder's current context without material.
       */
    }, {
      key: "getSharedContext",
      value: function getSharedContext() {
        Object.assign({}, this.context);
        return this.context;
      }

      /**
       * Sets builder's cache.
       *
       * @param {NodeCache} cache - The cache to set.
       */
    }, {
      key: "setCache",
      value: function setCache(cache) {
        this.cache = cache;
      }

      /**
       * Returns the builder's current cache.
       *
       * @return {NodeCache} The builder's current cache.
       */
    }, {
      key: "getCache",
      value: function getCache() {
        return this.cache;
      }

      /**
       * Returns a cache for the given node.
       *
       * @param {Node} node - The node.
       * @param {Boolean} [parent=true] - Whether this node refers to a shared parent cache or not.
       * @return {NodeCache} The cache.
       */
    }, {
      key: "getCacheFromNode",
      value: function getCacheFromNode(node) {
        var parent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
        var data = this.getDataFromNode(node);
        if (data.cache === undefined) data.cache = new NodeCache(parent ? this.getCache() : null);
        return data.cache;
      }

      /**
       * Whether the requested feature is available or not.
       *
       * @abstract
       * @param {String} name - The requested feature.
       * @return {Boolean} Whether the requested feature is supported or not.
       */
    }, {
      key: "isAvailable",
      value: function isAvailable(/*name*/
      ) {
        return false;
      }

      /**
       * Returns the vertexIndex input variable as a native shader string.
       *
       * @abstract
       * @return {String} The instanceIndex shader string.
       */
    }, {
      key: "getVertexIndex",
      value: function getVertexIndex() {
        console.warn('Abstract function.');
      }

      /**
       * Returns the instanceIndex input variable as a native shader string.
       *
       * @abstract
       * @return {String} The instanceIndex shader string.
       */
    }, {
      key: "getInstanceIndex",
      value: function getInstanceIndex() {
        console.warn('Abstract function.');
      }

      /**
       * Returns the drawIndex input variable as a native shader string.
       * Only relevant for WebGL and its `WEBGL_multi_draw` extension.
       *
       * @abstract
       * @return {String} The drawIndex shader string.
       */
    }, {
      key: "getDrawIndex",
      value: function getDrawIndex() {
        console.warn('Abstract function.');
      }

      /**
       * Returns the frontFacing input variable as a native shader string.
       *
       * @abstract
       * @return {String} The frontFacing shader string.
       */
    }, {
      key: "getFrontFacing",
      value: function getFrontFacing() {
        console.warn('Abstract function.');
      }

      /**
       * Returns the fragCoord input variable as a native shader string.
       *
       * @abstract
       * @return {String} The fragCoord shader string.
       */
    }, {
      key: "getFragCoord",
      value: function getFragCoord() {
        console.warn('Abstract function.');
      }

      /**
       * Whether to flip texture data along its vertical axis or not. WebGL needs
       * this method evaluate to `true`, WebGPU to `false`.
       *
       * @abstract
       * @return {Boolean} Whether to flip texture data along its vertical axis or not.
       */
    }, {
      key: "isFlipY",
      value: function isFlipY() {
        return false;
      }

      /**
       * Calling this method increases the usage count for the given node by one.
       *
       * @param {Node} node - The node to increase the usage count for.
       * @return {Number} The updated usage count.
       */
    }, {
      key: "increaseUsage",
      value: function increaseUsage(node) {
        var nodeData = this.getDataFromNode(node);
        nodeData.usageCount = nodeData.usageCount === undefined ? 1 : nodeData.usageCount + 1;
        return nodeData.usageCount;
      }

      /**
       * Generates a texture sample shader string for the given texture data.
       *
       * @abstract
       * @param {Texture} texture - The texture.
       * @param {String} textureProperty - The texture property name.
       * @param {String} uvSnippet - Snippet defining the texture coordinates.
       * @return {String} The generated shader string.
       */
    }, {
      key: "generateTexture",
      value: function generateTexture(/* texture, textureProperty, uvSnippet */
      ) {
        console.warn('Abstract function.');
      }

      /**
       * Generates a texture LOD shader string for the given texture data.
       *
       * @abstract
       * @param {Texture} texture - The texture.
       * @param {String} textureProperty - The texture property name.
       * @param {String} uvSnippet - Snippet defining the texture coordinates.
       * @param {String} levelSnippet - Snippet defining the mip level.
       * @return {String} The generated shader string.
       */
    }, {
      key: "generateTextureLod",
      value: function generateTextureLod(/* texture, textureProperty, uvSnippet, levelSnippet */
      ) {
        console.warn('Abstract function.');
      }

      /**
       * Generates the shader string for the given type and value.
       *
       * @param {String} type - The type.
       * @param {Any?} [value=null] - The value.
       * @return {String} The generated value as a shader string.
       */
    }, {
      key: "generateConst",
      value: function generateConst(type) {
        var _this184 = this;
        var value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
        if (value === null) {
          if (type === 'float' || type === 'int' || type === 'uint') value = 0;else if (type === 'bool') value = false;else if (type === 'color') value = new (_$$_REQUIRE(_dependencyMap[1], "./three.core.js").Color)();else if (type === 'vec2') value = new (_$$_REQUIRE(_dependencyMap[1], "./three.core.js").Vector2)();else if (type === 'vec3') value = new (_$$_REQUIRE(_dependencyMap[1], "./three.core.js").Vector3)();else if (type === 'vec4') value = new (_$$_REQUIRE(_dependencyMap[1], "./three.core.js").Vector4)();
        }
        if (type === 'float') return toFloat(value);
        if (type === 'int') return `${Math.round(value)}`;
        if (type === 'uint') return value >= 0 ? `${Math.round(value)}u` : '0u';
        if (type === 'bool') return value ? 'true' : 'false';
        if (type === 'color') return `${this.getType('vec3')}( ${toFloat(value.r)}, ${toFloat(value.g)}, ${toFloat(value.b)} )`;
        var typeLength = this.getTypeLength(type);
        var componentType = this.getComponentType(type);
        var generateConst = function generateConst(value) {
          return _this184.generateConst(componentType, value);
        };
        if (typeLength === 2) {
          return `${this.getType(type)}( ${generateConst(value.x)}, ${generateConst(value.y)} )`;
        } else if (typeLength === 3) {
          return `${this.getType(type)}( ${generateConst(value.x)}, ${generateConst(value.y)}, ${generateConst(value.z)} )`;
        } else if (typeLength === 4) {
          return `${this.getType(type)}( ${generateConst(value.x)}, ${generateConst(value.y)}, ${generateConst(value.z)}, ${generateConst(value.w)} )`;
        } else if (typeLength > 4 && value && (value.isMatrix3 || value.isMatrix4)) {
          return `${this.getType(type)}( ${value.elements.map(generateConst).join(', ')} )`;
        } else if (typeLength > 4) {
          return `${this.getType(type)}()`;
        }
        throw new Error(`NodeBuilder: Type '${type}' not found in generate constant attempt.`);
      }

      /**
       * It might be necessary to convert certain data types to different ones
       * so this method can be used to hide the conversion.
       *
       * @param {String} type - The type.
       * @return {String} The updated type.
       */
    }, {
      key: "getType",
      value: function getType(type) {
        if (type === 'color') return 'vec3';
        return type;
      }

      /**
       * Whether the given attribute name is defined in the geometry or not.
       *
       * @param {String} name - The attribute name.
       * @return {Boolean} Whether the given attribute name is defined in the geometry.
       */
    }, {
      key: "hasGeometryAttribute",
      value: function hasGeometryAttribute(name) {
        return this.geometry && this.geometry.getAttribute(name) !== undefined;
      }

      /**
       * Returns a node attribute for the given name and type.
       *
       * @param {String} name - The attribute's name.
       * @param {String} type - The attribute's type.
       * @return {NodeAttribute} The node attribute.
       */
    }, {
      key: "getAttribute",
      value: function getAttribute(name, type) {
        var attributes = this.attributes;

        // find attribute

        for (var _attribute9 of attributes) {
          if (_attribute9.name === name) {
            return _attribute9;
          }
        }

        // create a new if no exist

        var attribute = new NodeAttribute(name, type);
        attributes.push(attribute);
        return attribute;
      }

      /**
       * Returns for the given node and shader stage the property name for the shader.
       *
       * @param {Node} node - The node.
       * @param {('vertex'|'fragment'|'compute'|'any')} shaderStage - The shader stage.
       * @return {String} The property name.
       */
    }, {
      key: "getPropertyName",
      value: function getPropertyName(node /*, shaderStage*/) {
        return node.name;
      }

      /**
       * Whether the given type is a vector type or not.
       *
       * @param {String} type - The type to check.
       * @return {Boolean} Whether the given type is a vector type or not.
       */
    }, {
      key: "isVector",
      value: function isVector(type) {
        return /vec\d/.test(type);
      }

      /**
       * Whether the given type is a matrix type or not.
       *
       * @param {String} type - The type to check.
       * @return {Boolean} Whether the given type is a matrix type or not.
       */
    }, {
      key: "isMatrix",
      value: function isMatrix(type) {
        return /mat\d/.test(type);
      }

      /**
       * Whether the given type is a reference type or not.
       *
       * @param {String} type - The type to check.
       * @return {Boolean} Whether the given type is a reference type or not.
       */
    }, {
      key: "isReference",
      value: function isReference(type) {
        return type === 'void' || type === 'property' || type === 'sampler' || type === 'texture' || type === 'cubeTexture' || type === 'storageTexture' || type === 'depthTexture' || type === 'texture3D';
      }

      /**
       * Whether the given texture needs a conversion to working color space.
       *
       * @abstract
       * @param {Texture} texture - The texture to check.
       * @return {Boolean} Whether a color space conversion is required or not.
       */
    }, {
      key: "needsToWorkingColorSpace",
      value: function needsToWorkingColorSpace(/*texture*/
      ) {
        return false;
      }

      /**
       * Returns the component type of a given texture.
       *
       * @param {Texture} texture - The texture.
       * @return {String} The component type.
       */
    }, {
      key: "getComponentTypeFromTexture",
      value: function getComponentTypeFromTexture(texture) {
        var type = texture.type;
        if (texture.isDataTexture) {
          if (type === _$$_REQUIRE(_dependencyMap[1], "./three.core.js").IntType) return 'int';
          if (type === _$$_REQUIRE(_dependencyMap[1], "./three.core.js").UnsignedIntType) return 'uint';
        }
        return 'float';
      }

      /**
       * Returns the element type for a given type.
       *
       * @param {String} type - The type.
       * @return {String} The element type.
       */
    }, {
      key: "getElementType",
      value: function getElementType(type) {
        if (type === 'mat2') return 'vec2';
        if (type === 'mat3') return 'vec3';
        if (type === 'mat4') return 'vec4';
        return this.getComponentType(type);
      }

      /**
       * Returns the component type for a given type.
       *
       * @param {String} type - The type.
       * @return {String} The component type.
       */
    }, {
      key: "getComponentType",
      value: function getComponentType(type) {
        type = this.getVectorType(type);
        if (type === 'float' || type === 'bool' || type === 'int' || type === 'uint') return type;
        var componentType = /(b|i|u|)(vec|mat)([2-4])/.exec(type);
        if (componentType === null) return null;
        if (componentType[1] === 'b') return 'bool';
        if (componentType[1] === 'i') return 'int';
        if (componentType[1] === 'u') return 'uint';
        return 'float';
      }

      /**
       * Returns the vector type for a given type.
       *
       * @param {String} type - The type.
       * @return {String} The vector type.
       */
    }, {
      key: "getVectorType",
      value: function getVectorType(type) {
        if (type === 'color') return 'vec3';
        if (type === 'texture' || type === 'cubeTexture' || type === 'storageTexture' || type === 'texture3D') return 'vec4';
        return type;
      }

      /**
       * Returns the data type for the given the length and component type.
       *
       * @param {Number} length - The length.
       * @param {String} [componentType='float'] - The component type.
       * @return {String} The type.
       */
    }, {
      key: "getTypeFromLength",
      value: function getTypeFromLength(length) {
        var componentType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'float';
        if (length === 1) return componentType;
        var baseType = _getTypeFromLength(length);
        var prefix = componentType === 'float' ? '' : componentType[0];
        return prefix + baseType;
      }

      /**
       * Returns the type for a given typed array.
       *
       * @param {TypedArray} array - The typed array.
       * @return {String} The type.
       */
    }, {
      key: "getTypeFromArray",
      value: function getTypeFromArray(array) {
        return typeFromArray.get(array.constructor);
      }

      /**
       * Returns the type for a given buffer attribute.
       *
       * @param {BufferAttribute} attribute - The buffer attribute.
       * @return {String} The type.
       */
    }, {
      key: "getTypeFromAttribute",
      value: function getTypeFromAttribute(attribute) {
        var dataAttribute = attribute;
        if (attribute.isInterleavedBufferAttribute) dataAttribute = attribute.data;
        var array = dataAttribute.array;
        var itemSize = attribute.itemSize;
        var normalized = attribute.normalized;
        var arrayType;
        if (!(attribute instanceof _$$_REQUIRE(_dependencyMap[1], "./three.core.js").Float16BufferAttribute) && normalized !== true) {
          arrayType = this.getTypeFromArray(array);
        }
        return this.getTypeFromLength(itemSize, arrayType);
      }

      /**
       * Returns the length for the given data type.
       *
       * @param {String} type - The data type.
       * @return {Number} The length.
       */
    }, {
      key: "getTypeLength",
      value: function getTypeLength(type) {
        var vecType = this.getVectorType(type);
        var vecNum = /vec([2-4])/.exec(vecType);
        if (vecNum !== null) return Number(vecNum[1]);
        if (vecType === 'float' || vecType === 'bool' || vecType === 'int' || vecType === 'uint') return 1;
        if (/mat2/.test(type) === true) return 4;
        if (/mat3/.test(type) === true) return 9;
        if (/mat4/.test(type) === true) return 16;
        return 0;
      }

      /**
       * Returns the vector type for a given matrix type.
       *
       * @param {String} type - The matrix type.
       * @return {String} The vector type.
       */
    }, {
      key: "getVectorFromMatrix",
      value: function getVectorFromMatrix(type) {
        return type.replace('mat', 'vec');
      }

      /**
       * For a given type this method changes the component type to the
       * given value. E.g. `vec4` should be changed to the new component type
       * `uint` which results in `uvec4`.
       *
       * @param {String} type - The type.
       * @param {String} newComponentType - The new component type.
       * @return {String} The new type.
       */
    }, {
      key: "changeComponentType",
      value: function changeComponentType(type, newComponentType) {
        return this.getTypeFromLength(this.getTypeLength(type), newComponentType);
      }

      /**
       * Returns the integer type pendant for the given type.
       *
       * @param {String} type - The type.
       * @return {String} The integer type.
       */
    }, {
      key: "getIntegerType",
      value: function getIntegerType(type) {
        var componentType = this.getComponentType(type);
        if (componentType === 'int' || componentType === 'uint') return type;
        return this.changeComponentType(type, 'int');
      }

      /**
       * Adds a stack node to the internal stack.
       *
       * @return {StackNode} The added stack node.
       */
    }, {
      key: "addStack",
      value: function addStack() {
        this.stack = stack(this.stack);
        this.stacks.push(getCurrentStack() || this.stack);
        setCurrentStack(this.stack);
        return this.stack;
      }

      /**
       * Removes the last stack node from the internal stack.
       *
       * @return {StackNode} The removed stack node.
       */
    }, {
      key: "removeStack",
      value: function removeStack() {
        var lastStack = this.stack;
        this.stack = lastStack.parent;
        setCurrentStack(this.stacks.pop());
        return lastStack;
      }

      /**
       * The builder maintains (cached) data for each node during the building process. This method
       * can be used to get these data for a specific shader stage and cache.
       *
       * @param {Node} node - The node to get the data for.
       * @param {('vertex'|'fragment'|'compute'|'any')} [shaderStage=this.shaderStage] - The shader stage.
       * @param {NodeCache?} cache - An optional cache.
       * @return {Object} The node data.
       */
    }, {
      key: "getDataFromNode",
      value: function getDataFromNode(node) {
        var shaderStage = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.shaderStage;
        var cache = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
        cache = cache === null ? node.isGlobal(this) ? this.globalCache : this.cache : cache;
        var nodeData = cache.getData(node);
        if (nodeData === undefined) {
          nodeData = {};
          cache.setData(node, nodeData);
        }
        if (nodeData[shaderStage] === undefined) nodeData[shaderStage] = {};
        return nodeData[shaderStage];
      }

      /**
       * Returns the properties for the given node and shader stage.
       *
       * @param {Node} node - The node to get the properties for.
       * @param {('vertex'|'fragment'|'compute'|'any')} [shaderStage='any'] - The shader stage.
       * @return {Object} The node properties.
       */
    }, {
      key: "getNodeProperties",
      value: function getNodeProperties(node) {
        var shaderStage = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'any';
        var nodeData = this.getDataFromNode(node, shaderStage);
        return nodeData.properties || (nodeData.properties = {
          outputNode: null
        });
      }

      /**
       * Returns an instance of {@link NodeAttribute} for the given buffer attribute node.
       *
       * @param {BufferAttributeNode} node - The buffer attribute node.
       * @param {String} type - The node type.
       * @return {NodeAttribute} The node attribute.
       */
    }, {
      key: "getBufferAttributeFromNode",
      value: function getBufferAttributeFromNode(node, type) {
        var nodeData = this.getDataFromNode(node);
        var bufferAttribute = nodeData.bufferAttribute;
        if (bufferAttribute === undefined) {
          var index = this.uniforms.index++;
          bufferAttribute = new NodeAttribute('nodeAttribute' + index, type, node);
          this.bufferAttributes.push(bufferAttribute);
          nodeData.bufferAttribute = bufferAttribute;
        }
        return bufferAttribute;
      }

      /**
       * Returns an instance of {@link StructTypeNode} for the given output struct node.
       *
       * @param {OutputStructNode} node - The output struct node.
       * @param {Array<String>} types - The output struct types.
       * @param {('vertex'|'fragment'|'compute'|'any')} [shaderStage=this.shaderStage] - The shader stage.
       * @return {StructTypeNode} The struct type attribute.
       */
    }, {
      key: "getStructTypeFromNode",
      value: function getStructTypeFromNode(node, types) {
        var shaderStage = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.shaderStage;
        var nodeData = this.getDataFromNode(node, shaderStage);
        var structType = nodeData.structType;
        if (structType === undefined) {
          var index = this.structs.index++;
          structType = new StructTypeNode('StructType' + index, types);
          this.structs[shaderStage].push(structType);
          nodeData.structType = structType;
        }
        return structType;
      }

      /**
       * Returns an instance of {@link NodeUniform} for the given uniform node.
       *
       * @param {UniformNode} node - The uniform node.
       * @param {String} type - The uniform type.
       * @param {('vertex'|'fragment'|'compute'|'any')} [shaderStage=this.shaderStage] - The shader stage.
       * @param {String?} name - The name of the uniform.
       * @return {NodeUniform} The node uniform.
       */
    }, {
      key: "getUniformFromNode",
      value: function getUniformFromNode(node, type) {
        var shaderStage = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.shaderStage;
        var name = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
        var nodeData = this.getDataFromNode(node, shaderStage, this.globalCache);
        var nodeUniform = nodeData.uniform;
        if (nodeUniform === undefined) {
          var index = this.uniforms.index++;
          nodeUniform = new NodeUniform(name || 'nodeUniform' + index, type, node);
          this.uniforms[shaderStage].push(nodeUniform);
          nodeData.uniform = nodeUniform;
        }
        return nodeUniform;
      }

      /**
       * Returns an instance of {@link NodeVar} for the given variable node.
       *
       * @param {VarNode} node - The variable node.
       * @param {String?} name - The variable's name.
       * @param {String} [type=node.getNodeType( this )] - The variable's type.
       * @param {('vertex'|'fragment'|'compute'|'any')} [shaderStage=this.shaderStage] - The shader stage.
       * @return {NodeVar} The node variable.
       */
    }, {
      key: "getVarFromNode",
      value: function getVarFromNode(node) {
        var name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
        var type = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : node.getNodeType(this);
        var shaderStage = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : this.shaderStage;
        var nodeData = this.getDataFromNode(node, shaderStage);
        var nodeVar = nodeData.variable;
        if (nodeVar === undefined) {
          var vars = this.vars[shaderStage] || (this.vars[shaderStage] = []);
          if (name === null) name = 'nodeVar' + vars.length;
          nodeVar = new NodeVar(name, type);
          vars.push(nodeVar);
          nodeData.variable = nodeVar;
        }
        return nodeVar;
      }

      /**
       * Returns an instance of {@link NodeVarying} for the given varying node.
       *
       * @param {(VaryingNode|PropertyNode)} node - The varying node.
       * @param {String?} name - The varying's name.
       * @param {String} [type=node.getNodeType( this )] - The varying's type.
       * @return {NodeVar} The node varying.
       */
    }, {
      key: "getVaryingFromNode",
      value: function getVaryingFromNode(node) {
        var name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
        var type = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : node.getNodeType(this);
        var nodeData = this.getDataFromNode(node, 'any');
        var nodeVarying = nodeData.varying;
        if (nodeVarying === undefined) {
          var varyings = this.varyings;
          var index = varyings.length;
          if (name === null) name = 'nodeVarying' + index;
          nodeVarying = new NodeVarying(name, type);
          varyings.push(nodeVarying);
          nodeData.varying = nodeVarying;
        }
        return nodeVarying;
      }

      /**
       * Returns an instance of {@link NodeCode} for the given code node.
       *
       * @param {CodeNode} node - The code node.
       * @param {String} type - The node type.
       * @param {('vertex'|'fragment'|'compute'|'any')} [shaderStage=this.shaderStage] - The shader stage.
       * @return {NodeCode} The node code.
       */
    }, {
      key: "getCodeFromNode",
      value: function getCodeFromNode(node, type) {
        var shaderStage = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.shaderStage;
        var nodeData = this.getDataFromNode(node);
        var nodeCode = nodeData.code;
        if (nodeCode === undefined) {
          var codes = this.codes[shaderStage] || (this.codes[shaderStage] = []);
          var index = codes.length;
          nodeCode = new NodeCode('nodeCode' + index, type);
          codes.push(nodeCode);
          nodeData.code = nodeCode;
        }
        return nodeCode;
      }

      /**
       * Adds a code flow based on the code-block hierarchy.
      	 * This is used so that code-blocks like If,Else create their variables locally if the Node
       * is only used inside one of these conditionals in the current shader stage.
       *
       * @param {Node} node - The node to add.
       * @param {Node} nodeBlock - Node-based code-block. Usually 'ConditionalNode'.
       */
    }, {
      key: "addFlowCodeHierarchy",
      value: function addFlowCodeHierarchy(node, nodeBlock) {
        var _this$getDataFromNode = this.getDataFromNode(node),
          flowCodes = _this$getDataFromNode.flowCodes,
          flowCodeBlock = _this$getDataFromNode.flowCodeBlock;
        var needsFlowCode = true;
        var nodeBlockHierarchy = nodeBlock;
        while (nodeBlockHierarchy) {
          if (flowCodeBlock.get(nodeBlockHierarchy) === true) {
            needsFlowCode = false;
            break;
          }
          nodeBlockHierarchy = this.getDataFromNode(nodeBlockHierarchy).parentNodeBlock;
        }
        if (needsFlowCode) {
          for (var flowCode of flowCodes) {
            this.addLineFlowCode(flowCode);
          }
        }
      }

      /**
       * Add a inline-code to the current flow code-block.
       *
       * @param {Node} node - The node to add.
       * @param {String} code - The code to add.
       * @param {Node} nodeBlock - Current ConditionalNode
       */
    }, {
      key: "addLineFlowCodeBlock",
      value: function addLineFlowCodeBlock(node, code, nodeBlock) {
        var nodeData = this.getDataFromNode(node);
        var flowCodes = nodeData.flowCodes || (nodeData.flowCodes = []);
        var codeBlock = nodeData.flowCodeBlock || (nodeData.flowCodeBlock = new WeakMap());
        flowCodes.push(code);
        codeBlock.set(nodeBlock, true);
      }

      /**
       * Add a inline-code to the current flow.
       *
       * @param {String} code - The code to add.
       * @param {Node?} [node= null] - Optional Node, can help the system understand if the Node is part of a code-block.
       * @return {NodeBuilder} A reference to this node builder.
       */
    }, {
      key: "addLineFlowCode",
      value: function addLineFlowCode(code) {
        var node = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
        if (code === '') return this;
        if (node !== null && this.context.nodeBlock) {
          this.addLineFlowCodeBlock(node, code, this.context.nodeBlock);
        }
        code = this.tab + code;
        if (!/;\s*$/.test(code)) {
          code = code + ';\n';
        }
        this.flow.code += code;
        return this;
      }

      /**
       * Adds a code to the current code flow.
       *
       * @param {String} code - Shader code.
       * @return {NodeBuilder} A reference to this node builder.
       */
    }, {
      key: "addFlowCode",
      value: function addFlowCode(code) {
        this.flow.code += code;
        return this;
      }

      /**
       * Add tab in the code that will be generated so that other snippets respect the current tabulation.
       * Typically used in codes with If,Else.
       *
       * @return {NodeBuilder} A reference to this node builder.
       */
    }, {
      key: "addFlowTab",
      value: function addFlowTab() {
        this.tab += '\t';
        return this;
      }

      /**
       * Removes a tab.
       *
       * @return {NodeBuilder} A reference to this node builder.
       */
    }, {
      key: "removeFlowTab",
      value: function removeFlowTab() {
        this.tab = this.tab.slice(0, -1);
        return this;
      }

      /**
       * Gets the current flow data based on a Node.
       *
       * @param {Node} node - Node that the flow was started.
       * @param {('vertex'|'fragment'|'compute'|'any')} shaderStage - The shader stage.
       * @return {Object} The flow data.
       */
    }, {
      key: "getFlowData",
      value: function getFlowData(node /*, shaderStage*/) {
        return this.flowsData.get(node);
      }

      /**
       * Executes the node flow based on a root node to generate the final shader code.
       *
       * @param {Node} node - The node to execute.
       * @return {Object} The code flow.
       */
    }, {
      key: "flowNode",
      value: function flowNode(node) {
        var output = node.getNodeType(this);
        var flowData = this.flowChildNode(node, output);
        this.flowsData.set(node, flowData);
        return flowData;
      }

      /**
       * Returns the native shader operator name for a given generic name.
       * It is a similar type of method like {@link NodeBuilder#getMethod}.
       *
       * @param {ShaderNodeInternal} shaderNode - The shader node to build the function node with.
       * @return {FunctionNode} The build function node.
       */
    }, {
      key: "buildFunctionNode",
      value: function buildFunctionNode(shaderNode) {
        var fn = new FunctionNode();
        var previous = this.currentFunctionNode;
        this.currentFunctionNode = fn;
        fn.code = this.buildFunctionCode(shaderNode);
        this.currentFunctionNode = previous;
        return fn;
      }

      /**
       * Generates a code flow based on a TSL function: Fn().
       *
       * @param {ShaderNodeInternal} shaderNode - A function code will be generated based on the input.
       * @return {Object}
       */
    }, {
      key: "flowShaderNode",
      value: function flowShaderNode(shaderNode) {
        var layout = shaderNode.layout;
        var inputs = (0, _defineProperty2.default)({}, Symbol.iterator, function () {
          var index = 0;
          var values = Object.values(this);
          return {
            next: function next() {
              return {
                value: values[index],
                done: index++ >= values.length
              };
            }
          };
        });
        for (var input of layout.inputs) {
          inputs[input.name] = new ParameterNode(input.type, input.name);
        }

        //

        shaderNode.layout = null;
        var callNode = shaderNode.call(inputs);
        var flowData = this.flowStagesNode(callNode, layout.type);
        shaderNode.layout = layout;
        return flowData;
      }

      /**
       * Runs the node flow through all the steps of creation, 'setup', 'analyze', 'generate'.
       *
       * @param {Node} node - The node to execute.
       * @param {String?} output - Expected output type. For example 'vec3'.
       * @return {Object}
       */
    }, {
      key: "flowStagesNode",
      value: function flowStagesNode(node) {
        var output = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
        var previousFlow = this.flow;
        var previousVars = this.vars;
        var previousCache = this.cache;
        var previousBuildStage = this.buildStage;
        var previousStack = this.stack;
        var flow = {
          code: ''
        };
        this.flow = flow;
        this.vars = {};
        this.cache = new NodeCache();
        this.stack = stack();
        for (var buildStage of defaultBuildStages) {
          this.setBuildStage(buildStage);
          flow.result = node.build(this, output);
        }
        flow.vars = this.getVars(this.shaderStage);
        this.flow = previousFlow;
        this.vars = previousVars;
        this.cache = previousCache;
        this.stack = previousStack;
        this.setBuildStage(previousBuildStage);
        return flow;
      }

      /**
       * Returns the native shader operator name for a given generic name.
       * It is a similar type of method like {@link NodeBuilder#getMethod}.
       *
       * @abstract
       * @param {String} op - The operator name to resolve.
       * @return {String} The resolved operator name.
       */
    }, {
      key: "getFunctionOperator",
      value: function getFunctionOperator(/* op */
      ) {
        return null;
      }

      /**
       * Generates a code flow based on a child Node.
       *
       * @param {Node} node - The node to execute.
       * @param {String?} output - Expected output type. For example 'vec3'.
       * @return {Object} The code flow.
       */
    }, {
      key: "flowChildNode",
      value: function flowChildNode(node) {
        var output = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
        var previousFlow = this.flow;
        var flow = {
          code: ''
        };
        this.flow = flow;
        flow.result = node.build(this, output);
        this.flow = previousFlow;
        return flow;
      }

      /**
       * Executes a flow of code in a different stage.
       *
       * Some nodes like `varying()` have the ability to compute code in vertex-stage and
       * return the value in fragment-stage even if it is being executed in an input fragment.
       *
       * @param {('vertex'|'fragment'|'compute'|'any')} shaderStage - The shader stage.
       * @param {Node} node - The node to execute.
       * @param {String?} output - Expected output type. For example 'vec3'.
       * @param {String?} propertyName - The property name to assign the result.
       * @return {Object}
       */
    }, {
      key: "flowNodeFromShaderStage",
      value: function flowNodeFromShaderStage(shaderStage, node) {
        var output = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
        var propertyName = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
        var previousShaderStage = this.shaderStage;
        this.setShaderStage(shaderStage);
        var flowData = this.flowChildNode(node, output);
        if (propertyName !== null) {
          flowData.code += `${this.tab + propertyName} = ${flowData.result};\n`;
        }
        this.flowCode[shaderStage] = this.flowCode[shaderStage] + flowData.code;
        this.setShaderStage(previousShaderStage);
        return flowData;
      }

      /**
       * Returns an array holding all node attributes of this node builder.
       *
       * @return {Array<NodeAttribute>} The node attributes of this builder.
       */
    }, {
      key: "getAttributesArray",
      value: function getAttributesArray() {
        return this.attributes.concat(this.bufferAttributes);
      }

      /**
       * Returns the attribute definitions as a shader string for the given shader stage.
       *
       * @abstract
       * @param {('vertex'|'fragment'|'compute'|'any')} shaderStage - The shader stage.
       * @return {String} The attribute code section.
       */
    }, {
      key: "getAttributes",
      value: function getAttributes(/*shaderStage*/
      ) {
        console.warn('Abstract function.');
      }

      /**
       * Returns the varying definitions as a shader string for the given shader stage.
       *
       * @abstract
       * @param {('vertex'|'fragment'|'compute'|'any')} shaderStage - The shader stage.
       * @return {String} The varying code section.
       */
    }, {
      key: "getVaryings",
      value: function getVaryings(/*shaderStage*/
      ) {
        console.warn('Abstract function.');
      }

      /**
       * Returns a single variable definition as a shader string for the given variable type and name.
       *
       * @param {String} type - The variable's type.
       * @param {String} name - The variable's name.
       * @return {String} The shader string.
       */
    }, {
      key: "getVar",
      value: function getVar(type, name) {
        return `${this.getType(type)} ${name}`;
      }

      /**
       * Returns the variable definitions as a shader string for the given shader stage.
       *
       * @param {('vertex'|'fragment'|'compute'|'any')} shaderStage - The shader stage.
       * @return {String} The variable code section.
       */
    }, {
      key: "getVars",
      value: function getVars(shaderStage) {
        var snippet = '';
        var vars = this.vars[shaderStage];
        if (vars !== undefined) {
          for (var variable of vars) {
            snippet += `${this.getVar(variable.type, variable.name)}; `;
          }
        }
        return snippet;
      }

      /**
       * Returns the uniform definitions as a shader string for the given shader stage.
       *
       * @abstract
       * @param {('vertex'|'fragment'|'compute'|'any')} shaderStage - The shader stage.
       * @return {String} The uniform code section.
       */
    }, {
      key: "getUniforms",
      value: function getUniforms(/*shaderStage*/
      ) {
        console.warn('Abstract function.');
      }

      /**
       * Returns the native code definitions as a shader string for the given shader stage.
       *
       * @param {('vertex'|'fragment'|'compute'|'any')} shaderStage - The shader stage.
       * @return {String} The native code section.
       */
    }, {
      key: "getCodes",
      value: function getCodes(shaderStage) {
        var codes = this.codes[shaderStage];
        var code = '';
        if (codes !== undefined) {
          for (var nodeCode of codes) {
            code += nodeCode.code + '\n';
          }
        }
        return code;
      }

      /**
       * Returns the hash of this node builder.
       *
       * @return {String} The hash.
       */
    }, {
      key: "getHash",
      value: function getHash() {
        return this.vertexShader + this.fragmentShader + this.computeShader;
      }

      /**
       * Sets the current shader stage.
       *
       * @param {('vertex'|'fragment'|'compute'|'any')?} shaderStage - The shader stage to set.
       */
    }, {
      key: "setShaderStage",
      value: function setShaderStage(shaderStage) {
        this.shaderStage = shaderStage;
      }

      /**
       * Returns the current shader stage.
       *
       * @return {('vertex'|'fragment'|'compute'|'any')?} The current shader stage.
       */
    }, {
      key: "getShaderStage",
      value: function getShaderStage() {
        return this.shaderStage;
      }

      /**
       * Sets the current build stage.
       *
       * @param {('setup'|'analyze'|'generate')?} buildStage - The build stage to set.
       */
    }, {
      key: "setBuildStage",
      value: function setBuildStage(buildStage) {
        this.buildStage = buildStage;
      }

      /**
       * Returns the current build stage.
       *
       * @return {('setup'|'analyze'|'generate')?} The current build stage.
       */
    }, {
      key: "getBuildStage",
      value: function getBuildStage() {
        return this.buildStage;
      }

      /**
       * Controls the code build of the shader stages.
       *
       * @abstract
       */
    }, {
      key: "buildCode",
      value: function buildCode() {
        console.warn('Abstract function.');
      }

      /**
       * Central build method which controls the build for the given object.
       *
       * @return {NodeBuilder} A reference to this node builder.
       */
    }, {
      key: "build",
      value: function build() {
        var object = this.object,
          material = this.material,
          renderer = this.renderer;
        if (material !== null) {
          var nodeMaterial = renderer.library.fromMaterial(material);
          if (nodeMaterial === null) {
            console.error(`NodeMaterial: Material "${material.type}" is not compatible.`);
            nodeMaterial = new NodeMaterial();
          }
          nodeMaterial.build(this);
        } else {
          this.addFlow('compute', object);
        }

        // setup() -> stage 1: create possible new nodes and returns an output reference node
        // analyze()   -> stage 2: analyze nodes to possible optimization and validation
        // generate()  -> stage 3: generate shader

        for (var buildStage of defaultBuildStages) {
          this.setBuildStage(buildStage);
          if (this.context.vertex && this.context.vertex.isNode) {
            this.flowNodeFromShaderStage('vertex', this.context.vertex);
          }
          for (var shaderStage of shaderStages) {
            this.setShaderStage(shaderStage);
            var flowNodes = this.flowNodes[shaderStage];
            for (var node of flowNodes) {
              if (buildStage === 'generate') {
                this.flowNode(node);
              } else {
                node.build(this);
              }
            }
          }
        }
        this.setBuildStage(null);
        this.setShaderStage(null);

        // stage 4: build code for a specific output

        this.buildCode();
        this.buildUpdateNodes();
        return this;
      }

      /**
       * Returns a uniform representation which is later used for UBO generation and rendering.
       *
       * @param {NodeUniform} uniformNode - The uniform node.
       * @param {String} type - The requested type.
       * @return {Uniform} The uniform.
       */
    }, {
      key: "getNodeUniform",
      value: function getNodeUniform(uniformNode, type) {
        if (type === 'float' || type === 'int' || type === 'uint') return new NumberNodeUniform(uniformNode);
        if (type === 'vec2' || type === 'ivec2' || type === 'uvec2') return new Vector2NodeUniform(uniformNode);
        if (type === 'vec3' || type === 'ivec3' || type === 'uvec3') return new Vector3NodeUniform(uniformNode);
        if (type === 'vec4' || type === 'ivec4' || type === 'uvec4') return new Vector4NodeUniform(uniformNode);
        if (type === 'color') return new ColorNodeUniform(uniformNode);
        if (type === 'mat3') return new Matrix3NodeUniform(uniformNode);
        if (type === 'mat4') return new Matrix4NodeUniform(uniformNode);
        throw new Error(`Uniform "${type}" not declared.`);
      }

      /**
       * Formats the given shader snippet from a given type into another one. E.g.
       * this method might be used to convert a simple float string `"1.0"` into a
       * `vec3` representation: `"vec3<f32>( 1.0 )"`.
       *
       * @param {String} snippet - The shader snippet.
       * @param {String} fromType - The source type.
       * @param {String} toType - The target type.
       * @return {String} The updated shader string.
       */
    }, {
      key: "format",
      value: function format(snippet, fromType, toType) {
        fromType = this.getVectorType(fromType);
        toType = this.getVectorType(toType);
        if (fromType === toType || toType === null || this.isReference(toType)) {
          return snippet;
        }
        var fromTypeLength = this.getTypeLength(fromType);
        var toTypeLength = this.getTypeLength(toType);
        if (fromTypeLength === 16 && toTypeLength === 9) {
          return `${this.getType(toType)}(${snippet}[0].xyz, ${snippet}[1].xyz, ${snippet}[2].xyz)`;
        }
        if (fromTypeLength === 9 && toTypeLength === 4) {
          return `${this.getType(toType)}(${snippet}[0].xy, ${snippet}[1].xy)`;
        }
        if (fromTypeLength > 4) {
          // fromType is matrix-like

          // @TODO: ignore for now

          return snippet;
        }
        if (toTypeLength > 4 || toTypeLength === 0) {
          // toType is matrix-like or unknown

          // @TODO: ignore for now

          return snippet;
        }
        if (fromTypeLength === toTypeLength) {
          return `${this.getType(toType)}( ${snippet} )`;
        }
        if (fromTypeLength > toTypeLength) {
          return this.format(`${snippet}.${'xyz'.slice(0, toTypeLength)}`, this.getTypeFromLength(toTypeLength, this.getComponentType(fromType)), toType);
        }
        if (toTypeLength === 4 && fromTypeLength > 1) {
          // toType is vec4-like

          return `${this.getType(toType)}( ${this.format(snippet, fromType, 'vec3')}, 1.0 )`;
        }
        if (fromTypeLength === 2) {
          // fromType is vec2-like and toType is vec3-like

          return `${this.getType(toType)}( ${this.format(snippet, fromType, 'vec2')}, 0.0 )`;
        }
        if (fromTypeLength === 1 && toTypeLength > 1 && fromType !== this.getComponentType(toType)) {
          // fromType is float-like

          // convert a number value to vector type, e.g:
          // vec3( 1u ) -> vec3( float( 1u ) )

          snippet = `${this.getType(this.getComponentType(toType))}( ${snippet} )`;
        }
        return `${this.getType(toType)}( ${snippet} )`; // fromType is float-like
      }

      /**
       * Returns a signature with the engine's current revision.
       *
       * @return {String} The signature.
       */
    }, {
      key: "getSignature",
      value: function getSignature() {
        return `// Three.js r${_$$_REQUIRE(_dependencyMap[1], "./three.core.js").REVISION} - Node System\n`;
      }

      // deprecated
    }, {
      key: "createNodeMaterial",
      value: function createNodeMaterial() {
        var type = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'NodeMaterial';
        // @deprecated, r168

        throw new Error(`THREE.NodeBuilder: createNodeMaterial() was deprecated. Use new ${type}() instead.`);
      }
    }]);
  }();
  /**
   * Management class for updating nodes. The module tracks metrics like
   * the elapsed time, delta time, the render and frame ID to correctly
   * call the node update methods {@link Node#updateBefore}, {@link Node#update}
   * and {@link Node#updateAfter} depending on the node's configuration.
   */
  var NodeFrame = exports.NodeFrame = /*#__PURE__*/function () {
    /**
     * Constructs a new node fame.
     */
    function NodeFrame() {
      (0, _classCallCheck2.default)(this, NodeFrame);
      /**
       * The elapsed time in seconds.
       *
       * @type {Number}
       * @default 0
       */
      this.time = 0;

      /**
       * The delta time in seconds.
       *
       * @type {Number}
       * @default 0
       */
      this.deltaTime = 0;

      /**
       * The frame ID.
       *
       * @type {Number}
       * @default 0
       */
      this.frameId = 0;

      /**
       * The render ID.
       *
       * @type {Number}
       * @default 0
       */
      this.renderId = 0;

      /**
       * Used to control the {@link Node#update} call.
       *
       * @type {WeakMap<Node, Object>}
       */
      this.updateMap = new WeakMap();

      /**
       * Used to control the {@link Node#updateBefore} call.
       *
       * @type {WeakMap<Node, Object>}
       */
      this.updateBeforeMap = new WeakMap();

      /**
       * Used to control the {@link Node#updateAfter} call.
       *
       * @type {WeakMap<Node, Object>}
       */
      this.updateAfterMap = new WeakMap();

      /**
       * A reference to the current renderer.
       *
       * @type {Renderer?}
       * @default null
       */
      this.renderer = null;

      /**
       * A reference to the current material.
       *
       * @type {Material?}
       * @default null
       */
      this.material = null;

      /**
       * A reference to the current camera.
       *
       * @type {Camera?}
       * @default null
       */
      this.camera = null;

      /**
       * A reference to the current 3D object.
       *
       * @type {Object3D?}
       * @default null
       */
      this.object = null;

      /**
       * A reference to the current scene.
       *
       * @type {Scene?}
       * @default null
       */
      this.scene = null;
    }

    /**
     * Returns a dictionary for a given node and update map which
     * is used to correctly call node update methods per frame or render.
     *
     * @private
     * @param {WeakMap<Node, Object>} referenceMap - The reference weak map.
     * @param {Node} nodeRef - The reference to the current node.
     * @return {Object<String,WeakMap>} The dictionary.
     */
    return (0, _createClass2.default)(NodeFrame, [{
      key: "_getMaps",
      value: function _getMaps(referenceMap, nodeRef) {
        var maps = referenceMap.get(nodeRef);
        if (maps === undefined) {
          maps = {
            renderMap: new WeakMap(),
            frameMap: new WeakMap()
          };
          referenceMap.set(nodeRef, maps);
        }
        return maps;
      }

      /**
       * This method executes the {@link Node#updateBefore} for the given node.
       * It makes sure {@link Node#updateBeforeType} is honored meaning the update
       * is only executed once per frame, render or object depending on the update
       * type.
       *
       * @param {Node} node - The node that should be updated.
       */
    }, {
      key: "updateBeforeNode",
      value: function updateBeforeNode(node) {
        var updateType = node.getUpdateBeforeType();
        var reference = node.updateReference(this);
        if (updateType === NodeUpdateType.FRAME) {
          var _this$_getMaps = this._getMaps(this.updateBeforeMap, reference),
            frameMap = _this$_getMaps.frameMap;
          if (frameMap.get(reference) !== this.frameId) {
            if (node.updateBefore(this) !== false) {
              frameMap.set(reference, this.frameId);
            }
          }
        } else if (updateType === NodeUpdateType.RENDER) {
          var _this$_getMaps2 = this._getMaps(this.updateBeforeMap, reference),
            renderMap = _this$_getMaps2.renderMap;
          if (renderMap.get(reference) !== this.renderId) {
            if (node.updateBefore(this) !== false) {
              renderMap.set(reference, this.renderId);
            }
          }
        } else if (updateType === NodeUpdateType.OBJECT) {
          node.updateBefore(this);
        }
      }

      /**
       * This method executes the {@link Node#updateAfter} for the given node.
       * It makes sure {@link Node#updateAfterType} is honored meaning the update
       * is only executed once per frame, render or object depending on the update
       * type.
       *
       * @param {Node} node - The node that should be updated.
       */
    }, {
      key: "updateAfterNode",
      value: function updateAfterNode(node) {
        var updateType = node.getUpdateAfterType();
        var reference = node.updateReference(this);
        if (updateType === NodeUpdateType.FRAME) {
          var _this$_getMaps3 = this._getMaps(this.updateAfterMap, reference),
            frameMap = _this$_getMaps3.frameMap;
          if (frameMap.get(reference) !== this.frameId) {
            if (node.updateAfter(this) !== false) {
              frameMap.set(reference, this.frameId);
            }
          }
        } else if (updateType === NodeUpdateType.RENDER) {
          var _this$_getMaps4 = this._getMaps(this.updateAfterMap, reference),
            renderMap = _this$_getMaps4.renderMap;
          if (renderMap.get(reference) !== this.renderId) {
            if (node.updateAfter(this) !== false) {
              renderMap.set(reference, this.renderId);
            }
          }
        } else if (updateType === NodeUpdateType.OBJECT) {
          node.updateAfter(this);
        }
      }

      /**
       * This method executes the {@link Node#update} for the given node.
       * It makes sure {@link Node#updateType} is honored meaning the update
       * is only executed once per frame, render or object depending on the update
       * type.
       *
       * @param {Node} node - The node that should be updated.
       */
    }, {
      key: "updateNode",
      value: function updateNode(node) {
        var updateType = node.getUpdateType();
        var reference = node.updateReference(this);
        if (updateType === NodeUpdateType.FRAME) {
          var _this$_getMaps5 = this._getMaps(this.updateMap, reference),
            frameMap = _this$_getMaps5.frameMap;
          if (frameMap.get(reference) !== this.frameId) {
            if (node.update(this) !== false) {
              frameMap.set(reference, this.frameId);
            }
          }
        } else if (updateType === NodeUpdateType.RENDER) {
          var _this$_getMaps6 = this._getMaps(this.updateMap, reference),
            renderMap = _this$_getMaps6.renderMap;
          if (renderMap.get(reference) !== this.renderId) {
            if (node.update(this) !== false) {
              renderMap.set(reference, this.renderId);
            }
          }
        } else if (updateType === NodeUpdateType.OBJECT) {
          node.update(this);
        }
      }

      /**
       * Updates the internal state of the node frame. This method is
       * called by the renderer in its internal animation loop.
       */
    }, {
      key: "update",
      value: function update() {
        this.frameId++;
        if (this.lastTime === undefined) this.lastTime = performance.now();
        this.deltaTime = (performance.now() - this.lastTime) / 1000;
        this.lastTime = performance.now();
        this.time += this.deltaTime;
      }
    }]);
  }();
  /**
   * Describes the input of a {@link NodeFunction}.
   */
  var NodeFunctionInput = exports.NodeFunctionInput = /*#__PURE__*/(0, _createClass2.default)(
  /**
   * Constructs a new node function input.
   *
   * @param {String} type - The input type.
   * @param {String} name - The input name.
   * @param {Number?} [count=null] - If the input is an Array, count will be the length.
   * @param {('in'|'out'|'inout')} [qualifier=''] - The parameter qualifier (only relevant for GLSL).
   * @param {Boolean} [isConst=false] - Whether the input uses a const qualifier or not (only relevant for GLSL).
   */
  function NodeFunctionInput(type, name) {
    var count = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
    var qualifier = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : '';
    var isConst = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
    (0, _classCallCheck2.default)(this, NodeFunctionInput);
    /**
     *  The input type.
     *
     * @type {String}
     */
    this.type = type;

    /**
     * The input name.
     *
     * @type {String}
     */
    this.name = name;

    /**
     * If the input is an Array, count will be the length.
     *
     * @type {Number?}
     * @default null
     */
    this.count = count;

    /**
     *The parameter qualifier (only relevant for GLSL).
     *
     * @type {('in'|'out'|'inout')}
     * @default ''
     */
    this.qualifier = qualifier;

    /**
     * Whether the input uses a const qualifier or not (only relevant for GLSL).
     *
     * @type {Boolean}
     * @default false
     */
    this.isConst = isConst;
  });
  NodeFunctionInput.isNodeFunctionInput = true;

  /**
   * Module for representing directional lights as nodes.
   *
   * @augments AnalyticLightNode
   */
  var DirectionalLightNode = exports.DirectionalLightNode = /*#__PURE__*/function (_AnalyticLightNode2) {
    /**
     * Constructs a new directional light node.
     *
     * @param {DirectionalLight?} [light=null] - The directional light source.
     */
    function DirectionalLightNode() {
      var light = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      (0, _classCallCheck2.default)(this, DirectionalLightNode);
      return _callSuper(this, DirectionalLightNode, [light]);
    }
    (0, _inherits2.default)(DirectionalLightNode, _AnalyticLightNode2);
    return (0, _createClass2.default)(DirectionalLightNode, [{
      key: "setup",
      value: function setup(builder) {
        _superPropGet(DirectionalLightNode, "setup", this, 3)([builder]);
        var lightingModel = builder.context.lightingModel;
        var lightColor = this.colorNode;
        var lightDirection = lightTargetDirection(this.light);
        var reflectedLight = builder.context.reflectedLight;
        lightingModel.direct({
          lightDirection: lightDirection,
          lightColor: lightColor,
          reflectedLight: reflectedLight
        }, builder.stack, builder);
      }
    }], [{
      key: "type",
      get: function get() {
        return 'DirectionalLightNode';
      }
    }]);
  }(AnalyticLightNode);
  var _matrix41 = /*@__PURE__*/new (_$$_REQUIRE(_dependencyMap[1], "./three.core.js").Matrix4)();
  var _matrix42 = /*@__PURE__*/new (_$$_REQUIRE(_dependencyMap[1], "./three.core.js").Matrix4)();
  var _ltcLib = null;

  /**
   * Module for representing rect area lights as nodes.
   *
   * @augments AnalyticLightNode
   */
  var RectAreaLightNode = exports.RectAreaLightNode = /*#__PURE__*/function (_AnalyticLightNode3) {
    /**
     * Constructs a new rect area light node.
     *
     * @param {RectAreaLight?} [light=null] - The rect area light source.
     */
    function RectAreaLightNode() {
      var _this185;
      var light = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      (0, _classCallCheck2.default)(this, RectAreaLightNode);
      _this185 = _callSuper(this, RectAreaLightNode, [light]);

      /**
       * Uniform node representing the half height of the are light.
       *
       * @type {UniformNode<vec3>}
       */
      _this185.halfHeight = uniform(new (_$$_REQUIRE(_dependencyMap[1], "./three.core.js").Vector3)()).setGroup(renderGroup);

      /**
       * Uniform node representing the half width of the are light.
       *
       * @type {UniformNode<vec3>}
       */
      _this185.halfWidth = uniform(new (_$$_REQUIRE(_dependencyMap[1], "./three.core.js").Vector3)()).setGroup(renderGroup);

      /**
       * The `updateType` is set to `NodeUpdateType.RENDER` since the light
       * relies on `viewMatrix` which might vary per render call.
       *
       * @type {String}
       * @default 'render'
       */
      _this185.updateType = NodeUpdateType.RENDER;
      return _this185;
    }

    /**
     * Overwritten to updated rect area light specific uniforms.
     *
     * @param {NodeFrame} frame - A reference to the current node frame.
     */
    (0, _inherits2.default)(RectAreaLightNode, _AnalyticLightNode3);
    return (0, _createClass2.default)(RectAreaLightNode, [{
      key: "update",
      value: function update(frame) {
        _superPropGet(RectAreaLightNode, "update", this, 3)([frame]);
        var light = this.light;
        var viewMatrix = frame.camera.matrixWorldInverse;
        _matrix42.identity();
        _matrix41.copy(light.matrixWorld);
        _matrix41.premultiply(viewMatrix);
        _matrix42.extractRotation(_matrix41);
        this.halfWidth.value.set(light.width * 0.5, 0.0, 0.0);
        this.halfHeight.value.set(0.0, light.height * 0.5, 0.0);
        this.halfWidth.value.applyMatrix4(_matrix42);
        this.halfHeight.value.applyMatrix4(_matrix42);
      }
    }, {
      key: "setup",
      value: function setup(builder) {
        _superPropGet(RectAreaLightNode, "setup", this, 3)([builder]);
        var ltc_1, ltc_2;
        if (builder.isAvailable('float32Filterable')) {
          ltc_1 = texture(_ltcLib.LTC_FLOAT_1);
          ltc_2 = texture(_ltcLib.LTC_FLOAT_2);
        } else {
          ltc_1 = texture(_ltcLib.LTC_HALF_1);
          ltc_2 = texture(_ltcLib.LTC_HALF_2);
        }
        var colorNode = this.colorNode,
          light = this.light;
        var lightingModel = builder.context.lightingModel;
        var lightPosition = lightViewPosition(light);
        var reflectedLight = builder.context.reflectedLight;
        lightingModel.directRectArea({
          lightColor: colorNode,
          lightPosition: lightPosition,
          halfWidth: this.halfWidth,
          halfHeight: this.halfHeight,
          reflectedLight: reflectedLight,
          ltc_1: ltc_1,
          ltc_2: ltc_2
        }, builder.stack, builder);
      }

      /**
       * Used to configure the internal BRDF approximation texture data.
       *
       * @param {RectAreaLightTexturesLib} ltc - The BRDF approximation texture data.
       */
    }], [{
      key: "type",
      get: function get() {
        return 'RectAreaLightNode';
      }
    }, {
      key: "setLTC",
      value: function setLTC(ltc) {
        _ltcLib = ltc;
      }
    }]);
  }(AnalyticLightNode);
  /**
   * Module for representing spot lights as nodes.
   *
   * @augments AnalyticLightNode
   */
  var SpotLightNode = exports.SpotLightNode = /*#__PURE__*/function (_AnalyticLightNode4) {
    /**
     * Constructs a new spot light node.
     *
     * @param {SpotLight?} [light=null] - The spot light source.
     */
    function SpotLightNode() {
      var _this186;
      var light = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      (0, _classCallCheck2.default)(this, SpotLightNode);
      _this186 = _callSuper(this, SpotLightNode, [light]);

      /**
       * Uniform node representing the cone cosine.
       *
       * @type {UniformNode<float>}
       */
      _this186.coneCosNode = uniform(0).setGroup(renderGroup);

      /**
       * Uniform node representing the penumbra cosine.
       *
       * @type {UniformNode<float>}
       */
      _this186.penumbraCosNode = uniform(0).setGroup(renderGroup);

      /**
       * Uniform node representing the cutoff distance.
       *
       * @type {UniformNode<float>}
       */
      _this186.cutoffDistanceNode = uniform(0).setGroup(renderGroup);

      /**
       * Uniform node representing the decay exponent.
       *
       * @type {UniformNode<float>}
       */
      _this186.decayExponentNode = uniform(0).setGroup(renderGroup);
      return _this186;
    }

    /**
     * Overwritten to updated spot light specific uniforms.
     *
     * @param {NodeFrame} frame - A reference to the current node frame.
     */
    (0, _inherits2.default)(SpotLightNode, _AnalyticLightNode4);
    return (0, _createClass2.default)(SpotLightNode, [{
      key: "update",
      value: function update(frame) {
        _superPropGet(SpotLightNode, "update", this, 3)([frame]);
        var light = this.light;
        this.coneCosNode.value = Math.cos(light.angle);
        this.penumbraCosNode.value = Math.cos(light.angle * (1 - light.penumbra));
        this.cutoffDistanceNode.value = light.distance;
        this.decayExponentNode.value = light.decay;
      }

      /**
       * Computes the spot attenuation for the given angle.
       *
       * @param {Node<float>} angleCosine - The angle to compute the spot attenuation for.
       * @return {Node<float>} The spot attenuation.
       */
    }, {
      key: "getSpotAttenuation",
      value: function getSpotAttenuation(angleCosine) {
        var coneCosNode = this.coneCosNode,
          penumbraCosNode = this.penumbraCosNode;
        return smoothstep(coneCosNode, penumbraCosNode, angleCosine);
      }
    }, {
      key: "setup",
      value: function setup(builder) {
        _superPropGet(SpotLightNode, "setup", this, 3)([builder]);
        var lightingModel = builder.context.lightingModel;
        var colorNode = this.colorNode,
          cutoffDistanceNode = this.cutoffDistanceNode,
          decayExponentNode = this.decayExponentNode,
          light = this.light;
        var lVector = lightViewPosition(light).sub(positionView); // @TODO: Add it into LightNode

        var lightDirection = lVector.normalize();
        var angleCos = lightDirection.dot(lightTargetDirection(light));
        var spotAttenuation = this.getSpotAttenuation(angleCos);
        var lightDistance = lVector.length();
        var lightAttenuation = getDistanceAttenuation({
          lightDistance: lightDistance,
          cutoffDistance: cutoffDistanceNode,
          decayExponent: decayExponentNode
        });
        var lightColor = colorNode.mul(spotAttenuation).mul(lightAttenuation);
        if (light.map) {
          var spotLightCoord = lightProjectionUV(light);
          var projectedTexture = texture(light.map, spotLightCoord.xy).onRenderUpdate(function () {
            return light.map;
          });
          var inSpotLightMap = spotLightCoord.mul(2.).sub(1.).abs().lessThan(1.).all();
          lightColor = inSpotLightMap.select(lightColor.mul(projectedTexture), lightColor);
        }
        var reflectedLight = builder.context.reflectedLight;
        lightingModel.direct({
          lightDirection: lightDirection,
          lightColor: lightColor,
          reflectedLight: reflectedLight
        }, builder.stack, builder);
      }
    }], [{
      key: "type",
      get: function get() {
        return 'SpotLightNode';
      }
    }]);
  }(AnalyticLightNode);
  /**
   * An IES version of the default spot light node.
   *
   * @augments SpotLightNode
   */
  var IESSpotLightNode = exports.IESSpotLightNode = /*#__PURE__*/function (_SpotLightNode) {
    function IESSpotLightNode() {
      (0, _classCallCheck2.default)(this, IESSpotLightNode);
      return _callSuper(this, IESSpotLightNode, arguments);
    }
    (0, _inherits2.default)(IESSpotLightNode, _SpotLightNode);
    return (0, _createClass2.default)(IESSpotLightNode, [{
      key: "getSpotAttenuation",
      value:
      /**
       * Overwrites the default implementation to compute an IES conform spot attenuation.
       *
       * @param {Node<float>} angleCosine - The angle to compute the spot attenuation for.
       * @return {Node<float>} The spot attenuation.
       */
      function getSpotAttenuation(angleCosine) {
        var iesMap = this.light.iesMap;
        var spotAttenuation = null;
        if (iesMap && iesMap.isTexture === true) {
          var angle = angleCosine.acos().mul(1.0 / Math.PI);
          spotAttenuation = texture(iesMap, vec2(angle, 0), 0).r;
        } else {
          spotAttenuation = _superPropGet(IESSpotLightNode, "getSpotAttenuation", this, 3)([angleCosine]);
        }
        return spotAttenuation;
      }
    }], [{
      key: "type",
      get: function get() {
        return 'IESSpotLightNode';
      }
    }]);
  }(SpotLightNode);
  /**
   * Module for representing ambient lights as nodes.
   *
   * @augments AnalyticLightNode
   */
  var AmbientLightNode = exports.AmbientLightNode = /*#__PURE__*/function (_AnalyticLightNode5) {
    /**
     * Constructs a new ambient light node.
     *
     * @param {AmbientLight?} [light=null] - The ambient light source.
     */
    function AmbientLightNode() {
      var light = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      (0, _classCallCheck2.default)(this, AmbientLightNode);
      return _callSuper(this, AmbientLightNode, [light]);
    }
    (0, _inherits2.default)(AmbientLightNode, _AnalyticLightNode5);
    return (0, _createClass2.default)(AmbientLightNode, [{
      key: "setup",
      value: function setup(_ref336) {
        var context = _ref336.context;
        context.irradiance.addAssign(this.colorNode);
      }
    }], [{
      key: "type",
      get: function get() {
        return 'AmbientLightNode';
      }
    }]);
  }(AnalyticLightNode);
  /**
   * Module for representing hemisphere lights as nodes.
   *
   * @augments AnalyticLightNode
   */
  var HemisphereLightNode = exports.HemisphereLightNode = /*#__PURE__*/function (_AnalyticLightNode6) {
    /**
     * Constructs a new hemisphere light node.
     *
     * @param {HemisphereLight?} [light=null] - The hemisphere light source.
     */
    function HemisphereLightNode() {
      var _this187;
      var light = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      (0, _classCallCheck2.default)(this, HemisphereLightNode);
      _this187 = _callSuper(this, HemisphereLightNode, [light]);

      /**
       * Uniform node representing the light's position.
       *
       * @type {UniformNode<vec3>}
       */
      _this187.lightPositionNode = lightPosition(light);

      /**
       * A node representing the light's direction.
       *
       * @type {Node<vec3>}
       */
      _this187.lightDirectionNode = _this187.lightPositionNode.normalize();

      /**
       * Uniform node representing the light's ground color.
       *
       * @type {UniformNode<vec3>}
       */
      _this187.groundColorNode = uniform(new (_$$_REQUIRE(_dependencyMap[1], "./three.core.js").Color)()).setGroup(renderGroup);
      return _this187;
    }

    /**
     * Overwritten to updated hemisphere light specific uniforms.
     *
     * @param {NodeFrame} frame - A reference to the current node frame.
     */
    (0, _inherits2.default)(HemisphereLightNode, _AnalyticLightNode6);
    return (0, _createClass2.default)(HemisphereLightNode, [{
      key: "update",
      value: function update(frame) {
        var light = this.light;
        _superPropGet(HemisphereLightNode, "update", this, 3)([frame]);
        this.lightPositionNode.object3d = light;
        this.groundColorNode.value.copy(light.groundColor).multiplyScalar(light.intensity);
      }
    }, {
      key: "setup",
      value: function setup(builder) {
        var colorNode = this.colorNode,
          groundColorNode = this.groundColorNode,
          lightDirectionNode = this.lightDirectionNode;
        var dotNL = normalView.dot(lightDirectionNode);
        var hemiDiffuseWeight = dotNL.mul(0.5).add(0.5);
        var irradiance = mix(groundColorNode, colorNode, hemiDiffuseWeight);
        builder.context.irradiance.addAssign(irradiance);
      }
    }], [{
      key: "type",
      get: function get() {
        return 'HemisphereLightNode';
      }
    }]);
  }(AnalyticLightNode);
  /**
   * Module for representing light probes as nodes.
   *
   * @augments AnalyticLightNode
   */
  var LightProbeNode = exports.LightProbeNode = /*#__PURE__*/function (_AnalyticLightNode7) {
    /**
     * Constructs a new light probe node.
     *
     * @param {LightProbe?} [light=null] - The light probe.
     */
    function LightProbeNode() {
      var _this188;
      var light = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      (0, _classCallCheck2.default)(this, LightProbeNode);
      _this188 = _callSuper(this, LightProbeNode, [light]);
      var array = [];
      for (var i = 0; i < 9; i++) array.push(new (_$$_REQUIRE(_dependencyMap[1], "./three.core.js").Vector3)());

      /**
       * Light probe represented as a uniform of spherical harmonics.
       *
       * @type {UniformArrayNode}
       */
      _this188.lightProbe = uniformArray(array);
      return _this188;
    }

    /**
     * Overwritten to updated light probe specific uniforms.
     *
     * @param {NodeFrame} frame - A reference to the current node frame.
     */
    (0, _inherits2.default)(LightProbeNode, _AnalyticLightNode7);
    return (0, _createClass2.default)(LightProbeNode, [{
      key: "update",
      value: function update(frame) {
        var light = this.light;
        _superPropGet(LightProbeNode, "update", this, 3)([frame]);

        //

        for (var i = 0; i < 9; i++) {
          this.lightProbe.array[i].copy(light.sh.coefficients[i]).multiplyScalar(light.intensity);
        }
      }
    }, {
      key: "setup",
      value: function setup(builder) {
        var irradiance = getShIrradianceAt(normalWorld, this.lightProbe);
        builder.context.irradiance.addAssign(irradiance);
      }
    }], [{
      key: "type",
      get: function get() {
        return 'LightProbeNode';
      }
    }]);
  }(AnalyticLightNode);
  /**
   * Base class for node parsers. A derived parser must be implemented
   * for each supported native shader language.
   */
  var NodeParser = /*#__PURE__*/function () {
    function NodeParser() {
      (0, _classCallCheck2.default)(this, NodeParser);
    }
    return (0, _createClass2.default)(NodeParser, [{
      key: "parseFunction",
      value:
      /**
       * The method parses the given native code an returns a node function.
       *
       * @abstract
       * @param {String} source - The native shader code.
       * @return {NodeFunction} A node function.
       */
      function parseFunction(/*source*/
      ) {
        console.warn('Abstract function.');
      }
    }]);
  }();
  /**
   * Base class for node functions. A derived module must be implemented
   * for each supported native shader language. Similar to other `Node*` modules,
   * this class is only relevant during the building process and not used
   * in user-level code.
   */
  var NodeFunction = /*#__PURE__*/function () {
    /**
     * Constructs a new node function.
     *
     * @param {String} type - The node type. This type is the return type of the node function.
     * @param {Array<NodeFunctionInput>} inputs - The function's inputs.
     * @param {String} [name=''] - The function's name.
     * @param {String} [precision=''] - The precision qualifier.
     */
    function NodeFunction(type, inputs) {
      var name = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';
      var precision = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : '';
      (0, _classCallCheck2.default)(this, NodeFunction);
      /**
       * The node type. This type is the return type of the node function.
       *
       * @type {String}
       */
      this.type = type;

      /**
       * The function's inputs.
       *
       * @type {Array<NodeFunctionInput>}
       */
      this.inputs = inputs;

      /**
       * The name of the uniform.
       *
       * @type {String}
       * @default ''
       */
      this.name = name;

      /**
       * The precision qualifier.
       *
       * @type {String}
       * @default ''
       */
      this.precision = precision;
    }

    /**
     * This method returns the native code of the node function.
     *
     * @abstract
     * @param {String} name - The function's name.
     * @return {String} A shader code.
     */
    return (0, _createClass2.default)(NodeFunction, [{
      key: "getCode",
      value: function getCode(/*name = this.name*/
      ) {
        console.warn('Abstract function.');
      }
    }]);
  }();
  NodeFunction.isNodeFunction = true;
  var declarationRegexp$1 = /^\s*(highp|mediump|lowp)?\s*([a-z_0-9]+)\s*([a-z_0-9]+)?\s*\(([\s\S]*?)\)/i;
  var propertiesRegexp$1 = /[a-z_0-9]+/ig;
  var pragmaMain = '#pragma main';
  var parse$1 = function parse$1(source) {
    source = source.trim();
    var pragmaMainIndex = source.indexOf(pragmaMain);
    var mainCode = pragmaMainIndex !== -1 ? source.slice(pragmaMainIndex + pragmaMain.length) : source;
    var declaration = mainCode.match(declarationRegexp$1);
    if (declaration !== null && declaration.length === 5) {
      // tokenizer

      var inputsCode = declaration[4];
      var propsMatches = [];
      var nameMatch = null;
      while ((nameMatch = propertiesRegexp$1.exec(inputsCode)) !== null) {
        propsMatches.push(nameMatch);
      }

      // parser

      var inputs = [];
      var i = 0;
      while (i < propsMatches.length) {
        var isConst = propsMatches[i][0] === 'const';
        if (isConst === true) {
          i++;
        }
        var qualifier = propsMatches[i][0];
        if (qualifier === 'in' || qualifier === 'out' || qualifier === 'inout') {
          i++;
        } else {
          qualifier = '';
        }
        var _type = propsMatches[i++][0];
        var count = Number.parseInt(propsMatches[i][0]);
        if (Number.isNaN(count) === false) i++;else count = null;
        var _name = propsMatches[i++][0];
        inputs.push(new NodeFunctionInput(_type, _name, count, qualifier, isConst));
      }

      //

      var blockCode = mainCode.substring(declaration[0].length);
      var name = declaration[3] !== undefined ? declaration[3] : '';
      var type = declaration[2];
      var precision = declaration[1] !== undefined ? declaration[1] : '';
      var headerCode = pragmaMainIndex !== -1 ? source.slice(0, pragmaMainIndex) : '';
      return {
        type: type,
        inputs: inputs,
        name: name,
        precision: precision,
        inputsCode: inputsCode,
        blockCode: blockCode,
        headerCode: headerCode
      };
    } else {
      throw new Error('FunctionNode: Function is not a GLSL code.');
    }
  };

  /**
   * This class represents a GLSL node function.
   *
   * @augments NodeFunction
   */
  var GLSLNodeFunction = /*#__PURE__*/function (_NodeFunction) {
    /**
     * Constructs a new GLSL node function.
     *
     * @param {String} source - The GLSL source.
     */
    function GLSLNodeFunction(source) {
      var _this189;
      (0, _classCallCheck2.default)(this, GLSLNodeFunction);
      var _parse$ = parse$1(source),
        type = _parse$.type,
        inputs = _parse$.inputs,
        name = _parse$.name,
        precision = _parse$.precision,
        inputsCode = _parse$.inputsCode,
        blockCode = _parse$.blockCode,
        headerCode = _parse$.headerCode;
      _this189 = _callSuper(this, GLSLNodeFunction, [type, inputs, name, precision]);
      _this189.inputsCode = inputsCode;
      _this189.blockCode = blockCode;
      _this189.headerCode = headerCode;
      return _this189;
    }

    /**
     * This method returns the GLSL code of the node function.
     *
     * @param {String} [name=this.name] - The function's name.
     * @return {String} The shader code.
     */
    (0, _inherits2.default)(GLSLNodeFunction, _NodeFunction);
    return (0, _createClass2.default)(GLSLNodeFunction, [{
      key: "getCode",
      value: function getCode() {
        var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.name;
        var code;
        var blockCode = this.blockCode;
        if (blockCode !== '') {
          var type = this.type,
            inputsCode = this.inputsCode,
            headerCode = this.headerCode,
            precision = this.precision;
          var declarationCode = `${type} ${name} ( ${inputsCode.trim()} )`;
          if (precision !== '') {
            declarationCode = `${precision} ${declarationCode}`;
          }
          code = headerCode + declarationCode + blockCode;
        } else {
          // interface function

          code = '';
        }
        return code;
      }
    }]);
  }(NodeFunction);
  /**
   * A GLSL node parser.
   *
   * @augments NodeParser
   */
  var GLSLNodeParser = exports.GLSLNodeParser = /*#__PURE__*/function (_NodeParser) {
    function GLSLNodeParser() {
      (0, _classCallCheck2.default)(this, GLSLNodeParser);
      return _callSuper(this, GLSLNodeParser, arguments);
    }
    (0, _inherits2.default)(GLSLNodeParser, _NodeParser);
    return (0, _createClass2.default)(GLSLNodeParser, [{
      key: "parseFunction",
      value:
      /**
       * The method parses the given GLSL code an returns a node function.
       *
       * @param {String} source - The GLSL code.
       * @return {GLSLNodeFunction} A node function.
       */
      function parseFunction(source) {
        return new GLSLNodeFunction(source);
      }
    }]);
  }(NodeParser);
  var _outputNodeMap = new WeakMap();

  /**
   * This renderer module manages node-related objects and is the
   * primary interface between the renderer and the node system.
   *
   * @private
   * @augments DataMap
   */
  var Nodes = /*#__PURE__*/function (_DataMap7) {
    /**
     * Constructs a new nodes management component.
     *
     * @param {Renderer} renderer - The renderer.
     * @param {Backend} backend - The renderer's backend.
     */
    function Nodes(renderer, backend) {
      var _this190;
      (0, _classCallCheck2.default)(this, Nodes);
      _this190 = _callSuper(this, Nodes);

      /**
       * The renderer.
       *
       * @type {Renderer}
       */
      _this190.renderer = renderer;

      /**
       * The renderer's backend.
       *
       * @type {Backend}
       */
      _this190.backend = backend;

      /**
       * The node frame.
       *
       * @type {Renderer}
       */
      _this190.nodeFrame = new NodeFrame();

      /**
       * A cache for managing node builder states.
       *
       * @type {Map<Number,NodeBuilderState>}
       */
      _this190.nodeBuilderCache = new Map();

      /**
       * A cache for managing data cache key data.
       *
       * @type {ChainMap}
       */
      _this190.callHashCache = new ChainMap();

      /**
       * A cache for managing node uniforms group data.
       *
       * @type {ChainMap}
       */
      _this190.groupsData = new ChainMap();

      /**
       * A cache for managing node objects of
       * scene properties like fog or environments.
       *
       * @type {Object<String,WeakMap>}
       */
      _this190.cacheLib = {};
      return _this190;
    }

    /**
     * Returns `true` if the given node uniforms group must be updated or not.
     *
     * @param {NodeUniformsGroup} nodeUniformsGroup - The node uniforms group.
     * @return {Boolean} Whether the node uniforms group requires an update or not.
     */
    (0, _inherits2.default)(Nodes, _DataMap7);
    return (0, _createClass2.default)(Nodes, [{
      key: "updateGroup",
      value: function updateGroup(nodeUniformsGroup) {
        var groupNode = nodeUniformsGroup.groupNode;
        var name = groupNode.name;

        // objectGroup is always updated

        if (name === objectGroup.name) return true;

        // renderGroup is updated once per render/compute call

        if (name === renderGroup.name) {
          var uniformsGroupData = this.get(nodeUniformsGroup);
          var renderId = this.nodeFrame.renderId;
          if (uniformsGroupData.renderId !== renderId) {
            uniformsGroupData.renderId = renderId;
            return true;
          }
          return false;
        }

        // frameGroup is updated once per frame

        if (name === frameGroup.name) {
          var _uniformsGroupData = this.get(nodeUniformsGroup);
          var _frameId2 = this.nodeFrame.frameId;
          if (_uniformsGroupData.frameId !== _frameId2) {
            _uniformsGroupData.frameId = _frameId2;
            return true;
          }
          return false;
        }

        // other groups are updated just when groupNode.needsUpdate is true

        var groupChain = [groupNode, nodeUniformsGroup];
        var groupData = this.groupsData.get(groupChain);
        if (groupData === undefined) this.groupsData.set(groupChain, groupData = {});
        if (groupData.version !== groupNode.version) {
          groupData.version = groupNode.version;
          return true;
        }
        return false;
      }

      /**
       * Returns the cache key for the given render object.
       *
       * @param {RenderObject} renderObject - The render object.
       * @return {Number} The cache key.
       */
    }, {
      key: "getForRenderCacheKey",
      value: function getForRenderCacheKey(renderObject) {
        return renderObject.initialCacheKey;
      }

      /**
       * Returns a node builder state for the given render object.
       *
       * @param {RenderObject} renderObject - The render object.
       * @return {NodeBuilderState} The node builder state.
       */
    }, {
      key: "getForRender",
      value: function getForRender(renderObject) {
        var renderObjectData = this.get(renderObject);
        var nodeBuilderState = renderObjectData.nodeBuilderState;
        if (nodeBuilderState === undefined) {
          var nodeBuilderCache = this.nodeBuilderCache;
          var cacheKey = this.getForRenderCacheKey(renderObject);
          nodeBuilderState = nodeBuilderCache.get(cacheKey);
          if (nodeBuilderState === undefined) {
            var nodeBuilder = this.backend.createNodeBuilder(renderObject.object, this.renderer);
            nodeBuilder.scene = renderObject.scene;
            nodeBuilder.material = renderObject.material;
            nodeBuilder.camera = renderObject.camera;
            nodeBuilder.context.material = renderObject.material;
            nodeBuilder.lightsNode = renderObject.lightsNode;
            nodeBuilder.environmentNode = this.getEnvironmentNode(renderObject.scene);
            nodeBuilder.fogNode = this.getFogNode(renderObject.scene);
            nodeBuilder.clippingContext = renderObject.clippingContext;
            nodeBuilder.build();
            nodeBuilderState = this._createNodeBuilderState(nodeBuilder);
            nodeBuilderCache.set(cacheKey, nodeBuilderState);
          }
          nodeBuilderState.usedTimes++;
          renderObjectData.nodeBuilderState = nodeBuilderState;
        }
        return nodeBuilderState;
      }

      /**
       * Deletes the given object from the internal data map
       *
       * @param {Any} object - The object to delete.
       * @return {Object?} The deleted dictionary.
       */
    }, {
      key: "delete",
      value: function _delete(object) {
        if (object.isRenderObject) {
          var nodeBuilderState = this.get(object).nodeBuilderState;
          nodeBuilderState.usedTimes--;
          if (nodeBuilderState.usedTimes === 0) {
            this.nodeBuilderCache.delete(this.getForRenderCacheKey(object));
          }
        }
        return _superPropGet(Nodes, "delete", this, 3)([object]);
      }

      /**
       * Returns a node builder state for the given compute node.
       *
       * @param {Node} computeNode - The compute node.
       * @return {NodeBuilderState} The node builder state.
       */
    }, {
      key: "getForCompute",
      value: function getForCompute(computeNode) {
        var computeData = this.get(computeNode);
        var nodeBuilderState = computeData.nodeBuilderState;
        if (nodeBuilderState === undefined) {
          var nodeBuilder = this.backend.createNodeBuilder(computeNode, this.renderer);
          nodeBuilder.build();
          nodeBuilderState = this._createNodeBuilderState(nodeBuilder);
          computeData.nodeBuilderState = nodeBuilderState;
        }
        return nodeBuilderState;
      }

      /**
       * Creates a node builder state for the given node builder.
       *
       * @private
       * @param {NodeBuilder} nodeBuilder - The node builder.
       * @return {NodeBuilderState} The node builder state.
       */
    }, {
      key: "_createNodeBuilderState",
      value: function _createNodeBuilderState(nodeBuilder) {
        return new NodeBuilderState(nodeBuilder.vertexShader, nodeBuilder.fragmentShader, nodeBuilder.computeShader, nodeBuilder.getAttributesArray(), nodeBuilder.getBindings(), nodeBuilder.updateNodes, nodeBuilder.updateBeforeNodes, nodeBuilder.updateAfterNodes, nodeBuilder.monitor, nodeBuilder.transforms);
      }

      /**
       * Returns an environment node for the current configured
       * scene environment.
       *
       * @param {Scene} scene - The scene.
       * @return {Node} A node representing the current scene environment.
       */
    }, {
      key: "getEnvironmentNode",
      value: function getEnvironmentNode(scene) {
        this.updateEnvironment(scene);
        var environmentNode = null;
        if (scene.environmentNode && scene.environmentNode.isNode) {
          environmentNode = scene.environmentNode;
        } else {
          var sceneData = this.get(scene);
          if (sceneData.environmentNode) {
            environmentNode = sceneData.environmentNode;
          }
        }
        return environmentNode;
      }

      /**
       * Returns a background node for the current configured
       * scene background.
       *
       * @param {Scene} scene - The scene.
       * @return {Node} A node representing the current scene background.
       */
    }, {
      key: "getBackgroundNode",
      value: function getBackgroundNode(scene) {
        this.updateBackground(scene);
        var backgroundNode = null;
        if (scene.backgroundNode && scene.backgroundNode.isNode) {
          backgroundNode = scene.backgroundNode;
        } else {
          var sceneData = this.get(scene);
          if (sceneData.backgroundNode) {
            backgroundNode = sceneData.backgroundNode;
          }
        }
        return backgroundNode;
      }

      /**
       * Returns a fog node for the current configured scene fog.
       *
       * @param {Scene} scene - The scene.
       * @return {Node} A node representing the current scene fog.
       */
    }, {
      key: "getFogNode",
      value: function getFogNode(scene) {
        this.updateFog(scene);
        return scene.fogNode || this.get(scene).fogNode || null;
      }

      /**
       * Returns a cache key for the given scene and lights node.
       * This key is used by `RenderObject` as a part of the dynamic
       * cache key (a key that must be checked every time the render
       * objects is drawn).
       *
       * @param {Scene} scene - The scene.
       * @param {LightsNode} lightsNode - The lights node.
       * @return {Number} The cache key.
       */
    }, {
      key: "getCacheKey",
      value: function getCacheKey(scene, lightsNode) {
        var chain = [scene, lightsNode];
        var callId = this.renderer.info.calls;
        var cacheKeyData = this.callHashCache.get(chain);
        if (cacheKeyData === undefined || cacheKeyData.callId !== callId) {
          var environmentNode = this.getEnvironmentNode(scene);
          var fogNode = this.getFogNode(scene);
          var values = [];
          if (lightsNode) values.push(lightsNode.getCacheKey(true));
          if (environmentNode) values.push(environmentNode.getCacheKey());
          if (fogNode) values.push(fogNode.getCacheKey());
          values.push(this.renderer.shadowMap.enabled ? 1 : 0);
          cacheKeyData = {
            callId: callId,
            cacheKey: hashArray(values)
          };
          this.callHashCache.set(chain, cacheKeyData);
        }
        return cacheKeyData.cacheKey;
      }

      /**
       * A boolean that indicates whether tone mapping should be enabled
       * or not.
       *
       * @type {Boolean}
       */
    }, {
      key: "isToneMappingState",
      get: function get() {
        return this.renderer.getRenderTarget() ? false : true;
      }

      /**
       * If a scene background is configured, this method makes sure to
       * represent the background with a corresponding node-based implementation.
       *
       * @param {Scene} scene - The scene.
       */
    }, {
      key: "updateBackground",
      value: function updateBackground(scene) {
        var sceneData = this.get(scene);
        var background = scene.background;
        if (background) {
          var forceUpdate = scene.backgroundBlurriness === 0 && sceneData.backgroundBlurriness > 0 || scene.backgroundBlurriness > 0 && sceneData.backgroundBlurriness === 0;
          if (sceneData.background !== background || forceUpdate) {
            var backgroundNode = this.getCacheNode('background', background, function () {
              if (background.isCubeTexture === true || background.mapping === _$$_REQUIRE(_dependencyMap[1], "./three.core.js").EquirectangularReflectionMapping || background.mapping === _$$_REQUIRE(_dependencyMap[1], "./three.core.js").EquirectangularRefractionMapping || background.mapping === _$$_REQUIRE(_dependencyMap[1], "./three.core.js").CubeUVReflectionMapping) {
                if (scene.backgroundBlurriness > 0 || background.mapping === _$$_REQUIRE(_dependencyMap[1], "./three.core.js").CubeUVReflectionMapping) {
                  return pmremTexture(background);
                } else {
                  var envMap;
                  if (background.isCubeTexture === true) {
                    envMap = cubeTexture(background);
                  } else {
                    envMap = texture(background);
                  }
                  return cubeMapNode(envMap);
                }
              } else if (background.isTexture === true) {
                return texture(background, screenUV.flipY()).setUpdateMatrix(true);
              } else if (background.isColor !== true) {
                console.error('WebGPUNodes: Unsupported background configuration.', background);
              }
            }, forceUpdate);
            sceneData.backgroundNode = backgroundNode;
            sceneData.background = background;
            sceneData.backgroundBlurriness = scene.backgroundBlurriness;
          }
        } else if (sceneData.backgroundNode) {
          delete sceneData.backgroundNode;
          delete sceneData.background;
        }
      }

      /**
       * This method is part of the caching of nodes which are used to represents the
       * scene's background, fog or environment.
       *
       * @param {String} type - The type of object to cache.
       * @param {Object} object - The object.
       * @param {Function} callback - A callback that produces a node representation for the given object.
       * @param {Boolean} [forceUpdate=false] - Whether an update should be enforced or not.
       * @return {Node} The node representation.
       */
    }, {
      key: "getCacheNode",
      value: function getCacheNode(type, object, callback) {
        var forceUpdate = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
        var nodeCache = this.cacheLib[type] || (this.cacheLib[type] = new WeakMap());
        var node = nodeCache.get(object);
        if (node === undefined || forceUpdate) {
          node = callback();
          nodeCache.set(object, node);
        }
        return node;
      }

      /**
       * If a scene fog is configured, this method makes sure to
       * represent the fog with a corresponding node-based implementation.
       *
       * @param {Scene} scene - The scene.
       */
    }, {
      key: "updateFog",
      value: function updateFog(scene) {
        var sceneData = this.get(scene);
        var sceneFog = scene.fog;
        if (sceneFog) {
          if (sceneData.fog !== sceneFog) {
            var fogNode = this.getCacheNode('fog', sceneFog, function () {
              if (sceneFog.isFogExp2) {
                var _color2 = reference('color', 'color', sceneFog).setGroup(renderGroup);
                var density = reference('density', 'float', sceneFog).setGroup(renderGroup);
                return fog(_color2, densityFogFactor(density));
              } else if (sceneFog.isFog) {
                var _color3 = reference('color', 'color', sceneFog).setGroup(renderGroup);
                var near = reference('near', 'float', sceneFog).setGroup(renderGroup);
                var far = reference('far', 'float', sceneFog).setGroup(renderGroup);
                return fog(_color3, rangeFogFactor(near, far));
              } else {
                console.error('THREE.Renderer: Unsupported fog configuration.', sceneFog);
              }
            });
            sceneData.fogNode = fogNode;
            sceneData.fog = sceneFog;
          }
        } else {
          delete sceneData.fogNode;
          delete sceneData.fog;
        }
      }

      /**
       * If a scene environment is configured, this method makes sure to
       * represent the environment with a corresponding node-based implementation.
       *
       * @param {Scene} scene - The scene.
       */
    }, {
      key: "updateEnvironment",
      value: function updateEnvironment(scene) {
        var sceneData = this.get(scene);
        var environment = scene.environment;
        if (environment) {
          if (sceneData.environment !== environment) {
            var environmentNode = this.getCacheNode('environment', environment, function () {
              if (environment.isCubeTexture === true) {
                return cubeTexture(environment);
              } else if (environment.isTexture === true) {
                return texture(environment);
              } else {
                console.error('Nodes: Unsupported environment configuration.', environment);
              }
            });
            sceneData.environmentNode = environmentNode;
            sceneData.environment = environment;
          }
        } else if (sceneData.environmentNode) {
          delete sceneData.environmentNode;
          delete sceneData.environment;
        }
      }
    }, {
      key: "getNodeFrame",
      value: function getNodeFrame() {
        var renderer = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.renderer;
        var scene = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
        var object = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
        var camera = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
        var material = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;
        var nodeFrame = this.nodeFrame;
        nodeFrame.renderer = renderer;
        nodeFrame.scene = scene;
        nodeFrame.object = object;
        nodeFrame.camera = camera;
        nodeFrame.material = material;
        return nodeFrame;
      }
    }, {
      key: "getNodeFrameForRender",
      value: function getNodeFrameForRender(renderObject) {
        return this.getNodeFrame(renderObject.renderer, renderObject.scene, renderObject.object, renderObject.camera, renderObject.material);
      }

      /**
       * Returns the current output cache key.
       *
       * @return {String} The output cache key.
       */
    }, {
      key: "getOutputCacheKey",
      value: function getOutputCacheKey() {
        var renderer = this.renderer;
        return renderer.toneMapping + ',' + renderer.currentColorSpace;
      }

      /**
       * Checks if the output configuration (tone mapping and color space) for
       * the given target has changed.
       *
       * @param {Texture} outputTarget - The output target.
       * @return {Boolean} Whether the output configuration has changed or not.
       */
    }, {
      key: "hasOutputChange",
      value: function hasOutputChange(outputTarget) {
        var cacheKey = _outputNodeMap.get(outputTarget);
        return cacheKey !== this.getOutputCacheKey();
      }

      /**
       * Returns a node that represents the output configuration (tone mapping and
       * color space) for the current target.
       *
       * @param {Texture} outputTarget - The output target.
       * @return {Node} The output node.
       */
    }, {
      key: "getOutputNode",
      value: function getOutputNode(outputTarget) {
        var renderer = this.renderer;
        var cacheKey = this.getOutputCacheKey();
        var output = texture(outputTarget, screenUV).renderOutput(renderer.toneMapping, renderer.currentColorSpace);
        _outputNodeMap.set(outputTarget, cacheKey);
        return output;
      }

      /**
       * Triggers the call of `updateBefore()` methods
       * for all nodes of the given render object.
       *
       * @param {RenderObject} renderObject - The render object.
       */
    }, {
      key: "updateBefore",
      value: function updateBefore(renderObject) {
        var nodeBuilder = renderObject.getNodeBuilderState();
        for (var node of nodeBuilder.updateBeforeNodes) {
          // update frame state for each node

          this.getNodeFrameForRender(renderObject).updateBeforeNode(node);
        }
      }

      /**
       * Triggers the call of `updateAfter()` methods
       * for all nodes of the given render object.
       *
       * @param {RenderObject} renderObject - The render object.
       */
    }, {
      key: "updateAfter",
      value: function updateAfter(renderObject) {
        var nodeBuilder = renderObject.getNodeBuilderState();
        for (var node of nodeBuilder.updateAfterNodes) {
          // update frame state for each node

          this.getNodeFrameForRender(renderObject).updateAfterNode(node);
        }
      }

      /**
       * Triggers the call of `update()` methods
       * for all nodes of the given compute node.
       *
       * @param {Node} computeNode - The compute node.
       */
    }, {
      key: "updateForCompute",
      value: function updateForCompute(computeNode) {
        var nodeFrame = this.getNodeFrame();
        var nodeBuilder = this.getForCompute(computeNode);
        for (var node of nodeBuilder.updateNodes) {
          nodeFrame.updateNode(node);
        }
      }

      /**
       * Triggers the call of `update()` methods
       * for all nodes of the given compute node.
       *
       * @param {RenderObject} renderObject - The render object.
       */
    }, {
      key: "updateForRender",
      value: function updateForRender(renderObject) {
        var nodeFrame = this.getNodeFrameForRender(renderObject);
        var nodeBuilder = renderObject.getNodeBuilderState();
        for (var node of nodeBuilder.updateNodes) {
          nodeFrame.updateNode(node);
        }
      }

      /**
       * Returns `true` if the given render object requires a refresh.
       *
       * @param {RenderObject} renderObject - The render object.
       * @return {Boolean} Whether the given render object requires a refresh or not.
       */
    }, {
      key: "needsRefresh",
      value: function needsRefresh(renderObject) {
        var nodeFrame = this.getNodeFrameForRender(renderObject);
        var monitor = renderObject.getMonitor();
        return monitor.needsRefresh(renderObject, nodeFrame);
      }

      /**
       * Frees the intenral resources.
       */
    }, {
      key: "dispose",
      value: function dispose() {
        _superPropGet(Nodes, "dispose", this, 3)([]);
        this.nodeFrame = new NodeFrame();
        this.nodeBuilderCache = new Map();
        this.cacheLib = {};
      }
    }]);
  }(DataMap);
  var _plane = /*@__PURE__*/new (_$$_REQUIRE(_dependencyMap[1], "./three.core.js").Plane)();

  /**
   * Represents the state that is used to perform clipping via clipping planes.
   * There is a default clipping context for each render context. When the
   * scene holds instances of `ClippingGroup`, there will be a context for each
   * group.
   *
   * @private
   */
  var ClippingContext = /*#__PURE__*/function () {
    /**
     * Constructs a new clipping context.
     *
     * @param {ClippingContext?} [parentContext=null] - A reference to the parent clipping context.
     */
    function ClippingContext() {
      var parentContext = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      (0, _classCallCheck2.default)(this, ClippingContext);
      /**
       * The clipping context's version.
       *
       * @type {Number}
       * @readonly
       */
      this.version = 0;

      /**
       * Whether the intersection of the clipping planes is used to clip objects, rather than their union.
       *
       * @type {Boolean?}
       * @default null
       */
      this.clipIntersection = null;

      /**
       * The clipping context's cache key.
       *
       * @type {String}
       */
      this.cacheKey = '';

      /**
       * Whether the shadow pass is active or not.
       *
       * @type {Boolean}
       * @default false
       */
      this.shadowPass = false;

      /**
       * The view normal matrix.
       *
       * @type {Matrix3}
       */
      this.viewNormalMatrix = new (_$$_REQUIRE(_dependencyMap[1], "./three.core.js").Matrix3)();

      /**
       * Internal cache for maintaining clipping contexts.
       *
       * @type {WeakMap<ClippingGroup,ClippingContext>}
       */
      this.clippingGroupContexts = new WeakMap();

      /**
       * The intersection planes.
       *
       * @type {Array<Vector4>}
       */
      this.intersectionPlanes = [];

      /**
       * The intersection planes.
       *
       * @type {Array<Vector4>}
       */
      this.unionPlanes = [];

      /**
       * The version of the clipping context's parent context.
       *
       * @type {Number?}
       * @readonly
       */
      this.parentVersion = null;
      if (parentContext !== null) {
        this.viewNormalMatrix = parentContext.viewNormalMatrix;
        this.clippingGroupContexts = parentContext.clippingGroupContexts;
        this.shadowPass = parentContext.shadowPass;
        this.viewMatrix = parentContext.viewMatrix;
      }
    }

    /**
     * Projects the given source clipping planes and writes the result into the
     * destination array.
     *
     * @param {Array<Plane>} source - The source clipping planes.
     * @param {Array<Vector4>} destination - The destination.
     * @param {Number} offset - The offset.
     */
    return (0, _createClass2.default)(ClippingContext, [{
      key: "projectPlanes",
      value: function projectPlanes(source, destination, offset) {
        var l = source.length;
        for (var i = 0; i < l; i++) {
          _plane.copy(source[i]).applyMatrix4(this.viewMatrix, this.viewNormalMatrix);
          var v = destination[offset + i];
          var normal = _plane.normal;
          v.x = -normal.x;
          v.y = -normal.y;
          v.z = -normal.z;
          v.w = _plane.constant;
        }
      }

      /**
       * Updates the root clipping context of a scene.
       *
       * @param {Scene} scene - The scene.
       * @param {Camera} camera - The camera that is used to render the scene.
       */
    }, {
      key: "updateGlobal",
      value: function updateGlobal(scene, camera) {
        this.shadowPass = scene.overrideMaterial !== null && scene.overrideMaterial.isShadowNodeMaterial;
        this.viewMatrix = camera.matrixWorldInverse;
        this.viewNormalMatrix.getNormalMatrix(this.viewMatrix);
      }

      /**
       * Updates the clipping context.
       *
       * @param {ClippingContext} parentContext - The parent context.
       * @param {ClippingGroup} clippingGroup - The clipping group this context belongs to.
       */
    }, {
      key: "update",
      value: function update(parentContext, clippingGroup) {
        var update = false;
        if (parentContext.version !== this.parentVersion) {
          this.intersectionPlanes = Array.from(parentContext.intersectionPlanes);
          this.unionPlanes = Array.from(parentContext.unionPlanes);
          this.parentVersion = parentContext.version;
        }
        if (this.clipIntersection !== clippingGroup.clipIntersection) {
          this.clipIntersection = clippingGroup.clipIntersection;
          if (this.clipIntersection) {
            this.unionPlanes.length = parentContext.unionPlanes.length;
          } else {
            this.intersectionPlanes.length = parentContext.intersectionPlanes.length;
          }
        }
        var srcClippingPlanes = clippingGroup.clippingPlanes;
        var l = srcClippingPlanes.length;
        var dstClippingPlanes;
        var offset;
        if (this.clipIntersection) {
          dstClippingPlanes = this.intersectionPlanes;
          offset = parentContext.intersectionPlanes.length;
        } else {
          dstClippingPlanes = this.unionPlanes;
          offset = parentContext.unionPlanes.length;
        }
        if (dstClippingPlanes.length !== offset + l) {
          dstClippingPlanes.length = offset + l;
          for (var i = 0; i < l; i++) {
            dstClippingPlanes[offset + i] = new (_$$_REQUIRE(_dependencyMap[1], "./three.core.js").Vector4)();
          }
          update = true;
        }
        this.projectPlanes(srcClippingPlanes, dstClippingPlanes, offset);
        if (update) {
          this.version++;
          this.cacheKey = `${this.intersectionPlanes.length}:${this.unionPlanes.length}`;
        }
      }

      /**
       * Returns a clipping context for the given clipping group.
       *
       * @param {ClippingGroup} clippingGroup - The clipping group.
       * @return {ClippingContext} The clipping context.
       */
    }, {
      key: "getGroupContext",
      value: function getGroupContext(clippingGroup) {
        if (this.shadowPass && !clippingGroup.clipShadows) return this;
        var context = this.clippingGroupContexts.get(clippingGroup);
        if (context === undefined) {
          context = new ClippingContext(this);
          this.clippingGroupContexts.set(clippingGroup, context);
        }
        context.update(this, clippingGroup);
        return context;
      }

      /**
       * The count of union clipping planes.
       *
       * @type {Number}
       * @readonly
       */
    }, {
      key: "unionClippingCount",
      get: function get() {
        return this.unionPlanes.length;
      }
    }]);
  }();
  /**
   * This module is used to represent render bundles inside the renderer
   * for further processing.
   *
   * @private
   */
  var RenderBundle = /*#__PURE__*/(0, _createClass2.default)(
  /**
   * Constructs a new bundle group.
   *
   * @param {BundleGroup} bundleGroup - The bundle group.
   * @param {Camera} camera - The camera the bundle group is rendered with.
   */
  function RenderBundle(bundleGroup, camera) {
    (0, _classCallCheck2.default)(this, RenderBundle);
    this.bundleGroup = bundleGroup;
    this.camera = camera;
  });
  /**
   * This renderer module manages render bundles.
   *
   * @private
   */
  var RenderBundles = /*#__PURE__*/function () {
    /**
     * Constructs a new render bundle management component.
     */
    function RenderBundles() {
      (0, _classCallCheck2.default)(this, RenderBundles);
      /**
       * A chain map for maintaining the render bundles.
       *
       * @type {ChainMap}
       */
      this.bundles = new ChainMap();
    }

    /**
     * Returns a render bundle for the given bundle group and camera.
     *
     * @param {BundleGroup} bundleGroup - The bundle group.
     * @param {Camera} camera - The camera the bundle group is rendered with.
     * @return {RenderBundle} The render bundle.
     */
    return (0, _createClass2.default)(RenderBundles, [{
      key: "get",
      value: function get(bundleGroup, camera) {
        var bundles = this.bundles;
        var keys = [bundleGroup, camera];
        var bundle = bundles.get(keys);
        if (bundle === undefined) {
          bundle = new RenderBundle(bundleGroup, camera);
          bundles.set(keys, bundle);
        }
        return bundle;
      }

      /**
       * Frees all internal resources.
       */
    }, {
      key: "dispose",
      value: function dispose() {
        this.bundles = new ChainMap();
      }
    }]);
  }();
  /**
   * The purpose of a node library is to assign node implementations
   * to existing library features. In `WebGPURenderer` lights, materials
   * which are not based on `NodeMaterial` as well as tone mapping techniques
   * are implemented with node-based modules.
   *
   * @private
   */
  var NodeLibrary = /*#__PURE__*/function () {
    /**
     * Constructs a new node library.
     */
    function NodeLibrary() {
      (0, _classCallCheck2.default)(this, NodeLibrary);
      /**
       * A weak map that maps lights to light nodes.
       *
       * @type {WeakMap<Light.constructor,AnalyticLightNode.constructor>}
       */
      this.lightNodes = new WeakMap();

      /**
       * A map that maps materials to node materials.
       *
       * @type {WeakMap<String,NodeMaterial.constructor>}
       */
      this.materialNodes = new Map();

      /**
       * A map that maps tone mapping techniques (constants)
       * to tone mapping node functions.
       *
       * @type {WeakMap<Number,Function>}
       */
      this.toneMappingNodes = new Map();
    }

    /**
     * Returns a matching node material instance for the given material object.
     *
     * This method also assigns/copies the properties of the given material object
     * to the node material. This is done to make sure the current material
     * configuration carries over to the node version.
     *
     * @param {Material} material - A material.
     * @return {NodeMaterial} The corresponding node material.
     */
    return (0, _createClass2.default)(NodeLibrary, [{
      key: "fromMaterial",
      value: function fromMaterial(material) {
        if (material.isNodeMaterial) return material;
        var nodeMaterial = null;
        var nodeMaterialClass = this.getMaterialNodeClass(material.type);
        if (nodeMaterialClass !== null) {
          nodeMaterial = new nodeMaterialClass();
          for (var key in material) {
            nodeMaterial[key] = material[key];
          }
        }
        return nodeMaterial;
      }

      /**
       * Adds a tone mapping node function for a tone mapping technique (constant).
       *
       * @param {Function} toneMappingNode - The tone mapping node function.
       * @param {Number} toneMapping - The tone mapping.
       */
    }, {
      key: "addToneMapping",
      value: function addToneMapping(toneMappingNode, toneMapping) {
        this.addType(toneMappingNode, toneMapping, this.toneMappingNodes);
      }

      /**
       * Returns a tone mapping node function for a tone mapping technique (constant).
       *
       * @param {Number} toneMapping - The tone mapping.
       * @return {Function?} The tone mapping node function. Returns `null` if no node function is found.
       */
    }, {
      key: "getToneMappingFunction",
      value: function getToneMappingFunction(toneMapping) {
        return this.toneMappingNodes.get(toneMapping) || null;
      }

      /**
       * Returns a node material class definition for a material type.
       *
       * @param {Sring} materialType - The material type.
       * @return {NodeMaterial.constructor?} The node material class definition. Returns `null` if no node material is found.
       */
    }, {
      key: "getMaterialNodeClass",
      value: function getMaterialNodeClass(materialType) {
        return this.materialNodes.get(materialType) || null;
      }

      /**
       * Adds a node material class definition for a given material type.
       *
       * @param {NodeMaterial.constructor} materialNodeClass - The node material class definition.
       * @param {Sring} materialClassType - The material type.
       */
    }, {
      key: "addMaterial",
      value: function addMaterial(materialNodeClass, materialClassType) {
        this.addType(materialNodeClass, materialClassType, this.materialNodes);
      }

      /**
       * Returns a light node class definition for a light class definition.
       *
       * @param {Light.constructor} light - The light class definition.
       * @return {AnalyticLightNode.constructor?} The light node class definition. Returns `null` if no light node is found.
       */
    }, {
      key: "getLightNodeClass",
      value: function getLightNodeClass(light) {
        return this.lightNodes.get(light) || null;
      }

      /**
       * Adds a light node class definition for a given light class definition.
       *
       * @param {AnalyticLightNode.constructor} lightNodeClass - The light node class definition.
       * @param {Light.constructor} lightClass - The light class definition.
       */
    }, {
      key: "addLight",
      value: function addLight(lightNodeClass, lightClass) {
        this.addClass(lightNodeClass, lightClass, this.lightNodes);
      }

      /**
       * Adds a node class definition for the given type to the provided type library.
       *
       * @param {Any} nodeClass - The node class definition.
       * @param {String} type - The object type.
       * @param {Map} library - The type library.
       */
    }, {
      key: "addType",
      value: function addType(nodeClass, type, library) {
        if (library.has(type)) {
          console.warn(`Redefinition of node ${type}`);
          return;
        }
        if (typeof nodeClass !== 'function') throw new Error(`Node class ${nodeClass.name} is not a class.`);
        if (typeof type === 'function' || typeof type === 'object') throw new Error(`Base class ${type} is not a class.`);
        library.set(type, nodeClass);
      }

      /**
       * Adds a node class definition for the given class definition to the provided type library.
       *
       * @param {Any} nodeClass - The node class definition.
       * @param {Any} baseClass - The class definition.
       * @param {WeakMap} library - The type library.
       */
    }, {
      key: "addClass",
      value: function addClass(nodeClass, baseClass, library) {
        if (library.has(baseClass)) {
          console.warn(`Redefinition of node ${baseClass.name}`);
          return;
        }
        if (typeof nodeClass !== 'function') throw new Error(`Node class ${nodeClass.name} is not a class.`);
        if (typeof baseClass !== 'function') throw new Error(`Base class ${baseClass.name} is not a class.`);
        library.set(baseClass, nodeClass);
      }
    }]);
  }();
  var _defaultLights = /*@__PURE__*/new LightsNode();

  /**
   * This renderer module manages the lights nodes which are unique
   * per scene and camera combination.
   *
   * The lights node itself is later configured in the render list
   * with the actual lights from the scene.
   *
   * @private
   * @augments ChainMap
   */
  var Lighting = exports.Lighting = /*#__PURE__*/function (_ChainMap) {
    /**
     * Constructs a lighting management component.
     */
    function Lighting() {
      (0, _classCallCheck2.default)(this, Lighting);
      return _callSuper(this, Lighting);
    }

    /**
     * Creates a new lights node for the given array of lights.
     *
     * @param {Array<Light>} lights - The render object.
     * @return {Boolean} Whether if the given render object has an initialized geometry or not.
     */
    (0, _inherits2.default)(Lighting, _ChainMap);
    return (0, _createClass2.default)(Lighting, [{
      key: "createNode",
      value: function createNode() {
        var lights = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
        return new LightsNode().setLights(lights);
      }

      /**
       * Returns a lights node for the given scene and camera.
       *
       * @param {Scene} scene - The scene.
       * @param {Camera} camera - The camera.
       * @return {LightsNode} The lights node.
       */
    }, {
      key: "getNode",
      value: function getNode(scene, camera) {
        // ignore post-processing

        if (scene.isQuadMesh) return _defaultLights;

        // tiled lighting

        var keys = [scene, camera];
        var node = this.get(keys);
        if (node === undefined) {
          node = this.createNode();
          this.set(keys, node);
        }
        return node;
      }
    }]);
  }(ChainMap);
  /** @module Renderer **/
  var _scene = /*@__PURE__*/new (_$$_REQUIRE(_dependencyMap[1], "./three.core.js").Scene)();
  var _drawingBufferSize = /*@__PURE__*/new (_$$_REQUIRE(_dependencyMap[1], "./three.core.js").Vector2)();
  var _screen = /*@__PURE__*/new (_$$_REQUIRE(_dependencyMap[1], "./three.core.js").Vector4)();
  var _frustum = /*@__PURE__*/new (_$$_REQUIRE(_dependencyMap[1], "./three.core.js").Frustum)();
  var _projScreenMatrix = /*@__PURE__*/new (_$$_REQUIRE(_dependencyMap[1], "./three.core.js").Matrix4)();
  var _vector4 = /*@__PURE__*/new (_$$_REQUIRE(_dependencyMap[1], "./three.core.js").Vector4)();

  /**
   * Base class for renderers.
   */
  var Renderer = /*#__PURE__*/function () {
    /**
     * Constructs a new renderer.
     *
     * @param {Backend} backend - The backend the renderer is targeting (e.g. WebGPU or WebGL 2).
     * @param {Object} parameters - The configuration parameter.
     * @param {Boolean} [parameters.logarithmicDepthBuffer=false] - Whether logarithmic depth buffer is enabled or not.
     * @param {Boolean} [parameters.alpha=true] - Whether the default framebuffer (which represents the final contents of the canvas) should be transparent or opaque.
     * @param {Boolean} [parameters.depth=true] - Whether the default framebuffer should have a depth buffer or not.
     * @param {Boolean} [parameters.stencil=false] - Whether the default framebuffer should have a stencil buffer or not.
     * @param {Boolean} [parameters.antialias=false] - Whether MSAA as the default anti-aliasing should be enabled or not.
     * @param {Number} [parameters.samples=0] - When `antialias` is `true`, `4` samples are used by default. This parameter can set to any other integer value than 0
     * to overwrite the default.
     * @param {Function?} [parameters.getFallback=null] - This callback function can be used to provide a fallback backend, if the primary backend can't be targeted.
     */
    function Renderer(backend) {
      var _this191 = this;
      var parameters = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      (0, _classCallCheck2.default)(this, Renderer);
      /**
       * This flag can be used for type testing.
       *
       * @type {Boolean}
       * @readonly
       * @default true
       */
      this.isRenderer = true;

      //

      var _parameters$logarithm = parameters.logarithmicDepthBuffer,
        logarithmicDepthBuffer = _parameters$logarithm === void 0 ? false : _parameters$logarithm,
        _parameters$alpha = parameters.alpha,
        alpha = _parameters$alpha === void 0 ? true : _parameters$alpha,
        _parameters$depth2 = parameters.depth,
        depth = _parameters$depth2 === void 0 ? true : _parameters$depth2,
        _parameters$stencil = parameters.stencil,
        stencil = _parameters$stencil === void 0 ? false : _parameters$stencil,
        _parameters$antialias = parameters.antialias,
        antialias = _parameters$antialias === void 0 ? false : _parameters$antialias,
        _parameters$samples = parameters.samples,
        samples = _parameters$samples === void 0 ? 0 : _parameters$samples,
        _parameters$getFallba = parameters.getFallback,
        getFallback = _parameters$getFallba === void 0 ? null : _parameters$getFallba;

      /**
       * A reference to the canvas element the renderer is drawing to.
       * This value of this property will automatically be created by
       * the renderer.
       *
       * @type {HTMLCanvasElement|OffscreenCanvas}
       */
      this.domElement = backend.getDomElement();

      /**
       * A reference to the current backend.
       *
       * @type {Backend}
       */
      this.backend = backend;

      /**
       * The number of MSAA samples.
       *
       * @type {Number}
       * @default 0
       */
      this.samples = samples || antialias === true ? 4 : 0;

      /**
       * Whether the renderer should automatically clear the current rendering target
       * before execute a `render()` call. The target can be the canvas (default framebuffer)
       * or the current bound render target (custom framebuffer).
       *
       * @type {Boolean}
       * @default true
       */
      this.autoClear = true;

      /**
       * When `autoClear` is set to `true`, this property defines whether the renderer
       * should clear the color buffer.
       *
       * @type {Boolean}
       * @default true
       */
      this.autoClearColor = true;

      /**
       * When `autoClear` is set to `true`, this property defines whether the renderer
       * should clear the depth buffer.
       *
       * @type {Boolean}
       * @default true
       */
      this.autoClearDepth = true;

      /**
       * When `autoClear` is set to `true`, this property defines whether the renderer
       * should clear the stencil buffer.
       *
       * @type {Boolean}
       * @default true
       */
      this.autoClearStencil = true;

      /**
       * Whether the default framebuffer should be transparent or opaque.
       *
       * @type {Boolean}
       * @default true
       */
      this.alpha = alpha;

      /**
       * Whether logarithmic depth buffer is enabled or not.
       *
       * @type {Boolean}
       * @default false
       */
      this.logarithmicDepthBuffer = logarithmicDepthBuffer;

      /**
       * Defines the output color space of the renderer.
       *
       * @type {String}
       * @default SRGBColorSpace
       */
      this.outputColorSpace = _$$_REQUIRE(_dependencyMap[1], "./three.core.js").SRGBColorSpace;

      /**
       * Defines the tone mapping of the renderer.
       *
       * @type {Number}
       * @default NoToneMapping
       */
      this.toneMapping = _$$_REQUIRE(_dependencyMap[1], "./three.core.js").NoToneMapping;

      /**
       * Defines the tone mapping exposure.
       *
       * @type {Number}
       * @default 1
       */
      this.toneMappingExposure = 1.0;

      /**
       * Whether the renderer should sort its render lists or not.
       *
       * Note: Sorting is used to attempt to properly render objects that have some degree of transparency.
       * By definition, sorting objects may not work in all cases. Depending on the needs of application,
       * it may be necessary to turn off sorting and use other methods to deal with transparency rendering
       * e.g. manually determining each object's rendering order.
       *
       * @type {Boolean}
       * @default true
       */
      this.sortObjects = true;

      /**
       * Whether the default framebuffer should have a depth buffer or not.
       *
       * @type {Boolean}
       * @default true
       */
      this.depth = depth;

      /**
       * Whether the default framebuffer should have a stencil buffer or not.
       *
       * @type {Boolean}
       * @default false
       */
      this.stencil = stencil;

      /**
       * Holds a series of statistical information about the GPU memory
       * and the rendering process. Useful for debugging and monitoring.
       *
       * @type {Boolean}
       */
      this.info = new Info();
      this.nodes = {
        modelViewMatrix: null,
        modelNormalViewMatrix: null
      };

      /**
       * The node library defines how certain library objects like materials, lights
       * or tone mapping functions are mapped to node types. This is required since
       * although instances of classes like `MeshBasicMaterial` or `PointLight` can
       * be part of the scene graph, they are internally represented as nodes for
       * further processing.
       *
       * @type {NodeLibrary}
       */
      this.library = new NodeLibrary();

      /**
       * A map-like data structure for managing lights.
       *
       * @type {Lighting}
       */
      this.lighting = new Lighting();

      // internals

      /**
       * This callback function can be used to provide a fallback backend, if the primary backend can't be targeted.
       *
       * @private
       * @type {Function}
       */
      this._getFallback = getFallback;

      /**
       * The renderer's pixel ration.
       *
       * @private
       * @type {Number}
       * @default 1
       */
      this._pixelRatio = 1;

      /**
       * The width of the renderer's default framebuffer in logical pixel unit.
       *
       * @private
       * @type {Number}
       */
      this._width = this.domElement.width;

      /**
       * The height of the renderer's default framebuffer in logical pixel unit.
       *
       * @private
       * @type {Number}
       */
      this._height = this.domElement.height;

      /**
       * The viewport of the renderer in logical pixel unit.
       *
       * @private
       * @type {Vector4}
       */
      this._viewport = new (_$$_REQUIRE(_dependencyMap[1], "./three.core.js").Vector4)(0, 0, this._width, this._height);

      /**
       * The scissor rectangle of the renderer in logical pixel unit.
       *
       * @private
       * @type {Vector4}
       */
      this._scissor = new (_$$_REQUIRE(_dependencyMap[1], "./three.core.js").Vector4)(0, 0, this._width, this._height);

      /**
       * Whether the scissor test should be enabled or not.
       *
       * @private
       * @type {Vector4}
       */
      this._scissorTest = false;

      /**
       * A reference to a renderer module for managing shader attributes.
       *
       * @private
       * @type {Attributes?}
       * @default null
       */
      this._attributes = null;

      /**
       * A reference to a renderer module for managing geometries.
       *
       * @private
       * @type {Geometries?}
       * @default null
       */
      this._geometries = null;

      /**
       * A reference to a renderer module for managing node related logic.
       *
       * @private
       * @type {Nodes?}
       * @default null
       */
      this._nodes = null;

      /**
       * A reference to a renderer module for managing the internal animation loop.
       *
       * @private
       * @type {Animation?}
       * @default null
       */
      this._animation = null;

      /**
       * A reference to a renderer module for managing shader program bindings.
       *
       * @private
       * @type {Bindings?}
       * @default null
       */
      this._bindings = null;

      /**
       * A reference to a renderer module for managing render objects.
       *
       * @private
       * @type {RenderObjects?}
       * @default null
       */
      this._objects = null;

      /**
       * A reference to a renderer module for managing render and cmopute pipelines.
       *
       * @private
       * @type {Pipelines?}
       * @default null
       */
      this._pipelines = null;

      /**
       * A reference to a renderer module for managing render bundles.
       *
       * @private
       * @type {RenderBundles?}
       * @default null
       */
      this._bundles = null;

      /**
       * A reference to a renderer module for managing render lists.
       *
       * @private
       * @type {RenderLists?}
       * @default null
       */
      this._renderLists = null;

      /**
       * A reference to a renderer module for managing render contexts.
       *
       * @private
       * @type {RenderContexts?}
       * @default null
       */
      this._renderContexts = null;

      /**
       * A reference to a renderer module for managing textures.
       *
       * @private
       * @type {Textures?}
       * @default null
       */
      this._textures = null;

      /**
       * A reference to a renderer module for backgrounds.
       *
       * @private
       * @type {Background?}
       * @default null
       */
      this._background = null;

      /**
       * This fullscreen quad is used for internal render passes
       * like the tone mapping and color space output pass.
       *
       * @private
       * @type {QuadMesh}
       */
      this._quad = new QuadMesh(new NodeMaterial());
      this._quad.material.name = 'Renderer_output';

      /**
       * A reference to the current render context.
       *
       * @private
       * @type {RenderContext?}
       * @default null
       */
      this._currentRenderContext = null;

      /**
       * A custom sort function for the opaque render list.
       *
       * @private
       * @type {Function?}
       * @default null
       */
      this._opaqueSort = null;

      /**
       * A custom sort function for the transparent render list.
       *
       * @private
       * @type {Function?}
       * @default null
       */
      this._transparentSort = null;

      /**
       * The framebuffer target.
       *
       * @private
       * @type {RenderTarget?}
       * @default null
       */
      this._frameBufferTarget = null;
      var alphaClear = this.alpha === true ? 0 : 1;

      /**
       * The clear color value.
       *
       * @private
       * @type {Color4}
       */
      this._clearColor = new Color4(0, 0, 0, alphaClear);

      /**
       * The clear depth value.
       *
       * @private
       * @type {Number}
       * @default 1
       */
      this._clearDepth = 1;

      /**
       * The clear stencil value.
       *
       * @private
       * @type {Number}
       * @default 0
       */
      this._clearStencil = 0;

      /**
       * The current render target.
       *
       * @private
       * @type {RenderTarget?}
       * @default null
       */
      this._renderTarget = null;

      /**
       * The active cube face.
       *
       * @private
       * @type {Number}
       * @default 0
       */
      this._activeCubeFace = 0;

      /**
       * The active mipmap level.
       *
       * @private
       * @type {Number}
       * @default 0
       */
      this._activeMipmapLevel = 0;

      /**
       * The MRT setting.
       *
       * @private
       * @type {MRTNode?}
       * @default null
       */
      this._mrt = null;

      /**
       * This function defines how a render object is going
       * to be rendered.
       *
       * @private
       * @type {Function?}
       * @default null
       */
      this._renderObjectFunction = null;

      /**
       * Used to keep track of the current render object function.
       *
       * @private
       * @type {Function?}
       * @default null
       */
      this._currentRenderObjectFunction = null;

      /**
       * Used to keep track of the current render bundle.
       *
       * @private
       * @type {RenderBundle?}
       * @default null
       */
      this._currentRenderBundle = null;

      /**
       * Next to `_renderObjectFunction()`, this function provides another hook
       * for influening the render process of a render object. It is meant for internal
       * use and only relevant for `compileAsync()` right now. Instead of using
       * the default logic of `_renderObjectDirect()` which actually draws the render object,
       * a different function might be used which performs no draw but just the node
       * and pipeline updates.
       *
       * @private
       * @type {Function?}
       * @default null
       */
      this._handleObjectFunction = this._renderObjectDirect;

      /**
       * Indicates whether the device has been lost or not. In WebGL terms, the device
       * lost is considered as a context lost. When this is set to `true`, rendering
       * isn't possible anymore.
       *
       * @private
       * @type {Boolean}
       * @default false
       */
      this._isDeviceLost = false;

      /**
       * A callback function that defines what should happen when a device/context lost occurs.
       *
       * @type {Function}
       */
      this.onDeviceLost = this._onDeviceLost;

      /**
       * Whether the renderer has been initialized or not.
       *
       * @private
       * @type {Boolean}
       * @default false
       */
      this._initialized = false;

      /**
       * A reference to the promise which initializes the renderer.
       *
       * @private
       * @type {Promise?}
       * @default null
       */
      this._initPromise = null;

      /**
       * An array of compilation promises which are used in `compileAsync()`.
       *
       * @private
       * @type {Array<Promise>?}
       * @default null
       */
      this._compilationPromises = null;

      /**
       * Whether the renderer should render transparent render objects or not.
       *
       * @type {Boolean}
       * @default true
       */
      this.transparent = true;

      /**
       * Whether the renderer should render opaque render objects or not.
       *
       * @type {Boolean}
       * @default true
       */
      this.opaque = true;

      /**
       * Shadow map configuration
       * @typedef {Object} ShadowMapConfig
       * @property {Boolean} enabled - Whether to globally enable shadows or not.
       * @property {Number} type - The shadow map type.
       */

      /**
       * The renderer's shadow configuration.
       *
       * @type {module:Renderer~ShadowMapConfig}
       */
      this.shadowMap = {
        enabled: false,
        type: _$$_REQUIRE(_dependencyMap[1], "./three.core.js").PCFShadowMap
      };

      /**
       * XR configuration.
       * @typedef {Object} XRConfig
       * @property {Boolean} enabled - Whether to globally enable XR or not.
       */

      /**
       * The renderer's XR configuration.
       *
       * @type {module:Renderer~XRConfig}
       */
      this.xr = {
        enabled: false
      };

      /**
       * Debug configuration.
       * @typedef {Object} DebugConfig
       * @property {Boolean} checkShaderErrors - Whether shader errors should be checked or not.
       * @property {Function} onShaderError - A callback function that is executed when a shader error happens. Only supported with WebGL 2 right now.
       * @property {Function} getShaderAsync - Allows the get the raw shader code for the given scene, camerea and 3D object.
       */

      /**
       * The renderer's debug configuration.
       *
       * @type {module:Renderer~DebugConfig}
       */
      this.debug = {
        checkShaderErrors: true,
        onShaderError: null,
        getShaderAsync: function () {
          var _getShaderAsync = (0, _asyncToGenerator2.default)(function* (scene, camera, object) {
            yield _this191.compileAsync(scene, camera);
            var renderList = _this191._renderLists.get(scene, camera);
            var renderContext = _this191._renderContexts.get(scene, camera, _this191._renderTarget);
            var material = scene.overrideMaterial || object.material;
            var renderObject = _this191._objects.get(object, material, scene, camera, renderList.lightsNode, renderContext, renderContext.clippingContext);
            var _renderObject$getNode = renderObject.getNodeBuilderState(),
              fragmentShader = _renderObject$getNode.fragmentShader,
              vertexShader = _renderObject$getNode.vertexShader;
            return {
              fragmentShader: fragmentShader,
              vertexShader: vertexShader
            };
          });
          function getShaderAsync(_x8, _x9, _x10) {
            return _getShaderAsync.apply(this, arguments);
          }
          return getShaderAsync;
        }()
      };
    }

    /**
     * Initializes the renderer so it is ready for usage.
     *
     * @async
     * @return {Promise} A Promise that resolves when the renderer has been initialized.
     */
    return (0, _createClass2.default)(Renderer, [{
      key: "init",
      value: (function () {
        var _init2 = (0, _asyncToGenerator2.default)(function* () {
          var _this192 = this;
          if (this._initialized) {
            throw new Error('Renderer: Backend has already been initialized.');
          }
          if (this._initPromise !== null) {
            return this._initPromise;
          }
          this._initPromise = new Promise(/*#__PURE__*/function () {
            var _ref337 = (0, _asyncToGenerator2.default)(function* (resolve, reject) {
              var backend = _this192.backend;
              try {
                yield backend.init(_this192);
              } catch (error) {
                if (_this192._getFallback !== null) {
                  // try the fallback

                  try {
                    _this192.backend = backend = _this192._getFallback(error);
                    yield backend.init(_this192);
                  } catch (error) {
                    reject(error);
                    return;
                  }
                } else {
                  reject(error);
                  return;
                }
              }
              _this192._nodes = new Nodes(_this192, backend);
              _this192._animation = new Animation(_this192._nodes, _this192.info);
              _this192._attributes = new Attributes(backend);
              _this192._background = new Background(_this192, _this192._nodes);
              _this192._geometries = new Geometries(_this192._attributes, _this192.info);
              _this192._textures = new Textures(_this192, backend, _this192.info);
              _this192._pipelines = new Pipelines(backend, _this192._nodes);
              _this192._bindings = new Bindings(backend, _this192._nodes, _this192._textures, _this192._attributes, _this192._pipelines, _this192.info);
              _this192._objects = new RenderObjects(_this192, _this192._nodes, _this192._geometries, _this192._pipelines, _this192._bindings, _this192.info);
              _this192._renderLists = new RenderLists(_this192.lighting);
              _this192._bundles = new RenderBundles();
              _this192._renderContexts = new RenderContexts();

              //

              _this192._animation.start();
              _this192._initialized = true;
              resolve();
            });
            return function (_x11, _x12) {
              return _ref337.apply(this, arguments);
            };
          }());
          return this._initPromise;
        });
        function init() {
          return _init2.apply(this, arguments);
        }
        return init;
      }()
      /**
       * The coordinate system of the renderer. The value of this property
       * depends on the selected backend. Either `THREE.WebGLCoordinateSystem` or
       * `THREE.WebGPUCoordinateSystem`.
       *
       * @readonly
       * @type {Number}
       */
      )
    }, {
      key: "coordinateSystem",
      get: function get() {
        return this.backend.coordinateSystem;
      }

      /**
       * Compiles all materials in the given scene. This can be useful to avoid a
       * phenomenon which is called "shader compilation stutter", which occurs when
       * rendering an object with a new shader for the first time.
       *
       * If you want to add a 3D object to an existing scene, use the third optional
       * parameter for applying the target scene. Note that the (target) scene's lighting
       * and environment must be configured before calling this method.
       *
       * @async
       * @param {Object3D} scene - The scene or 3D object to precompile.
       * @param {Camera} camera - The camera that is used to render the scene.
       * @param {Scene} targetScene - If the first argument is a 3D object, this parameter must represent the scene the 3D object is going to be added.
       * @return {Promise} A Promise that resolves when the compile has been finished.
       */
    }, {
      key: "compileAsync",
      value: (function () {
        var _compileAsync = (0, _asyncToGenerator2.default)(function* (scene, camera) {
          var targetScene = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
          if (this._isDeviceLost === true) return;
          if (this._initialized === false) yield this.init();

          // preserve render tree

          var nodeFrame = this._nodes.nodeFrame;
          var previousRenderId = nodeFrame.renderId;
          var previousRenderContext = this._currentRenderContext;
          var previousRenderObjectFunction = this._currentRenderObjectFunction;
          var previousCompilationPromises = this._compilationPromises;

          //

          var sceneRef = scene.isScene === true ? scene : _scene;
          if (targetScene === null) targetScene = scene;
          var renderTarget = this._renderTarget;
          var renderContext = this._renderContexts.get(targetScene, camera, renderTarget);
          var activeMipmapLevel = this._activeMipmapLevel;
          var compilationPromises = [];
          this._currentRenderContext = renderContext;
          this._currentRenderObjectFunction = this.renderObject;
          this._handleObjectFunction = this._createObjectPipeline;
          this._compilationPromises = compilationPromises;
          nodeFrame.renderId++;

          //

          nodeFrame.update();

          //

          renderContext.depth = this.depth;
          renderContext.stencil = this.stencil;
          if (!renderContext.clippingContext) renderContext.clippingContext = new ClippingContext();
          renderContext.clippingContext.updateGlobal(sceneRef, camera);

          //

          sceneRef.onBeforeRender(this, scene, camera, renderTarget);

          //

          var renderList = this._renderLists.get(scene, camera);
          renderList.begin();
          this._projectObject(scene, camera, 0, renderList, renderContext.clippingContext);

          // include lights from target scene
          if (targetScene !== scene) {
            targetScene.traverseVisible(function (object) {
              if (object.isLight && object.layers.test(camera.layers)) {
                renderList.pushLight(object);
              }
            });
          }
          renderList.finish();

          //

          if (renderTarget !== null) {
            this._textures.updateRenderTarget(renderTarget, activeMipmapLevel);
            var renderTargetData = this._textures.get(renderTarget);
            renderContext.textures = renderTargetData.textures;
            renderContext.depthTexture = renderTargetData.depthTexture;
          } else {
            renderContext.textures = null;
            renderContext.depthTexture = null;
          }

          //

          this._background.update(sceneRef, renderList, renderContext);

          // process render lists

          var opaqueObjects = renderList.opaque;
          var transparentObjects = renderList.transparent;
          var transparentDoublePassObjects = renderList.transparentDoublePass;
          var lightsNode = renderList.lightsNode;
          if (this.opaque === true && opaqueObjects.length > 0) this._renderObjects(opaqueObjects, camera, sceneRef, lightsNode);
          if (this.transparent === true && transparentObjects.length > 0) this._renderTransparents(transparentObjects, transparentDoublePassObjects, camera, sceneRef, lightsNode);

          // restore render tree

          nodeFrame.renderId = previousRenderId;
          this._currentRenderContext = previousRenderContext;
          this._currentRenderObjectFunction = previousRenderObjectFunction;
          this._compilationPromises = previousCompilationPromises;
          this._handleObjectFunction = this._renderObjectDirect;

          // wait for all promises setup by backends awaiting compilation/linking/pipeline creation to complete

          yield Promise.all(compilationPromises);
        });
        function compileAsync(_x13, _x14) {
          return _compileAsync.apply(this, arguments);
        }
        return compileAsync;
      }()
      /**
       * Renders the scene in an async fashion.
       *
       * @async
       * @param {Object3D} scene - The scene or 3D object to render.
       * @param {Camera} camera - The camera.
       * @return {Promise} A Promise that resolves when the render has been finished.
       */
      )
    }, {
      key: "renderAsync",
      value: (function () {
        var _renderAsync2 = (0, _asyncToGenerator2.default)(function* (scene, camera) {
          if (this._initialized === false) yield this.init();
          var renderContext = this._renderScene(scene, camera);
          yield this.backend.resolveTimestampAsync(renderContext, 'render');
        });
        function renderAsync(_x15, _x16) {
          return _renderAsync2.apply(this, arguments);
        }
        return renderAsync;
      }()
      /**
       * Can be used to synchronize CPU operations with GPU tasks. So when this method is called,
       * the CPU waits for the GPU to complete its operation (e.g. a compute task).
       *
       * @async
       * @return {Promise} A Promise that resolves when synchronization has been finished.
       */
      )
    }, {
      key: "waitForGPU",
      value: (function () {
        var _waitForGPU = (0, _asyncToGenerator2.default)(function* () {
          yield this.backend.waitForGPU();
        });
        function waitForGPU() {
          return _waitForGPU.apply(this, arguments);
        }
        return waitForGPU;
      }()
      /**
       * Sets the given MRT configuration.
       *
       * @param {MRTNode} mrt - The MRT node to set.
       * @return {Renderer} A reference to this renderer.
       */
      )
    }, {
      key: "setMRT",
      value: function setMRT(mrt) {
        this._mrt = mrt;
        return this;
      }

      /**
       * Returns the MRT configuration.
       *
       * @return {MRTNode} The MRT configuration.
       */
    }, {
      key: "getMRT",
      value: function getMRT() {
        return this._mrt;
      }

      /**
       * Default implementation of the device lost callback.
       *
       * @private
       * @param {Object} info - Information about the context lost.
       */
    }, {
      key: "_onDeviceLost",
      value: function _onDeviceLost(info) {
        var errorMessage = `THREE.WebGPURenderer: ${info.api} Device Lost:\n\nMessage: ${info.message}`;
        if (info.reason) {
          errorMessage += `\nReason: ${info.reason}`;
        }
        console.error(errorMessage);
        this._isDeviceLost = true;
      }

      /**
       * Renders the given render bundle.
       *
       * @private
       * @param {Object} bundle - Render bundle data.
       * @param {Scene} sceneRef - The scene the render bundle belongs to.
       * @param {LightsNode} lightsNode - The current lights node.
       */
    }, {
      key: "_renderBundle",
      value: function _renderBundle(bundle, sceneRef, lightsNode) {
        var bundleGroup = bundle.bundleGroup,
          camera = bundle.camera,
          renderList = bundle.renderList;
        var renderContext = this._currentRenderContext;

        //

        var renderBundle = this._bundles.get(bundleGroup, camera);
        var renderBundleData = this.backend.get(renderBundle);
        if (renderBundleData.renderContexts === undefined) renderBundleData.renderContexts = new Set();

        //

        var needsUpdate = bundleGroup.version !== renderBundleData.version;
        var renderBundleNeedsUpdate = renderBundleData.renderContexts.has(renderContext) === false || needsUpdate;
        renderBundleData.renderContexts.add(renderContext);
        if (renderBundleNeedsUpdate) {
          this.backend.beginBundle(renderContext);
          if (renderBundleData.renderObjects === undefined || needsUpdate) {
            renderBundleData.renderObjects = [];
          }
          this._currentRenderBundle = renderBundle;
          var opaqueObjects = renderList.opaque;
          if (this.opaque === true && opaqueObjects.length > 0) this._renderObjects(opaqueObjects, camera, sceneRef, lightsNode);
          this._currentRenderBundle = null;

          //

          this.backend.finishBundle(renderContext, renderBundle);
          renderBundleData.version = bundleGroup.version;
        } else {
          var renderObjects = renderBundleData.renderObjects;
          for (var i = 0, l = renderObjects.length; i < l; i++) {
            var renderObject = renderObjects[i];
            if (this._nodes.needsRefresh(renderObject)) {
              this._nodes.updateBefore(renderObject);
              this._nodes.updateForRender(renderObject);
              this._bindings.updateForRender(renderObject);
              this._nodes.updateAfter(renderObject);
            }
          }
        }
        this.backend.addBundle(renderContext, renderBundle);
      }

      /**
       * Renders the scene or 3D object with the given camera. This method can only be called
       * if the renderer has been initialized.
       *
       * The target of the method is the default framebuffer (meaning the canvas)
       * or alternatively a render target when specified via `setRenderTarget()`.
       *
       * @param {Object3D} scene - The scene or 3D object to render.
       * @param {Camera} camera - The camera to render the scene with.
       * @return {Promise?} A Promise that resolve when the scene has been rendered.
       * Only returned when the renderer has not been initialized.
       */
    }, {
      key: "render",
      value: function render(scene, camera) {
        if (this._initialized === false) {
          console.warn('THREE.Renderer: .render() called before the backend is initialized. Try using .renderAsync() instead.');
          return this.renderAsync(scene, camera);
        }
        this._renderScene(scene, camera);
      }

      /**
       * Returns an internal render target which is used when computing the output tone mapping
       * and color space conversion. Unlike in `WebGLRenderer`, this is done in a separate render
       * pass and not inline to achieve more correct results.
       *
       * @private
       * @return {RenderTarget?} The render target. The method returns `null` if no output conversion should be applied.
       */
    }, {
      key: "_getFrameBufferTarget",
      value: function _getFrameBufferTarget() {
        var currentToneMapping = this.currentToneMapping,
          currentColorSpace = this.currentColorSpace;
        var useToneMapping = currentToneMapping !== _$$_REQUIRE(_dependencyMap[1], "./three.core.js").NoToneMapping;
        var useColorSpace = currentColorSpace !== _$$_REQUIRE(_dependencyMap[1], "./three.core.js").LinearSRGBColorSpace;
        if (useToneMapping === false && useColorSpace === false) return null;
        var _this$getDrawingBuffe = this.getDrawingBufferSize(_drawingBufferSize),
          width = _this$getDrawingBuffe.width,
          height = _this$getDrawingBuffe.height;
        var depth = this.depth,
          stencil = this.stencil;
        var frameBufferTarget = this._frameBufferTarget;
        if (frameBufferTarget === null) {
          frameBufferTarget = new (_$$_REQUIRE(_dependencyMap[1], "./three.core.js").RenderTarget)(width, height, {
            depthBuffer: depth,
            stencilBuffer: stencil,
            type: _$$_REQUIRE(_dependencyMap[1], "./three.core.js").HalfFloatType,
            // FloatType
            format: _$$_REQUIRE(_dependencyMap[1], "./three.core.js").RGBAFormat,
            colorSpace: _$$_REQUIRE(_dependencyMap[1], "./three.core.js").LinearSRGBColorSpace,
            generateMipmaps: false,
            minFilter: _$$_REQUIRE(_dependencyMap[1], "./three.core.js").LinearFilter,
            magFilter: _$$_REQUIRE(_dependencyMap[1], "./three.core.js").LinearFilter,
            samples: this.samples
          });
          frameBufferTarget.isPostProcessingRenderTarget = true;
          this._frameBufferTarget = frameBufferTarget;
        }
        frameBufferTarget.depthBuffer = depth;
        frameBufferTarget.stencilBuffer = stencil;
        frameBufferTarget.setSize(width, height);
        frameBufferTarget.viewport.copy(this._viewport);
        frameBufferTarget.scissor.copy(this._scissor);
        frameBufferTarget.viewport.multiplyScalar(this._pixelRatio);
        frameBufferTarget.scissor.multiplyScalar(this._pixelRatio);
        frameBufferTarget.scissorTest = this._scissorTest;
        return frameBufferTarget;
      }

      /**
       * Renders the scene or 3D object with the given camera.
       *
       * @private
       * @param {Object3D} scene - The scene or 3D object to render.
       * @param {Camera} camera - The camera to render the scene with.
       * @param {Boolean} [useFrameBufferTarget=true] - Whether to use a framebuffer target or not.
       * @return {RenderContext} The current render context.
       */
    }, {
      key: "_renderScene",
      value: function _renderScene(scene, camera) {
        var useFrameBufferTarget = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
        if (this._isDeviceLost === true) return;
        var frameBufferTarget = useFrameBufferTarget ? this._getFrameBufferTarget() : null;

        // preserve render tree

        var nodeFrame = this._nodes.nodeFrame;
        var previousRenderId = nodeFrame.renderId;
        var previousRenderContext = this._currentRenderContext;
        var previousRenderObjectFunction = this._currentRenderObjectFunction;

        //

        var sceneRef = scene.isScene === true ? scene : _scene;
        var outputRenderTarget = this._renderTarget;
        var activeCubeFace = this._activeCubeFace;
        var activeMipmapLevel = this._activeMipmapLevel;

        //

        var renderTarget;
        if (frameBufferTarget !== null) {
          renderTarget = frameBufferTarget;
          this.setRenderTarget(renderTarget);
        } else {
          renderTarget = outputRenderTarget;
        }

        //

        var renderContext = this._renderContexts.get(scene, camera, renderTarget);
        this._currentRenderContext = renderContext;
        this._currentRenderObjectFunction = this._renderObjectFunction || this.renderObject;

        //

        this.info.calls++;
        this.info.render.calls++;
        this.info.render.frameCalls++;
        nodeFrame.renderId = this.info.calls;

        //

        var coordinateSystem = this.coordinateSystem;
        if (camera.coordinateSystem !== coordinateSystem) {
          camera.coordinateSystem = coordinateSystem;
          camera.updateProjectionMatrix();
        }

        //

        if (scene.matrixWorldAutoUpdate === true) scene.updateMatrixWorld();
        if (camera.parent === null && camera.matrixWorldAutoUpdate === true) camera.updateMatrixWorld();

        //

        var viewport = this._viewport;
        var scissor = this._scissor;
        var pixelRatio = this._pixelRatio;
        if (renderTarget !== null) {
          viewport = renderTarget.viewport;
          scissor = renderTarget.scissor;
          pixelRatio = 1;
        }
        this.getDrawingBufferSize(_drawingBufferSize);
        _screen.set(0, 0, _drawingBufferSize.width, _drawingBufferSize.height);
        var minDepth = viewport.minDepth === undefined ? 0 : viewport.minDepth;
        var maxDepth = viewport.maxDepth === undefined ? 1 : viewport.maxDepth;
        renderContext.viewportValue.copy(viewport).multiplyScalar(pixelRatio).floor();
        renderContext.viewportValue.width >>= activeMipmapLevel;
        renderContext.viewportValue.height >>= activeMipmapLevel;
        renderContext.viewportValue.minDepth = minDepth;
        renderContext.viewportValue.maxDepth = maxDepth;
        renderContext.viewport = renderContext.viewportValue.equals(_screen) === false;
        renderContext.scissorValue.copy(scissor).multiplyScalar(pixelRatio).floor();
        renderContext.scissor = this._scissorTest && renderContext.scissorValue.equals(_screen) === false;
        renderContext.scissorValue.width >>= activeMipmapLevel;
        renderContext.scissorValue.height >>= activeMipmapLevel;
        if (!renderContext.clippingContext) renderContext.clippingContext = new ClippingContext();
        renderContext.clippingContext.updateGlobal(sceneRef, camera);

        //

        sceneRef.onBeforeRender(this, scene, camera, renderTarget);

        //

        _projScreenMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
        _frustum.setFromProjectionMatrix(_projScreenMatrix, coordinateSystem);
        var renderList = this._renderLists.get(scene, camera);
        renderList.begin();
        this._projectObject(scene, camera, 0, renderList, renderContext.clippingContext);
        renderList.finish();
        if (this.sortObjects === true) {
          renderList.sort(this._opaqueSort, this._transparentSort);
        }

        //

        if (renderTarget !== null) {
          this._textures.updateRenderTarget(renderTarget, activeMipmapLevel);
          var renderTargetData = this._textures.get(renderTarget);
          renderContext.textures = renderTargetData.textures;
          renderContext.depthTexture = renderTargetData.depthTexture;
          renderContext.width = renderTargetData.width;
          renderContext.height = renderTargetData.height;
          renderContext.renderTarget = renderTarget;
          renderContext.depth = renderTarget.depthBuffer;
          renderContext.stencil = renderTarget.stencilBuffer;
        } else {
          renderContext.textures = null;
          renderContext.depthTexture = null;
          renderContext.width = this.domElement.width;
          renderContext.height = this.domElement.height;
          renderContext.depth = this.depth;
          renderContext.stencil = this.stencil;
        }
        renderContext.width >>= activeMipmapLevel;
        renderContext.height >>= activeMipmapLevel;
        renderContext.activeCubeFace = activeCubeFace;
        renderContext.activeMipmapLevel = activeMipmapLevel;
        renderContext.occlusionQueryCount = renderList.occlusionQueryCount;

        //

        this._background.update(sceneRef, renderList, renderContext);

        //

        this.backend.beginRender(renderContext);

        // process render lists

        var bundles = renderList.bundles,
          lightsNode = renderList.lightsNode,
          transparentDoublePassObjects = renderList.transparentDoublePass,
          transparentObjects = renderList.transparent,
          opaqueObjects = renderList.opaque;
        if (bundles.length > 0) this._renderBundles(bundles, sceneRef, lightsNode);
        if (this.opaque === true && opaqueObjects.length > 0) this._renderObjects(opaqueObjects, camera, sceneRef, lightsNode);
        if (this.transparent === true && transparentObjects.length > 0) this._renderTransparents(transparentObjects, transparentDoublePassObjects, camera, sceneRef, lightsNode);

        // finish render pass

        this.backend.finishRender(renderContext);

        // restore render tree

        nodeFrame.renderId = previousRenderId;
        this._currentRenderContext = previousRenderContext;
        this._currentRenderObjectFunction = previousRenderObjectFunction;

        //

        if (frameBufferTarget !== null) {
          this.setRenderTarget(outputRenderTarget, activeCubeFace, activeMipmapLevel);
          var quad = this._quad;
          if (this._nodes.hasOutputChange(renderTarget.texture)) {
            quad.material.fragmentNode = this._nodes.getOutputNode(renderTarget.texture);
            quad.material.needsUpdate = true;
          }
          this._renderScene(quad, quad.camera, false);
        }

        //

        sceneRef.onAfterRender(this, scene, camera, renderTarget);

        //

        return renderContext;
      }

      /**
       * Returns the maximum available anisotropy for texture filtering.
       *
       * @return {Number} The maximum available anisotropy.
       */
    }, {
      key: "getMaxAnisotropy",
      value: function getMaxAnisotropy() {
        return this.backend.getMaxAnisotropy();
      }

      /**
       * Returns the active cube face.
       *
       * @return {Number} The active cube face.
       */
    }, {
      key: "getActiveCubeFace",
      value: function getActiveCubeFace() {
        return this._activeCubeFace;
      }

      /**
       * Returns the active mipmap level.
       *
       * @return {Number} The active mipmap level.
       */
    }, {
      key: "getActiveMipmapLevel",
      value: function getActiveMipmapLevel() {
        return this._activeMipmapLevel;
      }

      /**
       * Applications are advised to always define the animation loop
       * with this method and not manually with `requestAnimationFrame()`
       * for best compatibility.
       *
       * @async
       * @param {Function} callback - The application's animation loop.
       * @return {Promise} A Promise that resolves when the set has been exeucted.
       */
    }, {
      key: "setAnimationLoop",
      value: (function () {
        var _setAnimationLoop = (0, _asyncToGenerator2.default)(function* (callback) {
          if (this._initialized === false) yield this.init();
          this._animation.setAnimationLoop(callback);
        });
        function setAnimationLoop(_x17) {
          return _setAnimationLoop.apply(this, arguments);
        }
        return setAnimationLoop;
      }()
      /**
       * Can be used to transfer buffer data from a storage buffer attribute
       * from the GPU to the CPU in context of compute shaders.
       *
       * @async
       * @param {StorageBufferAttribute} attribute - The storage buffer attribute.
       * @return {Promise<ArrayBuffer>} A promise that resolves with the buffer data when the data are ready.
       */
      )
    }, {
      key: "getArrayBufferAsync",
      value: (function () {
        var _getArrayBufferAsync = (0, _asyncToGenerator2.default)(function* (attribute) {
          return yield this.backend.getArrayBufferAsync(attribute);
        });
        function getArrayBufferAsync(_x18) {
          return _getArrayBufferAsync.apply(this, arguments);
        }
        return getArrayBufferAsync;
      }()
      /**
       * Returns the rendering context.
       *
       * @return {GPUCanvasContext|WebGL2RenderingContext} The rendering context.
       */
      )
    }, {
      key: "getContext",
      value: function getContext() {
        return this.backend.getContext();
      }

      /**
       * Returns the pixel ratio.
       *
       * @return {Number} The pixel ratio.
       */
    }, {
      key: "getPixelRatio",
      value: function getPixelRatio() {
        return this._pixelRatio;
      }

      /**
       * Returns the drawing buffer size in physical pixels. This method honors the pixel ratio.
       *
       * @param {Vector2} target - The method writes the result in this target object.
       * @return {Vector2} The drawing buffer size.
       */
    }, {
      key: "getDrawingBufferSize",
      value: function getDrawingBufferSize(target) {
        return target.set(this._width * this._pixelRatio, this._height * this._pixelRatio).floor();
      }

      /**
       * Returns the renderer's size in logical pixels. This method does not honor the pixel ratio.
       *
       * @param {Vector2} target - The method writes the result in this target object.
       * @return {Vector2} The drawing buffer size.
       */
    }, {
      key: "getSize",
      value: function getSize(target) {
        return target.set(this._width, this._height);
      }

      /**
       * Sets the given pixel ration and resizes the canvas if necessary.
       *
       * @param {Number} [value=1] - The pixel ratio.
       */
    }, {
      key: "setPixelRatio",
      value: function setPixelRatio() {
        var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
        if (this._pixelRatio === value) return;
        this._pixelRatio = value;
        this.setSize(this._width, this._height, false);
      }

      /**
       * This method allows to define the drawing buffer size by specifying
       * width, height and pixel ratio all at once. The size of the drawing
       * buffer is computed with this formula:
       * ````
       * size.x = width * pixelRatio;
       * size.y = height * pixelRatio;
       *```
       *
       * @param {Number} width - The width in logical pixels.
       * @param {Number} height - The height in logical pixels.
       * @param {Number} pixelRatio - The pixel ratio.
       */
    }, {
      key: "setDrawingBufferSize",
      value: function setDrawingBufferSize(width, height, pixelRatio) {
        this._width = width;
        this._height = height;
        this._pixelRatio = pixelRatio;
        this.domElement.width = Math.floor(width * pixelRatio);
        this.domElement.height = Math.floor(height * pixelRatio);
        this.setViewport(0, 0, width, height);
        if (this._initialized) this.backend.updateSize();
      }

      /**
       * Sets the size of the renderer.
       *
       * @param {Number} width - The width in logical pixels.
       * @param {Number} height - The height in logical pixels.
       * @param {Boolean} [updateStyle=true] - Whether to update the `style` attribute of the canvas or not.
       */
    }, {
      key: "setSize",
      value: function setSize(width, height) {
        var updateStyle = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
        this._width = width;
        this._height = height;
        this.domElement.width = Math.floor(width * this._pixelRatio);
        this.domElement.height = Math.floor(height * this._pixelRatio);
        if (updateStyle === true) {
          this.domElement.style.width = width + 'px';
          this.domElement.style.height = height + 'px';
        }
        this.setViewport(0, 0, width, height);
        if (this._initialized) this.backend.updateSize();
      }

      /**
       * Defines a manual sort function for the opaque render list.
       * Pass `null` to use the default sort.
       *
       * @param {Function} method - The sort function.
       */
    }, {
      key: "setOpaqueSort",
      value: function setOpaqueSort(method) {
        this._opaqueSort = method;
      }

      /**
       * Defines a manual sort function for the transparent render list.
       * Pass `null` to use the default sort.
       *
       * @param {Function} method - The sort function.
       */
    }, {
      key: "setTransparentSort",
      value: function setTransparentSort(method) {
        this._transparentSort = method;
      }

      /**
       * Returns the scissor rectangle.
       *
       * @param {Vector4} target - The method writes the result in this target object.
       * @return {Vector4} The scissor rectangle.
       */
    }, {
      key: "getScissor",
      value: function getScissor(target) {
        var scissor = this._scissor;
        target.x = scissor.x;
        target.y = scissor.y;
        target.width = scissor.width;
        target.height = scissor.height;
        return target;
      }

      /**
       * Defines the scissor rectangle.
       *
       * @param {Number | Vector4} x - The horizontal coordinate for the lower left corner of the box in logical pixel unit.
       * Instead of passing four arguments, the method also works with a single four-dimensional vector.
       * @param {Number} y - The vertical coordinate for the lower left corner of the box in logical pixel unit.
       * @param {Number} width - The width of the scissor box in logical pixel unit.
       * @param {Number} height - The height of the scissor box in logical pixel unit.
       */
    }, {
      key: "setScissor",
      value: function setScissor(x, y, width, height) {
        var scissor = this._scissor;
        if (x.isVector4) {
          scissor.copy(x);
        } else {
          scissor.set(x, y, width, height);
        }
      }

      /**
       * Returns the scissor test value.
       *
       * @return {Boolean} Whether the scissor test should be enabled or not.
       */
    }, {
      key: "getScissorTest",
      value: function getScissorTest() {
        return this._scissorTest;
      }

      /**
       * Defines the scissor test.
       *
       * @param {Boolean} boolean - Whether the scissor test should be enabled or not.
       */
    }, {
      key: "setScissorTest",
      value: function setScissorTest(boolean) {
        this._scissorTest = boolean;
        this.backend.setScissorTest(boolean);
      }

      /**
       * Returns the viewport definition.
       *
       * @param {Vector4} target - The method writes the result in this target object.
       * @return {Vector4} The viewport definition.
       */
    }, {
      key: "getViewport",
      value: function getViewport(target) {
        return target.copy(this._viewport);
      }

      /**
       * Defines the viewport.
       *
       * @param {Number | Vector4} x - The horizontal coordinate for the lower left corner of the viewport origin in logical pixel unit.
       * @param {Number} y - The vertical coordinate for the lower left corner of the viewport origin  in logical pixel unit.
       * @param {Number} width - The width of the viewport in logical pixel unit.
       * @param {Number} height - The height of the viewport in logical pixel unit.
       * @param {Number} minDepth - The minimum depth value of the viewport. WebGPU only.
       * @param {Number} maxDepth - The maximum depth value of the viewport. WebGPU only.
       */
    }, {
      key: "setViewport",
      value: function setViewport(x, y, width, height) {
        var minDepth = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
        var maxDepth = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 1;
        var viewport = this._viewport;
        if (x.isVector4) {
          viewport.copy(x);
        } else {
          viewport.set(x, y, width, height);
        }
        viewport.minDepth = minDepth;
        viewport.maxDepth = maxDepth;
      }

      /**
       * Returns the clear color.
       *
       * @param {Color} target - The method writes the result in this target object.
       * @return {Color} The clear color.
       */
    }, {
      key: "getClearColor",
      value: function getClearColor(target) {
        return target.copy(this._clearColor);
      }

      /**
       * Defines the clear color and optionally the clear alpha.
       *
       * @param {Color} color - The clear color.
       * @param {Number} [alpha=1] - The clear alpha.
       */
    }, {
      key: "setClearColor",
      value: function setClearColor(color) {
        var alpha = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
        this._clearColor.set(color);
        this._clearColor.a = alpha;
      }

      /**
       * Returns the clear alpha.
       *
       * @return {Number} The clear alpha.
       */
    }, {
      key: "getClearAlpha",
      value: function getClearAlpha() {
        return this._clearColor.a;
      }

      /**
       * Defines the clear alpha.
       *
       * @param {Number} alpha - The clear alpha.
       */
    }, {
      key: "setClearAlpha",
      value: function setClearAlpha(alpha) {
        this._clearColor.a = alpha;
      }

      /**
       * Returns the clear depth.
       *
       * @return {Number} The clear depth.
       */
    }, {
      key: "getClearDepth",
      value: function getClearDepth() {
        return this._clearDepth;
      }

      /**
       * Defines the clear depth.
       *
       * @param {Number} depth - The clear depth.
       */
    }, {
      key: "setClearDepth",
      value: function setClearDepth(depth) {
        this._clearDepth = depth;
      }

      /**
       * Returns the clear stencil.
       *
       * @return {Number} The clear stencil.
       */
    }, {
      key: "getClearStencil",
      value: function getClearStencil() {
        return this._clearStencil;
      }

      /**
       * Defines the clear stencil.
       *
       * @param {Number} stencil - The clear stencil.
       */
    }, {
      key: "setClearStencil",
      value: function setClearStencil(stencil) {
        this._clearStencil = stencil;
      }

      /**
       * This method performs an occlusion query for the given 3D object.
       * It returns `true` if the given 3D object is fully occluded by other
       * 3D objects in the scene.
       *
       * @param {Object3D} object - The 3D object to test.
       * @return {Boolean} Whether the 3D object is fully occluded or not.
       */
    }, {
      key: "isOccluded",
      value: function isOccluded(object) {
        var renderContext = this._currentRenderContext;
        return renderContext && this.backend.isOccluded(renderContext, object);
      }

      /**
       * Performs a manual clear operation. This method ignores `autoClear` properties.
       *
       * @param {Boolean} [color=true] - Whether the color buffer should be cleared or not.
       * @param {Boolean} [depth=true] - Whether the depth buffer should be cleared or not.
       * @param {Boolean} [stencil=true] - Whether the stencil buffer should be cleared or not.
       * @return {Promise} A Promise that resolves when the clear operation has been executed.
       * Only returned when the renderer has not been initialized.
       */
    }, {
      key: "clear",
      value: function clear() {
        var color = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
        var depth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
        var stencil = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
        if (this._initialized === false) {
          console.warn('THREE.Renderer: .clear() called before the backend is initialized. Try using .clearAsync() instead.');
          return this.clearAsync(color, depth, stencil);
        }
        var renderTarget = this._renderTarget || this._getFrameBufferTarget();
        var renderContext = null;
        if (renderTarget !== null) {
          this._textures.updateRenderTarget(renderTarget);
          var renderTargetData = this._textures.get(renderTarget);
          renderContext = this._renderContexts.get(null, null, renderTarget);
          renderContext.textures = renderTargetData.textures;
          renderContext.depthTexture = renderTargetData.depthTexture;
          renderContext.width = renderTargetData.width;
          renderContext.height = renderTargetData.height;
          renderContext.renderTarget = renderTarget;
          renderContext.depth = renderTarget.depthBuffer;
          renderContext.stencil = renderTarget.stencilBuffer;
        }
        this.backend.clear(color, depth, stencil, renderContext);
        if (renderTarget !== null && this._renderTarget === null) {
          // If a color space transform or tone mapping is required,
          // the clear operation clears the intermediate renderTarget texture, but does not update the screen canvas.

          var quad = this._quad;
          if (this._nodes.hasOutputChange(renderTarget.texture)) {
            quad.material.fragmentNode = this._nodes.getOutputNode(renderTarget.texture);
            quad.material.needsUpdate = true;
          }
          this._renderScene(quad, quad.camera, false);
        }
      }

      /**
       * Performs a manual clear operation of the color buffer. This method ignores `autoClear` properties.
       *
       * @return {Promise} A Promise that resolves when the clear operation has been executed.
       * Only returned when the renderer has not been initialized.
       */
    }, {
      key: "clearColor",
      value: function clearColor() {
        return this.clear(true, false, false);
      }

      /**
       * Performs a manual clear operation of the depth buffer. This method ignores `autoClear` properties.
       *
       * @return {Promise} A Promise that resolves when the clear operation has been executed.
       * Only returned when the renderer has not been initialized.
       */
    }, {
      key: "clearDepth",
      value: function clearDepth() {
        return this.clear(false, true, false);
      }

      /**
       * Performs a manual clear operation of the stencil buffer. This method ignores `autoClear` properties.
       *
       * @return {Promise} A Promise that resolves when the clear operation has been executed.
       * Only returned when the renderer has not been initialized.
       */
    }, {
      key: "clearStencil",
      value: function clearStencil() {
        return this.clear(false, false, true);
      }

      /**
       * Async version of {@link module:Renderer~Renderer#clear}.
       *
       * @async
       * @param {Boolean} [color=true] - Whether the color buffer should be cleared or not.
       * @param {Boolean} [depth=true] - Whether the depth buffer should be cleared or not.
       * @param {Boolean} [stencil=true] - Whether the stencil buffer should be cleared or not.
       * @return {Promise} A Promise that resolves when the clear operation has been executed.
       */
    }, {
      key: "clearAsync",
      value: (function () {
        var _clearAsync = (0, _asyncToGenerator2.default)(function* () {
          var color = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
          var depth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
          var stencil = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
          if (this._initialized === false) yield this.init();
          this.clear(color, depth, stencil);
        });
        function clearAsync() {
          return _clearAsync.apply(this, arguments);
        }
        return clearAsync;
      }()
      /**
       * Async version of {@link module:Renderer~Renderer#clearColor}.
       *
       * @async
       * @return {Promise} A Promise that resolves when the clear operation has been executed.
       */
      )
    }, {
      key: "clearColorAsync",
      value: (function () {
        var _clearColorAsync = (0, _asyncToGenerator2.default)(function* () {
          this.clearAsync(true, false, false);
        });
        function clearColorAsync() {
          return _clearColorAsync.apply(this, arguments);
        }
        return clearColorAsync;
      }()
      /**
       * Async version of {@link module:Renderer~Renderer#clearDepth}.
       *
       * @async
       * @return {Promise} A Promise that resolves when the clear operation has been executed.
       */
      )
    }, {
      key: "clearDepthAsync",
      value: (function () {
        var _clearDepthAsync = (0, _asyncToGenerator2.default)(function* () {
          this.clearAsync(false, true, false);
        });
        function clearDepthAsync() {
          return _clearDepthAsync.apply(this, arguments);
        }
        return clearDepthAsync;
      }()
      /**
       * Async version of {@link module:Renderer~Renderer#clearStencil}.
       *
       * @async
       * @return {Promise} A Promise that resolves when the clear operation has been executed.
       */
      )
    }, {
      key: "clearStencilAsync",
      value: (function () {
        var _clearStencilAsync = (0, _asyncToGenerator2.default)(function* () {
          this.clearAsync(false, false, true);
        });
        function clearStencilAsync() {
          return _clearStencilAsync.apply(this, arguments);
        }
        return clearStencilAsync;
      }()
      /**
       * The current output tone mapping of the renderer. When a render target is set,
       * the output tone mapping is always `NoToneMapping`.
       *
       * @type {Number}
       */
      )
    }, {
      key: "currentToneMapping",
      get: function get() {
        return this._renderTarget !== null ? _$$_REQUIRE(_dependencyMap[1], "./three.core.js").NoToneMapping : this.toneMapping;
      }

      /**
       * The current output color space of the renderer. When a render target is set,
       * the output color space is always `LinearSRGBColorSpace`.
       *
       * @type {String}
       */
    }, {
      key: "currentColorSpace",
      get: function get() {
        return this._renderTarget !== null ? _$$_REQUIRE(_dependencyMap[1], "./three.core.js").LinearSRGBColorSpace : this.outputColorSpace;
      }

      /**
       * Frees all internal resources of the renderer. Call this method if the renderer
       * is no longer in use by your app.
       */
    }, {
      key: "dispose",
      value: function dispose() {
        this.info.dispose();
        this.backend.dispose();
        this._animation.dispose();
        this._objects.dispose();
        this._pipelines.dispose();
        this._nodes.dispose();
        this._bindings.dispose();
        this._renderLists.dispose();
        this._renderContexts.dispose();
        this._textures.dispose();
        this.setRenderTarget(null);
        this.setAnimationLoop(null);
      }

      /**
       * Sets the given render target. Calling this method means the renderer does not
       * target the default framebuffer (meaning the canvas) anymore but a custom framebuffer.
       * Use `null` as the first argument to reset the state.
       *
       * @param {RenderTarget?} renderTarget - The render target to set.
       * @param {Number} [activeCubeFace=0] - The active cube face.
       * @param {Number} [activeMipmapLevel=0] - The active mipmap level.
       */
    }, {
      key: "setRenderTarget",
      value: function setRenderTarget(renderTarget) {
        var activeCubeFace = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        var activeMipmapLevel = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
        this._renderTarget = renderTarget;
        this._activeCubeFace = activeCubeFace;
        this._activeMipmapLevel = activeMipmapLevel;
      }

      /**
       * Returns the current render target.
       *
       * @return {RenderTarget?} The render target. Returns `null` if no render target is set.
       */
    }, {
      key: "getRenderTarget",
      value: function getRenderTarget() {
        return this._renderTarget;
      }

      /**
       * Callback for {@link module:Renderer~Renderer#setRenderObjectFunction}.
       *
       * @callback renderObjectFunction
       * @param {Object3D} object - The 3D object.
       * @param {Scene} scene - The scene the 3D object belongs to.
       * @param {Camera} camera - The camera the object should be rendered with.
       * @param {BufferGeometry} geometry - The object's geometry.
       * @param {Material} material - The object's material.
       * @param {Object?} group - Only relevant for objects using multiple materials. This represents a group entry from the respective `BufferGeometry`.
       * @param {LightsNode} lightsNode - The current lights node.
       * @param {ClippingContext} clippingContext - The clipping context.
       * @param {String?} [passId=null] - An optional ID for identifying the pass.
       */

      /**
       * Sets the given render object function. Calling this method overwrites the default implementation
       * which is {@link module:Renderer~Renderer#renderObject}. Defining a custom function can be useful
       * if you want to modify the way objects are rendered. For example you can define things like "every
       * object that has material of a certain type should perform a pre-pass with a special overwrite material".
       * The custom function must always call `renderObject()` in its implementation.
       *
       * Use `null` as the first argument to reset the state.
       *
       * @param {module:Renderer~renderObjectFunction?} renderObjectFunction - The render object function.
       */
    }, {
      key: "setRenderObjectFunction",
      value: function setRenderObjectFunction(renderObjectFunction) {
        this._renderObjectFunction = renderObjectFunction;
      }

      /**
       * Returns the current render object function.
       *
       * @return {Function?} The current render object function. Returns `null` if no function is set.
       */
    }, {
      key: "getRenderObjectFunction",
      value: function getRenderObjectFunction() {
        return this._renderObjectFunction;
      }

      /**
       * Execute a single or an array of compute nodes. This method can only be called
       * if the renderer has been initialized.
       *
       * @param {Node|Array<Node>} computeNodes - The compute node(s).
       * @return {Promise?} A Promise that resolve when the compute has finished. Only returned when the renderer has not been initialized.
       */
    }, {
      key: "compute",
      value: function compute(computeNodes) {
        var _this193 = this;
        if (this.isDeviceLost === true) return;
        if (this._initialized === false) {
          console.warn('THREE.Renderer: .compute() called before the backend is initialized. Try using .computeAsync() instead.');
          return this.computeAsync(computeNodes);
        }

        //

        var nodeFrame = this._nodes.nodeFrame;
        var previousRenderId = nodeFrame.renderId;

        //

        this.info.calls++;
        this.info.compute.calls++;
        this.info.compute.frameCalls++;
        nodeFrame.renderId = this.info.calls;

        //

        var backend = this.backend;
        var pipelines = this._pipelines;
        var bindings = this._bindings;
        var nodes = this._nodes;
        var computeList = Array.isArray(computeNodes) ? computeNodes : [computeNodes];
        if (computeList[0] === undefined || computeList[0].isComputeNode !== true) {
          throw new Error('THREE.Renderer: .compute() expects a ComputeNode.');
        }
        backend.beginCompute(computeNodes);
        var _loop = function _loop(computeNode) {
          // onInit

          if (pipelines.has(computeNode) === false) {
            var _dispose2 = function dispose() {
              computeNode.removeEventListener('dispose', _dispose2);
              pipelines.delete(computeNode);
              bindings.delete(computeNode);
              nodes.delete(computeNode);
            };
            computeNode.addEventListener('dispose', _dispose2);

            //

            var onInitFn = computeNode.onInitFunction;
            if (onInitFn !== null) {
              onInitFn.call(computeNode, {
                renderer: _this193
              });
            }
          }
          nodes.updateForCompute(computeNode);
          bindings.updateForCompute(computeNode);
          var computeBindings = bindings.getForCompute(computeNode);
          var computePipeline = pipelines.getForCompute(computeNode, computeBindings);
          backend.compute(computeNodes, computeNode, computeBindings, computePipeline);
        };
        for (var computeNode of computeList) {
          _loop(computeNode);
        }
        backend.finishCompute(computeNodes);

        //

        nodeFrame.renderId = previousRenderId;
      }

      /**
       * Execute a single or an array of compute nodes.
       *
       * @async
       * @param {Node|Array<Node>} computeNodes - The compute node(s).
       * @return {Promise?} A Promise that resolve when the compute has finished.
       */
    }, {
      key: "computeAsync",
      value: (function () {
        var _computeAsync = (0, _asyncToGenerator2.default)(function* (computeNodes) {
          if (this._initialized === false) yield this.init();
          this.compute(computeNodes);
          yield this.backend.resolveTimestampAsync(computeNodes, 'compute');
        });
        function computeAsync(_x19) {
          return _computeAsync.apply(this, arguments);
        }
        return computeAsync;
      }()
      /**
       * Checks if the given feature is supported by the selected backend.
       *
       * @async
       * @param {String} name - The feature's name.
       * @return {Promise<Boolean>} A Promise that resolves with a bool that indicates whether the feature is supported or not.
       */
      )
    }, {
      key: "hasFeatureAsync",
      value: (function () {
        var _hasFeatureAsync = (0, _asyncToGenerator2.default)(function* (name) {
          if (this._initialized === false) yield this.init();
          return this.backend.hasFeature(name);
        });
        function hasFeatureAsync(_x20) {
          return _hasFeatureAsync.apply(this, arguments);
        }
        return hasFeatureAsync;
      }()
      /**
       * Checks if the given feature is supported by the selected backend. If the
       * renderer has not been initialized, this method always returns `false`.
       *
       * @param {String} name - The feature's name.
       * @return {Boolean} Whether the feature is supported or not.
       */
      )
    }, {
      key: "hasFeature",
      value: function hasFeature(name) {
        if (this._initialized === false) {
          console.warn('THREE.Renderer: .hasFeature() called before the backend is initialized. Try using .hasFeatureAsync() instead.');
          return false;
        }
        return this.backend.hasFeature(name);
      }

      /**
       * Returns `true` when the renderer has been initialized.
       *
       * @return {Boolean} Whether the renderer has been initialized or not.
       */
    }, {
      key: "hasInitialized",
      value: function hasInitialized() {
        return this._initialized;
      }

      /**
       * Initializes the given textures. Useful for preloading a texture rather than waiting until first render
       * (which can cause noticeable lags due to decode and GPU upload overhead).
       *
       * @async
       * @param {Texture} texture - The texture.
       * @return {Promise} A Promise that resolves when the texture has been initialized.
       */
    }, {
      key: "initTextureAsync",
      value: (function () {
        var _initTextureAsync = (0, _asyncToGenerator2.default)(function* (texture) {
          if (this._initialized === false) yield this.init();
          this._textures.updateTexture(texture);
        });
        function initTextureAsync(_x21) {
          return _initTextureAsync.apply(this, arguments);
        }
        return initTextureAsync;
      }()
      /**
       * Initializes the given textures. Useful for preloading a texture rather than waiting until first render
       * (which can cause noticeable lags due to decode and GPU upload overhead).
       *
       * This method can only be used if the renderer has been initialized.
       *
       * @param {Texture} texture - The texture.
       */
      )
    }, {
      key: "initTexture",
      value: function initTexture(texture) {
        if (this._initialized === false) {
          console.warn('THREE.Renderer: .initTexture() called before the backend is initialized. Try using .initTextureAsync() instead.');
        }
        this._textures.updateTexture(texture);
      }

      /**
       * Copies the current bound framebuffer into the given texture.
       *
       * @param {FramebufferTexture} framebufferTexture - The texture.
       * @param {Vector2|Vector4} rectangle - A two or four dimensional vector that defines the rectangular portion of the framebuffer that should be copied.
       */
    }, {
      key: "copyFramebufferToTexture",
      value: function copyFramebufferToTexture(framebufferTexture) {
        var rectangle = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
        if (rectangle !== null) {
          if (rectangle.isVector2) {
            rectangle = _vector4.set(rectangle.x, rectangle.y, framebufferTexture.image.width, framebufferTexture.image.height).floor();
          } else if (rectangle.isVector4) {
            rectangle = _vector4.copy(rectangle).floor();
          } else {
            console.error('THREE.Renderer.copyFramebufferToTexture: Invalid rectangle.');
            return;
          }
        } else {
          rectangle = _vector4.set(0, 0, framebufferTexture.image.width, framebufferTexture.image.height);
        }

        //

        var renderContext = this._currentRenderContext;
        var renderTarget;
        if (renderContext !== null) {
          renderTarget = renderContext.renderTarget;
        } else {
          renderTarget = this._renderTarget || this._getFrameBufferTarget();
          if (renderTarget !== null) {
            this._textures.updateRenderTarget(renderTarget);
            renderContext = this._textures.get(renderTarget);
          }
        }

        //

        this._textures.updateTexture(framebufferTexture, {
          renderTarget: renderTarget
        });
        this.backend.copyFramebufferToTexture(framebufferTexture, renderContext, rectangle);
      }

      /**
       * Copies data of source texture into a destination texture.
       *
       * @param {Texture} srcTexture - The source texture.
       * @param {Texture} dstTexture - The destination texture.
       * @param {Box2|Box3} [srcRegion=null] - A bounding box which describes the source region. Can be two or three-dimensional.
       * @param {Vector2|Vector3} [dstPosition=null] - A vector that represents the origin of the destination region. Can be two or three-dimensional.
       * @param {Number} level - The mipmap level to copy.
       */
    }, {
      key: "copyTextureToTexture",
      value: function copyTextureToTexture(srcTexture, dstTexture) {
        var srcRegion = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
        var dstPosition = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
        var level = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
        this._textures.updateTexture(srcTexture);
        this._textures.updateTexture(dstTexture);
        this.backend.copyTextureToTexture(srcTexture, dstTexture, srcRegion, dstPosition, level);
      }

      /**
       * Reads pixel data from the given render target.
       *
       * @async
       * @param {RenderTarget} renderTarget - The render target to read from.
       * @param {Number} x - The `x` coordinate of the copy region's origin.
       * @param {Number} y - The `y` coordinate of the copy region's origin.
       * @param {Number} width - The width of the copy region.
       * @param {Number} height - The height of the copy region.
       * @param {Number} [textureIndex=0] - The texture index of a MRT render target.
       * @param {Number} [faceIndex=0] - The active cube face index.
       * @return {Promise<TypedArray>} A Promise that resolves when the read has been finished. The resolve provides the read data as a typed array.
       */
    }, {
      key: "readRenderTargetPixelsAsync",
      value: (function () {
        var _readRenderTargetPixelsAsync = (0, _asyncToGenerator2.default)(function* (renderTarget, x, y, width, height) {
          var textureIndex = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;
          var faceIndex = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 0;
          return this.backend.copyTextureToBuffer(renderTarget.textures[textureIndex], x, y, width, height, faceIndex);
        });
        function readRenderTargetPixelsAsync(_x22, _x23, _x24, _x25, _x26) {
          return _readRenderTargetPixelsAsync.apply(this, arguments);
        }
        return readRenderTargetPixelsAsync;
      }()
      /**
       * Analyzes the given 3D object's hierarchy and builds render lists from the
       * processed hierarchy.
       *
       * @param {Object3D} object - The 3D object to process (usually a scene).
       * @param {Camera} camera - The camera the object is rendered with.
       * @param {Number} groupOrder - The group order is derived from the `renderOrder` of groups and is used to group 3D objects within groups.
       * @param {RenderList} renderList - The current render list.
       * @param {ClippingContext} clippingContext - The current clipping context.
       */
      )
    }, {
      key: "_projectObject",
      value: function _projectObject(object, camera, groupOrder, renderList, clippingContext) {
        if (object.visible === false) return;
        var visible = object.layers.test(camera.layers);
        if (visible) {
          if (object.isGroup) {
            groupOrder = object.renderOrder;
            if (object.isClippingGroup && object.enabled) clippingContext = clippingContext.getGroupContext(object);
          } else if (object.isLOD) {
            if (object.autoUpdate === true) object.update(camera);
          } else if (object.isLight) {
            renderList.pushLight(object);
          } else if (object.isSprite) {
            if (!object.frustumCulled || _frustum.intersectsSprite(object)) {
              if (this.sortObjects === true) {
                _vector4.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix);
              }
              var geometry = object.geometry,
                material = object.material;
              if (material.visible) {
                renderList.push(object, geometry, material, groupOrder, _vector4.z, null, clippingContext);
              }
            }
          } else if (object.isLineLoop) {
            console.error('THREE.Renderer: Objects of type THREE.LineLoop are not supported. Please use THREE.Line or THREE.LineSegments.');
          } else if (object.isMesh || object.isLine || object.isPoints) {
            if (!object.frustumCulled || _frustum.intersectsObject(object)) {
              var _geometry2 = object.geometry,
                _material2 = object.material;
              if (this.sortObjects === true) {
                if (_geometry2.boundingSphere === null) _geometry2.computeBoundingSphere();
                _vector4.copy(_geometry2.boundingSphere.center).applyMatrix4(object.matrixWorld).applyMatrix4(_projScreenMatrix);
              }
              if (Array.isArray(_material2)) {
                var groups = _geometry2.groups;
                for (var i = 0, l = groups.length; i < l; i++) {
                  var group = groups[i];
                  var groupMaterial = _material2[group.materialIndex];
                  if (groupMaterial && groupMaterial.visible) {
                    renderList.push(object, _geometry2, groupMaterial, groupOrder, _vector4.z, group, clippingContext);
                  }
                }
              } else if (_material2.visible) {
                renderList.push(object, _geometry2, _material2, groupOrder, _vector4.z, null, clippingContext);
              }
            }
          }
        }
        if (object.isBundleGroup === true && this.backend.beginBundle !== undefined) {
          var baseRenderList = renderList;

          // replace render list
          renderList = this._renderLists.get(object, camera);
          renderList.begin();
          baseRenderList.pushBundle({
            bundleGroup: object,
            camera: camera,
            renderList: renderList
          });
          renderList.finish();
        }
        var children = object.children;
        for (var _i12 = 0, _l3 = children.length; _i12 < _l3; _i12++) {
          this._projectObject(children[_i12], camera, groupOrder, renderList, clippingContext);
        }
      }

      /**
       * Renders the given render bundles.
       *
       * @private
       * @param {Array<Object>} bundles - Array with render bundle data.
       * @param {Scene} sceneRef - The scene the render bundles belong to.
       * @param {LightsNode} lightsNode - The current lights node.
       */
    }, {
      key: "_renderBundles",
      value: function _renderBundles(bundles, sceneRef, lightsNode) {
        for (var bundle of bundles) {
          this._renderBundle(bundle, sceneRef, lightsNode);
        }
      }

      /**
       * Renders the transparent objects from the given render lists.
       *
       * @private
       * @param {Array<Object>} renderList - The transparent render list.
       * @param {Array<Object>} doublePassList - The list of transparent objects which require a double pass (e.g. because of transmission).
       * @param {Camera} camera - The camera the render list should be rendered with.
       * @param {Scene} scene - The scene the render list belongs to.
       * @param {LightsNode} lightsNode - The current lights node.
       */
    }, {
      key: "_renderTransparents",
      value: function _renderTransparents(renderList, doublePassList, camera, scene, lightsNode) {
        if (doublePassList.length > 0) {
          // render back side

          for (var _ref338 of doublePassList) {
            var material = _ref338.material;
            material.side = _$$_REQUIRE(_dependencyMap[1], "./three.core.js").BackSide;
          }
          this._renderObjects(doublePassList, camera, scene, lightsNode, 'backSide');

          // render front side

          for (var _ref339 of doublePassList) {
            var _material3 = _ref339.material;
            _material3.side = _$$_REQUIRE(_dependencyMap[1], "./three.core.js").FrontSide;
          }
          this._renderObjects(renderList, camera, scene, lightsNode);

          // restore

          for (var _ref340 of doublePassList) {
            var _material4 = _ref340.material;
            _material4.side = _$$_REQUIRE(_dependencyMap[1], "./three.core.js").DoubleSide;
          }
        } else {
          this._renderObjects(renderList, camera, scene, lightsNode);
        }
      }

      /**
       * Renders the objects from the given render list.
       *
       * @private
       * @param {Array<Object>} renderList - The render list.
       * @param {Camera} camera - The camera the render list should be rendered with.
       * @param {Scene} scene - The scene the render list belongs to.
       * @param {LightsNode} lightsNode - The current lights node.
       * @param {String?} [passId=null] - An optional ID for identifying the pass.
       */
    }, {
      key: "_renderObjects",
      value: function _renderObjects(renderList, camera, scene, lightsNode) {
        var passId = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;
        // process renderable objects

        for (var i = 0, il = renderList.length; i < il; i++) {
          var renderItem = renderList[i];

          // @TODO: Add support for multiple materials per object. This will require to extract
          // the material from the renderItem object and pass it with its group data to renderObject().

          var object = renderItem.object,
            geometry = renderItem.geometry,
            material = renderItem.material,
            group = renderItem.group,
            clippingContext = renderItem.clippingContext;
          if (camera.isArrayCamera) {
            var cameras = camera.cameras;
            for (var j = 0, jl = cameras.length; j < jl; j++) {
              var camera2 = cameras[j];
              if (object.layers.test(camera2.layers)) {
                var vp = camera2.viewport;
                var minDepth = vp.minDepth === undefined ? 0 : vp.minDepth;
                var maxDepth = vp.maxDepth === undefined ? 1 : vp.maxDepth;
                var viewportValue = this._currentRenderContext.viewportValue;
                viewportValue.copy(vp).multiplyScalar(this._pixelRatio).floor();
                viewportValue.minDepth = minDepth;
                viewportValue.maxDepth = maxDepth;
                this.backend.updateViewport(this._currentRenderContext);
                this._currentRenderObjectFunction(object, scene, camera2, geometry, material, group, lightsNode, clippingContext, passId);
              }
            }
          } else {
            this._currentRenderObjectFunction(object, scene, camera, geometry, material, group, lightsNode, clippingContext, passId);
          }
        }
      }

      /**
       * This method represents the default render object function that manages the render lifecycle
       * of the object.
       *
       * @param {Object3D} object - The 3D object.
       * @param {Scene} scene - The scene the 3D object belongs to.
       * @param {Camera} camera - The camera the object should be rendered with.
       * @param {BufferGeometry} geometry - The object's geometry.
       * @param {Material} material - The object's material.
       * @param {Object?} group - Only relevant for objects using multiple materials. This represents a group entry from the respective `BufferGeometry`.
       * @param {LightsNode} lightsNode - The current lights node.
       * @param {ClippingContext} clippingContext - The clipping context.
       * @param {String?} [passId=null] - An optional ID for identifying the pass.
       */
    }, {
      key: "renderObject",
      value: function renderObject(object, scene, camera, geometry, material, group, lightsNode) {
        var clippingContext = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : null;
        var passId = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : null;
        var overridePositionNode;
        var overrideColorNode;
        var overrideDepthNode;

        //

        object.onBeforeRender(this, scene, camera, geometry, material, group);

        //

        if (scene.overrideMaterial !== null) {
          var overrideMaterial = scene.overrideMaterial;
          if (material.positionNode && material.positionNode.isNode) {
            overridePositionNode = overrideMaterial.positionNode;
            overrideMaterial.positionNode = material.positionNode;
          }
          overrideMaterial.alphaTest = material.alphaTest;
          overrideMaterial.alphaMap = material.alphaMap;
          overrideMaterial.transparent = material.transparent || material.transmission > 0;
          if (overrideMaterial.isShadowNodeMaterial) {
            overrideMaterial.side = material.shadowSide === null ? material.side : material.shadowSide;
            if (material.depthNode && material.depthNode.isNode) {
              overrideDepthNode = overrideMaterial.depthNode;
              overrideMaterial.depthNode = material.depthNode;
            }
            if (material.castShadowNode && material.castShadowNode.isNode) {
              overrideColorNode = overrideMaterial.colorNode;
              overrideMaterial.colorNode = material.castShadowNode;
            }
          }
          material = overrideMaterial;
        }

        //

        if (material.transparent === true && material.side === _$$_REQUIRE(_dependencyMap[1], "./three.core.js").DoubleSide && material.forceSinglePass === false) {
          material.side = _$$_REQUIRE(_dependencyMap[1], "./three.core.js").BackSide;
          this._handleObjectFunction(object, material, scene, camera, lightsNode, group, clippingContext, 'backSide'); // create backSide pass id

          material.side = _$$_REQUIRE(_dependencyMap[1], "./three.core.js").FrontSide;
          this._handleObjectFunction(object, material, scene, camera, lightsNode, group, clippingContext, passId); // use default pass id

          material.side = _$$_REQUIRE(_dependencyMap[1], "./three.core.js").DoubleSide;
        } else {
          this._handleObjectFunction(object, material, scene, camera, lightsNode, group, clippingContext, passId);
        }

        //

        if (overridePositionNode !== undefined) {
          scene.overrideMaterial.positionNode = overridePositionNode;
        }
        if (overrideDepthNode !== undefined) {
          scene.overrideMaterial.depthNode = overrideDepthNode;
        }
        if (overrideColorNode !== undefined) {
          scene.overrideMaterial.colorNode = overrideColorNode;
        }

        //

        object.onAfterRender(this, scene, camera, geometry, material, group);
      }

      /**
       * This method represents the default `_handleObjectFunction` implementation which creates
       * a render object from the given data and performs the draw command with the selected backend.
       *
       * @private
       * @param {Object3D} object - The 3D object.
       * @param {Material} material - The object's material.
       * @param {Scene} scene - The scene the 3D object belongs to.
       * @param {Camera} camera - The camera the object should be rendered with.
       * @param {LightsNode} lightsNode - The current lights node.
       * @param {Object?} group - Only relevant for objects using multiple materials. This represents a group entry from the respective `BufferGeometry`.
       * @param {ClippingContext} clippingContext - The clipping context.
       * @param {String?} [passId=null] - An optional ID for identifying the pass.
       */
    }, {
      key: "_renderObjectDirect",
      value: function _renderObjectDirect(object, material, scene, camera, lightsNode, group, clippingContext, passId) {
        var renderObject = this._objects.get(object, material, scene, camera, lightsNode, this._currentRenderContext, clippingContext, passId);
        renderObject.drawRange = object.geometry.drawRange;
        renderObject.group = group;

        //

        var needsRefresh = this._nodes.needsRefresh(renderObject);
        if (needsRefresh) {
          this._nodes.updateBefore(renderObject);
          this._geometries.updateForRender(renderObject);
          this._nodes.updateForRender(renderObject);
          this._bindings.updateForRender(renderObject);
        }
        this._pipelines.updateForRender(renderObject);

        //

        if (this._currentRenderBundle !== null) {
          var renderBundleData = this.backend.get(this._currentRenderBundle);
          renderBundleData.renderObjects.push(renderObject);
          renderObject.bundle = this._currentRenderBundle.bundleGroup;
        }
        this.backend.draw(renderObject, this.info);
        if (needsRefresh) this._nodes.updateAfter(renderObject);
      }

      /**
       * A different implementation for `_handleObjectFunction` which only makes sure the object is ready for rendering.
       * Used in `compileAsync()`.
       *
       * @private
       * @param {Object3D} object - The 3D object.
       * @param {Material} material - The object's material.
       * @param {Scene} scene - The scene the 3D object belongs to.
       * @param {Camera} camera - The camera the object should be rendered with.
       * @param {LightsNode} lightsNode - The current lights node.
       * @param {Object?} group - Only relevant for objects using multiple materials. This represents a group entry from the respective `BufferGeometry`.
       * @param {ClippingContext} clippingContext - The clipping context.
       * @param {String?} [passId=null] - An optional ID for identifying the pass.
       */
    }, {
      key: "_createObjectPipeline",
      value: function _createObjectPipeline(object, material, scene, camera, lightsNode, group, clippingContext, passId) {
        var renderObject = this._objects.get(object, material, scene, camera, lightsNode, this._currentRenderContext, clippingContext, passId);
        renderObject.drawRange = object.geometry.drawRange;
        renderObject.group = group;

        //

        this._nodes.updateBefore(renderObject);
        this._geometries.updateForRender(renderObject);
        this._nodes.updateForRender(renderObject);
        this._bindings.updateForRender(renderObject);
        this._pipelines.getForRender(renderObject, this._compilationPromises);
        this._nodes.updateAfter(renderObject);
      }

      /**
       * Alias for `compileAsync()`.
       *
       * @method
       * @param {Object3D} scene - The scene or 3D object to precompile.
       * @param {Camera} camera - The camera that is used to render the scene.
       * @param {Scene} targetScene - If the first argument is a 3D object, this parameter must represent the scene the 3D object is going to be added.
       * @return {Promise} A Promise that resolves when the compile has been finished.
       */
    }, {
      key: "compile",
      get: function get() {
        return this.compileAsync;
      }
    }]);
  }();
  /**
   * A binding represents the connection between a resource (like a texture, sampler
   * or uniform buffer) and the resource definition in a shader stage.
   *
   * This module is an abstract base class for all concrete bindings types.
   *
   * @abstract
   * @private
   */
  var Binding = /*#__PURE__*/function () {
    /**
     * Constructs a new binding.
     *
     * @param {String} [name=''] - The binding's name.
     */
    function Binding() {
      var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
      (0, _classCallCheck2.default)(this, Binding);
      /**
       * The binding's name.
       *
       * @type {String}
       */
      this.name = name;

      /**
       * A bitmask that defines in what shader stages the
       * binding's resource is accessible.
       *
       * @type {String}
       */
      this.visibility = 0;
    }

    /**
     * Makes sure binding's resource is visible for the given shader stage.
     *
     * @param {Number} visibility - The shader stage.
     */
    return (0, _createClass2.default)(Binding, [{
      key: "setVisibility",
      value: function setVisibility(visibility) {
        this.visibility |= visibility;
      }

      /**
       * Clones the binding.
       *
       * @return {Binding} The cloned binding.
       */
    }, {
      key: "clone",
      value: function clone() {
        return Object.assign(new this.constructor(), this);
      }
    }]);
  }();
  /** @module BufferUtils **/
  /**
   * This function is usually called with the length in bytes of an array buffer.
   * It returns an padded value whic ensure chunk size alignment according to STD140 layout.
   *
   * @function
   * @param {Number} floatLength - The buffer length.
   * @return {Number} The padded length.
   */
  function getFloatLength(floatLength) {
    // ensure chunk size alignment (STD140 layout)

    return floatLength + (GPU_CHUNK_BYTES - floatLength % GPU_CHUNK_BYTES) % GPU_CHUNK_BYTES;
  }

  /**
   * Represents a buffer binding type.
   *
   * @private
   * @abstract
   * @augments Binding
   */
  var Buffer = /*#__PURE__*/function (_Binding) {
    /**
     * Constructs a new buffer.
     *
     * @param {String} name - The buffer's name.
     * @param {TypedArray} [buffer=null] - The buffer.
     */
    function Buffer(name) {
      var _this194;
      var buffer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      (0, _classCallCheck2.default)(this, Buffer);
      _this194 = _callSuper(this, Buffer, [name]);

      /**
       * This flag can be used for type testing.
       *
       * @type {Boolean}
       * @readonly
       * @default true
       */
      _this194.isBuffer = true;

      /**
       * The bytes per element.
       *
       * @type {Number}
       */
      _this194.bytesPerElement = Float32Array.BYTES_PER_ELEMENT;

      /**
       * A reference to the internal buffer.
       *
       * @private
       * @type {TypedArray}
       */
      _this194._buffer = buffer;
      return _this194;
    }

    /**
     * The buffer's byte length.
     *
     * @type {Number}
     * @readonly
     */
    (0, _inherits2.default)(Buffer, _Binding);
    return (0, _createClass2.default)(Buffer, [{
      key: "byteLength",
      get: function get() {
        return getFloatLength(this._buffer.byteLength);
      }

      /**
       * A reference to the internal buffer.
       *
       * @type {Float32Array}
       * @readonly
       */
    }, {
      key: "buffer",
      get: function get() {
        return this._buffer;
      }

      /**
       * Updates the binding.
       *
       * @return {Boolean} Whether the buffer has been updated and must be
       * uploaded to the GPU.
       */
    }, {
      key: "update",
      value: function update() {
        return true;
      }
    }]);
  }(Binding);
  /**
   * Represents a uniform buffer binding type.
   *
   * @private
   * @augments Buffer
   */
  var UniformBuffer = /*#__PURE__*/function (_Buffer) {
    /**
     * Constructs a new uniform buffer.
     *
     * @param {String} name - The buffer's name.
     * @param {TypedArray} [buffer=null] - The buffer.
     */
    function UniformBuffer(name) {
      var _this195;
      var buffer = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      (0, _classCallCheck2.default)(this, UniformBuffer);
      _this195 = _callSuper(this, UniformBuffer, [name, buffer]);

      /**
       * This flag can be used for type testing.
       *
       * @type {Boolean}
       * @readonly
       * @default true
       */
      _this195.isUniformBuffer = true;
      return _this195;
    }
    (0, _inherits2.default)(UniformBuffer, _Buffer);
    return (0, _createClass2.default)(UniformBuffer);
  }(Buffer);
  var _id$4 = 0;

  /**
   * A special form of uniform buffer binding type.
   * It's buffer value is managed by a node object.
   *
   * @private
   * @augments UniformBuffer
   */
  var NodeUniformBuffer = /*#__PURE__*/function (_UniformBuffer) {
    /**
     * Constructs a new node-based uniform buffer.
     *
     * @param {BufferNode} nodeUniform - The uniform buffer node.
     * @param {UniformGroupNode} groupNode - The uniform group node.
     */
    function NodeUniformBuffer(nodeUniform, groupNode) {
      var _this196;
      (0, _classCallCheck2.default)(this, NodeUniformBuffer);
      _this196 = _callSuper(this, NodeUniformBuffer, ['UniformBuffer_' + _id$4++, nodeUniform ? nodeUniform.value : null]);

      /**
       * The uniform buffer node.
       *
       * @type {BufferNode}
       */
      _this196.nodeUniform = nodeUniform;

      /**
       * The uniform group node.
       *
       * @type {UniformGroupNode}
       */
      _this196.groupNode = groupNode;
      return _this196;
    }

    /**
     * The uniform buffer.
     *
     * @type {Float32Array}
     */
    (0, _inherits2.default)(NodeUniformBuffer, _UniformBuffer);
    return (0, _createClass2.default)(NodeUniformBuffer, [{
      key: "buffer",
      get: function get() {
        return this.nodeUniform.value;
      }
    }]);
  }(UniformBuffer);
  /**
   * This class represents a uniform buffer binding but with
   * an API that allows to maintain individual uniform objects.
   *
   * @private
   * @augments UniformBuffer
   */
  var UniformsGroup = /*#__PURE__*/function (_UniformBuffer2) {
    /**
     * Constructs a new uniforms group.
     *
     * @param {String} name - The group's name.
     */
    function UniformsGroup(name) {
      var _this197;
      (0, _classCallCheck2.default)(this, UniformsGroup);
      _this197 = _callSuper(this, UniformsGroup, [name]);

      /**
       * This flag can be used for type testing.
       *
       * @type {Boolean}
       * @readonly
       * @default true
       */
      _this197.isUniformsGroup = true;

      /**
       * An array with the raw uniform values.
       *
       * @private
       * @type {Array<Number>?}
       * @default null
       */
      _this197._values = null;

      /**
       * An array of uniform objects.
       *
       * The order of uniforms in this array must match the order of uniforms in the shader.
       *
       * @type {Array<Uniform>}
       */
      _this197.uniforms = [];
      return _this197;
    }

    /**
     * Adds a uniform to this group.
     *
     * @param {Uniform} uniform - The uniform to add.
     * @return {UniformsGroup} A reference to this group.
     */
    (0, _inherits2.default)(UniformsGroup, _UniformBuffer2);
    return (0, _createClass2.default)(UniformsGroup, [{
      key: "addUniform",
      value: function addUniform(uniform) {
        this.uniforms.push(uniform);
        return this;
      }

      /**
       * Removes a uniform from this group.
       *
       * @param {Uniform} uniform - The uniform to remove.
       * @return {UniformsGroup} A reference to this group.
       */
    }, {
      key: "removeUniform",
      value: function removeUniform(uniform) {
        var index = this.uniforms.indexOf(uniform);
        if (index !== -1) {
          this.uniforms.splice(index, 1);
        }
        return this;
      }

      /**
       * An array with the raw uniform values.
       *
       * @type {Array<Number>}
       */
    }, {
      key: "values",
      get: function get() {
        if (this._values === null) {
          this._values = Array.from(this.buffer);
        }
        return this._values;
      }

      /**
       * A Float32 array buffer with the uniform values.
       *
       * @type {Float32Array}
       */
    }, {
      key: "buffer",
      get: function get() {
        var buffer = this._buffer;
        if (buffer === null) {
          var byteLength = this.byteLength;
          buffer = new Float32Array(new ArrayBuffer(byteLength));
          this._buffer = buffer;
        }
        return buffer;
      }

      /**
       * The byte length of the buffer with correct buffer alignment.
       *
       * @type {Number}
       */
    }, {
      key: "byteLength",
      get: function get() {
        var offset = 0; // global buffer offset in bytes

        for (var i = 0, l = this.uniforms.length; i < l; i++) {
          var _uniform = this.uniforms[i];
          var boundary = _uniform.boundary,
            itemSize = _uniform.itemSize;

          // offset within a single chunk in bytes

          var chunkOffset = offset % GPU_CHUNK_BYTES;
          var remainingSizeInChunk = GPU_CHUNK_BYTES - chunkOffset;

          // conformance tests

          if (chunkOffset !== 0 && remainingSizeInChunk - boundary < 0) {
            // check for chunk overflow

            offset += GPU_CHUNK_BYTES - chunkOffset;
          } else if (chunkOffset % boundary !== 0) {
            // check for correct alignment

            offset += chunkOffset % boundary;
          }
          _uniform.offset = offset / this.bytesPerElement;
          offset += itemSize * this.bytesPerElement;
        }
        return Math.ceil(offset / GPU_CHUNK_BYTES) * GPU_CHUNK_BYTES;
      }

      /**
       * Updates this group by updating each uniform object of
       * the internal uniform list. The uniform objects check if their
       * values has actually changed so this method only returns
       * `true` if there is a real value change.
       *
       * @return {Boolean} Whether the uniforms have been updated and
       * must be uploaded to the GPU.
       */
    }, {
      key: "update",
      value: function update() {
        var updated = false;
        for (var _uniform2 of this.uniforms) {
          if (this.updateByType(_uniform2) === true) {
            updated = true;
          }
        }
        return updated;
      }

      /**
       * Updates a given uniform by calling an update method matching
       * the uniforms type.
       *
       * @param {Uniform} uniform - The uniform to update.
       * @return {Boolean} Whether the uniform has been updated or not.
       */
    }, {
      key: "updateByType",
      value: function updateByType(uniform) {
        if (uniform.isNumberUniform) return this.updateNumber(uniform);
        if (uniform.isVector2Uniform) return this.updateVector2(uniform);
        if (uniform.isVector3Uniform) return this.updateVector3(uniform);
        if (uniform.isVector4Uniform) return this.updateVector4(uniform);
        if (uniform.isColorUniform) return this.updateColor(uniform);
        if (uniform.isMatrix3Uniform) return this.updateMatrix3(uniform);
        if (uniform.isMatrix4Uniform) return this.updateMatrix4(uniform);
        console.error('THREE.WebGPUUniformsGroup: Unsupported uniform type.', uniform);
      }

      /**
       * Updates a given Number uniform.
       *
       * @param {NumberUniform} uniform - The Number uniform.
       * @return {Boolean} Whether the uniform has been updated or not.
       */
    }, {
      key: "updateNumber",
      value: function updateNumber(uniform) {
        var updated = false;
        var a = this.values;
        var v = uniform.getValue();
        var offset = uniform.offset;
        var type = uniform.getType();
        if (a[offset] !== v) {
          var b = this._getBufferForType(type);
          b[offset] = a[offset] = v;
          updated = true;
        }
        return updated;
      }

      /**
       * Updates a given Vector2 uniform.
       *
       * @param {Vector2Uniform} uniform - The Vector2 uniform.
       * @return {Boolean} Whether the uniform has been updated or not.
       */
    }, {
      key: "updateVector2",
      value: function updateVector2(uniform) {
        var updated = false;
        var a = this.values;
        var v = uniform.getValue();
        var offset = uniform.offset;
        var type = uniform.getType();
        if (a[offset + 0] !== v.x || a[offset + 1] !== v.y) {
          var b = this._getBufferForType(type);
          b[offset + 0] = a[offset + 0] = v.x;
          b[offset + 1] = a[offset + 1] = v.y;
          updated = true;
        }
        return updated;
      }

      /**
       * Updates a given Vector3 uniform.
       *
       * @param {Vector3Uniform} uniform - The Vector3 uniform.
       * @return {Boolean} Whether the uniform has been updated or not.
       */
    }, {
      key: "updateVector3",
      value: function updateVector3(uniform) {
        var updated = false;
        var a = this.values;
        var v = uniform.getValue();
        var offset = uniform.offset;
        var type = uniform.getType();
        if (a[offset + 0] !== v.x || a[offset + 1] !== v.y || a[offset + 2] !== v.z) {
          var b = this._getBufferForType(type);
          b[offset + 0] = a[offset + 0] = v.x;
          b[offset + 1] = a[offset + 1] = v.y;
          b[offset + 2] = a[offset + 2] = v.z;
          updated = true;
        }
        return updated;
      }

      /**
       * Updates a given Vector4 uniform.
       *
       * @param {Vector4Uniform} uniform - The Vector4 uniform.
       * @return {Boolean} Whether the uniform has been updated or not.
       */
    }, {
      key: "updateVector4",
      value: function updateVector4(uniform) {
        var updated = false;
        var a = this.values;
        var v = uniform.getValue();
        var offset = uniform.offset;
        var type = uniform.getType();
        if (a[offset + 0] !== v.x || a[offset + 1] !== v.y || a[offset + 2] !== v.z || a[offset + 4] !== v.w) {
          var b = this._getBufferForType(type);
          b[offset + 0] = a[offset + 0] = v.x;
          b[offset + 1] = a[offset + 1] = v.y;
          b[offset + 2] = a[offset + 2] = v.z;
          b[offset + 3] = a[offset + 3] = v.w;
          updated = true;
        }
        return updated;
      }

      /**
       * Updates a given Color uniform.
       *
       * @param {ColorUniform} uniform - The Color uniform.
       * @return {Boolean} Whether the uniform has been updated or not.
       */
    }, {
      key: "updateColor",
      value: function updateColor(uniform) {
        var updated = false;
        var a = this.values;
        var c = uniform.getValue();
        var offset = uniform.offset;
        if (a[offset + 0] !== c.r || a[offset + 1] !== c.g || a[offset + 2] !== c.b) {
          var b = this.buffer;
          b[offset + 0] = a[offset + 0] = c.r;
          b[offset + 1] = a[offset + 1] = c.g;
          b[offset + 2] = a[offset + 2] = c.b;
          updated = true;
        }
        return updated;
      }

      /**
       * Updates a given Matrix3 uniform.
       *
       * @param {Matrix3Uniform} uniform - The Matrix3 uniform.
       * @return {Boolean} Whether the uniform has been updated or not.
       */
    }, {
      key: "updateMatrix3",
      value: function updateMatrix3(uniform) {
        var updated = false;
        var a = this.values;
        var e = uniform.getValue().elements;
        var offset = uniform.offset;
        if (a[offset + 0] !== e[0] || a[offset + 1] !== e[1] || a[offset + 2] !== e[2] || a[offset + 4] !== e[3] || a[offset + 5] !== e[4] || a[offset + 6] !== e[5] || a[offset + 8] !== e[6] || a[offset + 9] !== e[7] || a[offset + 10] !== e[8]) {
          var b = this.buffer;
          b[offset + 0] = a[offset + 0] = e[0];
          b[offset + 1] = a[offset + 1] = e[1];
          b[offset + 2] = a[offset + 2] = e[2];
          b[offset + 4] = a[offset + 4] = e[3];
          b[offset + 5] = a[offset + 5] = e[4];
          b[offset + 6] = a[offset + 6] = e[5];
          b[offset + 8] = a[offset + 8] = e[6];
          b[offset + 9] = a[offset + 9] = e[7];
          b[offset + 10] = a[offset + 10] = e[8];
          updated = true;
        }
        return updated;
      }

      /**
       * Updates a given Matrix4 uniform.
       *
       * @param {Matrix4Uniform} uniform - The Matrix4 uniform.
       * @return {Boolean} Whether the uniform has been updated or not.
       */
    }, {
      key: "updateMatrix4",
      value: function updateMatrix4(uniform) {
        var updated = false;
        var a = this.values;
        var e = uniform.getValue().elements;
        var offset = uniform.offset;
        if (arraysEqual(a, e, offset) === false) {
          var b = this.buffer;
          b.set(e, offset);
          setArray(a, e, offset);
          updated = true;
        }
        return updated;
      }

      /**
       * Returns a typed array that matches the given data type.
       *
       * @param {String} type - The data type.
       * @return {TypedArray} The typed array.
       */
    }, {
      key: "_getBufferForType",
      value: function _getBufferForType(type) {
        if (type === 'int' || type === 'ivec2' || type === 'ivec3' || type === 'ivec4') return new Int32Array(this.buffer.buffer);
        if (type === 'uint' || type === 'uvec2' || type === 'uvec3' || type === 'uvec4') return new Uint32Array(this.buffer.buffer);
        return this.buffer;
      }
    }]);
  }(UniformBuffer);
  /**
   * Sets the values of the second array to the first array.
   *
   * @param {TypedArray} a - The first array.
   * @param {TypedArray} b - The second array.
   * @param {Number} offset - An index offset for the first array.
   */
  function setArray(a, b, offset) {
    for (var i = 0, l = b.length; i < l; i++) {
      a[offset + i] = b[i];
    }
  }

  /**
   * Returns `true` if the given arrays are equal.
   *
   * @param {TypedArray} a - The first array.
   * @param {TypedArray} b - The second array.
   * @param {Number} offset - An index offset for the first array.
   * @return {Boolean} Whether the given arrays are equal or not.
   */
  function arraysEqual(a, b, offset) {
    for (var i = 0, l = b.length; i < l; i++) {
      if (a[offset + i] !== b[i]) return false;
    }
    return true;
  }
  var _id$3 = 0;

  /**
   * A special form of uniforms group that represents
   * the individual uniforms as node-based uniforms.
   *
   * @private
   * @augments UniformsGroup
   */
  var NodeUniformsGroup = /*#__PURE__*/function (_UniformsGroup) {
    /**
     * Constructs a new node-based uniforms group.
     *
     * @param {String} name - The group's name.
     * @param {UniformGroupNode} groupNode - The uniform group node.
     */
    function NodeUniformsGroup(name, groupNode) {
      var _this198;
      (0, _classCallCheck2.default)(this, NodeUniformsGroup);
      _this198 = _callSuper(this, NodeUniformsGroup, [name]);

      /**
       * The group's ID.
       *
       * @type {Number}
       */
      _this198.id = _id$3++;

      /**
       * The uniform group node.
       *
       * @type {UniformGroupNode}
       */
      _this198.groupNode = groupNode;

      /**
       * This flag can be used for type testing.
       *
       * @type {Boolean}
       * @readonly
       * @default true
       */
      _this198.isNodeUniformsGroup = true;
      return _this198;
    }
    (0, _inherits2.default)(NodeUniformsGroup, _UniformsGroup);
    return (0, _createClass2.default)(NodeUniformsGroup);
  }(UniformsGroup);
  var _id$2 = 0;

  /**
   * Represents a sampled texture binding type.
   *
   * @private
   * @augments Binding
   */
  var SampledTexture = /*#__PURE__*/function (_Binding2) {
    /**
     * Constructs a new sampled texture.
     *
     * @param {String} name - The sampled texture's name.
     * @param {Texture?} texture - The texture this binding is referring to.
     */
    function SampledTexture(name, texture) {
      var _this199;
      (0, _classCallCheck2.default)(this, SampledTexture);
      _this199 = _callSuper(this, SampledTexture, [name]);

      /**
       * This identifier.
       *
       * @type {Number}
       */
      _this199.id = _id$2++;

      /**
       * The texture this binding is referring to.
       *
       * @type {Texture?}
       */
      _this199.texture = texture;

      /**
       * The binding's version.
       *
       * @type {Number}
       */
      _this199.version = texture ? texture.version : 0;

      /**
       * Whether the texture is a storage texture or not.
       *
       * @type {Boolean}
       * @default false
       */
      _this199.store = false;

      /**
       * The binding's generation which is an additional version
       * qualifier.
       *
       * @type {Number?}
       * @default null
       */
      _this199.generation = null;

      /**
       * This flag can be used for type testing.
       *
       * @type {Boolean}
       * @readonly
       * @default true
       */
      _this199.isSampledTexture = true;
      return _this199;
    }

    /**
     * Returns `true` whether this binding requires an update for the
     * given generation.
     *
     * @param {Number} generation - The generation.
     * @return {Boolean} Whether an update is required or not.
     */
    (0, _inherits2.default)(SampledTexture, _Binding2);
    return (0, _createClass2.default)(SampledTexture, [{
      key: "needsBindingsUpdate",
      value: function needsBindingsUpdate(generation) {
        var texture = this.texture;
        if (generation !== this.generation) {
          this.generation = generation;
          return true;
        }
        return texture.isVideoTexture;
      }

      /**
       * Updates the binding.
       *
       * @param {Number} generation - The generation.
       * @return {Boolean} Whether the texture has been updated and must be
       * uploaded to the GPU.
       */
    }, {
      key: "update",
      value: function update() {
        var texture = this.texture,
          version = this.version;
        if (version !== texture.version) {
          this.version = texture.version;
          return true;
        }
        return false;
      }
    }]);
  }(Binding);
  /**
   * A special form of sampled texture binding type.
   * It's texture value is managed by a node object.
   *
   * @private
   * @augments SampledTexture
   */
  var NodeSampledTexture = /*#__PURE__*/function (_SampledTexture) {
    /**
     * Constructs a new node-based sampled texture.
     *
     * @param {String} name - The textures's name.
     * @param {TextureNode} textureNode - The texture node.
     * @param {UniformGroupNode} groupNode - The uniform group node.
     * @param {String?} [access=null] - The access type.
     */
    function NodeSampledTexture(name, textureNode, groupNode) {
      var _this200;
      var access = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
      (0, _classCallCheck2.default)(this, NodeSampledTexture);
      _this200 = _callSuper(this, NodeSampledTexture, [name, textureNode ? textureNode.value : null]);

      /**
       * The texture node.
       *
       * @type {TextureNode}
       */
      _this200.textureNode = textureNode;

      /**
       * The uniform group node.
       *
       * @type {UniformGroupNode}
       */
      _this200.groupNode = groupNode;

      /**
       * The access type.
       *
       * @type {String?}
       * @default null
       */
      _this200.access = access;
      return _this200;
    }

    /**
     * Overwrites the default to additionally check if the node value has changed.
     *
     * @param {Number} generation - The generation.
     * @return {Boolean} Whether an update is required or not.
     */
    (0, _inherits2.default)(NodeSampledTexture, _SampledTexture);
    return (0, _createClass2.default)(NodeSampledTexture, [{
      key: "needsBindingsUpdate",
      value: function needsBindingsUpdate(generation) {
        return this.textureNode.value !== this.texture || _superPropGet(NodeSampledTexture, "needsBindingsUpdate", this, 3)([generation]);
      }

      /**
       * Updates the binding.
       *
       * @param {Number} generation - The generation.
       * @return {Boolean} Whether the texture has been updated and must be
       * uploaded to the GPU.
       */
    }, {
      key: "update",
      value: function update() {
        var textureNode = this.textureNode;
        if (this.texture !== textureNode.value) {
          this.texture = textureNode.value;
          return true;
        }
        return _superPropGet(NodeSampledTexture, "update", this, 3)([]);
      }
    }]);
  }(SampledTexture);
  /**
   * A special form of sampled cube texture binding type.
   * It's texture value is managed by a node object.
   *
   * @private
   * @augments NodeSampledTexture
   */
  var NodeSampledCubeTexture = /*#__PURE__*/function (_NodeSampledTexture) {
    /**
     * Constructs a new node-based sampled cube texture.
     *
     * @param {String} name - The textures's name.
     * @param {TextureNode} textureNode - The texture node.
     * @param {UniformGroupNode} groupNode - The uniform group node.
     * @param {String?} [access=null] - The access type.
     */
    function NodeSampledCubeTexture(name, textureNode, groupNode) {
      var _this201;
      var access = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
      (0, _classCallCheck2.default)(this, NodeSampledCubeTexture);
      _this201 = _callSuper(this, NodeSampledCubeTexture, [name, textureNode, groupNode, access]);

      /**
       * This flag can be used for type testing.
       *
       * @type {Boolean}
       * @readonly
       * @default true
       */
      _this201.isSampledCubeTexture = true;
      return _this201;
    }
    (0, _inherits2.default)(NodeSampledCubeTexture, _NodeSampledTexture);
    return (0, _createClass2.default)(NodeSampledCubeTexture);
  }(NodeSampledTexture);
  /**
   * A special form of sampled 3D texture binding type.
   * It's texture value is managed by a node object.
   *
   * @private
   * @augments NodeSampledTexture
   */
  var NodeSampledTexture3D = /*#__PURE__*/function (_NodeSampledTexture2) {
    /**
     * Constructs a new node-based sampled 3D texture.
     *
     * @param {String} name - The textures's name.
     * @param {TextureNode} textureNode - The texture node.
     * @param {UniformGroupNode} groupNode - The uniform group node.
     * @param {String?} [access=null] - The access type.
     */
    function NodeSampledTexture3D(name, textureNode, groupNode) {
      var _this202;
      var access = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
      (0, _classCallCheck2.default)(this, NodeSampledTexture3D);
      _this202 = _callSuper(this, NodeSampledTexture3D, [name, textureNode, groupNode, access]);

      /**
       * This flag can be used for type testing.
       *
       * @type {Boolean}
       * @readonly
       * @default true
       */
      _this202.isSampledTexture3D = true;
      return _this202;
    }
    (0, _inherits2.default)(NodeSampledTexture3D, _NodeSampledTexture2);
    return (0, _createClass2.default)(NodeSampledTexture3D);
  }(NodeSampledTexture);
  var glslMethods = {
    textureDimensions: 'textureSize',
    equals: 'equal'
  };
  var precisionLib = {
    low: 'lowp',
    medium: 'mediump',
    high: 'highp'
  };
  var supports$1 = {
    swizzleAssign: true,
    storageBuffer: false
  };
  var defaultPrecisions = `
precision highp float;
precision highp int;
precision highp sampler2D;
precision highp sampler3D;
precision highp samplerCube;
precision highp sampler2DArray;

precision highp usampler2D;
precision highp usampler3D;
precision highp usamplerCube;
precision highp usampler2DArray;

precision highp isampler2D;
precision highp isampler3D;
precision highp isamplerCube;
precision highp isampler2DArray;

precision lowp sampler2DShadow;
`;
  var GLSLNodeBuilder = /*#__PURE__*/function (_NodeBuilder) {
    function GLSLNodeBuilder(object, renderer) {
      var _this203;
      (0, _classCallCheck2.default)(this, GLSLNodeBuilder);
      _this203 = _callSuper(this, GLSLNodeBuilder, [object, renderer, new GLSLNodeParser()]);
      _this203.uniformGroups = {};
      _this203.transforms = [];
      _this203.extensions = {};
      _this203.builtins = {
        vertex: [],
        fragment: [],
        compute: []
      };
      _this203.useComparisonMethod = true;
      return _this203;
    }
    (0, _inherits2.default)(GLSLNodeBuilder, _NodeBuilder);
    return (0, _createClass2.default)(GLSLNodeBuilder, [{
      key: "needsToWorkingColorSpace",
      value: function needsToWorkingColorSpace(texture) {
        return texture.isVideoTexture === true && texture.colorSpace !== _$$_REQUIRE(_dependencyMap[1], "./three.core.js").NoColorSpace;
      }
    }, {
      key: "getMethod",
      value: function getMethod(method) {
        return glslMethods[method] || method;
      }
    }, {
      key: "getOutputStructName",
      value: function getOutputStructName() {
        return '';
      }
    }, {
      key: "buildFunctionCode",
      value: function buildFunctionCode(shaderNode) {
        var layout = shaderNode.layout;
        var flowData = this.flowShaderNode(shaderNode);
        var parameters = [];
        for (var input of layout.inputs) {
          parameters.push(this.getType(input.type) + ' ' + input.name);
        }

        //

        var code = `${this.getType(layout.type)} ${layout.name}( ${parameters.join(', ')} ) {

	${flowData.vars}

${flowData.code}
	return ${flowData.result};

}`;

        //

        return code;
      }
    }, {
      key: "setupPBO",
      value: function setupPBO(storageBufferNode) {
        var attribute = storageBufferNode.value;
        if (attribute.pbo === undefined) {
          var originalArray = attribute.array;
          var numElements = attribute.count * attribute.itemSize;
          var itemSize = attribute.itemSize;
          var isInteger = attribute.array.constructor.name.toLowerCase().includes('int');
          var format = isInteger ? _$$_REQUIRE(_dependencyMap[1], "./three.core.js").RedIntegerFormat : _$$_REQUIRE(_dependencyMap[1], "./three.core.js").RedFormat;
          if (itemSize === 2) {
            format = isInteger ? _$$_REQUIRE(_dependencyMap[1], "./three.core.js").RGIntegerFormat : _$$_REQUIRE(_dependencyMap[1], "./three.core.js").RGFormat;
          } else if (itemSize === 3) {
            format = isInteger ? _$$_REQUIRE(_dependencyMap[1], "./three.core.js").RGBIntegerFormat : _$$_REQUIRE(_dependencyMap[1], "./three.core.js").RGBFormat;
          } else if (itemSize === 4) {
            format = isInteger ? _$$_REQUIRE(_dependencyMap[1], "./three.core.js").RGBAIntegerFormat : _$$_REQUIRE(_dependencyMap[1], "./three.core.js").RGBAFormat;
          }
          var typeMap = {
            Float32Array: _$$_REQUIRE(_dependencyMap[1], "./three.core.js").FloatType,
            Uint8Array: _$$_REQUIRE(_dependencyMap[1], "./three.core.js").UnsignedByteType,
            Uint16Array: _$$_REQUIRE(_dependencyMap[1], "./three.core.js").UnsignedShortType,
            Uint32Array: _$$_REQUIRE(_dependencyMap[1], "./three.core.js").UnsignedIntType,
            Int8Array: _$$_REQUIRE(_dependencyMap[1], "./three.core.js").ByteType,
            Int16Array: _$$_REQUIRE(_dependencyMap[1], "./three.core.js").ShortType,
            Int32Array: _$$_REQUIRE(_dependencyMap[1], "./three.core.js").IntType,
            Uint8ClampedArray: _$$_REQUIRE(_dependencyMap[1], "./three.core.js").UnsignedByteType
          };
          var width = Math.pow(2, Math.ceil(Math.log2(Math.sqrt(numElements / itemSize))));
          var height = Math.ceil(numElements / itemSize / width);
          if (width * height * itemSize < numElements) height++; // Ensure enough space

          var newSize = width * height * itemSize;
          var newArray = new originalArray.constructor(newSize);
          newArray.set(originalArray, 0);
          attribute.array = newArray;
          var pboTexture = new (_$$_REQUIRE(_dependencyMap[1], "./three.core.js").DataTexture)(attribute.array, width, height, format, typeMap[attribute.array.constructor.name] || _$$_REQUIRE(_dependencyMap[1], "./three.core.js").FloatType);
          pboTexture.needsUpdate = true;
          pboTexture.isPBOTexture = true;
          var pbo = new TextureNode(pboTexture, null, null);
          pbo.setPrecision('high');
          attribute.pboNode = pbo;
          attribute.pbo = pbo.value;
          this.getUniformFromNode(attribute.pboNode, 'texture', this.shaderStage, this.context.label);
        }
      }
    }, {
      key: "getPropertyName",
      value: function getPropertyName(node) {
        var shaderStage = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.shaderStage;
        if (node.isNodeUniform && node.node.isTextureNode !== true && node.node.isBufferNode !== true) {
          return shaderStage.charAt(0) + '_' + node.name;
        }
        return _superPropGet(GLSLNodeBuilder, "getPropertyName", this, 3)([node, shaderStage]);
      }
    }, {
      key: "generatePBO",
      value: function generatePBO(storageArrayElementNode) {
        var node = storageArrayElementNode.node,
          indexNode = storageArrayElementNode.indexNode;
        var attribute = node.value;
        if (this.renderer.backend.has(attribute)) {
          var attributeData = this.renderer.backend.get(attribute);
          attributeData.pbo = attribute.pbo;
        }
        var nodeUniform = this.getUniformFromNode(attribute.pboNode, 'texture', this.shaderStage, this.context.label);
        var textureName = this.getPropertyName(nodeUniform);
        this.increaseUsage(indexNode); // force cache generate to be used as index in x,y
        var indexSnippet = indexNode.build(this, 'uint');
        var elementNodeData = this.getDataFromNode(storageArrayElementNode);
        var propertyName = elementNodeData.propertyName;
        if (propertyName === undefined) {
          // property element

          var nodeVar = this.getVarFromNode(storageArrayElementNode);
          propertyName = this.getPropertyName(nodeVar);

          // property size

          var bufferNodeData = this.getDataFromNode(node);
          var propertySizeName = bufferNodeData.propertySizeName;
          if (propertySizeName === undefined) {
            propertySizeName = propertyName + 'Size';
            this.getVarFromNode(node, propertySizeName, 'uint');
            this.addLineFlowCode(`${propertySizeName} = uint( textureSize( ${textureName}, 0 ).x )`, storageArrayElementNode);
            bufferNodeData.propertySizeName = propertySizeName;
          }

          //

          var itemSize = attribute.itemSize;
          var channel = '.' + vectorComponents.join('').slice(0, itemSize);
          var uvSnippet = `ivec2(${indexSnippet} % ${propertySizeName}, ${indexSnippet} / ${propertySizeName})`;
          var snippet = this.generateTextureLoad(null, textureName, uvSnippet, null, '0');

          //

          var prefix = 'vec4';
          if (attribute.pbo.type === _$$_REQUIRE(_dependencyMap[1], "./three.core.js").UnsignedIntType) {
            prefix = 'uvec4';
          } else if (attribute.pbo.type === _$$_REQUIRE(_dependencyMap[1], "./three.core.js").IntType) {
            prefix = 'ivec4';
          }
          this.addLineFlowCode(`${propertyName} = ${prefix}(${snippet})${channel}`, storageArrayElementNode);
          elementNodeData.propertyName = propertyName;
        }
        return propertyName;
      }
    }, {
      key: "generateTextureLoad",
      value: function generateTextureLoad(texture, textureProperty, uvIndexSnippet, depthSnippet) {
        var levelSnippet = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : '0';
        if (depthSnippet) {
          return `texelFetch( ${textureProperty}, ivec3( ${uvIndexSnippet}, ${depthSnippet} ), ${levelSnippet} )`;
        } else {
          return `texelFetch( ${textureProperty}, ${uvIndexSnippet}, ${levelSnippet} )`;
        }
      }
    }, {
      key: "generateTexture",
      value: function generateTexture(texture, textureProperty, uvSnippet, depthSnippet) {
        if (texture.isDepthTexture) {
          return `texture( ${textureProperty}, ${uvSnippet} ).x`;
        } else {
          if (depthSnippet) uvSnippet = `vec3( ${uvSnippet}, ${depthSnippet} )`;
          return `texture( ${textureProperty}, ${uvSnippet} )`;
        }
      }
    }, {
      key: "generateTextureLevel",
      value: function generateTextureLevel(texture, textureProperty, uvSnippet, levelSnippet) {
        return `textureLod( ${textureProperty}, ${uvSnippet}, ${levelSnippet} )`;
      }
    }, {
      key: "generateTextureBias",
      value: function generateTextureBias(texture, textureProperty, uvSnippet, biasSnippet) {
        return `texture( ${textureProperty}, ${uvSnippet}, ${biasSnippet} )`;
      }
    }, {
      key: "generateTextureGrad",
      value: function generateTextureGrad(texture, textureProperty, uvSnippet, gradSnippet) {
        return `textureGrad( ${textureProperty}, ${uvSnippet}, ${gradSnippet[0]}, ${gradSnippet[1]} )`;
      }
    }, {
      key: "generateTextureCompare",
      value: function generateTextureCompare(texture, textureProperty, uvSnippet, compareSnippet, depthSnippet) {
        var shaderStage = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : this.shaderStage;
        if (shaderStage === 'fragment') {
          return `texture( ${textureProperty}, vec3( ${uvSnippet}, ${compareSnippet} ) )`;
        } else {
          console.error(`WebGPURenderer: THREE.DepthTexture.compareFunction() does not support ${shaderStage} shader.`);
        }
      }
    }, {
      key: "getVars",
      value: function getVars(shaderStage) {
        var snippets = [];
        var vars = this.vars[shaderStage];
        if (vars !== undefined) {
          for (var variable of vars) {
            snippets.push(`${this.getVar(variable.type, variable.name)};`);
          }
        }
        return snippets.join('\n\t');
      }
    }, {
      key: "getUniforms",
      value: function getUniforms(shaderStage) {
        var uniforms = this.uniforms[shaderStage];
        var bindingSnippets = [];
        var uniformGroups = {};
        for (var _uniform3 of uniforms) {
          var snippet = null;
          var group = false;
          if (_uniform3.type === 'texture') {
            var _texture6 = _uniform3.node.value;
            var typePrefix = '';
            if (_texture6.isDataTexture === true) {
              if (_texture6.type === _$$_REQUIRE(_dependencyMap[1], "./three.core.js").UnsignedIntType) {
                typePrefix = 'u';
              } else if (_texture6.type === _$$_REQUIRE(_dependencyMap[1], "./three.core.js").IntType) {
                typePrefix = 'i';
              }
            }
            if (_texture6.compareFunction) {
              snippet = `sampler2DShadow ${_uniform3.name};`;
            } else if (_texture6.isDataArrayTexture === true || _texture6.isCompressedArrayTexture === true) {
              snippet = `${typePrefix}sampler2DArray ${_uniform3.name};`;
            } else {
              snippet = `${typePrefix}sampler2D ${_uniform3.name};`;
            }
          } else if (_uniform3.type === 'cubeTexture') {
            snippet = `samplerCube ${_uniform3.name};`;
          } else if (_uniform3.type === 'texture3D') {
            snippet = `sampler3D ${_uniform3.name};`;
          } else if (_uniform3.type === 'buffer') {
            var bufferNode = _uniform3.node;
            var bufferType = this.getType(bufferNode.bufferType);
            var bufferCount = bufferNode.bufferCount;
            var bufferCountSnippet = bufferCount > 0 ? bufferCount : '';
            snippet = `${bufferNode.name} {\n\t${bufferType} ${_uniform3.name}[${bufferCountSnippet}];\n};\n`;
          } else {
            var vectorType = this.getVectorType(_uniform3.type);
            snippet = `${vectorType} ${this.getPropertyName(_uniform3, shaderStage)};`;
            group = true;
          }
          var precision = _uniform3.node.precision;
          if (precision !== null) {
            snippet = precisionLib[precision] + ' ' + snippet;
          }
          if (group) {
            snippet = '\t' + snippet;
            var groupName = _uniform3.groupNode.name;
            var groupSnippets = uniformGroups[groupName] || (uniformGroups[groupName] = []);
            groupSnippets.push(snippet);
          } else {
            snippet = 'uniform ' + snippet;
            bindingSnippets.push(snippet);
          }
        }
        var output = '';
        for (var name in uniformGroups) {
          var _groupSnippets = uniformGroups[name];
          output += this._getGLSLUniformStruct(shaderStage + '_' + name, _groupSnippets.join('\n')) + '\n';
        }
        output += bindingSnippets.join('\n');
        return output;
      }
    }, {
      key: "getTypeFromAttribute",
      value: function getTypeFromAttribute(attribute) {
        var nodeType = _superPropGet(GLSLNodeBuilder, "getTypeFromAttribute", this, 3)([attribute]);
        if (/^[iu]/.test(nodeType) && attribute.gpuType !== _$$_REQUIRE(_dependencyMap[1], "./three.core.js").IntType) {
          var dataAttribute = attribute;
          if (attribute.isInterleavedBufferAttribute) dataAttribute = attribute.data;
          var array = dataAttribute.array;
          if ((array instanceof Uint32Array || array instanceof Int32Array) === false) {
            nodeType = nodeType.slice(1);
          }
        }
        return nodeType;
      }
    }, {
      key: "getAttributes",
      value: function getAttributes(shaderStage) {
        var snippet = '';
        if (shaderStage === 'vertex' || shaderStage === 'compute') {
          var attributes = this.getAttributesArray();
          var location = 0;
          for (var _attribute10 of attributes) {
            snippet += `layout( location = ${location++} ) in ${_attribute10.type} ${_attribute10.name};\n`;
          }
        }
        return snippet;
      }
    }, {
      key: "getStructMembers",
      value: function getStructMembers(struct) {
        var snippets = [];
        var members = struct.getMemberTypes();
        for (var i = 0; i < members.length; i++) {
          var member = members[i];
          snippets.push(`layout( location = ${i} ) out ${member} m${i};`);
        }
        return snippets.join('\n');
      }
    }, {
      key: "getStructs",
      value: function getStructs(shaderStage) {
        var snippets = [];
        var structs = this.structs[shaderStage];
        if (structs.length === 0) {
          return 'layout( location = 0 ) out vec4 fragColor;\n';
        }
        for (var index = 0, _length2 = structs.length; index < _length2; index++) {
          var struct = structs[index];
          var snippet = '\n';
          snippet += this.getStructMembers(struct);
          snippet += '\n';
          snippets.push(snippet);
        }
        return snippets.join('\n\n');
      }
    }, {
      key: "getVaryings",
      value: function getVaryings(shaderStage) {
        var snippet = '';
        var varyings = this.varyings;
        if (shaderStage === 'vertex' || shaderStage === 'compute') {
          for (var _varying of varyings) {
            if (shaderStage === 'compute') _varying.needsInterpolation = true;
            var type = this.getType(_varying.type);
            var flat = type.includes('int') || type.includes('uv') || type.includes('iv') ? 'flat ' : '';
            snippet += `${flat}${_varying.needsInterpolation ? 'out' : '/*out*/'} ${type} ${_varying.name};\n`;
          }
        } else if (shaderStage === 'fragment') {
          for (var _varying2 of varyings) {
            if (_varying2.needsInterpolation) {
              var _type2 = this.getType(_varying2.type);
              var _flat = _type2.includes('int') || _type2.includes('uv') || _type2.includes('iv') ? 'flat ' : '';
              snippet += `${_flat}in ${_type2} ${_varying2.name};\n`;
            }
          }
        }
        for (var _builtin of this.builtins[shaderStage]) {
          snippet += `${_builtin};\n`;
        }
        return snippet;
      }
    }, {
      key: "getVertexIndex",
      value: function getVertexIndex() {
        return 'uint( gl_VertexID )';
      }
    }, {
      key: "getInstanceIndex",
      value: function getInstanceIndex() {
        return 'uint( gl_InstanceID )';
      }
    }, {
      key: "getInvocationLocalIndex",
      value: function getInvocationLocalIndex() {
        var workgroupSize = this.object.workgroupSize;
        var size = workgroupSize.reduce(function (acc, curr) {
          return acc * curr;
        }, 1);
        return `uint( gl_InstanceID ) % ${size}u`;
      }
    }, {
      key: "getDrawIndex",
      value: function getDrawIndex() {
        var extensions = this.renderer.backend.extensions;
        if (extensions.has('WEBGL_multi_draw')) {
          return 'uint( gl_DrawID )';
        }
        return null;
      }
    }, {
      key: "getFrontFacing",
      value: function getFrontFacing() {
        return 'gl_FrontFacing';
      }
    }, {
      key: "getFragCoord",
      value: function getFragCoord() {
        return 'gl_FragCoord.xy';
      }
    }, {
      key: "getFragDepth",
      value: function getFragDepth() {
        return 'gl_FragDepth';
      }
    }, {
      key: "enableExtension",
      value: function enableExtension(name, behavior) {
        var shaderStage = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.shaderStage;
        var map = this.extensions[shaderStage] || (this.extensions[shaderStage] = new Map());
        if (map.has(name) === false) {
          map.set(name, {
            name: name,
            behavior: behavior
          });
        }
      }
    }, {
      key: "getExtensions",
      value: function getExtensions(shaderStage) {
        var snippets = [];
        if (shaderStage === 'vertex') {
          var ext = this.renderer.backend.extensions;
          var isBatchedMesh = this.object.isBatchedMesh;
          if (isBatchedMesh && ext.has('WEBGL_multi_draw')) {
            this.enableExtension('GL_ANGLE_multi_draw', 'require', shaderStage);
          }
        }
        var extensions = this.extensions[shaderStage];
        if (extensions !== undefined) {
          for (var _ref341 of extensions.values()) {
            var name = _ref341.name;
            var behavior = _ref341.behavior;
            snippets.push(`#extension ${name} : ${behavior}`);
          }
        }
        return snippets.join('\n');
      }
    }, {
      key: "getClipDistance",
      value: function getClipDistance() {
        return 'gl_ClipDistance';
      }
    }, {
      key: "isAvailable",
      value: function isAvailable(name) {
        var result = supports$1[name];
        if (result === undefined) {
          var extensionName;
          result = false;
          switch (name) {
            case 'float32Filterable':
              extensionName = 'OES_texture_float_linear';
              break;
            case 'clipDistance':
              extensionName = 'WEBGL_clip_cull_distance';
              break;
          }
          if (extensionName !== undefined) {
            var extensions = this.renderer.backend.extensions;
            if (extensions.has(extensionName)) {
              extensions.get(extensionName);
              result = true;
            }
          }
          supports$1[name] = result;
        }
        return result;
      }
    }, {
      key: "isFlipY",
      value: function isFlipY() {
        return true;
      }
    }, {
      key: "enableHardwareClipping",
      value: function enableHardwareClipping(planeCount) {
        this.enableExtension('GL_ANGLE_clip_cull_distance', 'require');
        this.builtins['vertex'].push(`out float gl_ClipDistance[ ${planeCount} ]`);
      }
    }, {
      key: "registerTransform",
      value: function registerTransform(varyingName, attributeNode) {
        this.transforms.push({
          varyingName: varyingName,
          attributeNode: attributeNode
        });
      }
    }, {
      key: "getTransforms",
      value: function getTransforms(/* shaderStage  */
      ) {
        var transforms = this.transforms;
        var snippet = '';
        for (var i = 0; i < transforms.length; i++) {
          var transform = transforms[i];
          var attributeName = this.getPropertyName(transform.attributeNode);
          snippet += `${transform.varyingName} = ${attributeName};\n\t`;
        }
        return snippet;
      }
    }, {
      key: "_getGLSLUniformStruct",
      value: function _getGLSLUniformStruct(name, vars) {
        return `
layout( std140 ) uniform ${name} {
${vars}
};`;
      }
    }, {
      key: "_getGLSLVertexCode",
      value: function _getGLSLVertexCode(shaderData) {
        return `#version 300 es

${this.getSignature()}

// extensions 
${shaderData.extensions}

// precision
${defaultPrecisions}

// uniforms
${shaderData.uniforms}

// varyings
${shaderData.varyings}

// attributes
${shaderData.attributes}

// codes
${shaderData.codes}

void main() {

	// vars
	${shaderData.vars}

	// transforms
	${shaderData.transforms}

	// flow
	${shaderData.flow}

	gl_PointSize = 1.0;

}
`;
      }
    }, {
      key: "_getGLSLFragmentCode",
      value: function _getGLSLFragmentCode(shaderData) {
        return `#version 300 es

${this.getSignature()}

// precision
${defaultPrecisions}

// uniforms
${shaderData.uniforms}

// varyings
${shaderData.varyings}

// codes
${shaderData.codes}

${shaderData.structs}

void main() {

	// vars
	${shaderData.vars}

	// flow
	${shaderData.flow}

}
`;
      }
    }, {
      key: "buildCode",
      value: function buildCode() {
        var shadersData = this.material !== null ? {
          fragment: {},
          vertex: {}
        } : {
          compute: {}
        };
        this.sortBindingGroups();
        for (var shaderStage in shadersData) {
          var flow = '// code\n\n';
          flow += this.flowCode[shaderStage];
          var flowNodes = this.flowNodes[shaderStage];
          var mainNode = flowNodes[flowNodes.length - 1];
          for (var node of flowNodes) {
            var flowSlotData = this.getFlowData(node /*, shaderStage*/);
            var slotName = node.name;
            if (slotName) {
              if (flow.length > 0) flow += '\n';
              flow += `\t// flow -> ${slotName}\n\t`;
            }
            flow += `${flowSlotData.code}\n\t`;
            if (node === mainNode && shaderStage !== 'compute') {
              flow += '// result\n\t';
              if (shaderStage === 'vertex') {
                flow += 'gl_Position = ';
                flow += `${flowSlotData.result};`;
              } else if (shaderStage === 'fragment') {
                if (!node.outputNode.isOutputStructNode) {
                  flow += 'fragColor = ';
                  flow += `${flowSlotData.result};`;
                }
              }
            }
          }
          var stageData = shadersData[shaderStage];
          stageData.extensions = this.getExtensions(shaderStage);
          stageData.uniforms = this.getUniforms(shaderStage);
          stageData.attributes = this.getAttributes(shaderStage);
          stageData.varyings = this.getVaryings(shaderStage);
          stageData.vars = this.getVars(shaderStage);
          stageData.structs = this.getStructs(shaderStage);
          stageData.codes = this.getCodes(shaderStage);
          stageData.transforms = this.getTransforms(shaderStage);
          stageData.flow = flow;
        }
        if (this.material !== null) {
          this.vertexShader = this._getGLSLVertexCode(shadersData.vertex);
          this.fragmentShader = this._getGLSLFragmentCode(shadersData.fragment);
        } else {
          this.computeShader = this._getGLSLVertexCode(shadersData.compute);
        }
      }
    }, {
      key: "getUniformFromNode",
      value: function getUniformFromNode(node, type, shaderStage) {
        var name = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
        var uniformNode = _superPropGet(GLSLNodeBuilder, "getUniformFromNode", this, 3)([node, type, shaderStage, name]);
        var nodeData = this.getDataFromNode(node, shaderStage, this.globalCache);
        var uniformGPU = nodeData.uniformGPU;
        if (uniformGPU === undefined) {
          var group = node.groupNode;
          var groupName = group.name;
          var bindings = this.getBindGroupArray(groupName, shaderStage);
          if (type === 'texture') {
            uniformGPU = new NodeSampledTexture(uniformNode.name, uniformNode.node, group);
            bindings.push(uniformGPU);
          } else if (type === 'cubeTexture') {
            uniformGPU = new NodeSampledCubeTexture(uniformNode.name, uniformNode.node, group);
            bindings.push(uniformGPU);
          } else if (type === 'texture3D') {
            uniformGPU = new NodeSampledTexture3D(uniformNode.name, uniformNode.node, group);
            bindings.push(uniformGPU);
          } else if (type === 'buffer') {
            node.name = `NodeBuffer_${node.id}`;
            uniformNode.name = `buffer${node.id}`;
            var _buffer4 = new NodeUniformBuffer(node, group);
            _buffer4.name = node.name;
            bindings.push(_buffer4);
            uniformGPU = _buffer4;
          } else {
            var uniformsStage = this.uniformGroups[shaderStage] || (this.uniformGroups[shaderStage] = {});
            var uniformsGroup = uniformsStage[groupName];
            if (uniformsGroup === undefined) {
              uniformsGroup = new NodeUniformsGroup(shaderStage + '_' + groupName, group);
              //uniformsGroup.setVisibility( gpuShaderStageLib[ shaderStage ] );

              uniformsStage[groupName] = uniformsGroup;
              bindings.push(uniformsGroup);
            }
            uniformGPU = this.getNodeUniform(uniformNode, type);
            uniformsGroup.addUniform(uniformGPU);
          }
          nodeData.uniformGPU = uniformGPU;
        }
        return uniformNode;
      }
    }]);
  }(NodeBuilder);
  var _vector2 = null;
  var _color4 = null;

  /**
   * Most of the rendering related logic is implemented in the
   * {@link module:Renderer} module and related management components.
   * Sometimes it is required though to execute commands which are
   * specific to the current 3D backend (which is WebGPU or WebGL 2).
   * This abstract base class defines an interface that encapsulates
   * all backend-related logic. Derived classes for each backend must
   * implement the interface.
   *
   * @abstract
   * @private
   */
  var Backend = /*#__PURE__*/function () {
    /**
     * Constructs a new backend.
     *
     * @param {Object} parameters - An object holding parameters for the backend.
     */
    function Backend() {
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      (0, _classCallCheck2.default)(this, Backend);
      /**
       * The parameters of the backend.
       *
       * @type {Object}
       */
      this.parameters = Object.assign({}, parameters);

      /**
       * This weak map holds backend-specific data of objects
       * like textures, attributes or render targets.
       *
       * @type {WeakMap}
       */
      this.data = new WeakMap();

      /**
       * A reference to the renderer.
       *
       * @type {Renderer?}
       * @default null
       */
      this.renderer = null;

      /**
       * A reference to the canvas element the renderer is drawing to.
       *
       * @type {(HTMLCanvasElement|OffscreenCanvas)?}
       * @default null
       */
      this.domElement = null;
    }

    /**
     * Initializes the backend so it is ready for usage. Concrete backends
     * are supposed to implement their rendering context creation and related
     * operations in this method.
     *
     * @async
     * @param {Renderer} renderer - The renderer.
     * @return {Promise} A Promise that resolves when the backend has been initialized.
     */
    return (0, _createClass2.default)(Backend, [{
      key: "init",
      value: (function () {
        var _init3 = (0, _asyncToGenerator2.default)(function* (renderer) {
          this.renderer = renderer;
        });
        function init(_x27) {
          return _init3.apply(this, arguments);
        }
        return init;
      }()
      /**
       * The coordinate system of the backend.
       *
       * @abstract
       * @type {Number}
       * @readonly
       */
      )
    }, {
      key: "coordinateSystem",
      get: function get() {}

      // render context

      /**
       * This method is executed at the beginning of a render call and
       * can be used by the backend to prepare the state for upcoming
       * draw calls.
       *
       * @abstract
       * @param {RenderContext} renderContext - The render context.
       */
    }, {
      key: "beginRender",
      value: function beginRender(/*renderContext*/) {}

      /**
       * This method is executed at the end of a render call and
       * can be used by the backend to finalize work after draw
       * calls.
       *
       * @abstract
       * @param {RenderContext} renderContext - The render context.
       */
    }, {
      key: "finishRender",
      value: function finishRender(/*renderContext*/) {}

      /**
       * This method is executed at the beginning of a compute call and
       * can be used by the backend to prepare the state for upcoming
       * compute tasks.
       *
       * @abstract
       * @param {Node|Array<Node>} computeGroup - The compute node(s).
       */
    }, {
      key: "beginCompute",
      value: function beginCompute(/*computeGroup*/) {}

      /**
       * This method is executed at the end of a compute call and
       * can be used by the backend to finalize work after compute
       * tasks.
       *
       * @abstract
       * @param {Node|Array<Node>} computeGroup - The compute node(s).
       */
    }, {
      key: "finishCompute",
      value: function finishCompute(/*computeGroup*/) {}

      // render object

      /**
       * Executes a draw command for the given render object.
       *
       * @abstract
       * @param {RenderObject} renderObject - The render object to draw.
       * @param {Info} info - Holds a series of statistical information about the GPU memory and the rendering process.
       */
    }, {
      key: "draw",
      value: function draw(/*renderObject, info*/) {}

      // compute node

      /**
       * Executes a compute command for the given compute node.
       *
       * @abstract
       * @param {Node|Array<Node>} computeGroup - The group of compute nodes of a compute call. Can be a single compute node.
       * @param {Node} computeNode - The compute node.
       * @param {Array<BindGroup>} bindings - The bindings.
       * @param {ComputePipeline} computePipeline - The compute pipeline.
       */
    }, {
      key: "compute",
      value: function compute(/*computeGroup, computeNode, computeBindings, computePipeline*/) {}

      // program

      /**
       * Creates a shader program from the given programmable stage.
       *
       * @abstract
       * @param {ProgrammableStage} program - The programmable stage.
       */
    }, {
      key: "createProgram",
      value: function createProgram(/*program*/) {}

      /**
       * Destroys the shader program of the given programmable stage.
       *
       * @abstract
       * @param {ProgrammableStage} program - The programmable stage.
       */
    }, {
      key: "destroyProgram",
      value: function destroyProgram(/*program*/) {}

      // bindings

      /**
       * Creates bindings from the given bind group definition.
       *
       * @abstract
       * @param {BindGroup} bindGroup - The bind group.
       * @param {Array<BindGroup>} bindings - Array of bind groups.
       * @param {Number} cacheIndex - The cache index.
       * @param {Number} version - The version.
       */
    }, {
      key: "createBindings",
      value: function createBindings(/*bindGroup, bindings, cacheIndex, version*/) {}

      /**
       * Updates the given bind group definition.
       *
       * @abstract
       * @param {BindGroup} bindGroup - The bind group.
       * @param {Array<BindGroup>} bindings - Array of bind groups.
       * @param {Number} cacheIndex - The cache index.
       * @param {Number} version - The version.
       */
    }, {
      key: "updateBindings",
      value: function updateBindings(/*bindGroup, bindings, cacheIndex, version*/) {}

      /**
       * Updates a buffer binding.
       *
       * @abstract
       * @param {Buffer} binding - The buffer binding to update.
       */
    }, {
      key: "updateBinding",
      value: function updateBinding(/*binding*/) {}

      // pipeline

      /**
       * Creates a render pipeline for the given render object.
       *
       * @abstract
       * @param {RenderObject} renderObject - The render object.
       * @param {Array<Promise>} promises - An array of compilation promises which are used in `compileAsync()`.
       */
    }, {
      key: "createRenderPipeline",
      value: function createRenderPipeline(/*renderObject, promises*/) {}

      /**
       * Creates a compute pipeline for the given compute node.
       *
       * @abstract
       * @param {ComputePipeline} computePipeline - The compute pipeline.
       * @param {Array<BindGroup>} bindings - The bindings.
       */
    }, {
      key: "createComputePipeline",
      value: function createComputePipeline(/*computePipeline, bindings*/) {}

      // cache key

      /**
       * Returns `true` if the render pipeline requires an update.
       *
       * @abstract
       * @param {RenderObject} renderObject - The render object.
       * @return {Boolean} Whether the render pipeline requires an update or not.
       */
    }, {
      key: "needsRenderUpdate",
      value: function needsRenderUpdate(/*renderObject*/) {}

      /**
       * Returns a cache key that is used to identify render pipelines.
       *
       * @abstract
       * @param {RenderObject} renderObject - The render object.
       * @return {String} The cache key.
       */
    }, {
      key: "getRenderCacheKey",
      value: function getRenderCacheKey(/*renderObject*/) {}

      // node builder

      /**
       * Returns a node builder for the given render object.
       *
       * @abstract
       * @param {RenderObject} renderObject - The render object.
       * @param {Renderer} renderer - The renderer.
       * @return {NodeBuilder} The node builder.
       */
    }, {
      key: "createNodeBuilder",
      value: function createNodeBuilder(/*renderObject, renderer*/) {}

      // textures

      /**
       * Creates a sampler for the given texture.
       *
       * @abstract
       * @param {Texture} texture - The texture to create the sampler for.
       */
    }, {
      key: "createSampler",
      value: function createSampler(/*texture*/) {}

      /**
       * Destroys the sampler for the given texture.
       *
       * @abstract
       * @param {Texture} texture - The texture to destroy the sampler for.
       */
    }, {
      key: "destroySampler",
      value: function destroySampler(/*texture*/) {}

      /**
       * Creates a default texture for the given texture that can be used
       * as a placeholder until the actual texture is ready for usage.
       *
       * @abstract
       * @param {Texture} texture - The texture to create a default texture for.
       */
    }, {
      key: "createDefaultTexture",
      value: function createDefaultTexture(/*texture*/) {}

      /**
       * Defines a texture on the GPU for the given texture object.
       *
       * @abstract
       * @param {Texture} texture - The texture.
       * @param {Object} [options={}] - Optional configuration parameter.
       */
    }, {
      key: "createTexture",
      value: function createTexture(/*texture, options={}*/) {}

      /**
       * Uploads the updated texture data to the GPU.
       *
       * @abstract
       * @param {Texture} texture - The texture.
       * @param {Object} [options={}] - Optional configuration parameter.
       */
    }, {
      key: "updateTexture",
      value: function updateTexture(/*texture, options = {}*/) {}

      /**
       * Generates mipmaps for the given texture
       *
       * @abstract
       * @param {Texture} texture - The texture.
       */
    }, {
      key: "generateMipmaps",
      value: function generateMipmaps(/*texture*/) {}

      /**
       * Destroys the GPU data for the given texture object.
       *
       * @abstract
       * @param {Texture} texture - The texture.
       */
    }, {
      key: "destroyTexture",
      value: function destroyTexture(/*texture*/) {}

      /**
       * Returns texture data as a typed array.
       *
       * @abstract
       * @param {Texture} texture - The texture to copy.
       * @param {Number} x - The x coordinate of the copy origin.
       * @param {Number} y - The y coordinate of the copy origin.
       * @param {Number} width - The width of the copy.
       * @param {Number} height - The height of the copy.
       * @param {Number} faceIndex - The face index.
       * @return {TypedArray} The texture data as a typed array.
       */
    }, {
      key: "copyTextureToBuffer",
      value: function copyTextureToBuffer(/*texture, x, y, width, height, faceIndex*/) {}

      /**
       * Copies data of the given source texture to the given destination texture.
       *
       * @abstract
       * @param {Texture} srcTexture - The source texture.
       * @param {Texture} dstTexture - The destination texture.
       * @param {Vector4?} [srcRegion=null] - The region of the source texture to copy.
       * @param {(Vector2|Vector3)?} [dstPosition=null] - The destination position of the copy.
       * @param {Number} [level=0] - The mip level to copy.
       */
    }, {
      key: "copyTextureToTexture",
      value: function copyTextureToTexture(/*srcTexture, dstTexture, srcRegion = null, dstPosition = null, level = 0*/) {}

      /**
      * Copies the current bound framebuffer to the given texture.
      *
      * @abstract
      * @param {Texture} texture - The destination texture.
      * @param {RenderContext} renderContext - The render context.
      * @param {Vector4} rectangle - A four dimensional vector defining the origin and dimension of the copy.
      */
    }, {
      key: "copyFramebufferToTexture",
      value: function copyFramebufferToTexture(/*texture, renderContext, rectangle*/) {}

      // attributes

      /**
       * Creates the buffer of a shader attribute.
       *
       * @abstract
       * @param {BufferAttribute} attribute - The buffer attribute.
       */
    }, {
      key: "createAttribute",
      value: function createAttribute(/*attribute*/) {}

      /**
       * Creates the buffer of an indexed shader attribute.
       *
       * @abstract
       * @param {BufferAttribute} attribute - The indexed buffer attribute.
       */
    }, {
      key: "createIndexAttribute",
      value: function createIndexAttribute(/*attribute*/) {}

      /**
       * Creates the buffer of a storage attribute.
       *
       * @abstract
       * @param {BufferAttribute} attribute - The buffer attribute.
       */
    }, {
      key: "createStorageAttribute",
      value: function createStorageAttribute(/*attribute*/) {}

      /**
       * Updates the buffer of a shader attribute.
       *
       * @abstract
       * @param {BufferAttribute} attribute - The buffer attribute to update.
       */
    }, {
      key: "updateAttribute",
      value: function updateAttribute(/*attribute*/) {}

      /**
       * Destroys the buffer of a shader attribute.
       *
       * @abstract
       * @param {BufferAttribute} attribute - The buffer attribute to destroy.
       */
    }, {
      key: "destroyAttribute",
      value: function destroyAttribute(/*attribute*/) {}

      // canvas

      /**
       * Returns the backend's rendering context.
       *
       * @abstract
       * @return {Object} The rendering context.
       */
    }, {
      key: "getContext",
      value: function getContext() {}

      /**
       * Backends can use this method if they have to run
       * logic when the renderer gets resized.
       *
       * @abstract
       */
    }, {
      key: "updateSize",
      value: function updateSize() {}

      /**
       * Updates the viewport with the values from the given render context.
       *
       * @abstract
       * @param {RenderContext} renderContext - The render context.
       */
    }, {
      key: "updateViewport",
      value: function updateViewport(/*renderContext*/) {}

      // utils

      /**
       * Returns `true` if the given 3D object is fully occluded by other
       * 3D objects in the scene. Backends must implement this method by using
       * a Occlusion Query API.
       *
       * @abstract
       * @param {RenderContext} renderContext - The render context.
       * @param {Object3D} object - The 3D object to test.
       * @return {Boolean} Whether the 3D object is fully occluded or not.
       */
    }, {
      key: "isOccluded",
      value: function isOccluded(/*renderContext, object*/) {}

      /**
       * Resolves the time stamp for the given render context and type.
       *
       * @async
       * @abstract
       * @param {RenderContext} renderContext - The render context.
       * @param {String} type - The render context.
       * @return {Promise} A Promise that resolves when the time stamp has been computed.
       */
    }, {
      key: "resolveTimestampAsync",
      value: (function () {
        var _resolveTimestampAsync = (0, _asyncToGenerator2.default)(function* () {});
        function resolveTimestampAsync() {
          return _resolveTimestampAsync.apply(this, arguments);
        }
        return resolveTimestampAsync;
      }(
        /*renderContext, type*/
      )
      /**
       * Can be used to synchronize CPU operations with GPU tasks. So when this method is called,
       * the CPU waits for the GPU to complete its operation (e.g. a compute task).
       *
       * @async
       * @abstract
       * @return {Promise} A Promise that resolves when synchronization has been finished.
       */
      )
    }, {
      key: "waitForGPU",
      value: (function () {
        var _waitForGPU2 = (0, _asyncToGenerator2.default)(function* () {});
        function waitForGPU() {
          return _waitForGPU2.apply(this, arguments);
        }
        return waitForGPU;
      }()
      /**
       * Checks if the given feature is supported by the backend.
       *
       * @async
       * @abstract
       * @param {String} name - The feature's name.
       * @return {Promise<Boolean>} A Promise that resolves with a bool that indicates whether the feature is supported or not.
       */
      )
    }, {
      key: "hasFeatureAsync",
      value: (function () {
        var _hasFeatureAsync2 = (0, _asyncToGenerator2.default)(function* () {});
        function hasFeatureAsync() {
          return _hasFeatureAsync2.apply(this, arguments);
        }
        return hasFeatureAsync;
      }(
        /*name*/
      )
      /**
       * Checks if the given feature is supported  by the backend.
       *
       * @abstract
       * @param {String} name - The feature's name.
       * @return {Boolean} Whether the feature is supported or not.
       */
      )
    }, {
      key: "hasFeature",
      value: function hasFeature(/*name*/) {}

      /**
       * Returns the maximum anisotropy texture filtering value.
       *
       * @abstract
       * @return {Number} The maximum anisotropy texture filtering value.
       */
    }, {
      key: "getMaxAnisotropy",
      value: function getMaxAnisotropy() {}

      /**
       * Returns the drawing buffer size.
       *
       * @return {Vector2} The drawing buffer size.
       */
    }, {
      key: "getDrawingBufferSize",
      value: function getDrawingBufferSize() {
        _vector2 = _vector2 || new (_$$_REQUIRE(_dependencyMap[1], "./three.core.js").Vector2)();
        return this.renderer.getDrawingBufferSize(_vector2);
      }

      /**
       * Defines the scissor test.
       *
       * @abstract
       * @param {Boolean} boolean - Whether the scissor test should be enabled or not.
       */
    }, {
      key: "setScissorTest",
      value: function setScissorTest(/*boolean*/) {}

      /**
       * Returns the clear color and alpha into a single
       * color object.
       *
       * @return {Color4} The clear color.
       */
    }, {
      key: "getClearColor",
      value: function getClearColor() {
        var renderer = this.renderer;
        _color4 = _color4 || new Color4();
        renderer.getClearColor(_color4);
        _color4.getRGB(_color4, this.renderer.currentColorSpace);
        return _color4;
      }

      /**
       * Returns the DOM element. If no DOM element exists, the backend
       * creates a new one.
       *
       * @return {HTMLCanvasElement} The DOM element.
       */
    }, {
      key: "getDomElement",
      value: function getDomElement() {
        var domElement = this.domElement;
        if (domElement === null) {
          domElement = this.parameters.canvas !== undefined ? this.parameters.canvas : (0, _$$_REQUIRE(_dependencyMap[1], "./three.core.js").createCanvasElement)();

          // OffscreenCanvas does not have setAttribute, see #22811
          if ('setAttribute' in domElement) domElement.setAttribute('data-engine', `three.js r${_$$_REQUIRE(_dependencyMap[1], "./three.core.js").REVISION} webgpu`);
          this.domElement = domElement;
        }
        return domElement;
      }

      /**
       * Sets a dictionary for the given object into the
       * internal data structure.
       *
       * @param {Object} object - The object.
       * @param {Object} value - The dictionary to set.
       */
    }, {
      key: "set",
      value: function set(object, value) {
        this.data.set(object, value);
      }

      /**
       * Returns the dictionary for the given object.
       *
       * @param {Object} object - The object.
       * @return {Object} The object's dictionary.
       */
    }, {
      key: "get",
      value: function get(object) {
        var map = this.data.get(object);
        if (map === undefined) {
          map = {};
          this.data.set(object, map);
        }
        return map;
      }

      /**
       * Checks if the given object has a dictionary
       * with data defined.
       *
       * @param {Object} object - The object.
       * @return {Boolean} Whether a dictionary for the given object as been defined or not.
       */
    }, {
      key: "has",
      value: function has(object) {
        return this.data.has(object);
      }

      /**
       * Deletes an object from the internal data structure.
       *
       * @param {Object} object - The object to delete.
       */
    }, {
      key: "delete",
      value: function _delete(object) {
        this.data.delete(object);
      }

      /**
       * Frees internal resources.
       *
       * @abstract
       */
    }, {
      key: "dispose",
      value: function dispose() {}
    }]);
  }();
  var _id$1 = 0;
  var DualAttributeData = /*#__PURE__*/function () {
    function DualAttributeData(attributeData, dualBuffer) {
      (0, _classCallCheck2.default)(this, DualAttributeData);
      this.buffers = [attributeData.bufferGPU, dualBuffer];
      this.type = attributeData.type;
      this.bufferType = attributeData.bufferType;
      this.pbo = attributeData.pbo;
      this.byteLength = attributeData.byteLength;
      this.bytesPerElement = attributeData.BYTES_PER_ELEMENT;
      this.version = attributeData.version;
      this.isInteger = attributeData.isInteger;
      this.activeBufferIndex = 0;
      this.baseId = attributeData.id;
    }
    return (0, _createClass2.default)(DualAttributeData, [{
      key: "id",
      get: function get() {
        return `${this.baseId}|${this.activeBufferIndex}`;
      }
    }, {
      key: "bufferGPU",
      get: function get() {
        return this.buffers[this.activeBufferIndex];
      }
    }, {
      key: "transformBuffer",
      get: function get() {
        return this.buffers[this.activeBufferIndex ^ 1];
      }
    }, {
      key: "switchBuffers",
      value: function switchBuffers() {
        this.activeBufferIndex ^= 1;
      }
    }]);
  }();
  var WebGLAttributeUtils = /*#__PURE__*/function () {
    function WebGLAttributeUtils(backend) {
      (0, _classCallCheck2.default)(this, WebGLAttributeUtils);
      this.backend = backend;
    }
    return (0, _createClass2.default)(WebGLAttributeUtils, [{
      key: "createAttribute",
      value: function createAttribute(attribute, bufferType) {
        var backend = this.backend;
        var gl = backend.gl;
        var array = attribute.array;
        var usage = attribute.usage || gl.STATIC_DRAW;
        var bufferAttribute = attribute.isInterleavedBufferAttribute ? attribute.data : attribute;
        var bufferData = backend.get(bufferAttribute);
        var bufferGPU = bufferData.bufferGPU;
        if (bufferGPU === undefined) {
          bufferGPU = this._createBuffer(gl, bufferType, array, usage);
          bufferData.bufferGPU = bufferGPU;
          bufferData.bufferType = bufferType;
          bufferData.version = bufferAttribute.version;
        }

        //attribute.onUploadCallback();

        var type;
        if (array instanceof Float32Array) {
          type = gl.FLOAT;
        } else if (array instanceof Uint16Array) {
          if (attribute.isFloat16BufferAttribute) {
            type = gl.HALF_FLOAT;
          } else {
            type = gl.UNSIGNED_SHORT;
          }
        } else if (array instanceof Int16Array) {
          type = gl.SHORT;
        } else if (array instanceof Uint32Array) {
          type = gl.UNSIGNED_INT;
        } else if (array instanceof Int32Array) {
          type = gl.INT;
        } else if (array instanceof Int8Array) {
          type = gl.BYTE;
        } else if (array instanceof Uint8Array) {
          type = gl.UNSIGNED_BYTE;
        } else if (array instanceof Uint8ClampedArray) {
          type = gl.UNSIGNED_BYTE;
        } else {
          throw new Error('THREE.WebGLBackend: Unsupported buffer data format: ' + array);
        }
        var attributeData = {
          bufferGPU: bufferGPU,
          bufferType: bufferType,
          type: type,
          byteLength: array.byteLength,
          bytesPerElement: array.BYTES_PER_ELEMENT,
          version: attribute.version,
          pbo: attribute.pbo,
          isInteger: type === gl.INT || type === gl.UNSIGNED_INT || attribute.gpuType === _$$_REQUIRE(_dependencyMap[1], "./three.core.js").IntType,
          id: _id$1++
        };
        if (attribute.isStorageBufferAttribute || attribute.isStorageInstancedBufferAttribute) {
          // create buffer for transform feedback use
          var bufferGPUDual = this._createBuffer(gl, bufferType, array, usage);
          attributeData = new DualAttributeData(attributeData, bufferGPUDual);
        }
        backend.set(attribute, attributeData);
      }
    }, {
      key: "updateAttribute",
      value: function updateAttribute(attribute) {
        var backend = this.backend;
        var gl = backend.gl;
        var array = attribute.array;
        var bufferAttribute = attribute.isInterleavedBufferAttribute ? attribute.data : attribute;
        var bufferData = backend.get(bufferAttribute);
        var bufferType = bufferData.bufferType;
        var updateRanges = attribute.isInterleavedBufferAttribute ? attribute.data.updateRanges : attribute.updateRanges;
        gl.bindBuffer(bufferType, bufferData.bufferGPU);
        if (updateRanges.length === 0) {
          // Not using update ranges

          gl.bufferSubData(bufferType, 0, array);
        } else {
          for (var i = 0, l = updateRanges.length; i < l; i++) {
            var _range = updateRanges[i];
            gl.bufferSubData(bufferType, _range.start * array.BYTES_PER_ELEMENT, array, _range.start, _range.count);
          }
          bufferAttribute.clearUpdateRanges();
        }
        gl.bindBuffer(bufferType, null);
        bufferData.version = bufferAttribute.version;
      }
    }, {
      key: "destroyAttribute",
      value: function destroyAttribute(attribute) {
        var backend = this.backend;
        var gl = backend.gl;
        if (attribute.isInterleavedBufferAttribute) {
          backend.delete(attribute.data);
        }
        var attributeData = backend.get(attribute);
        gl.deleteBuffer(attributeData.bufferGPU);
        backend.delete(attribute);
      }
    }, {
      key: "getArrayBufferAsync",
      value: function () {
        var _getArrayBufferAsync2 = (0, _asyncToGenerator2.default)(function* (attribute) {
          var backend = this.backend;
          var gl = backend.gl;
          var bufferAttribute = attribute.isInterleavedBufferAttribute ? attribute.data : attribute;
          var _backend$get = backend.get(bufferAttribute),
            bufferGPU = _backend$get.bufferGPU;
          var array = attribute.array;
          var byteLength = array.byteLength;
          gl.bindBuffer(gl.COPY_READ_BUFFER, bufferGPU);
          var writeBuffer = gl.createBuffer();
          gl.bindBuffer(gl.COPY_WRITE_BUFFER, writeBuffer);
          gl.bufferData(gl.COPY_WRITE_BUFFER, byteLength, gl.STREAM_READ);
          gl.copyBufferSubData(gl.COPY_READ_BUFFER, gl.COPY_WRITE_BUFFER, 0, 0, byteLength);
          yield backend.utils._clientWaitAsync();
          var dstBuffer = new attribute.array.constructor(array.length);

          // Ensure the buffer is bound before reading
          gl.bindBuffer(gl.COPY_WRITE_BUFFER, writeBuffer);
          gl.getBufferSubData(gl.COPY_WRITE_BUFFER, 0, dstBuffer);
          gl.deleteBuffer(writeBuffer);
          gl.bindBuffer(gl.COPY_READ_BUFFER, null);
          gl.bindBuffer(gl.COPY_WRITE_BUFFER, null);
          return dstBuffer.buffer;
        });
        function getArrayBufferAsync(_x28) {
          return _getArrayBufferAsync2.apply(this, arguments);
        }
        return getArrayBufferAsync;
      }()
    }, {
      key: "_createBuffer",
      value: function _createBuffer(gl, bufferType, array, usage) {
        var bufferGPU = gl.createBuffer();
        gl.bindBuffer(bufferType, bufferGPU);
        gl.bufferData(bufferType, array, usage);
        gl.bindBuffer(bufferType, null);
        return bufferGPU;
      }
    }]);
  }();
  var initialized$1 = false,
    equationToGL,
    factorToGL;
  var WebGLState = /*#__PURE__*/function () {
    function WebGLState(backend) {
      (0, _classCallCheck2.default)(this, WebGLState);
      this.backend = backend;
      this.gl = this.backend.gl;
      this.enabled = {};
      this.currentFlipSided = null;
      this.currentCullFace = null;
      this.currentProgram = null;
      this.currentBlendingEnabled = false;
      this.currentBlending = null;
      this.currentBlendSrc = null;
      this.currentBlendDst = null;
      this.currentBlendSrcAlpha = null;
      this.currentBlendDstAlpha = null;
      this.currentPremultipledAlpha = null;
      this.currentPolygonOffsetFactor = null;
      this.currentPolygonOffsetUnits = null;
      this.currentColorMask = null;
      this.currentDepthFunc = null;
      this.currentDepthMask = null;
      this.currentStencilFunc = null;
      this.currentStencilRef = null;
      this.currentStencilFuncMask = null;
      this.currentStencilFail = null;
      this.currentStencilZFail = null;
      this.currentStencilZPass = null;
      this.currentStencilMask = null;
      this.currentLineWidth = null;
      this.currentClippingPlanes = 0;
      this.currentBoundFramebuffers = {};
      this.currentDrawbuffers = new WeakMap();
      this.maxTextures = this.gl.getParameter(this.gl.MAX_TEXTURE_IMAGE_UNITS);
      this.currentTextureSlot = null;
      this.currentBoundTextures = {};
      this.currentBoundBufferBases = {};
      if (initialized$1 === false) {
        this._init(this.gl);
        initialized$1 = true;
      }
    }
    return (0, _createClass2.default)(WebGLState, [{
      key: "_init",
      value: function _init(gl) {
        var _factorToGL;
        // Store only WebGL constants here.

        equationToGL = (0, _defineProperty2.default)((0, _defineProperty2.default)((0, _defineProperty2.default)({}, _$$_REQUIRE(_dependencyMap[1], "./three.core.js").AddEquation, gl.FUNC_ADD), _$$_REQUIRE(_dependencyMap[1], "./three.core.js").SubtractEquation, gl.FUNC_SUBTRACT), _$$_REQUIRE(_dependencyMap[1], "./three.core.js").ReverseSubtractEquation, gl.FUNC_REVERSE_SUBTRACT);
        factorToGL = (_factorToGL = {}, (0, _defineProperty2.default)((0, _defineProperty2.default)((0, _defineProperty2.default)((0, _defineProperty2.default)((0, _defineProperty2.default)((0, _defineProperty2.default)((0, _defineProperty2.default)((0, _defineProperty2.default)((0, _defineProperty2.default)((0, _defineProperty2.default)(_factorToGL, _$$_REQUIRE(_dependencyMap[1], "./three.core.js").ZeroFactor, gl.ZERO), _$$_REQUIRE(_dependencyMap[1], "./three.core.js").OneFactor, gl.ONE), _$$_REQUIRE(_dependencyMap[1], "./three.core.js").SrcColorFactor, gl.SRC_COLOR), _$$_REQUIRE(_dependencyMap[1], "./three.core.js").SrcAlphaFactor, gl.SRC_ALPHA), _$$_REQUIRE(_dependencyMap[1], "./three.core.js").SrcAlphaSaturateFactor, gl.SRC_ALPHA_SATURATE), _$$_REQUIRE(_dependencyMap[1], "./three.core.js").DstColorFactor, gl.DST_COLOR), _$$_REQUIRE(_dependencyMap[1], "./three.core.js").DstAlphaFactor, gl.DST_ALPHA), _$$_REQUIRE(_dependencyMap[1], "./three.core.js").OneMinusSrcColorFactor, gl.ONE_MINUS_SRC_COLOR), _$$_REQUIRE(_dependencyMap[1], "./three.core.js").OneMinusSrcAlphaFactor, gl.ONE_MINUS_SRC_ALPHA), _$$_REQUIRE(_dependencyMap[1], "./three.core.js").OneMinusDstColorFactor, gl.ONE_MINUS_DST_COLOR), (0, _defineProperty2.default)(_factorToGL, _$$_REQUIRE(_dependencyMap[1], "./three.core.js").OneMinusDstAlphaFactor, gl.ONE_MINUS_DST_ALPHA));
      }
    }, {
      key: "enable",
      value: function enable(id) {
        var enabled = this.enabled;
        if (enabled[id] !== true) {
          this.gl.enable(id);
          enabled[id] = true;
        }
      }
    }, {
      key: "disable",
      value: function disable(id) {
        var enabled = this.enabled;
        if (enabled[id] !== false) {
          this.gl.disable(id);
          enabled[id] = false;
        }
      }
    }, {
      key: "setFlipSided",
      value: function setFlipSided(flipSided) {
        if (this.currentFlipSided !== flipSided) {
          var gl = this.gl;
          if (flipSided) {
            gl.frontFace(gl.CW);
          } else {
            gl.frontFace(gl.CCW);
          }
          this.currentFlipSided = flipSided;
        }
      }
    }, {
      key: "setCullFace",
      value: function setCullFace(cullFace) {
        var gl = this.gl;
        if (cullFace !== _$$_REQUIRE(_dependencyMap[1], "./three.core.js").CullFaceNone) {
          this.enable(gl.CULL_FACE);
          if (cullFace !== this.currentCullFace) {
            if (cullFace === _$$_REQUIRE(_dependencyMap[1], "./three.core.js").CullFaceBack) {
              gl.cullFace(gl.BACK);
            } else if (cullFace === _$$_REQUIRE(_dependencyMap[1], "./three.core.js").CullFaceFront) {
              gl.cullFace(gl.FRONT);
            } else {
              gl.cullFace(gl.FRONT_AND_BACK);
            }
          }
        } else {
          this.disable(gl.CULL_FACE);
        }
        this.currentCullFace = cullFace;
      }
    }, {
      key: "setLineWidth",
      value: function setLineWidth(width) {
        var currentLineWidth = this.currentLineWidth,
          gl = this.gl;
        if (width !== currentLineWidth) {
          gl.lineWidth(width);
          this.currentLineWidth = width;
        }
      }
    }, {
      key: "setBlending",
      value: function setBlending(blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, premultipliedAlpha) {
        var gl = this.gl;
        if (blending === _$$_REQUIRE(_dependencyMap[1], "./three.core.js").NoBlending) {
          if (this.currentBlendingEnabled === true) {
            this.disable(gl.BLEND);
            this.currentBlendingEnabled = false;
          }
          return;
        }
        if (this.currentBlendingEnabled === false) {
          this.enable(gl.BLEND);
          this.currentBlendingEnabled = true;
        }
        if (blending !== _$$_REQUIRE(_dependencyMap[1], "./three.core.js").CustomBlending) {
          if (blending !== this.currentBlending || premultipliedAlpha !== this.currentPremultipledAlpha) {
            if (this.currentBlendEquation !== _$$_REQUIRE(_dependencyMap[1], "./three.core.js").AddEquation || this.currentBlendEquationAlpha !== _$$_REQUIRE(_dependencyMap[1], "./three.core.js").AddEquation) {
              gl.blendEquation(gl.FUNC_ADD);
              this.currentBlendEquation = _$$_REQUIRE(_dependencyMap[1], "./three.core.js").AddEquation;
              this.currentBlendEquationAlpha = _$$_REQUIRE(_dependencyMap[1], "./three.core.js").AddEquation;
            }
            if (premultipliedAlpha) {
              switch (blending) {
                case _$$_REQUIRE(_dependencyMap[1], "./three.core.js").NormalBlending:
                  gl.blendFuncSeparate(gl.ONE, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
                  break;
                case _$$_REQUIRE(_dependencyMap[1], "./three.core.js").AdditiveBlending:
                  gl.blendFunc(gl.ONE, gl.ONE);
                  break;
                case _$$_REQUIRE(_dependencyMap[1], "./three.core.js").SubtractiveBlending:
                  gl.blendFuncSeparate(gl.ZERO, gl.ONE_MINUS_SRC_COLOR, gl.ZERO, gl.ONE);
                  break;
                case _$$_REQUIRE(_dependencyMap[1], "./three.core.js").MultiplyBlending:
                  gl.blendFuncSeparate(gl.ZERO, gl.SRC_COLOR, gl.ZERO, gl.SRC_ALPHA);
                  break;
                default:
                  console.error('THREE.WebGLState: Invalid blending: ', blending);
                  break;
              }
            } else {
              switch (blending) {
                case _$$_REQUIRE(_dependencyMap[1], "./three.core.js").NormalBlending:
                  gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
                  break;
                case _$$_REQUIRE(_dependencyMap[1], "./three.core.js").AdditiveBlending:
                  gl.blendFunc(gl.SRC_ALPHA, gl.ONE);
                  break;
                case _$$_REQUIRE(_dependencyMap[1], "./three.core.js").SubtractiveBlending:
                  gl.blendFuncSeparate(gl.ZERO, gl.ONE_MINUS_SRC_COLOR, gl.ZERO, gl.ONE);
                  break;
                case _$$_REQUIRE(_dependencyMap[1], "./three.core.js").MultiplyBlending:
                  gl.blendFunc(gl.ZERO, gl.SRC_COLOR);
                  break;
                default:
                  console.error('THREE.WebGLState: Invalid blending: ', blending);
                  break;
              }
            }
            this.currentBlendSrc = null;
            this.currentBlendDst = null;
            this.currentBlendSrcAlpha = null;
            this.currentBlendDstAlpha = null;
            this.currentBlending = blending;
            this.currentPremultipledAlpha = premultipliedAlpha;
          }
          return;
        }

        // custom blending

        blendEquationAlpha = blendEquationAlpha || blendEquation;
        blendSrcAlpha = blendSrcAlpha || blendSrc;
        blendDstAlpha = blendDstAlpha || blendDst;
        if (blendEquation !== this.currentBlendEquation || blendEquationAlpha !== this.currentBlendEquationAlpha) {
          gl.blendEquationSeparate(equationToGL[blendEquation], equationToGL[blendEquationAlpha]);
          this.currentBlendEquation = blendEquation;
          this.currentBlendEquationAlpha = blendEquationAlpha;
        }
        if (blendSrc !== this.currentBlendSrc || blendDst !== this.currentBlendDst || blendSrcAlpha !== this.currentBlendSrcAlpha || blendDstAlpha !== this.currentBlendDstAlpha) {
          gl.blendFuncSeparate(factorToGL[blendSrc], factorToGL[blendDst], factorToGL[blendSrcAlpha], factorToGL[blendDstAlpha]);
          this.currentBlendSrc = blendSrc;
          this.currentBlendDst = blendDst;
          this.currentBlendSrcAlpha = blendSrcAlpha;
          this.currentBlendDstAlpha = blendDstAlpha;
        }
        this.currentBlending = blending;
        this.currentPremultipledAlpha = false;
      }
    }, {
      key: "setColorMask",
      value: function setColorMask(colorMask) {
        if (this.currentColorMask !== colorMask) {
          this.gl.colorMask(colorMask, colorMask, colorMask, colorMask);
          this.currentColorMask = colorMask;
        }
      }
    }, {
      key: "setDepthTest",
      value: function setDepthTest(depthTest) {
        var gl = this.gl;
        if (depthTest) {
          this.enable(gl.DEPTH_TEST);
        } else {
          this.disable(gl.DEPTH_TEST);
        }
      }
    }, {
      key: "setDepthMask",
      value: function setDepthMask(depthMask) {
        if (this.currentDepthMask !== depthMask) {
          this.gl.depthMask(depthMask);
          this.currentDepthMask = depthMask;
        }
      }
    }, {
      key: "setDepthFunc",
      value: function setDepthFunc(depthFunc) {
        if (this.currentDepthFunc !== depthFunc) {
          var gl = this.gl;
          switch (depthFunc) {
            case _$$_REQUIRE(_dependencyMap[1], "./three.core.js").NeverDepth:
              gl.depthFunc(gl.NEVER);
              break;
            case _$$_REQUIRE(_dependencyMap[1], "./three.core.js").AlwaysDepth:
              gl.depthFunc(gl.ALWAYS);
              break;
            case _$$_REQUIRE(_dependencyMap[1], "./three.core.js").LessDepth:
              gl.depthFunc(gl.LESS);
              break;
            case _$$_REQUIRE(_dependencyMap[1], "./three.core.js").LessEqualDepth:
              gl.depthFunc(gl.LEQUAL);
              break;
            case _$$_REQUIRE(_dependencyMap[1], "./three.core.js").EqualDepth:
              gl.depthFunc(gl.EQUAL);
              break;
            case _$$_REQUIRE(_dependencyMap[1], "./three.core.js").GreaterEqualDepth:
              gl.depthFunc(gl.GEQUAL);
              break;
            case _$$_REQUIRE(_dependencyMap[1], "./three.core.js").GreaterDepth:
              gl.depthFunc(gl.GREATER);
              break;
            case _$$_REQUIRE(_dependencyMap[1], "./three.core.js").NotEqualDepth:
              gl.depthFunc(gl.NOTEQUAL);
              break;
            default:
              gl.depthFunc(gl.LEQUAL);
          }
          this.currentDepthFunc = depthFunc;
        }
      }
    }, {
      key: "setStencilTest",
      value: function setStencilTest(stencilTest) {
        var gl = this.gl;
        if (stencilTest) {
          this.enable(gl.STENCIL_TEST);
        } else {
          this.disable(gl.STENCIL_TEST);
        }
      }
    }, {
      key: "setStencilMask",
      value: function setStencilMask(stencilMask) {
        if (this.currentStencilMask !== stencilMask) {
          this.gl.stencilMask(stencilMask);
          this.currentStencilMask = stencilMask;
        }
      }
    }, {
      key: "setStencilFunc",
      value: function setStencilFunc(stencilFunc, stencilRef, stencilMask) {
        if (this.currentStencilFunc !== stencilFunc || this.currentStencilRef !== stencilRef || this.currentStencilFuncMask !== stencilMask) {
          this.gl.stencilFunc(stencilFunc, stencilRef, stencilMask);
          this.currentStencilFunc = stencilFunc;
          this.currentStencilRef = stencilRef;
          this.currentStencilFuncMask = stencilMask;
        }
      }
    }, {
      key: "setStencilOp",
      value: function setStencilOp(stencilFail, stencilZFail, stencilZPass) {
        if (this.currentStencilFail !== stencilFail || this.currentStencilZFail !== stencilZFail || this.currentStencilZPass !== stencilZPass) {
          this.gl.stencilOp(stencilFail, stencilZFail, stencilZPass);
          this.currentStencilFail = stencilFail;
          this.currentStencilZFail = stencilZFail;
          this.currentStencilZPass = stencilZPass;
        }
      }
    }, {
      key: "setMaterial",
      value: function setMaterial(material, frontFaceCW, hardwareClippingPlanes) {
        var gl = this.gl;
        material.side === _$$_REQUIRE(_dependencyMap[1], "./three.core.js").DoubleSide ? this.disable(gl.CULL_FACE) : this.enable(gl.CULL_FACE);
        var flipSided = material.side === _$$_REQUIRE(_dependencyMap[1], "./three.core.js").BackSide;
        if (frontFaceCW) flipSided = !flipSided;
        this.setFlipSided(flipSided);
        material.blending === _$$_REQUIRE(_dependencyMap[1], "./three.core.js").NormalBlending && material.transparent === false ? this.setBlending(_$$_REQUIRE(_dependencyMap[1], "./three.core.js").NoBlending) : this.setBlending(material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.premultipliedAlpha);
        this.setDepthFunc(material.depthFunc);
        this.setDepthTest(material.depthTest);
        this.setDepthMask(material.depthWrite);
        this.setColorMask(material.colorWrite);
        var stencilWrite = material.stencilWrite;
        this.setStencilTest(stencilWrite);
        if (stencilWrite) {
          this.setStencilMask(material.stencilWriteMask);
          this.setStencilFunc(material.stencilFunc, material.stencilRef, material.stencilFuncMask);
          this.setStencilOp(material.stencilFail, material.stencilZFail, material.stencilZPass);
        }
        this.setPolygonOffset(material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits);
        material.alphaToCoverage === true && this.backend.renderer.samples > 1 ? this.enable(gl.SAMPLE_ALPHA_TO_COVERAGE) : this.disable(gl.SAMPLE_ALPHA_TO_COVERAGE);
        if (hardwareClippingPlanes > 0) {
          if (this.currentClippingPlanes !== hardwareClippingPlanes) {
            var CLIP_DISTANCE0_WEBGL = 0x3000;
            for (var i = 0; i < 8; i++) {
              if (i < hardwareClippingPlanes) {
                this.enable(CLIP_DISTANCE0_WEBGL + i);
              } else {
                this.disable(CLIP_DISTANCE0_WEBGL + i);
              }
            }
          }
        }
      }
    }, {
      key: "setPolygonOffset",
      value: function setPolygonOffset(polygonOffset, factor, units) {
        var gl = this.gl;
        if (polygonOffset) {
          this.enable(gl.POLYGON_OFFSET_FILL);
          if (this.currentPolygonOffsetFactor !== factor || this.currentPolygonOffsetUnits !== units) {
            gl.polygonOffset(factor, units);
            this.currentPolygonOffsetFactor = factor;
            this.currentPolygonOffsetUnits = units;
          }
        } else {
          this.disable(gl.POLYGON_OFFSET_FILL);
        }
      }
    }, {
      key: "useProgram",
      value: function useProgram(program) {
        if (this.currentProgram !== program) {
          this.gl.useProgram(program);
          this.currentProgram = program;
          return true;
        }
        return false;
      }

      // framebuffer
    }, {
      key: "bindFramebuffer",
      value: function bindFramebuffer(target, framebuffer) {
        var gl = this.gl,
          currentBoundFramebuffers = this.currentBoundFramebuffers;
        if (currentBoundFramebuffers[target] !== framebuffer) {
          gl.bindFramebuffer(target, framebuffer);
          currentBoundFramebuffers[target] = framebuffer;

          // gl.DRAW_FRAMEBUFFER is equivalent to gl.FRAMEBUFFER

          if (target === gl.DRAW_FRAMEBUFFER) {
            currentBoundFramebuffers[gl.FRAMEBUFFER] = framebuffer;
          }
          if (target === gl.FRAMEBUFFER) {
            currentBoundFramebuffers[gl.DRAW_FRAMEBUFFER] = framebuffer;
          }
          return true;
        }
        return false;
      }
    }, {
      key: "drawBuffers",
      value: function drawBuffers(renderContext, framebuffer) {
        var gl = this.gl;
        var drawBuffers = [];
        var needsUpdate = false;
        if (renderContext.textures !== null) {
          drawBuffers = this.currentDrawbuffers.get(framebuffer);
          if (drawBuffers === undefined) {
            drawBuffers = [];
            this.currentDrawbuffers.set(framebuffer, drawBuffers);
          }
          var textures = renderContext.textures;
          if (drawBuffers.length !== textures.length || drawBuffers[0] !== gl.COLOR_ATTACHMENT0) {
            for (var i = 0, il = textures.length; i < il; i++) {
              drawBuffers[i] = gl.COLOR_ATTACHMENT0 + i;
            }
            drawBuffers.length = textures.length;
            needsUpdate = true;
          }
        } else {
          if (drawBuffers[0] !== gl.BACK) {
            drawBuffers[0] = gl.BACK;
            needsUpdate = true;
          }
        }
        if (needsUpdate) {
          gl.drawBuffers(drawBuffers);
        }
      }

      // texture
    }, {
      key: "activeTexture",
      value: function activeTexture(webglSlot) {
        var gl = this.gl,
          currentTextureSlot = this.currentTextureSlot,
          maxTextures = this.maxTextures;
        if (webglSlot === undefined) webglSlot = gl.TEXTURE0 + maxTextures - 1;
        if (currentTextureSlot !== webglSlot) {
          gl.activeTexture(webglSlot);
          this.currentTextureSlot = webglSlot;
        }
      }
    }, {
      key: "bindTexture",
      value: function bindTexture(webglType, webglTexture, webglSlot) {
        var gl = this.gl,
          currentTextureSlot = this.currentTextureSlot,
          currentBoundTextures = this.currentBoundTextures,
          maxTextures = this.maxTextures;
        if (webglSlot === undefined) {
          if (currentTextureSlot === null) {
            webglSlot = gl.TEXTURE0 + maxTextures - 1;
          } else {
            webglSlot = currentTextureSlot;
          }
        }
        var boundTexture = currentBoundTextures[webglSlot];
        if (boundTexture === undefined) {
          boundTexture = {
            type: undefined,
            texture: undefined
          };
          currentBoundTextures[webglSlot] = boundTexture;
        }
        if (boundTexture.type !== webglType || boundTexture.texture !== webglTexture) {
          if (currentTextureSlot !== webglSlot) {
            gl.activeTexture(webglSlot);
            this.currentTextureSlot = webglSlot;
          }
          gl.bindTexture(webglType, webglTexture);
          boundTexture.type = webglType;
          boundTexture.texture = webglTexture;
        }
      }
    }, {
      key: "bindBufferBase",
      value: function bindBufferBase(target, index, buffer) {
        var gl = this.gl;
        var key = `${target}-${index}`;
        if (this.currentBoundBufferBases[key] !== buffer) {
          gl.bindBufferBase(target, index, buffer);
          this.currentBoundBufferBases[key] = buffer;
          return true;
        }
        return false;
      }
    }, {
      key: "unbindTexture",
      value: function unbindTexture() {
        var gl = this.gl,
          currentTextureSlot = this.currentTextureSlot,
          currentBoundTextures = this.currentBoundTextures;
        var boundTexture = currentBoundTextures[currentTextureSlot];
        if (boundTexture !== undefined && boundTexture.type !== undefined) {
          gl.bindTexture(boundTexture.type, null);
          boundTexture.type = undefined;
          boundTexture.texture = undefined;
        }
      }
    }]);
  }();
  var WebGLUtils = /*#__PURE__*/function () {
    function WebGLUtils(backend) {
      (0, _classCallCheck2.default)(this, WebGLUtils);
      this.backend = backend;
      this.gl = this.backend.gl;
      this.extensions = backend.extensions;
    }
    return (0, _createClass2.default)(WebGLUtils, [{
      key: "convert",
      value: function convert(p) {
        var colorSpace = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _$$_REQUIRE(_dependencyMap[1], "./three.core.js").NoColorSpace;
        var gl = this.gl,
          extensions = this.extensions;
        var extension;
        if (p === _$$_REQUIRE(_dependencyMap[1], "./three.core.js").UnsignedByteType) return gl.UNSIGNED_BYTE;
        if (p === _$$_REQUIRE(_dependencyMap[1], "./three.core.js").UnsignedShort4444Type) return gl.UNSIGNED_SHORT_4_4_4_4;
        if (p === _$$_REQUIRE(_dependencyMap[1], "./three.core.js").UnsignedShort5551Type) return gl.UNSIGNED_SHORT_5_5_5_1;
        if (p === _$$_REQUIRE(_dependencyMap[1], "./three.core.js").UnsignedInt5999Type) return gl.UNSIGNED_INT_5_9_9_9_REV;
        if (p === _$$_REQUIRE(_dependencyMap[1], "./three.core.js").ByteType) return gl.BYTE;
        if (p === _$$_REQUIRE(_dependencyMap[1], "./three.core.js").ShortType) return gl.SHORT;
        if (p === _$$_REQUIRE(_dependencyMap[1], "./three.core.js").UnsignedShortType) return gl.UNSIGNED_SHORT;
        if (p === _$$_REQUIRE(_dependencyMap[1], "./three.core.js").IntType) return gl.INT;
        if (p === _$$_REQUIRE(_dependencyMap[1], "./three.core.js").UnsignedIntType) return gl.UNSIGNED_INT;
        if (p === _$$_REQUIRE(_dependencyMap[1], "./three.core.js").FloatType) return gl.FLOAT;
        if (p === _$$_REQUIRE(_dependencyMap[1], "./three.core.js").HalfFloatType) {
          return gl.HALF_FLOAT;
        }
        if (p === _$$_REQUIRE(_dependencyMap[1], "./three.core.js").AlphaFormat) return gl.ALPHA;
        if (p === _$$_REQUIRE(_dependencyMap[1], "./three.core.js").RGBFormat) return gl.RGB;
        if (p === _$$_REQUIRE(_dependencyMap[1], "./three.core.js").RGBAFormat) return gl.RGBA;
        if (p === _$$_REQUIRE(_dependencyMap[1], "./three.core.js").LuminanceFormat) return gl.LUMINANCE;
        if (p === _$$_REQUIRE(_dependencyMap[1], "./three.core.js").LuminanceAlphaFormat) return gl.LUMINANCE_ALPHA;
        if (p === _$$_REQUIRE(_dependencyMap[1], "./three.core.js").DepthFormat) return gl.DEPTH_COMPONENT;
        if (p === _$$_REQUIRE(_dependencyMap[1], "./three.core.js").DepthStencilFormat) return gl.DEPTH_STENCIL;

        // WebGL2 formats.

        if (p === _$$_REQUIRE(_dependencyMap[1], "./three.core.js").RedFormat) return gl.RED;
        if (p === _$$_REQUIRE(_dependencyMap[1], "./three.core.js").RedIntegerFormat) return gl.RED_INTEGER;
        if (p === _$$_REQUIRE(_dependencyMap[1], "./three.core.js").RGFormat) return gl.RG;
        if (p === _$$_REQUIRE(_dependencyMap[1], "./three.core.js").RGIntegerFormat) return gl.RG_INTEGER;
        if (p === _$$_REQUIRE(_dependencyMap[1], "./three.core.js").RGBAIntegerFormat) return gl.RGBA_INTEGER;

        // S3TC

        if (p === _$$_REQUIRE(_dependencyMap[1], "./three.core.js").RGB_S3TC_DXT1_Format || p === _$$_REQUIRE(_dependencyMap[1], "./three.core.js").RGBA_S3TC_DXT1_Format || p === _$$_REQUIRE(_dependencyMap[1], "./three.core.js").RGBA_S3TC_DXT3_Format || p === _$$_REQUIRE(_dependencyMap[1], "./three.core.js").RGBA_S3TC_DXT5_Format) {
          if (colorSpace === _$$_REQUIRE(_dependencyMap[1], "./three.core.js").SRGBColorSpace) {
            extension = extensions.get('WEBGL_compressed_texture_s3tc_srgb');
            if (extension !== null) {
              if (p === _$$_REQUIRE(_dependencyMap[1], "./three.core.js").RGB_S3TC_DXT1_Format) return extension.COMPRESSED_SRGB_S3TC_DXT1_EXT;
              if (p === _$$_REQUIRE(_dependencyMap[1], "./three.core.js").RGBA_S3TC_DXT1_Format) return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
              if (p === _$$_REQUIRE(_dependencyMap[1], "./three.core.js").RGBA_S3TC_DXT3_Format) return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
              if (p === _$$_REQUIRE(_dependencyMap[1], "./three.core.js").RGBA_S3TC_DXT5_Format) return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
            } else {
              return null;
            }
          } else {
            extension = extensions.get('WEBGL_compressed_texture_s3tc');
            if (extension !== null) {
              if (p === _$$_REQUIRE(_dependencyMap[1], "./three.core.js").RGB_S3TC_DXT1_Format) return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;
              if (p === _$$_REQUIRE(_dependencyMap[1], "./three.core.js").RGBA_S3TC_DXT1_Format) return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;
              if (p === _$$_REQUIRE(_dependencyMap[1], "./three.core.js").RGBA_S3TC_DXT3_Format) return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;
              if (p === _$$_REQUIRE(_dependencyMap[1], "./three.core.js").RGBA_S3TC_DXT5_Format) return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;
            } else {
              return null;
            }
          }
        }

        // PVRTC

        if (p === _$$_REQUIRE(_dependencyMap[1], "./three.core.js").RGB_PVRTC_4BPPV1_Format || p === _$$_REQUIRE(_dependencyMap[1], "./three.core.js").RGB_PVRTC_2BPPV1_Format || p === _$$_REQUIRE(_dependencyMap[1], "./three.core.js").RGBA_PVRTC_4BPPV1_Format || p === _$$_REQUIRE(_dependencyMap[1], "./three.core.js").RGBA_PVRTC_2BPPV1_Format) {
          extension = extensions.get('WEBGL_compressed_texture_pvrtc');
          if (extension !== null) {
            if (p === _$$_REQUIRE(_dependencyMap[1], "./three.core.js").RGB_PVRTC_4BPPV1_Format) return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
            if (p === _$$_REQUIRE(_dependencyMap[1], "./three.core.js").RGB_PVRTC_2BPPV1_Format) return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
            if (p === _$$_REQUIRE(_dependencyMap[1], "./three.core.js").RGBA_PVRTC_4BPPV1_Format) return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
            if (p === _$$_REQUIRE(_dependencyMap[1], "./three.core.js").RGBA_PVRTC_2BPPV1_Format) return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
          } else {
            return null;
          }
        }

        // ETC

        if (p === _$$_REQUIRE(_dependencyMap[1], "./three.core.js").RGB_ETC1_Format || p === _$$_REQUIRE(_dependencyMap[1], "./three.core.js").RGB_ETC2_Format || p === _$$_REQUIRE(_dependencyMap[1], "./three.core.js").RGBA_ETC2_EAC_Format) {
          extension = extensions.get('WEBGL_compressed_texture_etc');
          if (extension !== null) {
            if (p === _$$_REQUIRE(_dependencyMap[1], "./three.core.js").RGB_ETC1_Format || p === _$$_REQUIRE(_dependencyMap[1], "./three.core.js").RGB_ETC2_Format) return colorSpace === _$$_REQUIRE(_dependencyMap[1], "./three.core.js").SRGBColorSpace ? extension.COMPRESSED_SRGB8_ETC2 : extension.COMPRESSED_RGB8_ETC2;
            if (p === _$$_REQUIRE(_dependencyMap[1], "./three.core.js").RGBA_ETC2_EAC_Format) return colorSpace === _$$_REQUIRE(_dependencyMap[1], "./three.core.js").SRGBColorSpace ? extension.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : extension.COMPRESSED_RGBA8_ETC2_EAC;
          } else {
            return null;
          }
        }

        // ASTC

        if (p === _$$_REQUIRE(_dependencyMap[1], "./three.core.js").RGBA_ASTC_4x4_Format || p === _$$_REQUIRE(_dependencyMap[1], "./three.core.js").RGBA_ASTC_5x4_Format || p === _$$_REQUIRE(_dependencyMap[1], "./three.core.js").RGBA_ASTC_5x5_Format || p === _$$_REQUIRE(_dependencyMap[1], "./three.core.js").RGBA_ASTC_6x5_Format || p === _$$_REQUIRE(_dependencyMap[1], "./three.core.js").RGBA_ASTC_6x6_Format || p === _$$_REQUIRE(_dependencyMap[1], "./three.core.js").RGBA_ASTC_8x5_Format || p === _$$_REQUIRE(_dependencyMap[1], "./three.core.js").RGBA_ASTC_8x6_Format || p === _$$_REQUIRE(_dependencyMap[1], "./three.core.js").RGBA_ASTC_8x8_Format || p === _$$_REQUIRE(_dependencyMap[1], "./three.core.js").RGBA_ASTC_10x5_Format || p === _$$_REQUIRE(_dependencyMap[1], "./three.core.js").RGBA_ASTC_10x6_Format || p === _$$_REQUIRE(_dependencyMap[1], "./three.core.js").RGBA_ASTC_10x8_Format || p === _$$_REQUIRE(_dependencyMap[1], "./three.core.js").RGBA_ASTC_10x10_Format || p === _$$_REQUIRE(_dependencyMap[1], "./three.core.js").RGBA_ASTC_12x10_Format || p === _$$_REQUIRE(_dependencyMap[1], "./three.core.js").RGBA_ASTC_12x12_Format) {
          extension = extensions.get('WEBGL_compressed_texture_astc');
          if (extension !== null) {
            if (p === _$$_REQUIRE(_dependencyMap[1], "./three.core.js").RGBA_ASTC_4x4_Format) return colorSpace === _$$_REQUIRE(_dependencyMap[1], "./three.core.js").SRGBColorSpace ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : extension.COMPRESSED_RGBA_ASTC_4x4_KHR;
            if (p === _$$_REQUIRE(_dependencyMap[1], "./three.core.js").RGBA_ASTC_5x4_Format) return colorSpace === _$$_REQUIRE(_dependencyMap[1], "./three.core.js").SRGBColorSpace ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : extension.COMPRESSED_RGBA_ASTC_5x4_KHR;
            if (p === _$$_REQUIRE(_dependencyMap[1], "./three.core.js").RGBA_ASTC_5x5_Format) return colorSpace === _$$_REQUIRE(_dependencyMap[1], "./three.core.js").SRGBColorSpace ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : extension.COMPRESSED_RGBA_ASTC_5x5_KHR;
            if (p === _$$_REQUIRE(_dependencyMap[1], "./three.core.js").RGBA_ASTC_6x5_Format) return colorSpace === _$$_REQUIRE(_dependencyMap[1], "./three.core.js").SRGBColorSpace ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : extension.COMPRESSED_RGBA_ASTC_6x5_KHR;
            if (p === _$$_REQUIRE(_dependencyMap[1], "./three.core.js").RGBA_ASTC_6x6_Format) return colorSpace === _$$_REQUIRE(_dependencyMap[1], "./three.core.js").SRGBColorSpace ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : extension.COMPRESSED_RGBA_ASTC_6x6_KHR;
            if (p === _$$_REQUIRE(_dependencyMap[1], "./three.core.js").RGBA_ASTC_8x5_Format) return colorSpace === _$$_REQUIRE(_dependencyMap[1], "./three.core.js").SRGBColorSpace ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : extension.COMPRESSED_RGBA_ASTC_8x5_KHR;
            if (p === _$$_REQUIRE(_dependencyMap[1], "./three.core.js").RGBA_ASTC_8x6_Format) return colorSpace === _$$_REQUIRE(_dependencyMap[1], "./three.core.js").SRGBColorSpace ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : extension.COMPRESSED_RGBA_ASTC_8x6_KHR;
            if (p === _$$_REQUIRE(_dependencyMap[1], "./three.core.js").RGBA_ASTC_8x8_Format) return colorSpace === _$$_REQUIRE(_dependencyMap[1], "./three.core.js").SRGBColorSpace ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : extension.COMPRESSED_RGBA_ASTC_8x8_KHR;
            if (p === _$$_REQUIRE(_dependencyMap[1], "./three.core.js").RGBA_ASTC_10x5_Format) return colorSpace === _$$_REQUIRE(_dependencyMap[1], "./three.core.js").SRGBColorSpace ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : extension.COMPRESSED_RGBA_ASTC_10x5_KHR;
            if (p === _$$_REQUIRE(_dependencyMap[1], "./three.core.js").RGBA_ASTC_10x6_Format) return colorSpace === _$$_REQUIRE(_dependencyMap[1], "./three.core.js").SRGBColorSpace ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : extension.COMPRESSED_RGBA_ASTC_10x6_KHR;
            if (p === _$$_REQUIRE(_dependencyMap[1], "./three.core.js").RGBA_ASTC_10x8_Format) return colorSpace === _$$_REQUIRE(_dependencyMap[1], "./three.core.js").SRGBColorSpace ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : extension.COMPRESSED_RGBA_ASTC_10x8_KHR;
            if (p === _$$_REQUIRE(_dependencyMap[1], "./three.core.js").RGBA_ASTC_10x10_Format) return colorSpace === _$$_REQUIRE(_dependencyMap[1], "./three.core.js").SRGBColorSpace ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : extension.COMPRESSED_RGBA_ASTC_10x10_KHR;
            if (p === _$$_REQUIRE(_dependencyMap[1], "./three.core.js").RGBA_ASTC_12x10_Format) return colorSpace === _$$_REQUIRE(_dependencyMap[1], "./three.core.js").SRGBColorSpace ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : extension.COMPRESSED_RGBA_ASTC_12x10_KHR;
            if (p === _$$_REQUIRE(_dependencyMap[1], "./three.core.js").RGBA_ASTC_12x12_Format) return colorSpace === _$$_REQUIRE(_dependencyMap[1], "./three.core.js").SRGBColorSpace ? extension.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : extension.COMPRESSED_RGBA_ASTC_12x12_KHR;
          } else {
            return null;
          }
        }

        // BPTC

        if (p === _$$_REQUIRE(_dependencyMap[1], "./three.core.js").RGBA_BPTC_Format) {
          extension = extensions.get('EXT_texture_compression_bptc');
          if (extension !== null) {
            if (p === _$$_REQUIRE(_dependencyMap[1], "./three.core.js").RGBA_BPTC_Format) return colorSpace === _$$_REQUIRE(_dependencyMap[1], "./three.core.js").SRGBColorSpace ? extension.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : extension.COMPRESSED_RGBA_BPTC_UNORM_EXT;
          } else {
            return null;
          }
        }

        // RGTC

        if (p === _$$_REQUIRE(_dependencyMap[1], "./three.core.js").RED_RGTC1_Format || p === _$$_REQUIRE(_dependencyMap[1], "./three.core.js").SIGNED_RED_RGTC1_Format || p === _$$_REQUIRE(_dependencyMap[1], "./three.core.js").RED_GREEN_RGTC2_Format || p === _$$_REQUIRE(_dependencyMap[1], "./three.core.js").SIGNED_RED_GREEN_RGTC2_Format) {
          extension = extensions.get('EXT_texture_compression_rgtc');
          if (extension !== null) {
            if (p === _$$_REQUIRE(_dependencyMap[1], "./three.core.js").RGBA_BPTC_Format) return extension.COMPRESSED_RED_RGTC1_EXT;
            if (p === _$$_REQUIRE(_dependencyMap[1], "./three.core.js").SIGNED_RED_RGTC1_Format) return extension.COMPRESSED_SIGNED_RED_RGTC1_EXT;
            if (p === _$$_REQUIRE(_dependencyMap[1], "./three.core.js").RED_GREEN_RGTC2_Format) return extension.COMPRESSED_RED_GREEN_RGTC2_EXT;
            if (p === _$$_REQUIRE(_dependencyMap[1], "./three.core.js").SIGNED_RED_GREEN_RGTC2_Format) return extension.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT;
          } else {
            return null;
          }
        }

        //

        if (p === _$$_REQUIRE(_dependencyMap[1], "./three.core.js").UnsignedInt248Type) {
          return gl.UNSIGNED_INT_24_8;
        }

        // if "p" can't be resolved, assume the user defines a WebGL constant as a string (fallback/workaround for packed RGB formats)

        return gl[p] !== undefined ? gl[p] : null;
      }
    }, {
      key: "_clientWaitAsync",
      value: function _clientWaitAsync() {
        var gl = this.gl;
        var sync = gl.fenceSync(gl.SYNC_GPU_COMMANDS_COMPLETE, 0);
        gl.flush();
        return new Promise(function (resolve, reject) {
          function test() {
            var res = gl.clientWaitSync(sync, gl.SYNC_FLUSH_COMMANDS_BIT, 0);
            if (res === gl.WAIT_FAILED) {
              gl.deleteSync(sync);
              reject();
              return;
            }
            if (res === gl.TIMEOUT_EXPIRED) {
              requestAnimationFrame(test);
              return;
            }
            gl.deleteSync(sync);
            resolve();
          }
          test();
        });
      }
    }]);
  }();
  var initialized = false,
    wrappingToGL,
    filterToGL,
    compareToGL;
  var WebGLTextureUtils = /*#__PURE__*/function () {
    function WebGLTextureUtils(backend) {
      (0, _classCallCheck2.default)(this, WebGLTextureUtils);
      this.backend = backend;
      this.gl = backend.gl;
      this.extensions = backend.extensions;
      this.defaultTextures = {};
      if (initialized === false) {
        this._init(this.gl);
        initialized = true;
      }
    }
    return (0, _createClass2.default)(WebGLTextureUtils, [{
      key: "_init",
      value: function _init(gl) {
        // Store only WebGL constants here.

        wrappingToGL = (0, _defineProperty2.default)((0, _defineProperty2.default)((0, _defineProperty2.default)({}, _$$_REQUIRE(_dependencyMap[1], "./three.core.js").RepeatWrapping, gl.REPEAT), _$$_REQUIRE(_dependencyMap[1], "./three.core.js").ClampToEdgeWrapping, gl.CLAMP_TO_EDGE), _$$_REQUIRE(_dependencyMap[1], "./three.core.js").MirroredRepeatWrapping, gl.MIRRORED_REPEAT);
        filterToGL = (0, _defineProperty2.default)((0, _defineProperty2.default)((0, _defineProperty2.default)((0, _defineProperty2.default)((0, _defineProperty2.default)((0, _defineProperty2.default)({}, _$$_REQUIRE(_dependencyMap[1], "./three.core.js").NearestFilter, gl.NEAREST), _$$_REQUIRE(_dependencyMap[1], "./three.core.js").NearestMipmapNearestFilter, gl.NEAREST_MIPMAP_NEAREST), _$$_REQUIRE(_dependencyMap[1], "./three.core.js").NearestMipmapLinearFilter, gl.NEAREST_MIPMAP_LINEAR), _$$_REQUIRE(_dependencyMap[1], "./three.core.js").LinearFilter, gl.LINEAR), _$$_REQUIRE(_dependencyMap[1], "./three.core.js").LinearMipmapNearestFilter, gl.LINEAR_MIPMAP_NEAREST), _$$_REQUIRE(_dependencyMap[1], "./three.core.js").LinearMipmapLinearFilter, gl.LINEAR_MIPMAP_LINEAR);
        compareToGL = (0, _defineProperty2.default)((0, _defineProperty2.default)((0, _defineProperty2.default)((0, _defineProperty2.default)((0, _defineProperty2.default)((0, _defineProperty2.default)((0, _defineProperty2.default)((0, _defineProperty2.default)({}, _$$_REQUIRE(_dependencyMap[1], "./three.core.js").NeverCompare, gl.NEVER), _$$_REQUIRE(_dependencyMap[1], "./three.core.js").AlwaysCompare, gl.ALWAYS), _$$_REQUIRE(_dependencyMap[1], "./three.core.js").LessCompare, gl.LESS), _$$_REQUIRE(_dependencyMap[1], "./three.core.js").LessEqualCompare, gl.LEQUAL), _$$_REQUIRE(_dependencyMap[1], "./three.core.js").EqualCompare, gl.EQUAL), _$$_REQUIRE(_dependencyMap[1], "./three.core.js").GreaterEqualCompare, gl.GEQUAL), _$$_REQUIRE(_dependencyMap[1], "./three.core.js").GreaterCompare, gl.GREATER), _$$_REQUIRE(_dependencyMap[1], "./three.core.js").NotEqualCompare, gl.NOTEQUAL);
      }
    }, {
      key: "filterFallback",
      value: function filterFallback(f) {
        var gl = this.gl;
        if (f === _$$_REQUIRE(_dependencyMap[1], "./three.core.js").NearestFilter || f === _$$_REQUIRE(_dependencyMap[1], "./three.core.js").NearestMipmapNearestFilter || f === _$$_REQUIRE(_dependencyMap[1], "./three.core.js").NearestMipmapLinearFilter) {
          return gl.NEAREST;
        }
        return gl.LINEAR;
      }
    }, {
      key: "getGLTextureType",
      value: function getGLTextureType(texture) {
        var gl = this.gl;
        var glTextureType;
        if (texture.isCubeTexture === true) {
          glTextureType = gl.TEXTURE_CUBE_MAP;
        } else if (texture.isDataArrayTexture === true || texture.isCompressedArrayTexture === true) {
          glTextureType = gl.TEXTURE_2D_ARRAY;
        } else if (texture.isData3DTexture === true) {
          // TODO: isCompressed3DTexture, wait for #26642

          glTextureType = gl.TEXTURE_3D;
        } else {
          glTextureType = gl.TEXTURE_2D;
        }
        return glTextureType;
      }
    }, {
      key: "getInternalFormat",
      value: function getInternalFormat(internalFormatName, glFormat, glType, colorSpace) {
        var forceLinearTransfer = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
        var gl = this.gl,
          extensions = this.extensions;
        if (internalFormatName !== null) {
          if (gl[internalFormatName] !== undefined) return gl[internalFormatName];
          console.warn('THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format \'' + internalFormatName + '\'');
        }
        var internalFormat = glFormat;
        if (glFormat === gl.RED) {
          if (glType === gl.FLOAT) internalFormat = gl.R32F;
          if (glType === gl.HALF_FLOAT) internalFormat = gl.R16F;
          if (glType === gl.UNSIGNED_BYTE) internalFormat = gl.R8;
          if (glType === gl.UNSIGNED_SHORT) internalFormat = gl.R16;
          if (glType === gl.UNSIGNED_INT) internalFormat = gl.R32UI;
          if (glType === gl.BYTE) internalFormat = gl.R8I;
          if (glType === gl.SHORT) internalFormat = gl.R16I;
          if (glType === gl.INT) internalFormat = gl.R32I;
        }
        if (glFormat === gl.RED_INTEGER) {
          if (glType === gl.UNSIGNED_BYTE) internalFormat = gl.R8UI;
          if (glType === gl.UNSIGNED_SHORT) internalFormat = gl.R16UI;
          if (glType === gl.UNSIGNED_INT) internalFormat = gl.R32UI;
          if (glType === gl.BYTE) internalFormat = gl.R8I;
          if (glType === gl.SHORT) internalFormat = gl.R16I;
          if (glType === gl.INT) internalFormat = gl.R32I;
        }
        if (glFormat === gl.RG) {
          if (glType === gl.FLOAT) internalFormat = gl.RG32F;
          if (glType === gl.HALF_FLOAT) internalFormat = gl.RG16F;
          if (glType === gl.UNSIGNED_BYTE) internalFormat = gl.RG8;
          if (glType === gl.UNSIGNED_SHORT) internalFormat = gl.RG16;
          if (glType === gl.UNSIGNED_INT) internalFormat = gl.RG32UI;
          if (glType === gl.BYTE) internalFormat = gl.RG8I;
          if (glType === gl.SHORT) internalFormat = gl.RG16I;
          if (glType === gl.INT) internalFormat = gl.RG32I;
        }
        if (glFormat === gl.RG_INTEGER) {
          if (glType === gl.UNSIGNED_BYTE) internalFormat = gl.RG8UI;
          if (glType === gl.UNSIGNED_SHORT) internalFormat = gl.RG16UI;
          if (glType === gl.UNSIGNED_INT) internalFormat = gl.RG32UI;
          if (glType === gl.BYTE) internalFormat = gl.RG8I;
          if (glType === gl.SHORT) internalFormat = gl.RG16I;
          if (glType === gl.INT) internalFormat = gl.RG32I;
        }
        if (glFormat === gl.RGB) {
          if (glType === gl.FLOAT) internalFormat = gl.RGB32F;
          if (glType === gl.HALF_FLOAT) internalFormat = gl.RGB16F;
          if (glType === gl.UNSIGNED_BYTE) internalFormat = gl.RGB8;
          if (glType === gl.UNSIGNED_SHORT) internalFormat = gl.RGB16;
          if (glType === gl.UNSIGNED_INT) internalFormat = gl.RGB32UI;
          if (glType === gl.BYTE) internalFormat = gl.RGB8I;
          if (glType === gl.SHORT) internalFormat = gl.RGB16I;
          if (glType === gl.INT) internalFormat = gl.RGB32I;
          if (glType === gl.UNSIGNED_BYTE) internalFormat = colorSpace === _$$_REQUIRE(_dependencyMap[1], "./three.core.js").SRGBColorSpace && forceLinearTransfer === false ? gl.SRGB8 : gl.RGB8;
          if (glType === gl.UNSIGNED_SHORT_5_6_5) internalFormat = gl.RGB565;
          if (glType === gl.UNSIGNED_SHORT_5_5_5_1) internalFormat = gl.RGB5_A1;
          if (glType === gl.UNSIGNED_SHORT_4_4_4_4) internalFormat = gl.RGB4;
          if (glType === gl.UNSIGNED_INT_5_9_9_9_REV) internalFormat = gl.RGB9_E5;
        }
        if (glFormat === gl.RGB_INTEGER) {
          if (glType === gl.UNSIGNED_BYTE) internalFormat = gl.RGB8UI;
          if (glType === gl.UNSIGNED_SHORT) internalFormat = gl.RGB16UI;
          if (glType === gl.UNSIGNED_INT) internalFormat = gl.RGB32UI;
          if (glType === gl.BYTE) internalFormat = gl.RGB8I;
          if (glType === gl.SHORT) internalFormat = gl.RGB16I;
          if (glType === gl.INT) internalFormat = gl.RGB32I;
        }
        if (glFormat === gl.RGBA) {
          if (glType === gl.FLOAT) internalFormat = gl.RGBA32F;
          if (glType === gl.HALF_FLOAT) internalFormat = gl.RGBA16F;
          if (glType === gl.UNSIGNED_BYTE) internalFormat = gl.RGBA8;
          if (glType === gl.UNSIGNED_SHORT) internalFormat = gl.RGBA16;
          if (glType === gl.UNSIGNED_INT) internalFormat = gl.RGBA32UI;
          if (glType === gl.BYTE) internalFormat = gl.RGBA8I;
          if (glType === gl.SHORT) internalFormat = gl.RGBA16I;
          if (glType === gl.INT) internalFormat = gl.RGBA32I;
          if (glType === gl.UNSIGNED_BYTE) internalFormat = colorSpace === _$$_REQUIRE(_dependencyMap[1], "./three.core.js").SRGBColorSpace && forceLinearTransfer === false ? gl.SRGB8_ALPHA8 : gl.RGBA8;
          if (glType === gl.UNSIGNED_SHORT_4_4_4_4) internalFormat = gl.RGBA4;
          if (glType === gl.UNSIGNED_SHORT_5_5_5_1) internalFormat = gl.RGB5_A1;
        }
        if (glFormat === gl.RGBA_INTEGER) {
          if (glType === gl.UNSIGNED_BYTE) internalFormat = gl.RGBA8UI;
          if (glType === gl.UNSIGNED_SHORT) internalFormat = gl.RGBA16UI;
          if (glType === gl.UNSIGNED_INT) internalFormat = gl.RGBA32UI;
          if (glType === gl.BYTE) internalFormat = gl.RGBA8I;
          if (glType === gl.SHORT) internalFormat = gl.RGBA16I;
          if (glType === gl.INT) internalFormat = gl.RGBA32I;
        }
        if (glFormat === gl.DEPTH_COMPONENT) {
          if (glType === gl.UNSIGNED_INT) internalFormat = gl.DEPTH24_STENCIL8;
          if (glType === gl.FLOAT) internalFormat = gl.DEPTH_COMPONENT32F;
        }
        if (glFormat === gl.DEPTH_STENCIL) {
          if (glType === gl.UNSIGNED_INT_24_8) internalFormat = gl.DEPTH24_STENCIL8;
        }
        if (internalFormat === gl.R16F || internalFormat === gl.R32F || internalFormat === gl.RG16F || internalFormat === gl.RG32F || internalFormat === gl.RGBA16F || internalFormat === gl.RGBA32F) {
          extensions.get('EXT_color_buffer_float');
        }
        return internalFormat;
      }
    }, {
      key: "setTextureParameters",
      value: function setTextureParameters(textureType, texture) {
        var gl = this.gl,
          extensions = this.extensions,
          backend = this.backend;
        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, texture.flipY);
        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha);
        gl.pixelStorei(gl.UNPACK_ALIGNMENT, texture.unpackAlignment);
        gl.pixelStorei(gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, gl.NONE);
        gl.texParameteri(textureType, gl.TEXTURE_WRAP_S, wrappingToGL[texture.wrapS]);
        gl.texParameteri(textureType, gl.TEXTURE_WRAP_T, wrappingToGL[texture.wrapT]);
        if (textureType === gl.TEXTURE_3D || textureType === gl.TEXTURE_2D_ARRAY) {
          gl.texParameteri(textureType, gl.TEXTURE_WRAP_R, wrappingToGL[texture.wrapR]);
        }
        gl.texParameteri(textureType, gl.TEXTURE_MAG_FILTER, filterToGL[texture.magFilter]);
        var hasMipmaps = texture.mipmaps !== undefined && texture.mipmaps.length > 0;

        // follow WebGPU backend mapping for texture filtering
        var minFilter = texture.minFilter === _$$_REQUIRE(_dependencyMap[1], "./three.core.js").LinearFilter && hasMipmaps ? _$$_REQUIRE(_dependencyMap[1], "./three.core.js").LinearMipmapLinearFilter : texture.minFilter;
        gl.texParameteri(textureType, gl.TEXTURE_MIN_FILTER, filterToGL[minFilter]);
        if (texture.compareFunction) {
          gl.texParameteri(textureType, gl.TEXTURE_COMPARE_MODE, gl.COMPARE_REF_TO_TEXTURE);
          gl.texParameteri(textureType, gl.TEXTURE_COMPARE_FUNC, compareToGL[texture.compareFunction]);
        }
        if (extensions.has('EXT_texture_filter_anisotropic') === true) {
          if (texture.magFilter === _$$_REQUIRE(_dependencyMap[1], "./three.core.js").NearestFilter) return;
          if (texture.minFilter !== _$$_REQUIRE(_dependencyMap[1], "./three.core.js").NearestMipmapLinearFilter && texture.minFilter !== _$$_REQUIRE(_dependencyMap[1], "./three.core.js").LinearMipmapLinearFilter) return;
          if (texture.type === _$$_REQUIRE(_dependencyMap[1], "./three.core.js").FloatType && extensions.has('OES_texture_float_linear') === false) return; // verify extension for WebGL 1 and WebGL 2

          if (texture.anisotropy > 1) {
            var extension = extensions.get('EXT_texture_filter_anisotropic');
            gl.texParameterf(textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(texture.anisotropy, backend.getMaxAnisotropy()));
          }
        }
      }
    }, {
      key: "createDefaultTexture",
      value: function createDefaultTexture(texture) {
        var gl = this.gl,
          backend = this.backend,
          defaultTextures = this.defaultTextures;
        var glTextureType = this.getGLTextureType(texture);
        var textureGPU = defaultTextures[glTextureType];
        if (textureGPU === undefined) {
          textureGPU = gl.createTexture();
          backend.state.bindTexture(glTextureType, textureGPU);
          gl.texParameteri(glTextureType, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
          gl.texParameteri(glTextureType, gl.TEXTURE_MAG_FILTER, gl.NEAREST);

          // gl.texImage2D( glTextureType, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, data );

          defaultTextures[glTextureType] = textureGPU;
        }
        backend.set(texture, {
          textureGPU: textureGPU,
          glTextureType: glTextureType,
          isDefault: true
        });
      }
    }, {
      key: "createTexture",
      value: function createTexture(texture, options) {
        var gl = this.gl,
          backend = this.backend;
        var levels = options.levels,
          width = options.width,
          height = options.height,
          depth = options.depth;
        var glFormat = backend.utils.convert(texture.format, texture.colorSpace);
        var glType = backend.utils.convert(texture.type);
        var glInternalFormat = this.getInternalFormat(texture.internalFormat, glFormat, glType, texture.colorSpace, texture.isVideoTexture);
        var textureGPU = gl.createTexture();
        var glTextureType = this.getGLTextureType(texture);
        backend.state.bindTexture(glTextureType, textureGPU);
        this.setTextureParameters(glTextureType, texture);
        if (texture.isDataArrayTexture || texture.isCompressedArrayTexture) {
          gl.texStorage3D(gl.TEXTURE_2D_ARRAY, levels, glInternalFormat, width, height, depth);
        } else if (texture.isData3DTexture) {
          gl.texStorage3D(gl.TEXTURE_3D, levels, glInternalFormat, width, height, depth);
        } else if (!texture.isVideoTexture) {
          gl.texStorage2D(glTextureType, levels, glInternalFormat, width, height);
        }
        backend.set(texture, {
          textureGPU: textureGPU,
          glTextureType: glTextureType,
          glFormat: glFormat,
          glType: glType,
          glInternalFormat: glInternalFormat
        });
      }
    }, {
      key: "copyBufferToTexture",
      value: function copyBufferToTexture(buffer, texture) {
        var gl = this.gl,
          backend = this.backend;
        var _backend$get2 = backend.get(texture),
          textureGPU = _backend$get2.textureGPU,
          glTextureType = _backend$get2.glTextureType,
          glFormat = _backend$get2.glFormat,
          glType = _backend$get2.glType;
        var _texture$source$data = texture.source.data,
          width = _texture$source$data.width,
          height = _texture$source$data.height;
        gl.bindBuffer(gl.PIXEL_UNPACK_BUFFER, buffer);
        backend.state.bindTexture(glTextureType, textureGPU);
        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
        gl.texSubImage2D(glTextureType, 0, 0, 0, width, height, glFormat, glType, 0);
        gl.bindBuffer(gl.PIXEL_UNPACK_BUFFER, null);
        backend.state.unbindTexture();
        // debug
        // const framebuffer = gl.createFramebuffer();
        // gl.bindFramebuffer( gl.FRAMEBUFFER, framebuffer );
        // gl.framebufferTexture2D( gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, glTextureType, textureGPU, 0 );

        // const readout = new Float32Array( width * height * 4 );

        // const altFormat = gl.getParameter( gl.IMPLEMENTATION_COLOR_READ_FORMAT );
        // const altType = gl.getParameter( gl.IMPLEMENTATION_COLOR_READ_TYPE );

        // gl.readPixels( 0, 0, width, height, altFormat, altType, readout );
        // gl.bindFramebuffer( gl.FRAMEBUFFER, null );
        // console.log( readout );
      }
    }, {
      key: "updateTexture",
      value: function updateTexture(texture, options) {
        var gl = this.gl;
        var width = options.width,
          height = options.height;
        var _this$backend$get = this.backend.get(texture),
          textureGPU = _this$backend$get.textureGPU,
          glTextureType = _this$backend$get.glTextureType,
          glFormat = _this$backend$get.glFormat,
          glType = _this$backend$get.glType,
          glInternalFormat = _this$backend$get.glInternalFormat;
        if (texture.isRenderTargetTexture || textureGPU === undefined /* unsupported texture format */) return;
        var getImage = function getImage(source) {
          if (source.isDataTexture) {
            return source.image.data;
          } else if (typeof HTMLImageElement !== 'undefined' && source instanceof HTMLImageElement || typeof HTMLCanvasElement !== 'undefined' && source instanceof HTMLCanvasElement || typeof ImageBitmap !== 'undefined' && source instanceof ImageBitmap || source instanceof OffscreenCanvas) {
            return source;
          }
          return source.data;
        };
        this.backend.state.bindTexture(glTextureType, textureGPU);
        this.setTextureParameters(glTextureType, texture);
        if (texture.isCompressedTexture) {
          var mipmaps = texture.mipmaps;
          var image = options.image;
          for (var i = 0; i < mipmaps.length; i++) {
            var mipmap = mipmaps[i];
            if (texture.isCompressedArrayTexture) {
              if (texture.format !== gl.RGBA) {
                if (glFormat !== null) {
                  gl.compressedTexSubImage3D(gl.TEXTURE_2D_ARRAY, i, 0, 0, 0, mipmap.width, mipmap.height, image.depth, glFormat, mipmap.data);
                } else {
                  console.warn('THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()');
                }
              } else {
                gl.texSubImage3D(gl.TEXTURE_2D_ARRAY, i, 0, 0, 0, mipmap.width, mipmap.height, image.depth, glFormat, glType, mipmap.data);
              }
            } else {
              if (glFormat !== null) {
                gl.compressedTexSubImage2D(gl.TEXTURE_2D, i, 0, 0, mipmap.width, mipmap.height, glFormat, mipmap.data);
              } else {
                console.warn('Unsupported compressed texture format');
              }
            }
          }
        } else if (texture.isCubeTexture) {
          var images = options.images;
          for (var _i13 = 0; _i13 < 6; _i13++) {
            var _image2 = getImage(images[_i13]);
            gl.texSubImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + _i13, 0, 0, 0, width, height, glFormat, glType, _image2);
          }
        } else if (texture.isDataArrayTexture) {
          var _image3 = options.image;
          gl.texSubImage3D(gl.TEXTURE_2D_ARRAY, 0, 0, 0, 0, _image3.width, _image3.height, _image3.depth, glFormat, glType, _image3.data);
        } else if (texture.isData3DTexture) {
          var _image4 = options.image;
          gl.texSubImage3D(gl.TEXTURE_3D, 0, 0, 0, 0, _image4.width, _image4.height, _image4.depth, glFormat, glType, _image4.data);
        } else if (texture.isVideoTexture) {
          texture.update();
          gl.texImage2D(glTextureType, 0, glInternalFormat, glFormat, glType, options.image);
        } else {
          var _image5 = getImage(options.image);
          gl.texSubImage2D(glTextureType, 0, 0, 0, width, height, glFormat, glType, _image5);
        }
      }
    }, {
      key: "generateMipmaps",
      value: function generateMipmaps(texture) {
        var gl = this.gl,
          backend = this.backend;
        var _backend$get3 = backend.get(texture),
          textureGPU = _backend$get3.textureGPU,
          glTextureType = _backend$get3.glTextureType;
        backend.state.bindTexture(glTextureType, textureGPU);
        gl.generateMipmap(glTextureType);
      }
    }, {
      key: "deallocateRenderBuffers",
      value: function deallocateRenderBuffers(renderTarget) {
        var gl = this.gl,
          backend = this.backend;

        // remove framebuffer reference
        if (renderTarget) {
          var renderContextData = backend.get(renderTarget);
          renderContextData.renderBufferStorageSetup = undefined;
          if (renderContextData.framebuffers) {
            for (var cacheKey in renderContextData.framebuffers) {
              gl.deleteFramebuffer(renderContextData.framebuffers[cacheKey]);
            }
            delete renderContextData.framebuffers;
          }
          if (renderContextData.depthRenderbuffer) {
            gl.deleteRenderbuffer(renderContextData.depthRenderbuffer);
            delete renderContextData.depthRenderbuffer;
          }
          if (renderContextData.stencilRenderbuffer) {
            gl.deleteRenderbuffer(renderContextData.stencilRenderbuffer);
            delete renderContextData.stencilRenderbuffer;
          }
          if (renderContextData.msaaFrameBuffer) {
            gl.deleteFramebuffer(renderContextData.msaaFrameBuffer);
            delete renderContextData.msaaFrameBuffer;
          }
          if (renderContextData.msaaRenderbuffers) {
            for (var i = 0; i < renderContextData.msaaRenderbuffers.length; i++) {
              gl.deleteRenderbuffer(renderContextData.msaaRenderbuffers[i]);
            }
            delete renderContextData.msaaRenderbuffers;
          }
        }
      }
    }, {
      key: "destroyTexture",
      value: function destroyTexture(texture) {
        var gl = this.gl,
          backend = this.backend;
        var _backend$get4 = backend.get(texture),
          textureGPU = _backend$get4.textureGPU,
          renderTarget = _backend$get4.renderTarget;
        this.deallocateRenderBuffers(renderTarget);
        gl.deleteTexture(textureGPU);
        backend.delete(texture);
      }
    }, {
      key: "copyTextureToTexture",
      value: function copyTextureToTexture(srcTexture, dstTexture) {
        var srcRegion = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
        var dstPosition = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
        var level = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
        var gl = this.gl,
          backend = this.backend;
        var state = this.backend.state;
        var _backend$get5 = backend.get(dstTexture),
          dstTextureGPU = _backend$get5.textureGPU,
          glTextureType = _backend$get5.glTextureType,
          glType = _backend$get5.glType,
          glFormat = _backend$get5.glFormat;
        var width, height, minX, minY;
        var dstX, dstY;
        if (srcRegion !== null) {
          width = srcRegion.max.x - srcRegion.min.x;
          height = srcRegion.max.y - srcRegion.min.y;
          minX = srcRegion.min.x;
          minY = srcRegion.min.y;
        } else {
          width = srcTexture.image.width;
          height = srcTexture.image.height;
          minX = 0;
          minY = 0;
        }
        if (dstPosition !== null) {
          dstX = dstPosition.x;
          dstY = dstPosition.y;
        } else {
          dstX = 0;
          dstY = 0;
        }
        state.bindTexture(glTextureType, dstTextureGPU);

        // As another texture upload may have changed pixelStorei
        // parameters, make sure they are correct for the dstTexture
        gl.pixelStorei(gl.UNPACK_ALIGNMENT, dstTexture.unpackAlignment);
        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, dstTexture.flipY);
        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, dstTexture.premultiplyAlpha);
        gl.pixelStorei(gl.UNPACK_ALIGNMENT, dstTexture.unpackAlignment);
        var currentUnpackRowLen = gl.getParameter(gl.UNPACK_ROW_LENGTH);
        var currentUnpackImageHeight = gl.getParameter(gl.UNPACK_IMAGE_HEIGHT);
        var currentUnpackSkipPixels = gl.getParameter(gl.UNPACK_SKIP_PIXELS);
        var currentUnpackSkipRows = gl.getParameter(gl.UNPACK_SKIP_ROWS);
        var currentUnpackSkipImages = gl.getParameter(gl.UNPACK_SKIP_IMAGES);
        var image = srcTexture.isCompressedTexture ? srcTexture.mipmaps[level] : srcTexture.image;
        gl.pixelStorei(gl.UNPACK_ROW_LENGTH, image.width);
        gl.pixelStorei(gl.UNPACK_IMAGE_HEIGHT, image.height);
        gl.pixelStorei(gl.UNPACK_SKIP_PIXELS, minX);
        gl.pixelStorei(gl.UNPACK_SKIP_ROWS, minY);
        if (srcTexture.isRenderTargetTexture || srcTexture.isDepthTexture) {
          var srcTextureData = backend.get(srcTexture);
          var dstTextureData = backend.get(dstTexture);
          var srcRenderContextData = backend.get(srcTextureData.renderTarget);
          var dstRenderContextData = backend.get(dstTextureData.renderTarget);
          var srcFramebuffer = srcRenderContextData.framebuffers[srcTextureData.cacheKey];
          var dstFramebuffer = dstRenderContextData.framebuffers[dstTextureData.cacheKey];
          state.bindFramebuffer(gl.READ_FRAMEBUFFER, srcFramebuffer);
          state.bindFramebuffer(gl.DRAW_FRAMEBUFFER, dstFramebuffer);
          var mask = gl.COLOR_BUFFER_BIT;
          if (srcTexture.isDepthTexture) mask = gl.DEPTH_BUFFER_BIT;
          gl.blitFramebuffer(minX, minY, width, height, dstX, dstY, width, height, mask, gl.NEAREST);
          state.bindFramebuffer(gl.READ_FRAMEBUFFER, null);
          state.bindFramebuffer(gl.DRAW_FRAMEBUFFER, null);
        } else {
          if (srcTexture.isDataTexture) {
            gl.texSubImage2D(gl.TEXTURE_2D, level, dstX, dstY, width, height, glFormat, glType, image.data);
          } else {
            if (srcTexture.isCompressedTexture) {
              gl.compressedTexSubImage2D(gl.TEXTURE_2D, level, dstX, dstY, image.width, image.height, glFormat, image.data);
            } else {
              gl.texSubImage2D(gl.TEXTURE_2D, level, dstX, dstY, width, height, glFormat, glType, image);
            }
          }
        }
        gl.pixelStorei(gl.UNPACK_ROW_LENGTH, currentUnpackRowLen);
        gl.pixelStorei(gl.UNPACK_IMAGE_HEIGHT, currentUnpackImageHeight);
        gl.pixelStorei(gl.UNPACK_SKIP_PIXELS, currentUnpackSkipPixels);
        gl.pixelStorei(gl.UNPACK_SKIP_ROWS, currentUnpackSkipRows);
        gl.pixelStorei(gl.UNPACK_SKIP_IMAGES, currentUnpackSkipImages);

        // Generate mipmaps only when copying level 0
        if (level === 0 && dstTexture.generateMipmaps) gl.generateMipmap(gl.TEXTURE_2D);
        state.unbindTexture();
      }
    }, {
      key: "copyFramebufferToTexture",
      value: function copyFramebufferToTexture(texture, renderContext, rectangle) {
        var gl = this.gl;
        var state = this.backend.state;
        var _this$backend$get2 = this.backend.get(texture),
          textureGPU = _this$backend$get2.textureGPU;
        var x = rectangle.x,
          y = rectangle.y,
          width = rectangle.z,
          height = rectangle.w;
        var requireDrawFrameBuffer = texture.isDepthTexture === true || renderContext.renderTarget && renderContext.renderTarget.samples > 0;
        var srcHeight = renderContext.renderTarget ? renderContext.renderTarget.height : this.backend.getDrawingBufferSize().y;
        if (requireDrawFrameBuffer) {
          var partial = x !== 0 || y !== 0;
          var mask;
          var attachment;
          if (texture.isDepthTexture === true) {
            mask = gl.DEPTH_BUFFER_BIT;
            attachment = gl.DEPTH_ATTACHMENT;
            if (renderContext.stencil) {
              mask |= gl.STENCIL_BUFFER_BIT;
            }
          } else {
            mask = gl.COLOR_BUFFER_BIT;
            attachment = gl.COLOR_ATTACHMENT0;
          }
          if (partial) {
            var renderTargetContextData = this.backend.get(renderContext.renderTarget);
            var fb = renderTargetContextData.framebuffers[renderContext.getCacheKey()];
            var msaaFrameBuffer = renderTargetContextData.msaaFrameBuffer;
            state.bindFramebuffer(gl.DRAW_FRAMEBUFFER, fb);
            state.bindFramebuffer(gl.READ_FRAMEBUFFER, msaaFrameBuffer);
            var flippedY = srcHeight - y - height;
            gl.blitFramebuffer(x, flippedY, x + width, flippedY + height, x, flippedY, x + width, flippedY + height, mask, gl.NEAREST);
            state.bindFramebuffer(gl.READ_FRAMEBUFFER, fb);
            state.bindTexture(gl.TEXTURE_2D, textureGPU);
            gl.copyTexSubImage2D(gl.TEXTURE_2D, 0, 0, 0, x, flippedY, width, height);
            state.unbindTexture();
          } else {
            var _fb = gl.createFramebuffer();
            state.bindFramebuffer(gl.DRAW_FRAMEBUFFER, _fb);
            gl.framebufferTexture2D(gl.DRAW_FRAMEBUFFER, attachment, gl.TEXTURE_2D, textureGPU, 0);
            gl.blitFramebuffer(0, 0, width, height, 0, 0, width, height, mask, gl.NEAREST);
            gl.deleteFramebuffer(_fb);
          }
        } else {
          state.bindTexture(gl.TEXTURE_2D, textureGPU);
          gl.copyTexSubImage2D(gl.TEXTURE_2D, 0, 0, 0, x, srcHeight - height - y, width, height);
          state.unbindTexture();
        }
        if (texture.generateMipmaps) this.generateMipmaps(texture);
        this.backend._setFramebuffer(renderContext);
      }

      // Setup storage for internal depth/stencil buffers and bind to correct framebuffer
    }, {
      key: "setupRenderBufferStorage",
      value: function setupRenderBufferStorage(renderbuffer, renderContext) {
        var gl = this.gl;
        var renderTarget = renderContext.renderTarget;
        var samples = renderTarget.samples,
          depthTexture = renderTarget.depthTexture,
          depthBuffer = renderTarget.depthBuffer,
          stencilBuffer = renderTarget.stencilBuffer,
          width = renderTarget.width,
          height = renderTarget.height;
        gl.bindRenderbuffer(gl.RENDERBUFFER, renderbuffer);
        if (depthBuffer && !stencilBuffer) {
          var glInternalFormat = gl.DEPTH_COMPONENT24;
          if (samples > 0) {
            if (depthTexture && depthTexture.isDepthTexture) {
              if (depthTexture.type === gl.FLOAT) {
                glInternalFormat = gl.DEPTH_COMPONENT32F;
              }
            }
            gl.renderbufferStorageMultisample(gl.RENDERBUFFER, samples, glInternalFormat, width, height);
          } else {
            gl.renderbufferStorage(gl.RENDERBUFFER, glInternalFormat, width, height);
          }
          gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, renderbuffer);
        } else if (depthBuffer && stencilBuffer) {
          if (samples > 0) {
            gl.renderbufferStorageMultisample(gl.RENDERBUFFER, samples, gl.DEPTH24_STENCIL8, width, height);
          } else {
            gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_STENCIL, width, height);
          }
          gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, gl.RENDERBUFFER, renderbuffer);
        }
      }
    }, {
      key: "copyTextureToBuffer",
      value: function () {
        var _copyTextureToBuffer = (0, _asyncToGenerator2.default)(function* (texture, x, y, width, height, faceIndex) {
          var backend = this.backend,
            gl = this.gl;
          var _this$backend$get3 = this.backend.get(texture),
            textureGPU = _this$backend$get3.textureGPU,
            glFormat = _this$backend$get3.glFormat,
            glType = _this$backend$get3.glType;
          var fb = gl.createFramebuffer();
          gl.bindFramebuffer(gl.READ_FRAMEBUFFER, fb);
          var target = texture.isCubeTexture ? gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndex : gl.TEXTURE_2D;
          gl.framebufferTexture2D(gl.READ_FRAMEBUFFER, gl.COLOR_ATTACHMENT0, target, textureGPU, 0);
          var typedArrayType = this._getTypedArrayType(glType);
          var bytesPerTexel = this._getBytesPerTexel(glType, glFormat);
          var elementCount = width * height;
          var byteLength = elementCount * bytesPerTexel;
          var buffer = gl.createBuffer();
          gl.bindBuffer(gl.PIXEL_PACK_BUFFER, buffer);
          gl.bufferData(gl.PIXEL_PACK_BUFFER, byteLength, gl.STREAM_READ);
          gl.readPixels(x, y, width, height, glFormat, glType, 0);
          gl.bindBuffer(gl.PIXEL_PACK_BUFFER, null);
          yield backend.utils._clientWaitAsync();
          var dstBuffer = new typedArrayType(byteLength / typedArrayType.BYTES_PER_ELEMENT);
          gl.bindBuffer(gl.PIXEL_PACK_BUFFER, buffer);
          gl.getBufferSubData(gl.PIXEL_PACK_BUFFER, 0, dstBuffer);
          gl.bindBuffer(gl.PIXEL_PACK_BUFFER, null);
          gl.deleteFramebuffer(fb);
          return dstBuffer;
        });
        function copyTextureToBuffer(_x29, _x30, _x31, _x32, _x33, _x34) {
          return _copyTextureToBuffer.apply(this, arguments);
        }
        return copyTextureToBuffer;
      }()
    }, {
      key: "_getTypedArrayType",
      value: function _getTypedArrayType(glType) {
        var gl = this.gl;
        if (glType === gl.UNSIGNED_BYTE) return Uint8Array;
        if (glType === gl.UNSIGNED_SHORT_4_4_4_4) return Uint16Array;
        if (glType === gl.UNSIGNED_SHORT_5_5_5_1) return Uint16Array;
        if (glType === gl.UNSIGNED_SHORT_5_6_5) return Uint16Array;
        if (glType === gl.UNSIGNED_SHORT) return Uint16Array;
        if (glType === gl.UNSIGNED_INT) return Uint32Array;
        if (glType === gl.HALF_FLOAT) return Uint16Array;
        if (glType === gl.FLOAT) return Float32Array;
        throw new Error(`Unsupported WebGL type: ${glType}`);
      }
    }, {
      key: "_getBytesPerTexel",
      value: function _getBytesPerTexel(glType, glFormat) {
        var gl = this.gl;
        var bytesPerComponent = 0;
        if (glType === gl.UNSIGNED_BYTE) bytesPerComponent = 1;
        if (glType === gl.UNSIGNED_SHORT_4_4_4_4 || glType === gl.UNSIGNED_SHORT_5_5_5_1 || glType === gl.UNSIGNED_SHORT_5_6_5 || glType === gl.UNSIGNED_SHORT || glType === gl.HALF_FLOAT) bytesPerComponent = 2;
        if (glType === gl.UNSIGNED_INT || glType === gl.FLOAT) bytesPerComponent = 4;
        if (glFormat === gl.RGBA) return bytesPerComponent * 4;
        if (glFormat === gl.RGB) return bytesPerComponent * 3;
        if (glFormat === gl.ALPHA) return bytesPerComponent;
      }
    }]);
  }();
  var WebGLExtensions = /*#__PURE__*/function () {
    function WebGLExtensions(backend) {
      (0, _classCallCheck2.default)(this, WebGLExtensions);
      this.backend = backend;
      this.gl = this.backend.gl;
      this.availableExtensions = this.gl.getSupportedExtensions();
      this.extensions = {};
    }
    return (0, _createClass2.default)(WebGLExtensions, [{
      key: "get",
      value: function get(name) {
        var extension = this.extensions[name];
        if (extension === undefined) {
          extension = this.gl.getExtension(name);
          this.extensions[name] = extension;
        }
        return extension;
      }
    }, {
      key: "has",
      value: function has(name) {
        return this.availableExtensions.includes(name);
      }
    }]);
  }();
  var WebGLCapabilities = /*#__PURE__*/function () {
    function WebGLCapabilities(backend) {
      (0, _classCallCheck2.default)(this, WebGLCapabilities);
      this.backend = backend;
      this.maxAnisotropy = null;
    }
    return (0, _createClass2.default)(WebGLCapabilities, [{
      key: "getMaxAnisotropy",
      value: function getMaxAnisotropy() {
        if (this.maxAnisotropy !== null) return this.maxAnisotropy;
        var gl = this.backend.gl;
        var extensions = this.backend.extensions;
        if (extensions.has('EXT_texture_filter_anisotropic') === true) {
          var extension = extensions.get('EXT_texture_filter_anisotropic');
          this.maxAnisotropy = gl.getParameter(extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
        } else {
          this.maxAnisotropy = 0;
        }
        return this.maxAnisotropy;
      }
    }]);
  }();
  var GLFeatureName = {
    'WEBGL_multi_draw': 'WEBGL_multi_draw',
    'WEBGL_compressed_texture_astc': 'texture-compression-astc',
    'WEBGL_compressed_texture_etc': 'texture-compression-etc2',
    'WEBGL_compressed_texture_etc1': 'texture-compression-etc1',
    'WEBGL_compressed_texture_pvrtc': 'texture-compression-pvrtc',
    'WEBKIT_WEBGL_compressed_texture_pvrtc': 'texture-compression-pvrtc',
    'WEBGL_compressed_texture_s3tc': 'texture-compression-bc',
    'EXT_texture_compression_bptc': 'texture-compression-bptc',
    'EXT_disjoint_timer_query_webgl2': 'timestamp-query'
  };
  var WebGLBufferRenderer = /*#__PURE__*/function () {
    function WebGLBufferRenderer(backend) {
      (0, _classCallCheck2.default)(this, WebGLBufferRenderer);
      this.gl = backend.gl;
      this.extensions = backend.extensions;
      this.info = backend.renderer.info;
      this.mode = null;
      this.index = 0;
      this.type = null;
      this.object = null;
    }
    return (0, _createClass2.default)(WebGLBufferRenderer, [{
      key: "render",
      value: function render(start, count) {
        var gl = this.gl,
          mode = this.mode,
          object = this.object,
          type = this.type,
          info = this.info,
          index = this.index;
        if (index !== 0) {
          gl.drawElements(mode, count, type, start);
        } else {
          gl.drawArrays(mode, start, count);
        }
        info.update(object, count, mode, 1);
      }
    }, {
      key: "renderInstances",
      value: function renderInstances(start, count, primcount) {
        var gl = this.gl,
          mode = this.mode,
          type = this.type,
          index = this.index,
          object = this.object,
          info = this.info;
        if (primcount === 0) return;
        if (index !== 0) {
          gl.drawElementsInstanced(mode, count, type, start, primcount);
        } else {
          gl.drawArraysInstanced(mode, start, count, primcount);
        }
        info.update(object, count, mode, primcount);
      }
    }, {
      key: "renderMultiDraw",
      value: function renderMultiDraw(starts, counts, drawCount) {
        var extensions = this.extensions,
          mode = this.mode,
          object = this.object,
          info = this.info;
        if (drawCount === 0) return;
        var extension = extensions.get('WEBGL_multi_draw');
        if (extension === null) {
          for (var i = 0; i < drawCount; i++) {
            this.render(starts[i], counts[i]);
          }
        } else {
          if (this.index !== 0) {
            extension.multiDrawElementsWEBGL(mode, counts, 0, this.type, starts, 0, drawCount);
          } else {
            extension.multiDrawArraysWEBGL(mode, starts, 0, counts, 0, drawCount);
          }
          var elementCount = 0;
          for (var _i14 = 0; _i14 < drawCount; _i14++) {
            elementCount += counts[_i14];
          }
          info.update(object, elementCount, mode, 1);
        }
      }
    }, {
      key: "renderMultiDrawInstances",
      value: function renderMultiDrawInstances(starts, counts, drawCount, primcount) {
        var extensions = this.extensions,
          mode = this.mode,
          object = this.object,
          info = this.info;
        if (drawCount === 0) return;
        var extension = extensions.get('WEBGL_multi_draw');
        if (extension === null) {
          for (var i = 0; i < drawCount; i++) {
            this.renderInstances(starts[i], counts[i], primcount[i]);
          }
        } else {
          if (this.index !== 0) {
            extension.multiDrawElementsInstancedWEBGL(mode, counts, 0, this.type, starts, 0, primcount, 0, drawCount);
          } else {
            extension.multiDrawArraysInstancedWEBGL(mode, starts, 0, counts, 0, primcount, 0, drawCount);
          }
          var elementCount = 0;
          for (var _i15 = 0; _i15 < drawCount; _i15++) {
            elementCount += counts[_i15] * primcount[_i15];
          }
          info.update(object, elementCount, mode, 1);
        }
      }

      //
    }]);
  }();
  /**
   * A backend implementation targeting WebGL 2.
   *
   * @private
   * @augments Backend
   */
  var WebGLBackend = /*#__PURE__*/function (_Backend) {
    /**
     * Constructs a new WebGPU backend.
     *
     * @param {Object} parameters - The configuration parameter.
     * @param {Boolean} [parameters.logarithmicDepthBuffer=false] - Whether logarithmic depth buffer is enabled or not.
     * @param {Boolean} [parameters.alpha=true] - Whether the default framebuffer (which represents the final contents of the canvas) should be transparent or opaque.
     * @param {Boolean} [parameters.depth=true] - Whether the default framebuffer should have a depth buffer or not.
     * @param {Boolean} [parameters.stencil=false] - Whether the default framebuffer should have a stencil buffer or not.
     * @param {Boolean} [parameters.antialias=false] - Whether MSAA as the default anti-aliasing should be enabled or not.
     * @param {Number} [parameters.samples=0] - When `antialias` is `true`, `4` samples are used by default. Set this parameter to any other integer value than 0 to overwrite the default.
     * @param {Boolean} [parameters.forceWebGL=false] - If set to `true`, the renderer uses it WebGL 2 backend no matter if WebGPU is supported or not.
     * @param {WebGL2RenderingContext} [parameters.context=undefined] - A WebGL 2 rendering context.
     */
    function WebGLBackend() {
      var _this204;
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      (0, _classCallCheck2.default)(this, WebGLBackend);
      _this204 = _callSuper(this, WebGLBackend, [parameters]);

      /**
       * This flag can be used for type testing.
       *
       * @type {Boolean}
       * @readonly
       * @default true
       */
      _this204.isWebGLBackend = true;

      /**
       * A reference to a backend module holding shader attribute-related
       * utility functions.
       *
       * @type {WebGLAttributeUtils?}
       * @default null
       */
      _this204.attributeUtils = null;

      /**
       * A reference to a backend module holding extension-related
       * utility functions.
       *
       * @type {WebGLExtensions?}
       * @default null
       */
      _this204.extensions = null;

      /**
       * A reference to a backend module holding capability-related
       * utility functions.
       *
       * @type {WebGLCapabilities?}
       * @default null
       */
      _this204.capabilities = null;

      /**
       * A reference to a backend module holding texture-related
       * utility functions.
       *
       * @type {WebGLTextureUtils?}
       * @default null
       */
      _this204.textureUtils = null;

      /**
       * A reference to a backend module holding renderer-related
       * utility functions.
       *
       * @type {WebGLBufferRenderer?}
       * @default null
       */
      _this204.bufferRenderer = null;

      /**
       * A reference to the rendering context.
       *
       * @type {WebGL2RenderingContext?}
       * @default null
       */
      _this204.gl = null;

      /**
       * A reference to a backend module holding state-related
       * utility functions.
       *
       * @type {WebGLState?}
       * @default null
       */
      _this204.state = null;

      /**
       * A reference to a backend module holding common
       * utility functions.
       *
       * @type {WebGLUtils?}
       * @default null
       */
      _this204.utils = null;

      /**
       * Dictionary for caching VAOs.
       *
       * @type {Object<String,WebGLVertexArrayObject>}
       */
      _this204.vaoCache = {};

      /**
       * Dictionary for caching transform feedback objects.
       *
       * @type {Object<String,WebGLTransformFeedback>}
       */
      _this204.transformFeedbackCache = {};

      /**
       * Controls if `gl.RASTERIZER_DISCARD` should be enabled or not.
       * Only relevant when using compute shaders.
       *
       * @type {Boolean}
       * @default false
       */
      _this204.discard = false;

      /**
       * A reference to the `EXT_disjoint_timer_query_webgl2` extension. `null` if the
       * device does not support the extension.
       *
       * @type {EXTDisjointTimerQueryWebGL2?}
       * @default null
       */
      _this204.disjoint = null;

      /**
      * A reference to the `KHR_parallel_shader_compile` extension. `null` if the
      * device does not support the extension.
      *
      * @type {KHRParallelShaderCompile?}
      * @default null
      */
      _this204.parallel = null;

      /**
       * Whether to track timestamps with a Timestamp Query API or not.
       *
       * @type {Boolean}
       * @default false
       */
      _this204.trackTimestamp = parameters.trackTimestamp === true;

      /**
       * A reference to the current render context.
       *
       * @private
       * @type {RenderContext}
       * @default null
       */
      _this204._currentContext = null;

      /**
       * A unique collection of bindings.
       *
       * @private
       * @type {WeakSet}
       */
      _this204._knownBindings = new WeakSet();
      return _this204;
    }

    /**
     * Initializes the backend so it is ready for usage.
     *
     * @param {Renderer} renderer - The renderer.
     */
    (0, _inherits2.default)(WebGLBackend, _Backend);
    return (0, _createClass2.default)(WebGLBackend, [{
      key: "init",
      value: function init(renderer) {
        _superPropGet(WebGLBackend, "init", this, 3)([renderer]);

        //

        var parameters = this.parameters;
        var glContext = parameters.context !== undefined ? parameters.context : renderer.domElement.getContext('webgl2');
        function onContextLost(event) {
          event.preventDefault();
          var contextLossInfo = {
            api: 'WebGL',
            message: event.statusMessage || 'Unknown reason',
            reason: null,
            originalEvent: event
          };
          renderer.onDeviceLost(contextLossInfo);
        }
        this._onContextLost = onContextLost;
        renderer.domElement.addEventListener('webglcontextlost', onContextLost, false);
        this.gl = glContext;
        this.extensions = new WebGLExtensions(this);
        this.capabilities = new WebGLCapabilities(this);
        this.attributeUtils = new WebGLAttributeUtils(this);
        this.textureUtils = new WebGLTextureUtils(this);
        this.bufferRenderer = new WebGLBufferRenderer(this);
        this.state = new WebGLState(this);
        this.utils = new WebGLUtils(this);
        this.extensions.get('EXT_color_buffer_float');
        this.extensions.get('WEBGL_clip_cull_distance');
        this.extensions.get('OES_texture_float_linear');
        this.extensions.get('EXT_color_buffer_half_float');
        this.extensions.get('WEBGL_multisampled_render_to_texture');
        this.extensions.get('WEBGL_render_shared_exponent');
        this.extensions.get('WEBGL_multi_draw');
        this.disjoint = this.extensions.get('EXT_disjoint_timer_query_webgl2');
        this.parallel = this.extensions.get('KHR_parallel_shader_compile');
      }

      /**
       * The coordinate system of the backend.
       *
       * @type {Number}
       * @readonly
       */
    }, {
      key: "coordinateSystem",
      get: function get() {
        return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").WebGLCoordinateSystem;
      }

      /**
       * Transfers buffer data from a storage buffer attribute
       * from the GPU to the CPU in context of compute shaders.
       *
       * @async
       * @param {StorageBufferAttribute} attribute - The storage buffer attribute.
       * @return {Promise<ArrayBuffer>} A promise that resolves with the buffer data when the data are ready.
       */
    }, {
      key: "getArrayBufferAsync",
      value: (function () {
        var _getArrayBufferAsync3 = (0, _asyncToGenerator2.default)(function* (attribute) {
          return yield this.attributeUtils.getArrayBufferAsync(attribute);
        });
        function getArrayBufferAsync(_x35) {
          return _getArrayBufferAsync3.apply(this, arguments);
        }
        return getArrayBufferAsync;
      }()
      /**
       * Can be used to synchronize CPU operations with GPU tasks. So when this method is called,
       * the CPU waits for the GPU to complete its operation (e.g. a compute task).
       *
       * @async
       * @return {Promise} A Promise that resolves when synchronization has been finished.
       */
      )
    }, {
      key: "waitForGPU",
      value: (function () {
        var _waitForGPU3 = (0, _asyncToGenerator2.default)(function* () {
          yield this.utils._clientWaitAsync();
        });
        function waitForGPU() {
          return _waitForGPU3.apply(this, arguments);
        }
        return waitForGPU;
      }()
      /**
       * Inits a time stamp query for the given render context.
       *
       * @param {RenderContext} renderContext - The render context.
       */
      )
    }, {
      key: "initTimestampQuery",
      value: function initTimestampQuery(renderContext) {
        if (!this.disjoint || !this.trackTimestamp) return;
        var renderContextData = this.get(renderContext);
        if (this.queryRunning) {
          if (!renderContextData.queryQueue) renderContextData.queryQueue = [];
          renderContextData.queryQueue.push(renderContext);
          return;
        }
        if (renderContextData.activeQuery) {
          this.gl.endQuery(this.disjoint.TIME_ELAPSED_EXT);
          renderContextData.activeQuery = null;
        }
        renderContextData.activeQuery = this.gl.createQuery();
        if (renderContextData.activeQuery !== null) {
          this.gl.beginQuery(this.disjoint.TIME_ELAPSED_EXT, renderContextData.activeQuery);
          this.queryRunning = true;
        }
      }

      // timestamp utils

      /**
       * Prepares the timestamp buffer.
       *
       * @param {RenderContext} renderContext - The render context.
       */
    }, {
      key: "prepareTimestampBuffer",
      value: function prepareTimestampBuffer(renderContext) {
        if (!this.disjoint || !this.trackTimestamp) return;
        var renderContextData = this.get(renderContext);
        if (renderContextData.activeQuery) {
          this.gl.endQuery(this.disjoint.TIME_ELAPSED_EXT);
          if (!renderContextData.gpuQueries) renderContextData.gpuQueries = [];
          renderContextData.gpuQueries.push({
            query: renderContextData.activeQuery
          });
          renderContextData.activeQuery = null;
          this.queryRunning = false;
          if (renderContextData.queryQueue && renderContextData.queryQueue.length > 0) {
            var nextRenderContext = renderContextData.queryQueue.shift();
            this.initTimestampQuery(nextRenderContext);
          }
        }
      }

      /**
       * Resolves the time stamp for the given render context and type.
       *
       * @async
       * @param {RenderContext} renderContext - The render context.
       * @param {String} type - The render context.
       * @return {Promise} A Promise that resolves when the time stamp has been computed.
       */
    }, {
      key: "resolveTimestampAsync",
      value: (function () {
        var _resolveTimestampAsync2 = (0, _asyncToGenerator2.default)(function* (renderContext) {
          var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'render';
          if (!this.disjoint || !this.trackTimestamp) return;
          var renderContextData = this.get(renderContext);
          if (!renderContextData.gpuQueries) renderContextData.gpuQueries = [];
          for (var i = 0; i < renderContextData.gpuQueries.length; i++) {
            var queryInfo = renderContextData.gpuQueries[i];
            var available = this.gl.getQueryParameter(queryInfo.query, this.gl.QUERY_RESULT_AVAILABLE);
            var disjoint = this.gl.getParameter(this.disjoint.GPU_DISJOINT_EXT);
            if (available && !disjoint) {
              var elapsed = this.gl.getQueryParameter(queryInfo.query, this.gl.QUERY_RESULT);
              var duration = Number(elapsed) / 1000000; // Convert nanoseconds to milliseconds
              this.gl.deleteQuery(queryInfo.query);
              renderContextData.gpuQueries.splice(i, 1); // Remove the processed query
              i--;
              this.renderer.info.updateTimestamp(type, duration);
            }
          }
        });
        function resolveTimestampAsync(_x36) {
          return _resolveTimestampAsync2.apply(this, arguments);
        }
        return resolveTimestampAsync;
      }()
      /**
       * Returns the backend's rendering context.
       *
       * @return {WebGL2RenderingContext} The rendering context.
       */
      )
    }, {
      key: "getContext",
      value: function getContext() {
        return this.gl;
      }

      /**
       * This method is executed at the beginning of a render call and prepares
       * the WebGL state for upcoming render calls
       *
       * @param {RenderContext} renderContext - The render context.
       */
    }, {
      key: "beginRender",
      value: function beginRender(renderContext) {
        var gl = this.gl;
        var renderContextData = this.get(renderContext);

        //

        //

        this.initTimestampQuery(renderContext);
        renderContextData.previousContext = this._currentContext;
        this._currentContext = renderContext;
        this._setFramebuffer(renderContext);
        this.clear(renderContext.clearColor, renderContext.clearDepth, renderContext.clearStencil, renderContext, false);

        //
        if (renderContext.viewport) {
          this.updateViewport(renderContext);
        } else {
          gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);
        }
        if (renderContext.scissor) {
          var _renderContext$scisso = renderContext.scissorValue,
            x = _renderContext$scisso.x,
            y = _renderContext$scisso.y,
            width = _renderContext$scisso.width,
            height = _renderContext$scisso.height;
          gl.scissor(x, renderContext.height - height - y, width, height);
        }
        var occlusionQueryCount = renderContext.occlusionQueryCount;
        if (occlusionQueryCount > 0) {
          // Get a reference to the array of objects with queries. The renderContextData property
          // can be changed by another render pass before the async reading of all previous queries complete
          renderContextData.currentOcclusionQueries = renderContextData.occlusionQueries;
          renderContextData.currentOcclusionQueryObjects = renderContextData.occlusionQueryObjects;
          renderContextData.lastOcclusionObject = null;
          renderContextData.occlusionQueries = new Array(occlusionQueryCount);
          renderContextData.occlusionQueryObjects = new Array(occlusionQueryCount);
          renderContextData.occlusionQueryIndex = 0;
        }
      }

      /**
       * This method is executed at the end of a render call and finalizes work
       * after draw calls.
       *
       * @param {RenderContext} renderContext - The render context.
       */
    }, {
      key: "finishRender",
      value: function finishRender(renderContext) {
        var gl = this.gl,
          state = this.state;
        var renderContextData = this.get(renderContext);
        var previousContext = renderContextData.previousContext;
        var occlusionQueryCount = renderContext.occlusionQueryCount;
        if (occlusionQueryCount > 0) {
          if (occlusionQueryCount > renderContextData.occlusionQueryIndex) {
            gl.endQuery(gl.ANY_SAMPLES_PASSED);
          }
          this.resolveOccludedAsync(renderContext);
        }
        var textures = renderContext.textures;
        if (textures !== null) {
          for (var i = 0; i < textures.length; i++) {
            var _texture7 = textures[i];
            if (_texture7.generateMipmaps) {
              this.generateMipmaps(_texture7);
            }
          }
        }
        this._currentContext = previousContext;
        if (renderContext.textures !== null && renderContext.renderTarget) {
          var renderTargetContextData = this.get(renderContext.renderTarget);
          var samples = renderContext.renderTarget.samples;
          if (samples > 0) {
            var fb = renderTargetContextData.framebuffers[renderContext.getCacheKey()];
            var mask = gl.COLOR_BUFFER_BIT;
            var msaaFrameBuffer = renderTargetContextData.msaaFrameBuffer;
            var _textures = renderContext.textures;
            state.bindFramebuffer(gl.READ_FRAMEBUFFER, msaaFrameBuffer);
            state.bindFramebuffer(gl.DRAW_FRAMEBUFFER, fb);
            for (var _i16 = 0; _i16 < _textures.length; _i16++) {
              // TODO Add support for MRT

              if (renderContext.scissor) {
                var _renderContext$scisso2 = renderContext.scissorValue,
                  x = _renderContext$scisso2.x,
                  y = _renderContext$scisso2.y,
                  width = _renderContext$scisso2.width,
                  height = _renderContext$scisso2.height;
                var viewY = renderContext.height - height - y;
                gl.blitFramebuffer(x, viewY, x + width, viewY + height, x, viewY, x + width, viewY + height, mask, gl.NEAREST);
                gl.invalidateSubFramebuffer(gl.READ_FRAMEBUFFER, renderTargetContextData.invalidationArray, x, viewY, width, height);
              } else {
                gl.blitFramebuffer(0, 0, renderContext.width, renderContext.height, 0, 0, renderContext.width, renderContext.height, mask, gl.NEAREST);
                gl.invalidateFramebuffer(gl.READ_FRAMEBUFFER, renderTargetContextData.invalidationArray);
              }
            }
          }
        }
        if (previousContext !== null) {
          this._setFramebuffer(previousContext);
          if (previousContext.viewport) {
            this.updateViewport(previousContext);
          } else {
            gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);
          }
        }
        this.prepareTimestampBuffer(renderContext);
      }

      /**
       * This method processes the result of occlusion queries and writes it
       * into render context data.
       *
       * @async
       * @param {RenderContext} renderContext - The render context.
       */
    }, {
      key: "resolveOccludedAsync",
      value: function resolveOccludedAsync(renderContext) {
        var renderContextData = this.get(renderContext);

        // handle occlusion query results

        var currentOcclusionQueries = renderContextData.currentOcclusionQueries,
          currentOcclusionQueryObjects = renderContextData.currentOcclusionQueryObjects;
        if (currentOcclusionQueries && currentOcclusionQueryObjects) {
          var occluded = new WeakSet();
          var gl = this.gl;
          renderContextData.currentOcclusionQueryObjects = null;
          renderContextData.currentOcclusionQueries = null;
          var _check = function check() {
            var completed = 0;

            // check all queries and requeue as appropriate
            for (var i = 0; i < currentOcclusionQueries.length; i++) {
              var query = currentOcclusionQueries[i];
              if (query === null) continue;
              if (gl.getQueryParameter(query, gl.QUERY_RESULT_AVAILABLE)) {
                if (gl.getQueryParameter(query, gl.QUERY_RESULT) > 0) occluded.add(currentOcclusionQueryObjects[i]);
                currentOcclusionQueries[i] = null;
                gl.deleteQuery(query);
                completed++;
              }
            }
            if (completed < currentOcclusionQueries.length) {
              requestAnimationFrame(_check);
            } else {
              renderContextData.occluded = occluded;
            }
          };
          _check();
        }
      }

      /**
       * Returns `true` if the given 3D object is fully occluded by other
       * 3D objects in the scene.
       *
       * @param {RenderContext} renderContext - The render context.
       * @param {Object3D} object - The 3D object to test.
       * @return {Boolean} Whether the 3D object is fully occluded or not.
       */
    }, {
      key: "isOccluded",
      value: function isOccluded(renderContext, object) {
        var renderContextData = this.get(renderContext);
        return renderContextData.occluded && renderContextData.occluded.has(object);
      }

      /**
       * Updates the viewport with the values from the given render context.
       *
       * @param {RenderContext} renderContext - The render context.
       */
    }, {
      key: "updateViewport",
      value: function updateViewport(renderContext) {
        var gl = this.gl;
        var _renderContext$viewpo = renderContext.viewportValue,
          x = _renderContext$viewpo.x,
          y = _renderContext$viewpo.y,
          width = _renderContext$viewpo.width,
          height = _renderContext$viewpo.height;
        gl.viewport(x, renderContext.height - height - y, width, height);
      }

      /**
       * Defines the scissor test.
       *
       * @param {Boolean} boolean - Whether the scissor test should be enabled or not.
       */
    }, {
      key: "setScissorTest",
      value: function setScissorTest(boolean) {
        var gl = this.gl;
        if (boolean) {
          gl.enable(gl.SCISSOR_TEST);
        } else {
          gl.disable(gl.SCISSOR_TEST);
        }
      }

      /**
       * Performs a clear operation.
       *
       * @param {Boolean} color - Whether the color buffer should be cleared or not.
       * @param {Boolean} depth - Whether the depth buffer should be cleared or not.
       * @param {Boolean} stencil - Whether the stencil buffer should be cleared or not.
       * @param {Object?} [descriptor=null] - The render context of the current set render target.
       * @param {Boolean} [setFrameBuffer=true] - TODO.
       */
    }, {
      key: "clear",
      value: function clear(color, depth, stencil) {
        var descriptor = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
        var setFrameBuffer = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : true;
        var gl = this.gl;
        if (descriptor === null) {
          var clearColor = this.getClearColor();

          // premultiply alpha

          clearColor.r *= clearColor.a;
          clearColor.g *= clearColor.a;
          clearColor.b *= clearColor.a;
          descriptor = {
            textures: null,
            clearColorValue: clearColor
          };
        }

        //

        var clear = 0;
        if (color) clear |= gl.COLOR_BUFFER_BIT;
        if (depth) clear |= gl.DEPTH_BUFFER_BIT;
        if (stencil) clear |= gl.STENCIL_BUFFER_BIT;
        if (clear !== 0) {
          var _clearColor2;
          if (descriptor.clearColorValue) {
            _clearColor2 = descriptor.clearColorValue;
          } else {
            _clearColor2 = this.getClearColor();

            // premultiply alpha

            _clearColor2.r *= _clearColor2.a;
            _clearColor2.g *= _clearColor2.a;
            _clearColor2.b *= _clearColor2.a;
          }
          if (depth) this.state.setDepthMask(true);
          if (descriptor.textures === null) {
            gl.clearColor(_clearColor2.r, _clearColor2.g, _clearColor2.b, _clearColor2.a);
            gl.clear(clear);
          } else {
            if (setFrameBuffer) this._setFramebuffer(descriptor);
            if (color) {
              for (var i = 0; i < descriptor.textures.length; i++) {
                gl.clearBufferfv(gl.COLOR, i, [_clearColor2.r, _clearColor2.g, _clearColor2.b, _clearColor2.a]);
              }
            }
            if (depth && stencil) {
              gl.clearBufferfi(gl.DEPTH_STENCIL, 0, 1, 0);
            } else if (depth) {
              gl.clearBufferfv(gl.DEPTH, 0, [1.0]);
            } else if (stencil) {
              gl.clearBufferiv(gl.STENCIL, 0, [0]);
            }
          }
        }
      }

      /**
       * This method is executed at the beginning of a compute call and
       * prepares the state for upcoming compute tasks.
       *
       * @param {Node|Array<Node>} computeGroup - The compute node(s).
       */
    }, {
      key: "beginCompute",
      value: function beginCompute(computeGroup) {
        var state = this.state,
          gl = this.gl;
        state.bindFramebuffer(gl.FRAMEBUFFER, null);
        this.initTimestampQuery(computeGroup);
      }

      /**
       * Executes a compute command for the given compute node.
       *
       * @param {Node|Array<Node>} computeGroup - The group of compute nodes of a compute call. Can be a single compute node.
       * @param {Node} computeNode - The compute node.
       * @param {Array<BindGroup>} bindings - The bindings.
       * @param {ComputePipeline} pipeline - The compute pipeline.
       */
    }, {
      key: "compute",
      value: function compute(computeGroup, computeNode, bindings, pipeline) {
        var state = this.state,
          gl = this.gl;
        if (this.discard === false) {
          // required here to handle async behaviour of render.compute()
          gl.enable(gl.RASTERIZER_DISCARD);
          this.discard = true;
        }
        var _this$get = this.get(pipeline),
          programGPU = _this$get.programGPU,
          transformBuffers = _this$get.transformBuffers,
          attributes = _this$get.attributes;
        var vaoKey = this._getVaoKey(null, attributes);
        var vaoGPU = this.vaoCache[vaoKey];
        if (vaoGPU === undefined) {
          this._createVao(null, attributes);
        } else {
          gl.bindVertexArray(vaoGPU);
        }
        state.useProgram(programGPU);
        this._bindUniforms(bindings);
        var transformFeedbackGPU = this._getTransformFeedback(transformBuffers);
        gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, transformFeedbackGPU);
        gl.beginTransformFeedback(gl.POINTS);
        if (attributes[0].isStorageInstancedBufferAttribute) {
          gl.drawArraysInstanced(gl.POINTS, 0, 1, computeNode.count);
        } else {
          gl.drawArrays(gl.POINTS, 0, computeNode.count);
        }
        gl.endTransformFeedback();
        gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, null);

        // switch active buffers

        for (var i = 0; i < transformBuffers.length; i++) {
          var dualAttributeData = transformBuffers[i];
          if (dualAttributeData.pbo) {
            this.textureUtils.copyBufferToTexture(dualAttributeData.transformBuffer, dualAttributeData.pbo);
          }
          dualAttributeData.switchBuffers();
        }
      }

      /**
       * This method is executed at the end of a compute call and
       * finalizes work after compute tasks.
       *
       * @param {Node|Array<Node>} computeGroup - The compute node(s).
       */
    }, {
      key: "finishCompute",
      value: function finishCompute(computeGroup) {
        var gl = this.gl;
        this.discard = false;
        gl.disable(gl.RASTERIZER_DISCARD);
        this.prepareTimestampBuffer(computeGroup);
        if (this._currentContext) {
          this._setFramebuffer(this._currentContext);
        }
      }

      /**
       * Executes a draw command for the given render object.
       *
       * @param {RenderObject} renderObject - The render object to draw.
       * @param {Info} info - Holds a series of statistical information about the GPU memory and the rendering process.
       */
    }, {
      key: "draw",
      value: function draw(renderObject /*, info*/) {
        var object = renderObject.object,
          pipeline = renderObject.pipeline,
          material = renderObject.material,
          context = renderObject.context,
          hardwareClippingPlanes = renderObject.hardwareClippingPlanes;
        var _this$get2 = this.get(pipeline),
          programGPU = _this$get2.programGPU;
        var gl = this.gl,
          state = this.state;
        var contextData = this.get(context);
        var drawParams = renderObject.getDrawParameters();
        if (drawParams === null) return;

        //

        this._bindUniforms(renderObject.getBindings());
        var frontFaceCW = object.isMesh && object.matrixWorld.determinant() < 0;
        state.setMaterial(material, frontFaceCW, hardwareClippingPlanes);
        state.useProgram(programGPU);

        //

        var renderObjectData = this.get(renderObject);
        var vaoGPU = renderObjectData.staticVao;
        if (vaoGPU === undefined || renderObjectData.geometryId !== renderObject.geometry.id) {
          var vaoKey = this._getVaoKey(renderObject.getIndex(), renderObject.getAttributes());
          vaoGPU = this.vaoCache[vaoKey];
          if (vaoGPU === undefined) {
            var staticVao;
            var _this$_createVao = this._createVao(renderObject.getIndex(), renderObject.getAttributes());
            vaoGPU = _this$_createVao.vaoGPU;
            staticVao = _this$_createVao.staticVao;
            if (staticVao) {
              renderObjectData.staticVao = vaoGPU;
              renderObjectData.geometryId = renderObject.geometry.id;
            }
          }
        }
        gl.bindVertexArray(vaoGPU);

        //

        var index = renderObject.getIndex();

        //

        var lastObject = contextData.lastOcclusionObject;
        if (lastObject !== object && lastObject !== undefined) {
          if (lastObject !== null && lastObject.occlusionTest === true) {
            gl.endQuery(gl.ANY_SAMPLES_PASSED);
            contextData.occlusionQueryIndex++;
          }
          if (object.occlusionTest === true) {
            var query = gl.createQuery();
            gl.beginQuery(gl.ANY_SAMPLES_PASSED, query);
            contextData.occlusionQueries[contextData.occlusionQueryIndex] = query;
            contextData.occlusionQueryObjects[contextData.occlusionQueryIndex] = object;
          }
          contextData.lastOcclusionObject = object;
        }

        //
        var renderer = this.bufferRenderer;
        if (object.isPoints) renderer.mode = gl.POINTS;else if (object.isLineSegments) renderer.mode = gl.LINES;else if (object.isLine) renderer.mode = gl.LINE_STRIP;else if (object.isLineLoop) renderer.mode = gl.LINE_LOOP;else {
          if (material.wireframe === true) {
            state.setLineWidth(material.wireframeLinewidth * this.renderer.getPixelRatio());
            renderer.mode = gl.LINES;
          } else {
            renderer.mode = gl.TRIANGLES;
          }
        }

        //

        var vertexCount = drawParams.vertexCount,
          instanceCount = drawParams.instanceCount;
        var firstVertex = drawParams.firstVertex;
        renderer.object = object;
        if (index !== null) {
          firstVertex *= index.array.BYTES_PER_ELEMENT;
          var indexData = this.get(index);
          renderer.index = index.count;
          renderer.type = indexData.type;
        } else {
          renderer.index = 0;
        }
        if (object.isBatchedMesh) {
          if (object._multiDrawInstances !== null) {
            renderer.renderMultiDrawInstances(object._multiDrawStarts, object._multiDrawCounts, object._multiDrawCount, object._multiDrawInstances);
          } else if (!this.hasFeature('WEBGL_multi_draw')) {
            (0, _$$_REQUIRE(_dependencyMap[1], "./three.core.js").warnOnce)('THREE.WebGLRenderer: WEBGL_multi_draw not supported.');
          } else {
            renderer.renderMultiDraw(object._multiDrawStarts, object._multiDrawCounts, object._multiDrawCount);
          }
        } else if (instanceCount > 1) {
          renderer.renderInstances(firstVertex, vertexCount, instanceCount);
        } else {
          renderer.render(firstVertex, vertexCount);
        }
        //

        gl.bindVertexArray(null);
      }

      /**
       * Explain why always null is returned.
       *
       * @param {RenderObject} renderObject - The render object.
       * @return {Boolean} Whether the render pipeline requires an update or not.
       */
    }, {
      key: "needsRenderUpdate",
      value: function needsRenderUpdate(/*renderObject*/
      ) {
        return false;
      }

      /**
       * Explain why no cache key is computed.
       *
       * @param {RenderObject} renderObject - The render object.
       * @return {String} The cache key.
       */
    }, {
      key: "getRenderCacheKey",
      value: function getRenderCacheKey(/*renderObject*/
      ) {
        return '';
      }

      // textures

      /**
       * Creates a default texture for the given texture that can be used
       * as a placeholder until the actual texture is ready for usage.
       *
       * @param {Texture} texture - The texture to create a default texture for.
       */
    }, {
      key: "createDefaultTexture",
      value: function createDefaultTexture(texture) {
        this.textureUtils.createDefaultTexture(texture);
      }

      /**
       * Defines a texture on the GPU for the given texture object.
       *
       * @param {Texture} texture - The texture.
       * @param {Object} [options={}] - Optional configuration parameter.
       */
    }, {
      key: "createTexture",
      value: function createTexture(texture, options) {
        this.textureUtils.createTexture(texture, options);
      }

      /**
       * Uploads the updated texture data to the GPU.
       *
       * @param {Texture} texture - The texture.
       * @param {Object} [options={}] - Optional configuration parameter.
       */
    }, {
      key: "updateTexture",
      value: function updateTexture(texture, options) {
        this.textureUtils.updateTexture(texture, options);
      }

      /**
       * Generates mipmaps for the given texture
       *
       * @param {Texture} texture - The texture.
       */
    }, {
      key: "generateMipmaps",
      value: function generateMipmaps(texture) {
        this.textureUtils.generateMipmaps(texture);
      }

      /**
       * Destroys the GPU data for the given texture object.
       *
       * @param {Texture} texture - The texture.
       */
    }, {
      key: "destroyTexture",
      value: function destroyTexture(texture) {
        this.textureUtils.destroyTexture(texture);
      }

      /**
       * Returns texture data as a typed array.
       *
       * @param {Texture} texture - The texture to copy.
       * @param {Number} x - The x coordinate of the copy origin.
       * @param {Number} y - The y coordinate of the copy origin.
       * @param {Number} width - The width of the copy.
       * @param {Number} height - The height of the copy.
       * @param {Number} faceIndex - The face index.
       * @return {TypedArray} The texture data as a typed array.
       */
    }, {
      key: "copyTextureToBuffer",
      value: function copyTextureToBuffer(texture, x, y, width, height, faceIndex) {
        return this.textureUtils.copyTextureToBuffer(texture, x, y, width, height, faceIndex);
      }

      /**
       * This method does nothing since WebGL 2 has no concept of samplers.
       *
       * @param {Texture} texture - The texture to create the sampler for.
       */
    }, {
      key: "createSampler",
      value: function createSampler(/*texture*/
      ) {

        //console.warn( 'Abstract class.' );
      }

      /**
       * This method does nothing since WebGL 2 has no concept of samplers.
       *
       * @param {Texture} texture - The texture to destroy the sampler for.
       */
    }, {
      key: "destroySampler",
      value: function destroySampler(/*texture*/) {}

      // node builder

      /**
       * Returns a node builder for the given render object.
       *
       * @param {RenderObject} object - The render object.
       * @param {Renderer} renderer - The renderer.
       * @return {GLSLNodeBuilder} The node builder.
       */
    }, {
      key: "createNodeBuilder",
      value: function createNodeBuilder(object, renderer) {
        return new GLSLNodeBuilder(object, renderer);
      }

      // program

      /**
       * Creates a shader program from the given programmable stage.
       *
       * @param {ProgrammableStage} program - The programmable stage.
       */
    }, {
      key: "createProgram",
      value: function createProgram(program) {
        var gl = this.gl;
        var stage = program.stage,
          code = program.code;
        var shader = stage === 'fragment' ? gl.createShader(gl.FRAGMENT_SHADER) : gl.createShader(gl.VERTEX_SHADER);
        gl.shaderSource(shader, code);
        gl.compileShader(shader);
        this.set(program, {
          shaderGPU: shader
        });
      }

      /**
       * Destroys the shader program of the given programmable stage.
       *
       * @param {ProgrammableStage} program - The programmable stage.
       */
    }, {
      key: "destroyProgram",
      value: function destroyProgram(program) {
        this.delete(program);
      }

      /**
       * Creates a render pipeline for the given render object.
       *
       * @param {RenderObject} renderObject - The render object.
       * @param {Array<Promise>} promises - An array of compilation promises which are used in `compileAsync()`.
       */
    }, {
      key: "createRenderPipeline",
      value: function createRenderPipeline(renderObject, promises) {
        var _this205 = this;
        var gl = this.gl;
        var pipeline = renderObject.pipeline;

        // Program

        var fragmentProgram = pipeline.fragmentProgram,
          vertexProgram = pipeline.vertexProgram;
        var programGPU = gl.createProgram();
        var fragmentShader = this.get(fragmentProgram).shaderGPU;
        var vertexShader = this.get(vertexProgram).shaderGPU;
        gl.attachShader(programGPU, fragmentShader);
        gl.attachShader(programGPU, vertexShader);
        gl.linkProgram(programGPU);
        this.set(pipeline, {
          programGPU: programGPU,
          fragmentShader: fragmentShader,
          vertexShader: vertexShader
        });
        if (promises !== null && this.parallel) {
          var p = new Promise(function (resolve /*, reject*/) {
            var parallel = _this205.parallel;
            var _checkStatus = function checkStatus() {
              if (gl.getProgramParameter(programGPU, parallel.COMPLETION_STATUS_KHR)) {
                _this205._completeCompile(renderObject, pipeline);
                resolve();
              } else {
                requestAnimationFrame(_checkStatus);
              }
            };
            _checkStatus();
          });
          promises.push(p);
          return;
        }
        this._completeCompile(renderObject, pipeline);
      }

      /**
       * Formats the source code of error messages.
       *
       * @private
       * @param {String} string - The code.
       * @param {Number} errorLine - The error line.
       * @return {String} The formatted code.
       */
    }, {
      key: "_handleSource",
      value: function _handleSource(string, errorLine) {
        var lines = string.split('\n');
        var lines2 = [];
        var from = Math.max(errorLine - 6, 0);
        var to = Math.min(errorLine + 6, lines.length);
        for (var i = from; i < to; i++) {
          var line = i + 1;
          lines2.push(`${line === errorLine ? '>' : ' '} ${line}: ${lines[i]}`);
        }
        return lines2.join('\n');
      }

      /**
       * Gets the shader compilation errors from the info log.
       *
       * @private
       * @param {WebGL2RenderingContext} gl - The rendering context.
       * @param {WebGLShader} shader - The WebGL shader object.
       * @param {String} type - The shader type.
       * @return {String} The shader errors.
       */
    }, {
      key: "_getShaderErrors",
      value: function _getShaderErrors(gl, shader, type) {
        var status = gl.getShaderParameter(shader, gl.COMPILE_STATUS);
        var errors = gl.getShaderInfoLog(shader).trim();
        if (status && errors === '') return '';
        var errorMatches = /ERROR: 0:(\d+)/.exec(errors);
        if (errorMatches) {
          var errorLine = parseInt(errorMatches[1]);
          return type.toUpperCase() + '\n\n' + errors + '\n\n' + this._handleSource(gl.getShaderSource(shader), errorLine);
        } else {
          return errors;
        }
      }

      /**
       * Logs shader compilation errors.
       *
       * @private
       * @param {WebGLProgram} programGPU - The WebGL program.
       * @param {WebGLShader} glFragmentShader - The fragment shader as a native WebGL shader object.
       * @param {WebGLShader} glVertexShader - The vertex shader as a native WebGL shader object.
       */
    }, {
      key: "_logProgramError",
      value: function _logProgramError(programGPU, glFragmentShader, glVertexShader) {
        if (this.renderer.debug.checkShaderErrors) {
          var gl = this.gl;
          var programLog = gl.getProgramInfoLog(programGPU).trim();
          if (gl.getProgramParameter(programGPU, gl.LINK_STATUS) === false) {
            if (typeof this.renderer.debug.onShaderError === 'function') {
              this.renderer.debug.onShaderError(gl, programGPU, glVertexShader, glFragmentShader);
            } else {
              // default error reporting

              var vertexErrors = this._getShaderErrors(gl, glVertexShader, 'vertex');
              var fragmentErrors = this._getShaderErrors(gl, glFragmentShader, 'fragment');
              console.error('THREE.WebGLProgram: Shader Error ' + gl.getError() + ' - ' + 'VALIDATE_STATUS ' + gl.getProgramParameter(programGPU, gl.VALIDATE_STATUS) + '\n\n' + 'Program Info Log: ' + programLog + '\n' + vertexErrors + '\n' + fragmentErrors);
            }
          } else if (programLog !== '') {
            console.warn('THREE.WebGLProgram: Program Info Log:', programLog);
          }
        }
      }

      /**
       * Completes the shader program setup for the given render object.
       *
       * @private
       * @param {RenderObject} renderObject - The render object.
       * @param {RenderPipeline} pipeline - The render pipeline.
       */
    }, {
      key: "_completeCompile",
      value: function _completeCompile(renderObject, pipeline) {
        var state = this.state,
          gl = this.gl;
        var pipelineData = this.get(pipeline);
        var programGPU = pipelineData.programGPU,
          fragmentShader = pipelineData.fragmentShader,
          vertexShader = pipelineData.vertexShader;
        if (gl.getProgramParameter(programGPU, gl.LINK_STATUS) === false) {
          this._logProgramError(programGPU, fragmentShader, vertexShader);
        }
        state.useProgram(programGPU);

        // Bindings

        var bindings = renderObject.getBindings();
        this._setupBindings(bindings, programGPU);

        //

        this.set(pipeline, {
          programGPU: programGPU
        });
      }

      /**
       * Creates a compute pipeline for the given compute node.
       *
       * @param {ComputePipeline} computePipeline - The compute pipeline.
       * @param {Array<BindGroup>} bindings - The bindings.
       */
    }, {
      key: "createComputePipeline",
      value: function createComputePipeline(computePipeline, bindings) {
        var state = this.state,
          gl = this.gl;

        // Program

        var fragmentProgram = {
          stage: 'fragment',
          code: '#version 300 es\nprecision highp float;\nvoid main() {}'
        };
        this.createProgram(fragmentProgram);
        var computeProgram = computePipeline.computeProgram;
        var programGPU = gl.createProgram();
        var fragmentShader = this.get(fragmentProgram).shaderGPU;
        var vertexShader = this.get(computeProgram).shaderGPU;
        var transforms = computeProgram.transforms;
        var transformVaryingNames = [];
        var transformAttributeNodes = [];
        for (var i = 0; i < transforms.length; i++) {
          var transform = transforms[i];
          transformVaryingNames.push(transform.varyingName);
          transformAttributeNodes.push(transform.attributeNode);
        }
        gl.attachShader(programGPU, fragmentShader);
        gl.attachShader(programGPU, vertexShader);
        gl.transformFeedbackVaryings(programGPU, transformVaryingNames, gl.SEPARATE_ATTRIBS);
        gl.linkProgram(programGPU);
        if (gl.getProgramParameter(programGPU, gl.LINK_STATUS) === false) {
          this._logProgramError(programGPU, fragmentShader, vertexShader);
        }
        state.useProgram(programGPU);

        // Bindings

        this._setupBindings(bindings, programGPU);
        var attributeNodes = computeProgram.attributes;
        var attributes = [];
        var transformBuffers = [];
        for (var _i17 = 0; _i17 < attributeNodes.length; _i17++) {
          var _attribute11 = attributeNodes[_i17].node.attribute;
          attributes.push(_attribute11);
          if (!this.has(_attribute11)) this.attributeUtils.createAttribute(_attribute11, gl.ARRAY_BUFFER);
        }
        for (var _i18 = 0; _i18 < transformAttributeNodes.length; _i18++) {
          var _attribute12 = transformAttributeNodes[_i18].attribute;
          if (!this.has(_attribute12)) this.attributeUtils.createAttribute(_attribute12, gl.ARRAY_BUFFER);
          var attributeData = this.get(_attribute12);
          transformBuffers.push(attributeData);
        }

        //

        this.set(computePipeline, {
          programGPU: programGPU,
          transformBuffers: transformBuffers,
          attributes: attributes
        });
      }

      /**
       * Creates bindings from the given bind group definition.
       *
       * @param {BindGroup} bindGroup - The bind group.
       * @param {Array<BindGroup>} bindings - Array of bind groups.
       * @param {Number} cacheIndex - The cache index.
       * @param {Number} version - The version.
       */
    }, {
      key: "createBindings",
      value: function createBindings(bindGroup, bindings /*, cacheIndex, version*/) {
        if (this._knownBindings.has(bindings) === false) {
          this._knownBindings.add(bindings);
          var uniformBuffers = 0;
          var textures = 0;
          for (var _bindGroup of bindings) {
            this.set(_bindGroup, {
              textures: textures,
              uniformBuffers: uniformBuffers
            });
            for (var binding of _bindGroup.bindings) {
              if (binding.isUniformBuffer) uniformBuffers++;
              if (binding.isSampledTexture) textures++;
            }
          }
        }
        this.updateBindings(bindGroup, bindings);
      }

      /**
       * Updates the given bind group definition.
       *
       * @param {BindGroup} bindGroup - The bind group.
       * @param {Array<BindGroup>} bindings - Array of bind groups.
       * @param {Number} cacheIndex - The cache index.
       * @param {Number} version - The version.
       */
    }, {
      key: "updateBindings",
      value: function updateBindings(bindGroup /*, bindings, cacheIndex, version*/) {
        var gl = this.gl;
        var bindGroupData = this.get(bindGroup);
        var i = bindGroupData.uniformBuffers;
        var t = bindGroupData.textures;
        for (var binding of bindGroup.bindings) {
          if (binding.isUniformsGroup || binding.isUniformBuffer) {
            var data = binding.buffer;
            var bufferGPU = gl.createBuffer();
            gl.bindBuffer(gl.UNIFORM_BUFFER, bufferGPU);
            gl.bufferData(gl.UNIFORM_BUFFER, data, gl.DYNAMIC_DRAW);
            this.set(binding, {
              index: i++,
              bufferGPU: bufferGPU
            });
          } else if (binding.isSampledTexture) {
            var _this$get3 = this.get(binding.texture),
              textureGPU = _this$get3.textureGPU,
              glTextureType = _this$get3.glTextureType;
            this.set(binding, {
              index: t++,
              textureGPU: textureGPU,
              glTextureType: glTextureType
            });
          }
        }
      }

      /**
       * Updates a buffer binding.
       *
       *  @param {Buffer} binding - The buffer binding to update.
       */
    }, {
      key: "updateBinding",
      value: function updateBinding(binding) {
        var gl = this.gl;
        if (binding.isUniformsGroup || binding.isUniformBuffer) {
          var bindingData = this.get(binding);
          var bufferGPU = bindingData.bufferGPU;
          var data = binding.buffer;
          gl.bindBuffer(gl.UNIFORM_BUFFER, bufferGPU);
          gl.bufferData(gl.UNIFORM_BUFFER, data, gl.DYNAMIC_DRAW);
        }
      }

      // attributes

      /**
       * Creates the buffer of an indexed shader attribute.
       *
       * @param {BufferAttribute} attribute - The indexed buffer attribute.
       */
    }, {
      key: "createIndexAttribute",
      value: function createIndexAttribute(attribute) {
        var gl = this.gl;
        this.attributeUtils.createAttribute(attribute, gl.ELEMENT_ARRAY_BUFFER);
      }

      /**
       * Creates the buffer of a shader attribute.
       *
       * @param {BufferAttribute} attribute - The buffer attribute.
       */
    }, {
      key: "createAttribute",
      value: function createAttribute(attribute) {
        if (this.has(attribute)) return;
        var gl = this.gl;
        this.attributeUtils.createAttribute(attribute, gl.ARRAY_BUFFER);
      }

      /**
       * Creates the buffer of a storage attribute.
       *
       * @param {BufferAttribute} attribute - The buffer attribute.
       */
    }, {
      key: "createStorageAttribute",
      value: function createStorageAttribute(attribute) {
        if (this.has(attribute)) return;
        var gl = this.gl;
        this.attributeUtils.createAttribute(attribute, gl.ARRAY_BUFFER);
      }

      /**
       * Updates the buffer of a shader attribute.
       *
       * @param {BufferAttribute} attribute - The buffer attribute to update.
       */
    }, {
      key: "updateAttribute",
      value: function updateAttribute(attribute) {
        this.attributeUtils.updateAttribute(attribute);
      }

      /**
       * Destroys the buffer of a shader attribute.
       *
       * @param {BufferAttribute} attribute - The buffer attribute to destroy.
       */
    }, {
      key: "destroyAttribute",
      value: function destroyAttribute(attribute) {
        this.attributeUtils.destroyAttribute(attribute);
      }

      /**
       * Checks if the given feature is supported  by the backend.
       *
       * @param {String} name - The feature's name.
       * @return {Boolean} Whether the feature is supported or not.
       */
    }, {
      key: "hasFeature",
      value: function hasFeature(name) {
        var keysMatching = Object.keys(GLFeatureName).filter(function (key) {
          return GLFeatureName[key] === name;
        });
        var extensions = this.extensions;
        for (var i = 0; i < keysMatching.length; i++) {
          if (extensions.has(keysMatching[i])) return true;
        }
        return false;
      }

      /**
       * Returns the maximum anisotropy texture filtering value.
       *
       * @return {Number} The maximum anisotropy texture filtering value.
       */
    }, {
      key: "getMaxAnisotropy",
      value: function getMaxAnisotropy() {
        return this.capabilities.getMaxAnisotropy();
      }

      /**
       * Copies data of the given source texture to the given destination texture.
       *
       * @param {Texture} srcTexture - The source texture.
       * @param {Texture} dstTexture - The destination texture.
       * @param {Vector4?} [srcRegion=null] - The region of the source texture to copy.
       * @param {(Vector2|Vector3)?} [dstPosition=null] - The destination position of the copy.
       * @param {Number} [level=0] - The mip level to copy.
       */
    }, {
      key: "copyTextureToTexture",
      value: function copyTextureToTexture(srcTexture, dstTexture) {
        var srcRegion = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
        var dstPosition = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
        var level = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
        this.textureUtils.copyTextureToTexture(srcTexture, dstTexture, srcRegion, dstPosition, level);
      }

      /**
       * Copies the current bound framebuffer to the given texture.
       *
       * @param {Texture} texture - The destination texture.
       * @param {RenderContext} renderContext - The render context.
       * @param {Vector4} rectangle - A four dimensional vector defining the origin and dimension of the copy.
       */
    }, {
      key: "copyFramebufferToTexture",
      value: function copyFramebufferToTexture(texture, renderContext, rectangle) {
        this.textureUtils.copyFramebufferToTexture(texture, renderContext, rectangle);
      }

      /**
       * Configures the active framebuffer from the given render context.
       *
       * @private
       * @param {RenderContext} descriptor - The render context.
       */
    }, {
      key: "_setFramebuffer",
      value: function _setFramebuffer(descriptor) {
        var gl = this.gl,
          state = this.state;
        var currentFrameBuffer = null;
        if (descriptor.textures !== null) {
          var renderTarget = descriptor.renderTarget;
          var renderTargetContextData = this.get(renderTarget);
          var samples = renderTarget.samples,
            depthBuffer = renderTarget.depthBuffer,
            stencilBuffer = renderTarget.stencilBuffer;
          var isCube = renderTarget.isWebGLCubeRenderTarget === true;
          var isRenderTarget3D = renderTarget.isRenderTarget3D === true;
          var isRenderTargetArray = renderTarget.isRenderTargetArray === true;
          var msaaFb = renderTargetContextData.msaaFrameBuffer;
          var depthRenderbuffer = renderTargetContextData.depthRenderbuffer;
          var cacheKey = _getCacheKey(descriptor);
          var fb;
          if (isCube) {
            renderTargetContextData.cubeFramebuffers || (renderTargetContextData.cubeFramebuffers = {});
            fb = renderTargetContextData.cubeFramebuffers[cacheKey];
          } else {
            renderTargetContextData.framebuffers || (renderTargetContextData.framebuffers = {});
            fb = renderTargetContextData.framebuffers[cacheKey];
          }
          if (fb === undefined) {
            fb = gl.createFramebuffer();
            state.bindFramebuffer(gl.FRAMEBUFFER, fb);
            var textures = descriptor.textures;
            if (isCube) {
              renderTargetContextData.cubeFramebuffers[cacheKey] = fb;
              var _this$get4 = this.get(textures[0]),
                textureGPU = _this$get4.textureGPU;
              var cubeFace = this.renderer._activeCubeFace;
              gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_CUBE_MAP_POSITIVE_X + cubeFace, textureGPU, 0);
            } else {
              renderTargetContextData.framebuffers[cacheKey] = fb;
              for (var i = 0; i < textures.length; i++) {
                var _texture8 = textures[i];
                var textureData = this.get(_texture8);
                textureData.renderTarget = descriptor.renderTarget;
                textureData.cacheKey = cacheKey; // required for copyTextureToTexture()

                var attachment = gl.COLOR_ATTACHMENT0 + i;
                if (isRenderTarget3D || isRenderTargetArray) {
                  var layer = this.renderer._activeCubeFace;
                  gl.framebufferTextureLayer(gl.FRAMEBUFFER, attachment, textureData.textureGPU, 0, layer);
                } else {
                  gl.framebufferTexture2D(gl.FRAMEBUFFER, attachment, gl.TEXTURE_2D, textureData.textureGPU, 0);
                }
              }
              state.drawBuffers(descriptor, fb);
            }
            if (descriptor.depthTexture !== null) {
              var _textureData2 = this.get(descriptor.depthTexture);
              var depthStyle = stencilBuffer ? gl.DEPTH_STENCIL_ATTACHMENT : gl.DEPTH_ATTACHMENT;
              _textureData2.renderTarget = descriptor.renderTarget;
              _textureData2.cacheKey = cacheKey; // required for copyTextureToTexture()

              gl.framebufferTexture2D(gl.FRAMEBUFFER, depthStyle, gl.TEXTURE_2D, _textureData2.textureGPU, 0);
            }
          }
          if (samples > 0) {
            if (msaaFb === undefined) {
              var invalidationArray = [];
              msaaFb = gl.createFramebuffer();
              state.bindFramebuffer(gl.FRAMEBUFFER, msaaFb);
              var msaaRenderbuffers = [];
              var _textures2 = descriptor.textures;
              for (var _i19 = 0; _i19 < _textures2.length; _i19++) {
                msaaRenderbuffers[_i19] = gl.createRenderbuffer();
                gl.bindRenderbuffer(gl.RENDERBUFFER, msaaRenderbuffers[_i19]);
                invalidationArray.push(gl.COLOR_ATTACHMENT0 + _i19);
                if (depthBuffer) {
                  var _depthStyle = stencilBuffer ? gl.DEPTH_STENCIL_ATTACHMENT : gl.DEPTH_ATTACHMENT;
                  invalidationArray.push(_depthStyle);
                }
                var _texture9 = descriptor.textures[_i19];
                var _textureData3 = this.get(_texture9);
                gl.renderbufferStorageMultisample(gl.RENDERBUFFER, samples, _textureData3.glInternalFormat, descriptor.width, descriptor.height);
                gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0 + _i19, gl.RENDERBUFFER, msaaRenderbuffers[_i19]);
              }
              renderTargetContextData.msaaFrameBuffer = msaaFb;
              renderTargetContextData.msaaRenderbuffers = msaaRenderbuffers;
              if (depthRenderbuffer === undefined) {
                depthRenderbuffer = gl.createRenderbuffer();
                this.textureUtils.setupRenderBufferStorage(depthRenderbuffer, descriptor);
                renderTargetContextData.depthRenderbuffer = depthRenderbuffer;
                var _depthStyle2 = stencilBuffer ? gl.DEPTH_STENCIL_ATTACHMENT : gl.DEPTH_ATTACHMENT;
                invalidationArray.push(_depthStyle2);
              }
              renderTargetContextData.invalidationArray = invalidationArray;
            }
            currentFrameBuffer = renderTargetContextData.msaaFrameBuffer;
          } else {
            currentFrameBuffer = fb;
          }
        }
        state.bindFramebuffer(gl.FRAMEBUFFER, currentFrameBuffer);
      }

      /**
       * Computes the VAO key for the given index and attributes.
       *
       * @private
       * @param {BufferAttribute?} index - The index. `null` for non-indexed geometries.
       * @param {Array<BufferAttribute>} attributes - An array of buffer attributes.
       * @return {String} The VAO key.
       */
    }, {
      key: "_getVaoKey",
      value: function _getVaoKey(index, attributes) {
        var key = '';
        if (index !== null) {
          var indexData = this.get(index);
          key += ':' + indexData.id;
        }
        for (var i = 0; i < attributes.length; i++) {
          var attributeData = this.get(attributes[i]);
          key += ':' + attributeData.id;
        }
        return key;
      }

      /**
       * Creates a VAO from the index and attributes.
       *
       * @private
       * @param {BufferAttribute?} index - The index. `null` for non-indexed geometries.
       * @param {Array<BufferAttribute>} attributes - An array of buffer attributes.
       * @return {Object} The VAO data.
       */
    }, {
      key: "_createVao",
      value: function _createVao(index, attributes) {
        var gl = this.gl;
        var vaoGPU = gl.createVertexArray();
        var key = '';
        var staticVao = true;
        gl.bindVertexArray(vaoGPU);
        if (index !== null) {
          var indexData = this.get(index);
          gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexData.bufferGPU);
          key += ':' + indexData.id;
        }
        for (var i = 0; i < attributes.length; i++) {
          var _attribute13 = attributes[i];
          var attributeData = this.get(_attribute13);
          key += ':' + attributeData.id;
          gl.bindBuffer(gl.ARRAY_BUFFER, attributeData.bufferGPU);
          gl.enableVertexAttribArray(i);
          if (_attribute13.isStorageBufferAttribute || _attribute13.isStorageInstancedBufferAttribute) staticVao = false;
          var stride = void 0,
            offset = void 0;
          if (_attribute13.isInterleavedBufferAttribute === true) {
            stride = _attribute13.data.stride * attributeData.bytesPerElement;
            offset = _attribute13.offset * attributeData.bytesPerElement;
          } else {
            stride = 0;
            offset = 0;
          }
          if (attributeData.isInteger) {
            gl.vertexAttribIPointer(i, _attribute13.itemSize, attributeData.type, stride, offset);
          } else {
            gl.vertexAttribPointer(i, _attribute13.itemSize, attributeData.type, _attribute13.normalized, stride, offset);
          }
          if (_attribute13.isInstancedBufferAttribute && !_attribute13.isInterleavedBufferAttribute) {
            gl.vertexAttribDivisor(i, _attribute13.meshPerAttribute);
          } else if (_attribute13.isInterleavedBufferAttribute && _attribute13.data.isInstancedInterleavedBuffer) {
            gl.vertexAttribDivisor(i, _attribute13.data.meshPerAttribute);
          }
        }
        gl.bindBuffer(gl.ARRAY_BUFFER, null);
        this.vaoCache[key] = vaoGPU;
        return {
          vaoGPU: vaoGPU,
          staticVao: staticVao
        };
      }

      /**
       * Creates a tranform feedback from the given transform buffers.
       *
       * @private
       * @param {Array<DualAttributeData>} transformBuffers - The tranform buffers.
       * @return {WebGLTransformFeedback} The tranform feedback.
       */
    }, {
      key: "_getTransformFeedback",
      value: function _getTransformFeedback(transformBuffers) {
        var key = '';
        for (var i = 0; i < transformBuffers.length; i++) {
          key += ':' + transformBuffers[i].id;
        }
        var transformFeedbackGPU = this.transformFeedbackCache[key];
        if (transformFeedbackGPU !== undefined) {
          return transformFeedbackGPU;
        }
        var gl = this.gl;
        transformFeedbackGPU = gl.createTransformFeedback();
        gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, transformFeedbackGPU);
        for (var _i20 = 0; _i20 < transformBuffers.length; _i20++) {
          var attributeData = transformBuffers[_i20];
          gl.bindBufferBase(gl.TRANSFORM_FEEDBACK_BUFFER, _i20, attributeData.transformBuffer);
        }
        gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK, null);
        this.transformFeedbackCache[key] = transformFeedbackGPU;
        return transformFeedbackGPU;
      }

      /**
       * Setups the given bindings.
       *
       * @private
       * @param {Array<BindGroup>} bindings - The bindings.
       * @param {WebGLProgram} programGPU - The WebGL program.
       */
    }, {
      key: "_setupBindings",
      value: function _setupBindings(bindings, programGPU) {
        var gl = this.gl;
        for (var bindGroup of bindings) {
          for (var binding of bindGroup.bindings) {
            var bindingData = this.get(binding);
            var index = bindingData.index;
            if (binding.isUniformsGroup || binding.isUniformBuffer) {
              var location = gl.getUniformBlockIndex(programGPU, binding.name);
              gl.uniformBlockBinding(programGPU, location, index);
            } else if (binding.isSampledTexture) {
              var _location = gl.getUniformLocation(programGPU, binding.name);
              gl.uniform1i(_location, index);
            }
          }
        }
      }

      /**
       * Binds the given uniforms.
       *
       * @private
       * @param {Array<BindGroup>} bindings - The bindings.
       */
    }, {
      key: "_bindUniforms",
      value: function _bindUniforms(bindings) {
        var gl = this.gl,
          state = this.state;
        for (var bindGroup of bindings) {
          for (var binding of bindGroup.bindings) {
            var bindingData = this.get(binding);
            var index = bindingData.index;
            if (binding.isUniformsGroup || binding.isUniformBuffer) {
              // TODO USE bindBufferRange to group multiple uniform buffers
              state.bindBufferBase(gl.UNIFORM_BUFFER, index, bindingData.bufferGPU);
            } else if (binding.isSampledTexture) {
              state.bindTexture(bindingData.glTextureType, bindingData.textureGPU, gl.TEXTURE0 + index);
            }
          }
        }
      }

      /**
       * Frees internal resources.
       */
    }, {
      key: "dispose",
      value: function dispose() {
        this.renderer.domElement.removeEventListener('webglcontextlost', this._onContextLost);
      }
    }]);
  }(Backend);
  var GPUPrimitiveTopology = {
    PointList: 'point-list',
    LineList: 'line-list',
    LineStrip: 'line-strip',
    TriangleList: 'triangle-list',
    TriangleStrip: 'triangle-strip'
  };
  var GPUCompareFunction = {
    Never: 'never',
    Less: 'less',
    Equal: 'equal',
    LessEqual: 'less-equal',
    Greater: 'greater',
    NotEqual: 'not-equal',
    GreaterEqual: 'greater-equal',
    Always: 'always'
  };
  var GPUStoreOp = {
    Store: 'store',
    Discard: 'discard'
  };
  var GPULoadOp = {
    Load: 'load',
    Clear: 'clear'
  };
  var GPUFrontFace = {
    CCW: 'ccw',
    CW: 'cw'
  };
  var GPUCullMode = {
    None: 'none',
    Front: 'front',
    Back: 'back'
  };
  var GPUIndexFormat = {
    Uint16: 'uint16',
    Uint32: 'uint32'
  };
  var GPUTextureFormat = {
    // 8-bit formats

    R8Unorm: 'r8unorm',
    R8Snorm: 'r8snorm',
    R8Uint: 'r8uint',
    R8Sint: 'r8sint',
    // 16-bit formats

    R16Uint: 'r16uint',
    R16Sint: 'r16sint',
    R16Float: 'r16float',
    RG8Unorm: 'rg8unorm',
    RG8Snorm: 'rg8snorm',
    RG8Uint: 'rg8uint',
    RG8Sint: 'rg8sint',
    // 32-bit formats

    R32Uint: 'r32uint',
    R32Sint: 'r32sint',
    R32Float: 'r32float',
    RG16Uint: 'rg16uint',
    RG16Sint: 'rg16sint',
    RG16Float: 'rg16float',
    RGBA8Unorm: 'rgba8unorm',
    RGBA8UnormSRGB: 'rgba8unorm-srgb',
    RGBA8Snorm: 'rgba8snorm',
    RGBA8Uint: 'rgba8uint',
    RGBA8Sint: 'rgba8sint',
    BGRA8Unorm: 'bgra8unorm',
    BGRA8UnormSRGB: 'bgra8unorm-srgb',
    // Packed 32-bit formats
    RGB9E5UFloat: 'rgb9e5ufloat',
    RGB10A2Unorm: 'rgb10a2unorm',
    RG11B10uFloat: 'rgb10a2unorm',
    // 64-bit formats

    RG32Uint: 'rg32uint',
    RG32Sint: 'rg32sint',
    RG32Float: 'rg32float',
    RGBA16Uint: 'rgba16uint',
    RGBA16Sint: 'rgba16sint',
    RGBA16Float: 'rgba16float',
    // 128-bit formats

    RGBA32Uint: 'rgba32uint',
    RGBA32Sint: 'rgba32sint',
    RGBA32Float: 'rgba32float',
    // Depth and stencil formats

    Stencil8: 'stencil8',
    Depth16Unorm: 'depth16unorm',
    Depth24Plus: 'depth24plus',
    Depth24PlusStencil8: 'depth24plus-stencil8',
    Depth32Float: 'depth32float',
    // 'depth32float-stencil8' extension

    Depth32FloatStencil8: 'depth32float-stencil8',
    // BC compressed formats usable if 'texture-compression-bc' is both
    // supported by the device/user agent and enabled in requestDevice.

    BC1RGBAUnorm: 'bc1-rgba-unorm',
    BC1RGBAUnormSRGB: 'bc1-rgba-unorm-srgb',
    BC2RGBAUnorm: 'bc2-rgba-unorm',
    BC2RGBAUnormSRGB: 'bc2-rgba-unorm-srgb',
    BC3RGBAUnorm: 'bc3-rgba-unorm',
    BC3RGBAUnormSRGB: 'bc3-rgba-unorm-srgb',
    BC4RUnorm: 'bc4-r-unorm',
    BC4RSnorm: 'bc4-r-snorm',
    BC5RGUnorm: 'bc5-rg-unorm',
    BC5RGSnorm: 'bc5-rg-snorm',
    BC6HRGBUFloat: 'bc6h-rgb-ufloat',
    BC6HRGBFloat: 'bc6h-rgb-float',
    BC7RGBAUnorm: 'bc7-rgba-unorm',
    BC7RGBAUnormSRGB: 'bc7-rgba-srgb',
    // ETC2 compressed formats usable if 'texture-compression-etc2' is both
    // supported by the device/user agent and enabled in requestDevice.

    ETC2RGB8Unorm: 'etc2-rgb8unorm',
    ETC2RGB8UnormSRGB: 'etc2-rgb8unorm-srgb',
    ETC2RGB8A1Unorm: 'etc2-rgb8a1unorm',
    ETC2RGB8A1UnormSRGB: 'etc2-rgb8a1unorm-srgb',
    ETC2RGBA8Unorm: 'etc2-rgba8unorm',
    ETC2RGBA8UnormSRGB: 'etc2-rgba8unorm-srgb',
    EACR11Unorm: 'eac-r11unorm',
    EACR11Snorm: 'eac-r11snorm',
    EACRG11Unorm: 'eac-rg11unorm',
    EACRG11Snorm: 'eac-rg11snorm',
    // ASTC compressed formats usable if 'texture-compression-astc' is both
    // supported by the device/user agent and enabled in requestDevice.

    ASTC4x4Unorm: 'astc-4x4-unorm',
    ASTC4x4UnormSRGB: 'astc-4x4-unorm-srgb',
    ASTC5x4Unorm: 'astc-5x4-unorm',
    ASTC5x4UnormSRGB: 'astc-5x4-unorm-srgb',
    ASTC5x5Unorm: 'astc-5x5-unorm',
    ASTC5x5UnormSRGB: 'astc-5x5-unorm-srgb',
    ASTC6x5Unorm: 'astc-6x5-unorm',
    ASTC6x5UnormSRGB: 'astc-6x5-unorm-srgb',
    ASTC6x6Unorm: 'astc-6x6-unorm',
    ASTC6x6UnormSRGB: 'astc-6x6-unorm-srgb',
    ASTC8x5Unorm: 'astc-8x5-unorm',
    ASTC8x5UnormSRGB: 'astc-8x5-unorm-srgb',
    ASTC8x6Unorm: 'astc-8x6-unorm',
    ASTC8x6UnormSRGB: 'astc-8x6-unorm-srgb',
    ASTC8x8Unorm: 'astc-8x8-unorm',
    ASTC8x8UnormSRGB: 'astc-8x8-unorm-srgb',
    ASTC10x5Unorm: 'astc-10x5-unorm',
    ASTC10x5UnormSRGB: 'astc-10x5-unorm-srgb',
    ASTC10x6Unorm: 'astc-10x6-unorm',
    ASTC10x6UnormSRGB: 'astc-10x6-unorm-srgb',
    ASTC10x8Unorm: 'astc-10x8-unorm',
    ASTC10x8UnormSRGB: 'astc-10x8-unorm-srgb',
    ASTC10x10Unorm: 'astc-10x10-unorm',
    ASTC10x10UnormSRGB: 'astc-10x10-unorm-srgb',
    ASTC12x10Unorm: 'astc-12x10-unorm',
    ASTC12x10UnormSRGB: 'astc-12x10-unorm-srgb',
    ASTC12x12Unorm: 'astc-12x12-unorm',
    ASTC12x12UnormSRGB: 'astc-12x12-unorm-srgb'
  };
  var GPUAddressMode = {
    ClampToEdge: 'clamp-to-edge',
    Repeat: 'repeat',
    MirrorRepeat: 'mirror-repeat'
  };
  var GPUFilterMode = {
    Linear: 'linear',
    Nearest: 'nearest'
  };
  var GPUBlendFactor = {
    Zero: 'zero',
    One: 'one',
    Src: 'src',
    OneMinusSrc: 'one-minus-src',
    SrcAlpha: 'src-alpha',
    OneMinusSrcAlpha: 'one-minus-src-alpha',
    Dst: 'dst',
    OneMinusDstColor: 'one-minus-dst',
    DstAlpha: 'dst-alpha',
    OneMinusDstAlpha: 'one-minus-dst-alpha',
    SrcAlphaSaturated: 'src-alpha-saturated',
    Constant: 'constant',
    OneMinusConstant: 'one-minus-constant'
  };
  var GPUBlendOperation = {
    Add: 'add',
    Subtract: 'subtract',
    ReverseSubtract: 'reverse-subtract',
    Min: 'min',
    Max: 'max'
  };
  var GPUColorWriteFlags = {
    None: 0,
    Red: 0x1,
    Green: 0x2,
    Blue: 0x4,
    Alpha: 0x8,
    All: 0xF
  };
  var GPUStencilOperation = {
    Keep: 'keep',
    Zero: 'zero',
    Replace: 'replace',
    Invert: 'invert',
    IncrementClamp: 'increment-clamp',
    DecrementClamp: 'decrement-clamp',
    IncrementWrap: 'increment-wrap',
    DecrementWrap: 'decrement-wrap'
  };
  var GPUBufferBindingType = {
    Uniform: 'uniform',
    Storage: 'storage',
    ReadOnlyStorage: 'read-only-storage'
  };
  var GPUStorageTextureAccess = {
    WriteOnly: 'write-only',
    ReadOnly: 'read-only',
    ReadWrite: 'read-write'
  };
  var GPUTextureSampleType = {
    Float: 'float',
    UnfilterableFloat: 'unfilterable-float',
    Depth: 'depth',
    SInt: 'sint',
    UInt: 'uint'
  };
  var GPUTextureDimension = {
    OneD: '1d',
    TwoD: '2d',
    ThreeD: '3d'
  };
  var GPUTextureViewDimension = {
    OneD: '1d',
    TwoD: '2d',
    TwoDArray: '2d-array',
    Cube: 'cube',
    CubeArray: 'cube-array',
    ThreeD: '3d'
  };
  var GPUTextureAspect = {
    All: 'all',
    StencilOnly: 'stencil-only',
    DepthOnly: 'depth-only'
  };
  var GPUInputStepMode = {
    Vertex: 'vertex',
    Instance: 'instance'
  };
  var GPUFeatureName = {
    DepthClipControl: 'depth-clip-control',
    Depth32FloatStencil8: 'depth32float-stencil8',
    TextureCompressionBC: 'texture-compression-bc',
    TextureCompressionETC2: 'texture-compression-etc2',
    TextureCompressionASTC: 'texture-compression-astc',
    TimestampQuery: 'timestamp-query',
    IndirectFirstInstance: 'indirect-first-instance',
    ShaderF16: 'shader-f16',
    RG11B10UFloat: 'rg11b10ufloat-renderable',
    BGRA8UNormStorage: 'bgra8unorm-storage',
    Float32Filterable: 'float32-filterable',
    ClipDistances: 'clip-distances',
    DualSourceBlending: 'dual-source-blending',
    Subgroups: 'subgroups'
  };

  /**
   * Represents a sampler binding type.
   *
   * @private
   * @augments Binding
   */
  var Sampler = /*#__PURE__*/function (_Binding3) {
    /**
     * Constructs a new sampler.
     *
     * @param {String} name - The samplers's name.
     * @param {Texture?} texture - The texture this binding is referring to.
     */
    function Sampler(name, texture) {
      var _this206;
      (0, _classCallCheck2.default)(this, Sampler);
      _this206 = _callSuper(this, Sampler, [name]);

      /**
       * The texture the sampler is referring to.
       *
       * @type {Texture?}
       */
      _this206.texture = texture;

      /**
       * The binding's version.
       *
       * @type {Number}
       */
      _this206.version = texture ? texture.version : 0;

      /**
       * This flag can be used for type testing.
       *
       * @type {Boolean}
       * @readonly
       * @default true
       */
      _this206.isSampler = true;
      return _this206;
    }
    (0, _inherits2.default)(Sampler, _Binding3);
    return (0, _createClass2.default)(Sampler);
  }(Binding);
  /**
   * A special form of sampler binding type.
   * It's texture value is managed by a node object.
   *
   * @private
   * @augments Sampler
   */
  var NodeSampler = /*#__PURE__*/function (_Sampler) {
    /**
     * Constructs a new node-based sampler.
     *
     * @param {String} name - The samplers's name.
     * @param {TextureNode} textureNode - The texture node.
     * @param {UniformGroupNode} groupNode - The uniform group node.
     */
    function NodeSampler(name, textureNode, groupNode) {
      var _this207;
      (0, _classCallCheck2.default)(this, NodeSampler);
      _this207 = _callSuper(this, NodeSampler, [name, textureNode ? textureNode.value : null]);

      /**
       * The texture node.
       *
       * @type {TextureNode}
       */
      _this207.textureNode = textureNode;

      /**
       * The uniform group node.
       *
       * @type {UniformGroupNode}
       */
      _this207.groupNode = groupNode;
      return _this207;
    }

    /**
     * Updates the texture value of this sampler.
     */
    (0, _inherits2.default)(NodeSampler, _Sampler);
    return (0, _createClass2.default)(NodeSampler, [{
      key: "update",
      value: function update() {
        this.texture = this.textureNode.value;
      }
    }]);
  }(Sampler);
  /**
   * Represents a storage buffer binding type.
   *
   * @private
   * @augments Buffer
   */
  var StorageBuffer = /*#__PURE__*/function (_Buffer2) {
    /**
     * Constructs a new uniform buffer.
     *
     * @param {String} name - The buffer's name.
     * @param {BufferAttribute} attribute - The buffer attribute.
     */
    function StorageBuffer(name, attribute) {
      var _this208;
      (0, _classCallCheck2.default)(this, StorageBuffer);
      _this208 = _callSuper(this, StorageBuffer, [name, attribute ? attribute.array : null]);

      /**
       * This flag can be used for type testing.
       *
       * @type {BufferAttribute}
       */
      _this208.attribute = attribute;

      /**
       * This flag can be used for type testing.
       *
       * @type {Boolean}
       * @readonly
       * @default true
       */
      _this208.isStorageBuffer = true;
      return _this208;
    }
    (0, _inherits2.default)(StorageBuffer, _Buffer2);
    return (0, _createClass2.default)(StorageBuffer);
  }(Buffer);
  var _id = 0;

  /**
   * A special form of storage buffer binding type.
   * It's buffer value is managed by a node object.
   *
   * @private
   * @augments StorageBuffer
   */
  var NodeStorageBuffer = /*#__PURE__*/function (_StorageBuffer) {
    /**
     * Constructs a new node-based storage buffer.
     *
     * @param {StorageBufferNode} nodeUniform - The storage buffer node.
     * @param {UniformGroupNode} groupNode - The uniform group node.
     */
    function NodeStorageBuffer(nodeUniform, groupNode) {
      var _this209;
      (0, _classCallCheck2.default)(this, NodeStorageBuffer);
      _this209 = _callSuper(this, NodeStorageBuffer, ['StorageBuffer_' + _id++, nodeUniform ? nodeUniform.value : null]);

      /**
       * The node uniform.
       *
       * @type {StorageBufferNode}
       */
      _this209.nodeUniform = nodeUniform;

      /**
       * The access type.
       *
       * @type {String}
       */
      _this209.access = nodeUniform ? nodeUniform.access : NodeAccess.READ_WRITE;

      /**
       * The uniform group node.
       *
       * @type {UniformGroupNode}
       */
      _this209.groupNode = groupNode;
      return _this209;
    }

    /**
     * The storage buffer.
     *
     * @type {BufferAttribute}
     */
    (0, _inherits2.default)(NodeStorageBuffer, _StorageBuffer);
    return (0, _createClass2.default)(NodeStorageBuffer, [{
      key: "buffer",
      get: function get() {
        return this.nodeUniform.value;
      }
    }]);
  }(StorageBuffer);
  var WebGPUTexturePassUtils = /*#__PURE__*/function (_DataMap8) {
    function WebGPUTexturePassUtils(device) {
      var _this210;
      (0, _classCallCheck2.default)(this, WebGPUTexturePassUtils);
      _this210 = _callSuper(this, WebGPUTexturePassUtils);
      _this210.device = device;
      var mipmapVertexSource = `
struct VarysStruct {
	@builtin( position ) Position: vec4<f32>,
	@location( 0 ) vTex : vec2<f32>
};

@vertex
fn main( @builtin( vertex_index ) vertexIndex : u32 ) -> VarysStruct {

	var Varys : VarysStruct;

	var pos = array< vec2<f32>, 4 >(
		vec2<f32>( -1.0,  1.0 ),
		vec2<f32>(  1.0,  1.0 ),
		vec2<f32>( -1.0, -1.0 ),
		vec2<f32>(  1.0, -1.0 )
	);

	var tex = array< vec2<f32>, 4 >(
		vec2<f32>( 0.0, 0.0 ),
		vec2<f32>( 1.0, 0.0 ),
		vec2<f32>( 0.0, 1.0 ),
		vec2<f32>( 1.0, 1.0 )
	);

	Varys.vTex = tex[ vertexIndex ];
	Varys.Position = vec4<f32>( pos[ vertexIndex ], 0.0, 1.0 );

	return Varys;

}
`;
      var mipmapFragmentSource = `
@group( 0 ) @binding( 0 )
var imgSampler : sampler;

@group( 0 ) @binding( 1 )
var img : texture_2d<f32>;

@fragment
fn main( @location( 0 ) vTex : vec2<f32> ) -> @location( 0 ) vec4<f32> {

	return textureSample( img, imgSampler, vTex );

}
`;
      var flipYFragmentSource = `
@group( 0 ) @binding( 0 )
var imgSampler : sampler;

@group( 0 ) @binding( 1 )
var img : texture_2d<f32>;

@fragment
fn main( @location( 0 ) vTex : vec2<f32> ) -> @location( 0 ) vec4<f32> {

	return textureSample( img, imgSampler, vec2( vTex.x, 1.0 - vTex.y ) );

}
`;
      _this210.mipmapSampler = device.createSampler({
        minFilter: GPUFilterMode.Linear
      });
      _this210.flipYSampler = device.createSampler({
        minFilter: GPUFilterMode.Nearest
      }); //@TODO?: Consider using textureLoad()

      // We'll need a new pipeline for every texture format used.
      _this210.transferPipelines = {};
      _this210.flipYPipelines = {};
      _this210.mipmapVertexShaderModule = device.createShaderModule({
        label: 'mipmapVertex',
        code: mipmapVertexSource
      });
      _this210.mipmapFragmentShaderModule = device.createShaderModule({
        label: 'mipmapFragment',
        code: mipmapFragmentSource
      });
      _this210.flipYFragmentShaderModule = device.createShaderModule({
        label: 'flipYFragment',
        code: flipYFragmentSource
      });
      return _this210;
    }
    (0, _inherits2.default)(WebGPUTexturePassUtils, _DataMap8);
    return (0, _createClass2.default)(WebGPUTexturePassUtils, [{
      key: "getTransferPipeline",
      value: function getTransferPipeline(format) {
        var pipeline = this.transferPipelines[format];
        if (pipeline === undefined) {
          pipeline = this.device.createRenderPipeline({
            label: `mipmap-${format}`,
            vertex: {
              module: this.mipmapVertexShaderModule,
              entryPoint: 'main'
            },
            fragment: {
              module: this.mipmapFragmentShaderModule,
              entryPoint: 'main',
              targets: [{
                format: format
              }]
            },
            primitive: {
              topology: GPUPrimitiveTopology.TriangleStrip,
              stripIndexFormat: GPUIndexFormat.Uint32
            },
            layout: 'auto'
          });
          this.transferPipelines[format] = pipeline;
        }
        return pipeline;
      }
    }, {
      key: "getFlipYPipeline",
      value: function getFlipYPipeline(format) {
        var pipeline = this.flipYPipelines[format];
        if (pipeline === undefined) {
          pipeline = this.device.createRenderPipeline({
            label: `flipY-${format}`,
            vertex: {
              module: this.mipmapVertexShaderModule,
              entryPoint: 'main'
            },
            fragment: {
              module: this.flipYFragmentShaderModule,
              entryPoint: 'main',
              targets: [{
                format: format
              }]
            },
            primitive: {
              topology: GPUPrimitiveTopology.TriangleStrip,
              stripIndexFormat: GPUIndexFormat.Uint32
            },
            layout: 'auto'
          });
          this.flipYPipelines[format] = pipeline;
        }
        return pipeline;
      }
    }, {
      key: "flipY",
      value: function flipY(textureGPU, textureGPUDescriptor) {
        var _this211 = this;
        var baseArrayLayer = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
        var format = textureGPUDescriptor.format;
        var _textureGPUDescriptor = textureGPUDescriptor.size,
          width = _textureGPUDescriptor.width,
          height = _textureGPUDescriptor.height;
        var transferPipeline = this.getTransferPipeline(format);
        var flipYPipeline = this.getFlipYPipeline(format);
        var tempTexture = this.device.createTexture({
          size: {
            width: width,
            height: height,
            depthOrArrayLayers: 1
          },
          format: format,
          usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.TEXTURE_BINDING
        });
        var srcView = textureGPU.createView({
          baseMipLevel: 0,
          mipLevelCount: 1,
          dimension: GPUTextureViewDimension.TwoD,
          baseArrayLayer: baseArrayLayer
        });
        var dstView = tempTexture.createView({
          baseMipLevel: 0,
          mipLevelCount: 1,
          dimension: GPUTextureViewDimension.TwoD,
          baseArrayLayer: 0
        });
        var commandEncoder = this.device.createCommandEncoder({});
        var pass = function pass(pipeline, sourceView, destinationView) {
          var bindGroupLayout = pipeline.getBindGroupLayout(0); // @TODO: Consider making this static.

          var bindGroup = _this211.device.createBindGroup({
            layout: bindGroupLayout,
            entries: [{
              binding: 0,
              resource: _this211.flipYSampler
            }, {
              binding: 1,
              resource: sourceView
            }]
          });
          var passEncoder = commandEncoder.beginRenderPass({
            colorAttachments: [{
              view: destinationView,
              loadOp: GPULoadOp.Clear,
              storeOp: GPUStoreOp.Store,
              clearValue: [0, 0, 0, 0]
            }]
          });
          passEncoder.setPipeline(pipeline);
          passEncoder.setBindGroup(0, bindGroup);
          passEncoder.draw(4, 1, 0, 0);
          passEncoder.end();
        };
        pass(transferPipeline, srcView, dstView);
        pass(flipYPipeline, dstView, srcView);
        this.device.queue.submit([commandEncoder.finish()]);
        tempTexture.destroy();
      }
    }, {
      key: "generateMipmaps",
      value: function generateMipmaps(textureGPU, textureGPUDescriptor) {
        var baseArrayLayer = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
        var textureData = this.get(textureGPU);
        if (textureData.useCount === undefined) {
          textureData.useCount = 0;
          textureData.layers = [];
        }
        var passes = textureData.layers[baseArrayLayer] || this._mipmapCreateBundles(textureGPU, textureGPUDescriptor, baseArrayLayer);
        var commandEncoder = this.device.createCommandEncoder({});
        this._mipmapRunBundles(commandEncoder, passes);
        this.device.queue.submit([commandEncoder.finish()]);
        if (textureData.useCount !== 0) textureData.layers[baseArrayLayer] = passes;
        textureData.useCount++;
      }
    }, {
      key: "_mipmapCreateBundles",
      value: function _mipmapCreateBundles(textureGPU, textureGPUDescriptor, baseArrayLayer) {
        var pipeline = this.getTransferPipeline(textureGPUDescriptor.format);
        var bindGroupLayout = pipeline.getBindGroupLayout(0); // @TODO: Consider making this static.

        var srcView = textureGPU.createView({
          baseMipLevel: 0,
          mipLevelCount: 1,
          dimension: GPUTextureViewDimension.TwoD,
          baseArrayLayer: baseArrayLayer
        });
        var passes = [];
        for (var i = 1; i < textureGPUDescriptor.mipLevelCount; i++) {
          var bindGroup = this.device.createBindGroup({
            layout: bindGroupLayout,
            entries: [{
              binding: 0,
              resource: this.mipmapSampler
            }, {
              binding: 1,
              resource: srcView
            }]
          });
          var dstView = textureGPU.createView({
            baseMipLevel: i,
            mipLevelCount: 1,
            dimension: GPUTextureViewDimension.TwoD,
            baseArrayLayer: baseArrayLayer
          });
          var passDescriptor = {
            colorAttachments: [{
              view: dstView,
              loadOp: GPULoadOp.Clear,
              storeOp: GPUStoreOp.Store,
              clearValue: [0, 0, 0, 0]
            }]
          };
          var passEncoder = this.device.createRenderBundleEncoder({
            colorFormats: [textureGPUDescriptor.format]
          });
          passEncoder.setPipeline(pipeline);
          passEncoder.setBindGroup(0, bindGroup);
          passEncoder.draw(4, 1, 0, 0);
          passes.push({
            renderBundles: [passEncoder.finish()],
            passDescriptor: passDescriptor
          });
          srcView = dstView;
        }
        return passes;
      }
    }, {
      key: "_mipmapRunBundles",
      value: function _mipmapRunBundles(commandEncoder, passes) {
        var levels = passes.length;
        for (var i = 0; i < levels; i++) {
          var _pass = passes[i];
          var passEncoder = commandEncoder.beginRenderPass(_pass.passDescriptor);
          passEncoder.executeBundles(_pass.renderBundles);
          passEncoder.end();
        }
      }
    }]);
  }(DataMap);
  var _compareToWebGPU = (0, _defineProperty2.default)((0, _defineProperty2.default)((0, _defineProperty2.default)((0, _defineProperty2.default)((0, _defineProperty2.default)((0, _defineProperty2.default)((0, _defineProperty2.default)((0, _defineProperty2.default)({}, _$$_REQUIRE(_dependencyMap[1], "./three.core.js").NeverCompare, 'never'), _$$_REQUIRE(_dependencyMap[1], "./three.core.js").LessCompare, 'less'), _$$_REQUIRE(_dependencyMap[1], "./three.core.js").EqualCompare, 'equal'), _$$_REQUIRE(_dependencyMap[1], "./three.core.js").LessEqualCompare, 'less-equal'), _$$_REQUIRE(_dependencyMap[1], "./three.core.js").GreaterCompare, 'greater'), _$$_REQUIRE(_dependencyMap[1], "./three.core.js").GreaterEqualCompare, 'greater-equal'), _$$_REQUIRE(_dependencyMap[1], "./three.core.js").AlwaysCompare, 'always'), _$$_REQUIRE(_dependencyMap[1], "./three.core.js").NotEqualCompare, 'not-equal');
  var _flipMap = [0, 1, 3, 2, 4, 5];
  var WebGPUTextureUtils = /*#__PURE__*/function () {
    function WebGPUTextureUtils(backend) {
      (0, _classCallCheck2.default)(this, WebGPUTextureUtils);
      this.backend = backend;
      this._passUtils = null;
      this.defaultTexture = {};
      this.defaultCubeTexture = {};
      this.defaultVideoFrame = null;
      this.colorBuffer = null;
      this.depthTexture = new (_$$_REQUIRE(_dependencyMap[1], "./three.core.js").DepthTexture)();
      this.depthTexture.name = 'depthBuffer';
    }
    return (0, _createClass2.default)(WebGPUTextureUtils, [{
      key: "createSampler",
      value: function createSampler(texture) {
        var backend = this.backend;
        var device = backend.device;
        var textureGPU = backend.get(texture);
        var samplerDescriptorGPU = {
          addressModeU: this._convertAddressMode(texture.wrapS),
          addressModeV: this._convertAddressMode(texture.wrapT),
          addressModeW: this._convertAddressMode(texture.wrapR),
          magFilter: this._convertFilterMode(texture.magFilter),
          minFilter: this._convertFilterMode(texture.minFilter),
          mipmapFilter: this._convertFilterMode(texture.minFilter),
          maxAnisotropy: 1
        };

        // anisotropy can only be used when all filter modes are set to linear.

        if (samplerDescriptorGPU.magFilter === GPUFilterMode.Linear && samplerDescriptorGPU.minFilter === GPUFilterMode.Linear && samplerDescriptorGPU.mipmapFilter === GPUFilterMode.Linear) {
          samplerDescriptorGPU.maxAnisotropy = texture.anisotropy;
        }
        if (texture.isDepthTexture && texture.compareFunction !== null) {
          samplerDescriptorGPU.compare = _compareToWebGPU[texture.compareFunction];
        }
        textureGPU.sampler = device.createSampler(samplerDescriptorGPU);
      }
    }, {
      key: "createDefaultTexture",
      value: function createDefaultTexture(texture) {
        var textureGPU;
        var format = getFormat(texture);
        if (texture.isCubeTexture) {
          textureGPU = this._getDefaultCubeTextureGPU(format);
        } else if (texture.isVideoTexture) {
          this.backend.get(texture).externalTexture = this._getDefaultVideoFrame();
        } else {
          textureGPU = this._getDefaultTextureGPU(format);
        }
        this.backend.get(texture).texture = textureGPU;
      }
    }, {
      key: "createTexture",
      value: function createTexture(texture) {
        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        var backend = this.backend;
        var textureData = backend.get(texture);
        if (textureData.initialized) {
          throw new Error('WebGPUTextureUtils: Texture already initialized.');
        }
        if (options.needsMipmaps === undefined) options.needsMipmaps = false;
        if (options.levels === undefined) options.levels = 1;
        if (options.depth === undefined) options.depth = 1;
        var width = options.width,
          height = options.height,
          depth = options.depth,
          levels = options.levels;
        if (texture.isFramebufferTexture) {
          if (options.renderTarget) {
            options.format = this.backend.utils.getCurrentColorFormat(options.renderTarget);
          } else {
            options.format = this.backend.utils.getPreferredCanvasFormat();
          }
        }
        var dimension = this._getDimension(texture);
        var format = texture.internalFormat || options.format || getFormat(texture, backend.device);
        textureData.format = format;
        var _backend$utils$getTex = backend.utils.getTextureSampleData(texture),
          samples = _backend$utils$getTex.samples,
          primarySamples = _backend$utils$getTex.primarySamples,
          isMSAA = _backend$utils$getTex.isMSAA;
        var usage = GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.COPY_SRC;
        if (texture.isStorageTexture === true) {
          usage |= GPUTextureUsage.STORAGE_BINDING;
        }
        if (texture.isCompressedTexture !== true && texture.isCompressedArrayTexture !== true) {
          usage |= GPUTextureUsage.RENDER_ATTACHMENT;
        }
        var textureDescriptorGPU = {
          label: texture.name,
          size: {
            width: width,
            height: height,
            depthOrArrayLayers: depth
          },
          mipLevelCount: levels,
          sampleCount: primarySamples,
          dimension: dimension,
          format: format,
          usage: usage
        };

        // texture creation

        if (texture.isVideoTexture) {
          var video = texture.source.data;
          var videoFrame = new VideoFrame(video);
          textureDescriptorGPU.size.width = videoFrame.displayWidth;
          textureDescriptorGPU.size.height = videoFrame.displayHeight;
          videoFrame.close();
          textureData.externalTexture = video;
        } else {
          if (format === undefined) {
            console.warn('WebGPURenderer: Texture format not supported.');
            return this.createDefaultTexture(texture);
          }
          textureData.texture = backend.device.createTexture(textureDescriptorGPU);
        }
        if (isMSAA) {
          var msaaTextureDescriptorGPU = Object.assign({}, textureDescriptorGPU);
          msaaTextureDescriptorGPU.label = msaaTextureDescriptorGPU.label + '-msaa';
          msaaTextureDescriptorGPU.sampleCount = samples;
          textureData.msaaTexture = backend.device.createTexture(msaaTextureDescriptorGPU);
        }
        textureData.initialized = true;
        textureData.textureDescriptorGPU = textureDescriptorGPU;
      }
    }, {
      key: "destroyTexture",
      value: function destroyTexture(texture) {
        var backend = this.backend;
        var textureData = backend.get(texture);
        if (textureData.texture !== undefined) textureData.texture.destroy();
        if (textureData.msaaTexture !== undefined) textureData.msaaTexture.destroy();
        backend.delete(texture);
      }
    }, {
      key: "destroySampler",
      value: function destroySampler(texture) {
        var backend = this.backend;
        var textureData = backend.get(texture);
        delete textureData.sampler;
      }
    }, {
      key: "generateMipmaps",
      value: function generateMipmaps(texture) {
        var textureData = this.backend.get(texture);
        if (texture.isCubeTexture) {
          for (var i = 0; i < 6; i++) {
            this._generateMipmaps(textureData.texture, textureData.textureDescriptorGPU, i);
          }
        } else {
          var _depth = texture.image.depth || 1;
          for (var _i21 = 0; _i21 < _depth; _i21++) {
            this._generateMipmaps(textureData.texture, textureData.textureDescriptorGPU, _i21);
          }
        }
      }
    }, {
      key: "getColorBuffer",
      value: function getColorBuffer() {
        if (this.colorBuffer) this.colorBuffer.destroy();
        var backend = this.backend;
        var _backend$getDrawingBu = backend.getDrawingBufferSize(),
          width = _backend$getDrawingBu.width,
          height = _backend$getDrawingBu.height;
        this.colorBuffer = backend.device.createTexture({
          label: 'colorBuffer',
          size: {
            width: width,
            height: height,
            depthOrArrayLayers: 1
          },
          sampleCount: backend.utils.getSampleCount(backend.renderer.samples),
          format: backend.utils.getPreferredCanvasFormat(),
          usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC
        });
        return this.colorBuffer;
      }
    }, {
      key: "getDepthBuffer",
      value: function getDepthBuffer() {
        var depth = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
        var stencil = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
        var backend = this.backend;
        var _backend$getDrawingBu2 = backend.getDrawingBufferSize(),
          width = _backend$getDrawingBu2.width,
          height = _backend$getDrawingBu2.height;
        var depthTexture = this.depthTexture;
        var depthTextureGPU = backend.get(depthTexture).texture;
        var format, type;
        if (stencil) {
          format = _$$_REQUIRE(_dependencyMap[1], "./three.core.js").DepthStencilFormat;
          type = _$$_REQUIRE(_dependencyMap[1], "./three.core.js").UnsignedInt248Type;
        } else if (depth) {
          format = _$$_REQUIRE(_dependencyMap[1], "./three.core.js").DepthFormat;
          type = _$$_REQUIRE(_dependencyMap[1], "./three.core.js").UnsignedIntType;
        }
        if (depthTextureGPU !== undefined) {
          if (depthTexture.image.width === width && depthTexture.image.height === height && depthTexture.format === format && depthTexture.type === type) {
            return depthTextureGPU;
          }
          this.destroyTexture(depthTexture);
        }
        depthTexture.name = 'depthBuffer';
        depthTexture.format = format;
        depthTexture.type = type;
        depthTexture.image.width = width;
        depthTexture.image.height = height;
        this.createTexture(depthTexture, {
          width: width,
          height: height
        });
        return backend.get(depthTexture).texture;
      }
    }, {
      key: "updateTexture",
      value: function updateTexture(texture, options) {
        var textureData = this.backend.get(texture);
        var textureDescriptorGPU = textureData.textureDescriptorGPU;
        if (texture.isRenderTargetTexture || textureDescriptorGPU === undefined /* unsupported texture format */) return;

        // transfer texture data

        if (texture.isDataTexture) {
          this._copyBufferToTexture(options.image, textureData.texture, textureDescriptorGPU, 0, texture.flipY);
        } else if (texture.isDataArrayTexture || texture.isData3DTexture) {
          for (var i = 0; i < options.image.depth; i++) {
            this._copyBufferToTexture(options.image, textureData.texture, textureDescriptorGPU, i, texture.flipY, i);
          }
        } else if (texture.isCompressedTexture || texture.isCompressedArrayTexture) {
          this._copyCompressedBufferToTexture(texture.mipmaps, textureData.texture, textureDescriptorGPU);
        } else if (texture.isCubeTexture) {
          this._copyCubeMapToTexture(options.images, textureData.texture, textureDescriptorGPU, texture.flipY);
        } else if (texture.isVideoTexture) {
          var video = texture.source.data;
          textureData.externalTexture = video;
        } else {
          this._copyImageToTexture(options.image, textureData.texture, textureDescriptorGPU, 0, texture.flipY);
        }

        //

        textureData.version = texture.version;
        if (texture.onUpdate) texture.onUpdate(texture);
      }
    }, {
      key: "copyTextureToBuffer",
      value: function () {
        var _copyTextureToBuffer2 = (0, _asyncToGenerator2.default)(function* (texture, x, y, width, height, faceIndex) {
          var device = this.backend.device;
          var textureData = this.backend.get(texture);
          var textureGPU = textureData.texture;
          var format = textureData.textureDescriptorGPU.format;
          var bytesPerTexel = this._getBytesPerTexel(format);
          var bytesPerRow = width * bytesPerTexel;
          bytesPerRow = Math.ceil(bytesPerRow / 256) * 256; // Align to 256 bytes

          var readBuffer = device.createBuffer({
            size: width * height * bytesPerTexel,
            usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ
          });
          var encoder = device.createCommandEncoder();
          encoder.copyTextureToBuffer({
            texture: textureGPU,
            origin: {
              x: x,
              y: y,
              z: faceIndex
            }
          }, {
            buffer: readBuffer,
            bytesPerRow: bytesPerRow
          }, {
            width: width,
            height: height
          });
          var typedArrayType = this._getTypedArrayType(format);
          device.queue.submit([encoder.finish()]);
          yield readBuffer.mapAsync(GPUMapMode.READ);
          var buffer = readBuffer.getMappedRange();
          return new typedArrayType(buffer);
        });
        function copyTextureToBuffer(_x37, _x38, _x39, _x40, _x41, _x42) {
          return _copyTextureToBuffer2.apply(this, arguments);
        }
        return copyTextureToBuffer;
      }()
    }, {
      key: "_isEnvironmentTexture",
      value: function _isEnvironmentTexture(texture) {
        var mapping = texture.mapping;
        return mapping === _$$_REQUIRE(_dependencyMap[1], "./three.core.js").EquirectangularReflectionMapping || mapping === _$$_REQUIRE(_dependencyMap[1], "./three.core.js").EquirectangularRefractionMapping || mapping === _$$_REQUIRE(_dependencyMap[1], "./three.core.js").CubeReflectionMapping || mapping === _$$_REQUIRE(_dependencyMap[1], "./three.core.js").CubeRefractionMapping;
      }
    }, {
      key: "_getDefaultTextureGPU",
      value: function _getDefaultTextureGPU(format) {
        var defaultTexture = this.defaultTexture[format];
        if (defaultTexture === undefined) {
          var _texture10 = new (_$$_REQUIRE(_dependencyMap[1], "./three.core.js").Texture)();
          _texture10.minFilter = _$$_REQUIRE(_dependencyMap[1], "./three.core.js").NearestFilter;
          _texture10.magFilter = _$$_REQUIRE(_dependencyMap[1], "./three.core.js").NearestFilter;
          this.createTexture(_texture10, {
            width: 1,
            height: 1,
            format: format
          });
          this.defaultTexture[format] = defaultTexture = _texture10;
        }
        return this.backend.get(defaultTexture).texture;
      }
    }, {
      key: "_getDefaultCubeTextureGPU",
      value: function _getDefaultCubeTextureGPU(format) {
        var defaultCubeTexture = this.defaultTexture[format];
        if (defaultCubeTexture === undefined) {
          var _texture11 = new (_$$_REQUIRE(_dependencyMap[1], "./three.core.js").CubeTexture)();
          _texture11.minFilter = _$$_REQUIRE(_dependencyMap[1], "./three.core.js").NearestFilter;
          _texture11.magFilter = _$$_REQUIRE(_dependencyMap[1], "./three.core.js").NearestFilter;
          this.createTexture(_texture11, {
            width: 1,
            height: 1,
            depth: 6
          });
          this.defaultCubeTexture[format] = defaultCubeTexture = _texture11;
        }
        return this.backend.get(defaultCubeTexture).texture;
      }
    }, {
      key: "_getDefaultVideoFrame",
      value: function _getDefaultVideoFrame() {
        var defaultVideoFrame = this.defaultVideoFrame;
        if (defaultVideoFrame === null) {
          var init = {
            timestamp: 0,
            codedWidth: 1,
            codedHeight: 1,
            format: 'RGBA'
          };
          this.defaultVideoFrame = defaultVideoFrame = new VideoFrame(new Uint8Array([0, 0, 0, 0xff]), init);
        }
        return defaultVideoFrame;
      }
    }, {
      key: "_copyCubeMapToTexture",
      value: function _copyCubeMapToTexture(images, textureGPU, textureDescriptorGPU, flipY) {
        for (var i = 0; i < 6; i++) {
          var image = images[i];
          var flipIndex = flipY === true ? _flipMap[i] : i;
          if (image.isDataTexture) {
            this._copyBufferToTexture(image.image, textureGPU, textureDescriptorGPU, flipIndex, flipY);
          } else {
            this._copyImageToTexture(image, textureGPU, textureDescriptorGPU, flipIndex, flipY);
          }
        }
      }
    }, {
      key: "_copyImageToTexture",
      value: function _copyImageToTexture(image, textureGPU, textureDescriptorGPU, originDepth, flipY) {
        var device = this.backend.device;
        device.queue.copyExternalImageToTexture({
          source: image
        }, {
          texture: textureGPU,
          mipLevel: 0,
          origin: {
            x: 0,
            y: 0,
            z: originDepth
          }
        }, {
          width: image.width,
          height: image.height,
          depthOrArrayLayers: 1
        });
        if (flipY === true) {
          this._flipY(textureGPU, textureDescriptorGPU, originDepth);
        }
      }
    }, {
      key: "_getPassUtils",
      value: function _getPassUtils() {
        var passUtils = this._passUtils;
        if (passUtils === null) {
          this._passUtils = passUtils = new WebGPUTexturePassUtils(this.backend.device);
        }
        return passUtils;
      }
    }, {
      key: "_generateMipmaps",
      value: function _generateMipmaps(textureGPU, textureDescriptorGPU) {
        var baseArrayLayer = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
        this._getPassUtils().generateMipmaps(textureGPU, textureDescriptorGPU, baseArrayLayer);
      }
    }, {
      key: "_flipY",
      value: function _flipY(textureGPU, textureDescriptorGPU) {
        var originDepth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
        this._getPassUtils().flipY(textureGPU, textureDescriptorGPU, originDepth);
      }
    }, {
      key: "_copyBufferToTexture",
      value: function _copyBufferToTexture(image, textureGPU, textureDescriptorGPU, originDepth, flipY) {
        var depth = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;
        // @TODO: Consider to use GPUCommandEncoder.copyBufferToTexture()
        // @TODO: Consider to support valid buffer layouts with other formats like RGB

        var device = this.backend.device;
        var data = image.data;
        var bytesPerTexel = this._getBytesPerTexel(textureDescriptorGPU.format);
        var bytesPerRow = image.width * bytesPerTexel;
        device.queue.writeTexture({
          texture: textureGPU,
          mipLevel: 0,
          origin: {
            x: 0,
            y: 0,
            z: originDepth
          }
        }, data, {
          offset: image.width * image.height * bytesPerTexel * depth,
          bytesPerRow: bytesPerRow
        }, {
          width: image.width,
          height: image.height,
          depthOrArrayLayers: 1
        });
        if (flipY === true) {
          this._flipY(textureGPU, textureDescriptorGPU, originDepth);
        }
      }
    }, {
      key: "_copyCompressedBufferToTexture",
      value: function _copyCompressedBufferToTexture(mipmaps, textureGPU, textureDescriptorGPU) {
        // @TODO: Consider to use GPUCommandEncoder.copyBufferToTexture()

        var device = this.backend.device;
        var blockData = this._getBlockData(textureDescriptorGPU.format);
        var isTextureArray = textureDescriptorGPU.size.depthOrArrayLayers > 1;
        for (var i = 0; i < mipmaps.length; i++) {
          var mipmap = mipmaps[i];
          var width = mipmap.width;
          var height = mipmap.height;
          var _depth2 = isTextureArray ? textureDescriptorGPU.size.depthOrArrayLayers : 1;
          var bytesPerRow = Math.ceil(width / blockData.width) * blockData.byteLength;
          var bytesPerImage = bytesPerRow * Math.ceil(height / blockData.height);
          for (var j = 0; j < _depth2; j++) {
            device.queue.writeTexture({
              texture: textureGPU,
              mipLevel: i,
              origin: {
                x: 0,
                y: 0,
                z: j
              }
            }, mipmap.data, {
              offset: j * bytesPerImage,
              bytesPerRow: bytesPerRow,
              rowsPerImage: Math.ceil(height / blockData.height)
            }, {
              width: Math.ceil(width / blockData.width) * blockData.width,
              height: Math.ceil(height / blockData.height) * blockData.height,
              depthOrArrayLayers: 1
            });
          }
        }
      }
    }, {
      key: "_getBlockData",
      value: function _getBlockData(format) {
        // this method is only relevant for compressed texture formats

        if (format === GPUTextureFormat.BC1RGBAUnorm || format === GPUTextureFormat.BC1RGBAUnormSRGB) return {
          byteLength: 8,
          width: 4,
          height: 4
        }; // DXT1
        if (format === GPUTextureFormat.BC2RGBAUnorm || format === GPUTextureFormat.BC2RGBAUnormSRGB) return {
          byteLength: 16,
          width: 4,
          height: 4
        }; // DXT3
        if (format === GPUTextureFormat.BC3RGBAUnorm || format === GPUTextureFormat.BC3RGBAUnormSRGB) return {
          byteLength: 16,
          width: 4,
          height: 4
        }; // DXT5
        if (format === GPUTextureFormat.BC4RUnorm || format === GPUTextureFormat.BC4RSNorm) return {
          byteLength: 8,
          width: 4,
          height: 4
        }; // RGTC1
        if (format === GPUTextureFormat.BC5RGUnorm || format === GPUTextureFormat.BC5RGSnorm) return {
          byteLength: 16,
          width: 4,
          height: 4
        }; // RGTC2
        if (format === GPUTextureFormat.BC6HRGBUFloat || format === GPUTextureFormat.BC6HRGBFloat) return {
          byteLength: 16,
          width: 4,
          height: 4
        }; // BPTC (float)
        if (format === GPUTextureFormat.BC7RGBAUnorm || format === GPUTextureFormat.BC7RGBAUnormSRGB) return {
          byteLength: 16,
          width: 4,
          height: 4
        }; // BPTC (unorm)

        if (format === GPUTextureFormat.ETC2RGB8Unorm || format === GPUTextureFormat.ETC2RGB8UnormSRGB) return {
          byteLength: 8,
          width: 4,
          height: 4
        };
        if (format === GPUTextureFormat.ETC2RGB8A1Unorm || format === GPUTextureFormat.ETC2RGB8A1UnormSRGB) return {
          byteLength: 8,
          width: 4,
          height: 4
        };
        if (format === GPUTextureFormat.ETC2RGBA8Unorm || format === GPUTextureFormat.ETC2RGBA8UnormSRGB) return {
          byteLength: 16,
          width: 4,
          height: 4
        };
        if (format === GPUTextureFormat.EACR11Unorm) return {
          byteLength: 8,
          width: 4,
          height: 4
        };
        if (format === GPUTextureFormat.EACR11Snorm) return {
          byteLength: 8,
          width: 4,
          height: 4
        };
        if (format === GPUTextureFormat.EACRG11Unorm) return {
          byteLength: 16,
          width: 4,
          height: 4
        };
        if (format === GPUTextureFormat.EACRG11Snorm) return {
          byteLength: 16,
          width: 4,
          height: 4
        };
        if (format === GPUTextureFormat.ASTC4x4Unorm || format === GPUTextureFormat.ASTC4x4UnormSRGB) return {
          byteLength: 16,
          width: 4,
          height: 4
        };
        if (format === GPUTextureFormat.ASTC5x4Unorm || format === GPUTextureFormat.ASTC5x4UnormSRGB) return {
          byteLength: 16,
          width: 5,
          height: 4
        };
        if (format === GPUTextureFormat.ASTC5x5Unorm || format === GPUTextureFormat.ASTC5x5UnormSRGB) return {
          byteLength: 16,
          width: 5,
          height: 5
        };
        if (format === GPUTextureFormat.ASTC6x5Unorm || format === GPUTextureFormat.ASTC6x5UnormSRGB) return {
          byteLength: 16,
          width: 6,
          height: 5
        };
        if (format === GPUTextureFormat.ASTC6x6Unorm || format === GPUTextureFormat.ASTC6x6UnormSRGB) return {
          byteLength: 16,
          width: 6,
          height: 6
        };
        if (format === GPUTextureFormat.ASTC8x5Unorm || format === GPUTextureFormat.ASTC8x5UnormSRGB) return {
          byteLength: 16,
          width: 8,
          height: 5
        };
        if (format === GPUTextureFormat.ASTC8x6Unorm || format === GPUTextureFormat.ASTC8x6UnormSRGB) return {
          byteLength: 16,
          width: 8,
          height: 6
        };
        if (format === GPUTextureFormat.ASTC8x8Unorm || format === GPUTextureFormat.ASTC8x8UnormSRGB) return {
          byteLength: 16,
          width: 8,
          height: 8
        };
        if (format === GPUTextureFormat.ASTC10x5Unorm || format === GPUTextureFormat.ASTC10x5UnormSRGB) return {
          byteLength: 16,
          width: 10,
          height: 5
        };
        if (format === GPUTextureFormat.ASTC10x6Unorm || format === GPUTextureFormat.ASTC10x6UnormSRGB) return {
          byteLength: 16,
          width: 10,
          height: 6
        };
        if (format === GPUTextureFormat.ASTC10x8Unorm || format === GPUTextureFormat.ASTC10x8UnormSRGB) return {
          byteLength: 16,
          width: 10,
          height: 8
        };
        if (format === GPUTextureFormat.ASTC10x10Unorm || format === GPUTextureFormat.ASTC10x10UnormSRGB) return {
          byteLength: 16,
          width: 10,
          height: 10
        };
        if (format === GPUTextureFormat.ASTC12x10Unorm || format === GPUTextureFormat.ASTC12x10UnormSRGB) return {
          byteLength: 16,
          width: 12,
          height: 10
        };
        if (format === GPUTextureFormat.ASTC12x12Unorm || format === GPUTextureFormat.ASTC12x12UnormSRGB) return {
          byteLength: 16,
          width: 12,
          height: 12
        };
      }
    }, {
      key: "_convertAddressMode",
      value: function _convertAddressMode(value) {
        var addressMode = GPUAddressMode.ClampToEdge;
        if (value === _$$_REQUIRE(_dependencyMap[1], "./three.core.js").RepeatWrapping) {
          addressMode = GPUAddressMode.Repeat;
        } else if (value === _$$_REQUIRE(_dependencyMap[1], "./three.core.js").MirroredRepeatWrapping) {
          addressMode = GPUAddressMode.MirrorRepeat;
        }
        return addressMode;
      }
    }, {
      key: "_convertFilterMode",
      value: function _convertFilterMode(value) {
        var filterMode = GPUFilterMode.Linear;
        if (value === _$$_REQUIRE(_dependencyMap[1], "./three.core.js").NearestFilter || value === _$$_REQUIRE(_dependencyMap[1], "./three.core.js").NearestMipmapNearestFilter || value === _$$_REQUIRE(_dependencyMap[1], "./three.core.js").NearestMipmapLinearFilter) {
          filterMode = GPUFilterMode.Nearest;
        }
        return filterMode;
      }
    }, {
      key: "_getBytesPerTexel",
      value: function _getBytesPerTexel(format) {
        // 8-bit formats
        if (format === GPUTextureFormat.R8Unorm || format === GPUTextureFormat.R8Snorm || format === GPUTextureFormat.R8Uint || format === GPUTextureFormat.R8Sint) return 1;

        // 16-bit formats
        if (format === GPUTextureFormat.R16Uint || format === GPUTextureFormat.R16Sint || format === GPUTextureFormat.R16Float || format === GPUTextureFormat.RG8Unorm || format === GPUTextureFormat.RG8Snorm || format === GPUTextureFormat.RG8Uint || format === GPUTextureFormat.RG8Sint) return 2;

        // 32-bit formats
        if (format === GPUTextureFormat.R32Uint || format === GPUTextureFormat.R32Sint || format === GPUTextureFormat.R32Float || format === GPUTextureFormat.RG16Uint || format === GPUTextureFormat.RG16Sint || format === GPUTextureFormat.RG16Float || format === GPUTextureFormat.RGBA8Unorm || format === GPUTextureFormat.RGBA8UnormSRGB || format === GPUTextureFormat.RGBA8Snorm || format === GPUTextureFormat.RGBA8Uint || format === GPUTextureFormat.RGBA8Sint || format === GPUTextureFormat.BGRA8Unorm || format === GPUTextureFormat.BGRA8UnormSRGB ||
        // Packed 32-bit formats
        format === GPUTextureFormat.RGB9E5UFloat || format === GPUTextureFormat.RGB10A2Unorm || format === GPUTextureFormat.RG11B10UFloat || format === GPUTextureFormat.Depth32Float || format === GPUTextureFormat.Depth24Plus || format === GPUTextureFormat.Depth24PlusStencil8 || format === GPUTextureFormat.Depth32FloatStencil8) return 4;

        // 64-bit formats
        if (format === GPUTextureFormat.RG32Uint || format === GPUTextureFormat.RG32Sint || format === GPUTextureFormat.RG32Float || format === GPUTextureFormat.RGBA16Uint || format === GPUTextureFormat.RGBA16Sint || format === GPUTextureFormat.RGBA16Float) return 8;

        // 128-bit formats
        if (format === GPUTextureFormat.RGBA32Uint || format === GPUTextureFormat.RGBA32Sint || format === GPUTextureFormat.RGBA32Float) return 16;
      }
    }, {
      key: "_getTypedArrayType",
      value: function _getTypedArrayType(format) {
        if (format === GPUTextureFormat.R8Uint) return Uint8Array;
        if (format === GPUTextureFormat.R8Sint) return Int8Array;
        if (format === GPUTextureFormat.R8Unorm) return Uint8Array;
        if (format === GPUTextureFormat.R8Snorm) return Int8Array;
        if (format === GPUTextureFormat.RG8Uint) return Uint8Array;
        if (format === GPUTextureFormat.RG8Sint) return Int8Array;
        if (format === GPUTextureFormat.RG8Unorm) return Uint8Array;
        if (format === GPUTextureFormat.RG8Snorm) return Int8Array;
        if (format === GPUTextureFormat.RGBA8Uint) return Uint8Array;
        if (format === GPUTextureFormat.RGBA8Sint) return Int8Array;
        if (format === GPUTextureFormat.RGBA8Unorm) return Uint8Array;
        if (format === GPUTextureFormat.RGBA8Snorm) return Int8Array;
        if (format === GPUTextureFormat.R16Uint) return Uint16Array;
        if (format === GPUTextureFormat.R16Sint) return Int16Array;
        if (format === GPUTextureFormat.RG16Uint) return Uint16Array;
        if (format === GPUTextureFormat.RG16Sint) return Int16Array;
        if (format === GPUTextureFormat.RGBA16Uint) return Uint16Array;
        if (format === GPUTextureFormat.RGBA16Sint) return Int16Array;
        if (format === GPUTextureFormat.R16Float) return Uint16Array;
        if (format === GPUTextureFormat.RG16Float) return Uint16Array;
        if (format === GPUTextureFormat.RGBA16Float) return Uint16Array;
        if (format === GPUTextureFormat.R32Uint) return Uint32Array;
        if (format === GPUTextureFormat.R32Sint) return Int32Array;
        if (format === GPUTextureFormat.R32Float) return Float32Array;
        if (format === GPUTextureFormat.RG32Uint) return Uint32Array;
        if (format === GPUTextureFormat.RG32Sint) return Int32Array;
        if (format === GPUTextureFormat.RG32Float) return Float32Array;
        if (format === GPUTextureFormat.RGBA32Uint) return Uint32Array;
        if (format === GPUTextureFormat.RGBA32Sint) return Int32Array;
        if (format === GPUTextureFormat.RGBA32Float) return Float32Array;
        if (format === GPUTextureFormat.BGRA8Unorm) return Uint8Array;
        if (format === GPUTextureFormat.BGRA8UnormSRGB) return Uint8Array;
        if (format === GPUTextureFormat.RGB10A2Unorm) return Uint32Array;
        if (format === GPUTextureFormat.RGB9E5UFloat) return Uint32Array;
        if (format === GPUTextureFormat.RG11B10UFloat) return Uint32Array;
        if (format === GPUTextureFormat.Depth32Float) return Float32Array;
        if (format === GPUTextureFormat.Depth24Plus) return Uint32Array;
        if (format === GPUTextureFormat.Depth24PlusStencil8) return Uint32Array;
        if (format === GPUTextureFormat.Depth32FloatStencil8) return Float32Array;
      }
    }, {
      key: "_getDimension",
      value: function _getDimension(texture) {
        var dimension;
        if (texture.isData3DTexture) {
          dimension = GPUTextureDimension.ThreeD;
        } else {
          dimension = GPUTextureDimension.TwoD;
        }
        return dimension;
      }
    }]);
  }();
  function getFormat(texture) {
    var device = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    var format = texture.format;
    var type = texture.type;
    var colorSpace = texture.colorSpace;
    var formatGPU;
    if (texture.isCompressedTexture === true || texture.isCompressedArrayTexture === true) {
      switch (format) {
        case _$$_REQUIRE(_dependencyMap[1], "./three.core.js").RGBA_S3TC_DXT1_Format:
          formatGPU = colorSpace === _$$_REQUIRE(_dependencyMap[1], "./three.core.js").SRGBColorSpace ? GPUTextureFormat.BC1RGBAUnormSRGB : GPUTextureFormat.BC1RGBAUnorm;
          break;
        case _$$_REQUIRE(_dependencyMap[1], "./three.core.js").RGBA_S3TC_DXT3_Format:
          formatGPU = colorSpace === _$$_REQUIRE(_dependencyMap[1], "./three.core.js").SRGBColorSpace ? GPUTextureFormat.BC2RGBAUnormSRGB : GPUTextureFormat.BC2RGBAUnorm;
          break;
        case _$$_REQUIRE(_dependencyMap[1], "./three.core.js").RGBA_S3TC_DXT5_Format:
          formatGPU = colorSpace === _$$_REQUIRE(_dependencyMap[1], "./three.core.js").SRGBColorSpace ? GPUTextureFormat.BC3RGBAUnormSRGB : GPUTextureFormat.BC3RGBAUnorm;
          break;
        case _$$_REQUIRE(_dependencyMap[1], "./three.core.js").RGB_ETC2_Format:
          formatGPU = colorSpace === _$$_REQUIRE(_dependencyMap[1], "./three.core.js").SRGBColorSpace ? GPUTextureFormat.ETC2RGB8UnormSRGB : GPUTextureFormat.ETC2RGB8Unorm;
          break;
        case _$$_REQUIRE(_dependencyMap[1], "./three.core.js").RGBA_ETC2_EAC_Format:
          formatGPU = colorSpace === _$$_REQUIRE(_dependencyMap[1], "./three.core.js").SRGBColorSpace ? GPUTextureFormat.ETC2RGBA8UnormSRGB : GPUTextureFormat.ETC2RGBA8Unorm;
          break;
        case _$$_REQUIRE(_dependencyMap[1], "./three.core.js").RGBA_ASTC_4x4_Format:
          formatGPU = colorSpace === _$$_REQUIRE(_dependencyMap[1], "./three.core.js").SRGBColorSpace ? GPUTextureFormat.ASTC4x4UnormSRGB : GPUTextureFormat.ASTC4x4Unorm;
          break;
        case _$$_REQUIRE(_dependencyMap[1], "./three.core.js").RGBA_ASTC_5x4_Format:
          formatGPU = colorSpace === _$$_REQUIRE(_dependencyMap[1], "./three.core.js").SRGBColorSpace ? GPUTextureFormat.ASTC5x4UnormSRGB : GPUTextureFormat.ASTC5x4Unorm;
          break;
        case _$$_REQUIRE(_dependencyMap[1], "./three.core.js").RGBA_ASTC_5x5_Format:
          formatGPU = colorSpace === _$$_REQUIRE(_dependencyMap[1], "./three.core.js").SRGBColorSpace ? GPUTextureFormat.ASTC5x5UnormSRGB : GPUTextureFormat.ASTC5x5Unorm;
          break;
        case _$$_REQUIRE(_dependencyMap[1], "./three.core.js").RGBA_ASTC_6x5_Format:
          formatGPU = colorSpace === _$$_REQUIRE(_dependencyMap[1], "./three.core.js").SRGBColorSpace ? GPUTextureFormat.ASTC6x5UnormSRGB : GPUTextureFormat.ASTC6x5Unorm;
          break;
        case _$$_REQUIRE(_dependencyMap[1], "./three.core.js").RGBA_ASTC_6x6_Format:
          formatGPU = colorSpace === _$$_REQUIRE(_dependencyMap[1], "./three.core.js").SRGBColorSpace ? GPUTextureFormat.ASTC6x6UnormSRGB : GPUTextureFormat.ASTC6x6Unorm;
          break;
        case _$$_REQUIRE(_dependencyMap[1], "./three.core.js").RGBA_ASTC_8x5_Format:
          formatGPU = colorSpace === _$$_REQUIRE(_dependencyMap[1], "./three.core.js").SRGBColorSpace ? GPUTextureFormat.ASTC8x5UnormSRGB : GPUTextureFormat.ASTC8x5Unorm;
          break;
        case _$$_REQUIRE(_dependencyMap[1], "./three.core.js").RGBA_ASTC_8x6_Format:
          formatGPU = colorSpace === _$$_REQUIRE(_dependencyMap[1], "./three.core.js").SRGBColorSpace ? GPUTextureFormat.ASTC8x6UnormSRGB : GPUTextureFormat.ASTC8x6Unorm;
          break;
        case _$$_REQUIRE(_dependencyMap[1], "./three.core.js").RGBA_ASTC_8x8_Format:
          formatGPU = colorSpace === _$$_REQUIRE(_dependencyMap[1], "./three.core.js").SRGBColorSpace ? GPUTextureFormat.ASTC8x8UnormSRGB : GPUTextureFormat.ASTC8x8Unorm;
          break;
        case _$$_REQUIRE(_dependencyMap[1], "./three.core.js").RGBA_ASTC_10x5_Format:
          formatGPU = colorSpace === _$$_REQUIRE(_dependencyMap[1], "./three.core.js").SRGBColorSpace ? GPUTextureFormat.ASTC10x5UnormSRGB : GPUTextureFormat.ASTC10x5Unorm;
          break;
        case _$$_REQUIRE(_dependencyMap[1], "./three.core.js").RGBA_ASTC_10x6_Format:
          formatGPU = colorSpace === _$$_REQUIRE(_dependencyMap[1], "./three.core.js").SRGBColorSpace ? GPUTextureFormat.ASTC10x6UnormSRGB : GPUTextureFormat.ASTC10x6Unorm;
          break;
        case _$$_REQUIRE(_dependencyMap[1], "./three.core.js").RGBA_ASTC_10x8_Format:
          formatGPU = colorSpace === _$$_REQUIRE(_dependencyMap[1], "./three.core.js").SRGBColorSpace ? GPUTextureFormat.ASTC10x8UnormSRGB : GPUTextureFormat.ASTC10x8Unorm;
          break;
        case _$$_REQUIRE(_dependencyMap[1], "./three.core.js").RGBA_ASTC_10x10_Format:
          formatGPU = colorSpace === _$$_REQUIRE(_dependencyMap[1], "./three.core.js").SRGBColorSpace ? GPUTextureFormat.ASTC10x10UnormSRGB : GPUTextureFormat.ASTC10x10Unorm;
          break;
        case _$$_REQUIRE(_dependencyMap[1], "./three.core.js").RGBA_ASTC_12x10_Format:
          formatGPU = colorSpace === _$$_REQUIRE(_dependencyMap[1], "./three.core.js").SRGBColorSpace ? GPUTextureFormat.ASTC12x10UnormSRGB : GPUTextureFormat.ASTC12x10Unorm;
          break;
        case _$$_REQUIRE(_dependencyMap[1], "./three.core.js").RGBA_ASTC_12x12_Format:
          formatGPU = colorSpace === _$$_REQUIRE(_dependencyMap[1], "./three.core.js").SRGBColorSpace ? GPUTextureFormat.ASTC12x12UnormSRGB : GPUTextureFormat.ASTC12x12Unorm;
          break;
        case _$$_REQUIRE(_dependencyMap[1], "./three.core.js").RGBAFormat:
          formatGPU = colorSpace === _$$_REQUIRE(_dependencyMap[1], "./three.core.js").SRGBColorSpace ? GPUTextureFormat.RGBA8UnormSRGB : GPUTextureFormat.RGBA8Unorm;
          break;
        default:
          console.error('WebGPURenderer: Unsupported texture format.', format);
      }
    } else {
      switch (format) {
        case _$$_REQUIRE(_dependencyMap[1], "./three.core.js").RGBAFormat:
          switch (type) {
            case _$$_REQUIRE(_dependencyMap[1], "./three.core.js").ByteType:
              formatGPU = GPUTextureFormat.RGBA8Snorm;
              break;
            case _$$_REQUIRE(_dependencyMap[1], "./three.core.js").ShortType:
              formatGPU = GPUTextureFormat.RGBA16Sint;
              break;
            case _$$_REQUIRE(_dependencyMap[1], "./three.core.js").UnsignedShortType:
              formatGPU = GPUTextureFormat.RGBA16Uint;
              break;
            case _$$_REQUIRE(_dependencyMap[1], "./three.core.js").UnsignedIntType:
              formatGPU = GPUTextureFormat.RGBA32Uint;
              break;
            case _$$_REQUIRE(_dependencyMap[1], "./three.core.js").IntType:
              formatGPU = GPUTextureFormat.RGBA32Sint;
              break;
            case _$$_REQUIRE(_dependencyMap[1], "./three.core.js").UnsignedByteType:
              formatGPU = colorSpace === _$$_REQUIRE(_dependencyMap[1], "./three.core.js").SRGBColorSpace ? GPUTextureFormat.RGBA8UnormSRGB : GPUTextureFormat.RGBA8Unorm;
              break;
            case _$$_REQUIRE(_dependencyMap[1], "./three.core.js").HalfFloatType:
              formatGPU = GPUTextureFormat.RGBA16Float;
              break;
            case _$$_REQUIRE(_dependencyMap[1], "./three.core.js").FloatType:
              formatGPU = GPUTextureFormat.RGBA32Float;
              break;
            default:
              console.error('WebGPURenderer: Unsupported texture type with RGBAFormat.', type);
          }
          break;
        case _$$_REQUIRE(_dependencyMap[1], "./three.core.js").RGBFormat:
          switch (type) {
            case _$$_REQUIRE(_dependencyMap[1], "./three.core.js").UnsignedInt5999Type:
              formatGPU = GPUTextureFormat.RGB9E5UFloat;
              break;
            default:
              console.error('WebGPURenderer: Unsupported texture type with RGBFormat.', type);
          }
          break;
        case _$$_REQUIRE(_dependencyMap[1], "./three.core.js").RedFormat:
          switch (type) {
            case _$$_REQUIRE(_dependencyMap[1], "./three.core.js").ByteType:
              formatGPU = GPUTextureFormat.R8Snorm;
              break;
            case _$$_REQUIRE(_dependencyMap[1], "./three.core.js").ShortType:
              formatGPU = GPUTextureFormat.R16Sint;
              break;
            case _$$_REQUIRE(_dependencyMap[1], "./three.core.js").UnsignedShortType:
              formatGPU = GPUTextureFormat.R16Uint;
              break;
            case _$$_REQUIRE(_dependencyMap[1], "./three.core.js").UnsignedIntType:
              formatGPU = GPUTextureFormat.R32Uint;
              break;
            case _$$_REQUIRE(_dependencyMap[1], "./three.core.js").IntType:
              formatGPU = GPUTextureFormat.R32Sint;
              break;
            case _$$_REQUIRE(_dependencyMap[1], "./three.core.js").UnsignedByteType:
              formatGPU = GPUTextureFormat.R8Unorm;
              break;
            case _$$_REQUIRE(_dependencyMap[1], "./three.core.js").HalfFloatType:
              formatGPU = GPUTextureFormat.R16Float;
              break;
            case _$$_REQUIRE(_dependencyMap[1], "./three.core.js").FloatType:
              formatGPU = GPUTextureFormat.R32Float;
              break;
            default:
              console.error('WebGPURenderer: Unsupported texture type with RedFormat.', type);
          }
          break;
        case _$$_REQUIRE(_dependencyMap[1], "./three.core.js").RGFormat:
          switch (type) {
            case _$$_REQUIRE(_dependencyMap[1], "./three.core.js").ByteType:
              formatGPU = GPUTextureFormat.RG8Snorm;
              break;
            case _$$_REQUIRE(_dependencyMap[1], "./three.core.js").ShortType:
              formatGPU = GPUTextureFormat.RG16Sint;
              break;
            case _$$_REQUIRE(_dependencyMap[1], "./three.core.js").UnsignedShortType:
              formatGPU = GPUTextureFormat.RG16Uint;
              break;
            case _$$_REQUIRE(_dependencyMap[1], "./three.core.js").UnsignedIntType:
              formatGPU = GPUTextureFormat.RG32Uint;
              break;
            case _$$_REQUIRE(_dependencyMap[1], "./three.core.js").IntType:
              formatGPU = GPUTextureFormat.RG32Sint;
              break;
            case _$$_REQUIRE(_dependencyMap[1], "./three.core.js").UnsignedByteType:
              formatGPU = GPUTextureFormat.RG8Unorm;
              break;
            case _$$_REQUIRE(_dependencyMap[1], "./three.core.js").HalfFloatType:
              formatGPU = GPUTextureFormat.RG16Float;
              break;
            case _$$_REQUIRE(_dependencyMap[1], "./three.core.js").FloatType:
              formatGPU = GPUTextureFormat.RG32Float;
              break;
            default:
              console.error('WebGPURenderer: Unsupported texture type with RGFormat.', type);
          }
          break;
        case _$$_REQUIRE(_dependencyMap[1], "./three.core.js").DepthFormat:
          switch (type) {
            case _$$_REQUIRE(_dependencyMap[1], "./three.core.js").UnsignedShortType:
              formatGPU = GPUTextureFormat.Depth16Unorm;
              break;
            case _$$_REQUIRE(_dependencyMap[1], "./three.core.js").UnsignedIntType:
              formatGPU = GPUTextureFormat.Depth24Plus;
              break;
            case _$$_REQUIRE(_dependencyMap[1], "./three.core.js").FloatType:
              formatGPU = GPUTextureFormat.Depth32Float;
              break;
            default:
              console.error('WebGPURenderer: Unsupported texture type with DepthFormat.', type);
          }
          break;
        case _$$_REQUIRE(_dependencyMap[1], "./three.core.js").DepthStencilFormat:
          switch (type) {
            case _$$_REQUIRE(_dependencyMap[1], "./three.core.js").UnsignedInt248Type:
              formatGPU = GPUTextureFormat.Depth24PlusStencil8;
              break;
            case _$$_REQUIRE(_dependencyMap[1], "./three.core.js").FloatType:
              if (device && device.features.has(GPUFeatureName.Depth32FloatStencil8) === false) {
                console.error('WebGPURenderer: Depth textures with DepthStencilFormat + FloatType can only be used with the "depth32float-stencil8" GPU feature.');
              }
              formatGPU = GPUTextureFormat.Depth32FloatStencil8;
              break;
            default:
              console.error('WebGPURenderer: Unsupported texture type with DepthStencilFormat.', type);
          }
          break;
        case _$$_REQUIRE(_dependencyMap[1], "./three.core.js").RedIntegerFormat:
          switch (type) {
            case _$$_REQUIRE(_dependencyMap[1], "./three.core.js").IntType:
              formatGPU = GPUTextureFormat.R32Sint;
              break;
            case _$$_REQUIRE(_dependencyMap[1], "./three.core.js").UnsignedIntType:
              formatGPU = GPUTextureFormat.R32Uint;
              break;
            default:
              console.error('WebGPURenderer: Unsupported texture type with RedIntegerFormat.', type);
          }
          break;
        case _$$_REQUIRE(_dependencyMap[1], "./three.core.js").RGIntegerFormat:
          switch (type) {
            case _$$_REQUIRE(_dependencyMap[1], "./three.core.js").IntType:
              formatGPU = GPUTextureFormat.RG32Sint;
              break;
            case _$$_REQUIRE(_dependencyMap[1], "./three.core.js").UnsignedIntType:
              formatGPU = GPUTextureFormat.RG32Uint;
              break;
            default:
              console.error('WebGPURenderer: Unsupported texture type with RGIntegerFormat.', type);
          }
          break;
        case _$$_REQUIRE(_dependencyMap[1], "./three.core.js").RGBAIntegerFormat:
          switch (type) {
            case _$$_REQUIRE(_dependencyMap[1], "./three.core.js").IntType:
              formatGPU = GPUTextureFormat.RGBA32Sint;
              break;
            case _$$_REQUIRE(_dependencyMap[1], "./three.core.js").UnsignedIntType:
              formatGPU = GPUTextureFormat.RGBA32Uint;
              break;
            default:
              console.error('WebGPURenderer: Unsupported texture type with RGBAIntegerFormat.', type);
          }
          break;
        default:
          console.error('WebGPURenderer: Unsupported texture format.', format);
      }
    }
    return formatGPU;
  }
  var declarationRegexp = /^[fn]*\s*([a-z_0-9]+)?\s*\(([\s\S]*?)\)\s*[\-\>]*\s*([a-z_0-9]+(?:<[\s\S]+?>)?)/i;
  var propertiesRegexp = /([a-z_0-9]+)\s*:\s*([a-z_0-9]+(?:<[\s\S]+?>)?)/ig;
  var wgslTypeLib$1 = {
    'f32': 'float',
    'i32': 'int',
    'u32': 'uint',
    'bool': 'bool',
    'vec2<f32>': 'vec2',
    'vec2<i32>': 'ivec2',
    'vec2<u32>': 'uvec2',
    'vec2<bool>': 'bvec2',
    'vec2f': 'vec2',
    'vec2i': 'ivec2',
    'vec2u': 'uvec2',
    'vec2b': 'bvec2',
    'vec3<f32>': 'vec3',
    'vec3<i32>': 'ivec3',
    'vec3<u32>': 'uvec3',
    'vec3<bool>': 'bvec3',
    'vec3f': 'vec3',
    'vec3i': 'ivec3',
    'vec3u': 'uvec3',
    'vec3b': 'bvec3',
    'vec4<f32>': 'vec4',
    'vec4<i32>': 'ivec4',
    'vec4<u32>': 'uvec4',
    'vec4<bool>': 'bvec4',
    'vec4f': 'vec4',
    'vec4i': 'ivec4',
    'vec4u': 'uvec4',
    'vec4b': 'bvec4',
    'mat2x2<f32>': 'mat2',
    'mat2x2f': 'mat2',
    'mat3x3<f32>': 'mat3',
    'mat3x3f': 'mat3',
    'mat4x4<f32>': 'mat4',
    'mat4x4f': 'mat4',
    'sampler': 'sampler',
    'texture_1d': 'texture',
    'texture_2d': 'texture',
    'texture_2d_array': 'texture',
    'texture_multisampled_2d': 'cubeTexture',
    'texture_depth_2d': 'depthTexture',
    'texture_depth_multisampled_2d': 'depthTexture',
    'texture_3d': 'texture3D',
    'texture_cube': 'cubeTexture',
    'texture_cube_array': 'cubeTexture',
    'texture_storage_1d': 'storageTexture',
    'texture_storage_2d': 'storageTexture',
    'texture_storage_2d_array': 'storageTexture',
    'texture_storage_3d': 'storageTexture'
  };
  var parse = function parse(source) {
    source = source.trim();
    var declaration = source.match(declarationRegexp);
    if (declaration !== null && declaration.length === 4) {
      var inputsCode = declaration[2];
      var propsMatches = [];
      var match = null;
      while ((match = propertiesRegexp.exec(inputsCode)) !== null) {
        propsMatches.push({
          name: match[1],
          type: match[2]
        });
      }

      // Process matches to correctly pair names and types
      var inputs = [];
      for (var i = 0; i < propsMatches.length; i++) {
        var _propsMatches$i = propsMatches[i],
          _name2 = _propsMatches$i.name,
          _type3 = _propsMatches$i.type;
        var resolvedType = _type3;
        if (resolvedType.startsWith('ptr')) {
          resolvedType = 'pointer';
        } else {
          if (resolvedType.startsWith('texture')) {
            resolvedType = _type3.split('<')[0];
          }
          resolvedType = wgslTypeLib$1[resolvedType];
        }
        inputs.push(new NodeFunctionInput(resolvedType, _name2));
      }
      var blockCode = source.substring(declaration[0].length);
      var outputType = declaration[3] || 'void';
      var name = declaration[1] !== undefined ? declaration[1] : '';
      var type = wgslTypeLib$1[outputType] || outputType;
      return {
        type: type,
        inputs: inputs,
        name: name,
        inputsCode: inputsCode,
        blockCode: blockCode,
        outputType: outputType
      };
    } else {
      throw new Error('FunctionNode: Function is not a WGSL code.');
    }
  };

  /**
   * This class represents a WSL node function.
   *
   * @augments NodeFunction
   */
  var WGSLNodeFunction = /*#__PURE__*/function (_NodeFunction2) {
    /**
     * Constructs a new WGSL node function.
     *
     * @param {String} source - The WGSL source.
     */
    function WGSLNodeFunction(source) {
      var _this212;
      (0, _classCallCheck2.default)(this, WGSLNodeFunction);
      var _parse = parse(source),
        type = _parse.type,
        inputs = _parse.inputs,
        name = _parse.name,
        inputsCode = _parse.inputsCode,
        blockCode = _parse.blockCode,
        outputType = _parse.outputType;
      _this212 = _callSuper(this, WGSLNodeFunction, [type, inputs, name]);
      _this212.inputsCode = inputsCode;
      _this212.blockCode = blockCode;
      _this212.outputType = outputType;
      return _this212;
    }

    /**
     * This method returns the WGSL code of the node function.
     *
     * @param {String} [name=this.name] - The function's name.
     * @return {String} The shader code.
     */
    (0, _inherits2.default)(WGSLNodeFunction, _NodeFunction2);
    return (0, _createClass2.default)(WGSLNodeFunction, [{
      key: "getCode",
      value: function getCode() {
        var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.name;
        var outputType = this.outputType !== 'void' ? '-> ' + this.outputType : '';
        return `fn ${name} ( ${this.inputsCode.trim()} ) ${outputType}` + this.blockCode;
      }
    }]);
  }(NodeFunction);
  /**
   * A WGSL node parser.
   *
   * @augments NodeParser
   */
  var WGSLNodeParser = /*#__PURE__*/function (_NodeParser2) {
    function WGSLNodeParser() {
      (0, _classCallCheck2.default)(this, WGSLNodeParser);
      return _callSuper(this, WGSLNodeParser, arguments);
    }
    (0, _inherits2.default)(WGSLNodeParser, _NodeParser2);
    return (0, _createClass2.default)(WGSLNodeParser, [{
      key: "parseFunction",
      value:
      /**
       * The method parses the given WGSL code an returns a node function.
       *
       * @param {String} source - The WGSL code.
       * @return {WGSLNodeFunction} A node function.
       */
      function parseFunction(source) {
        return new WGSLNodeFunction(source);
      }
    }]);
  }(NodeParser); // GPUShaderStage is not defined in browsers not supporting WebGPU
  var GPUShaderStage = typeof self !== 'undefined' ? self.GPUShaderStage : {
    VERTEX: 1,
    FRAGMENT: 2,
    COMPUTE: 4
  };
  var accessNames = (0, _defineProperty2.default)((0, _defineProperty2.default)((0, _defineProperty2.default)({}, NodeAccess.READ_ONLY, 'read'), NodeAccess.WRITE_ONLY, 'write'), NodeAccess.READ_WRITE, 'read_write');
  var wrapNames = (0, _defineProperty2.default)((0, _defineProperty2.default)((0, _defineProperty2.default)({}, _$$_REQUIRE(_dependencyMap[1], "./three.core.js").RepeatWrapping, 'repeat'), _$$_REQUIRE(_dependencyMap[1], "./three.core.js").ClampToEdgeWrapping, 'clamp'), _$$_REQUIRE(_dependencyMap[1], "./three.core.js").MirroredRepeatWrapping, 'mirror');
  var gpuShaderStageLib = {
    'vertex': GPUShaderStage ? GPUShaderStage.VERTEX : 1,
    'fragment': GPUShaderStage ? GPUShaderStage.FRAGMENT : 2,
    'compute': GPUShaderStage ? GPUShaderStage.COMPUTE : 4
  };
  var supports = {
    instance: true,
    swizzleAssign: false,
    storageBuffer: true
  };
  var wgslFnOpLib = {
    '^^': 'tsl_xor'
  };
  var wgslTypeLib = {
    float: 'f32',
    int: 'i32',
    uint: 'u32',
    bool: 'bool',
    color: 'vec3<f32>',
    vec2: 'vec2<f32>',
    ivec2: 'vec2<i32>',
    uvec2: 'vec2<u32>',
    bvec2: 'vec2<bool>',
    vec3: 'vec3<f32>',
    ivec3: 'vec3<i32>',
    uvec3: 'vec3<u32>',
    bvec3: 'vec3<bool>',
    vec4: 'vec4<f32>',
    ivec4: 'vec4<i32>',
    uvec4: 'vec4<u32>',
    bvec4: 'vec4<bool>',
    mat2: 'mat2x2<f32>',
    mat3: 'mat3x3<f32>',
    mat4: 'mat4x4<f32>'
  };
  var wgslCodeCache = {};
  var wgslPolyfill = {
    tsl_xor: new CodeNode('fn tsl_xor( a : bool, b : bool ) -> bool { return ( a || b ) && !( a && b ); }'),
    mod_float: new CodeNode('fn tsl_mod_float( x : f32, y : f32 ) -> f32 { return x - y * floor( x / y ); }'),
    mod_vec2: new CodeNode('fn tsl_mod_vec2( x : vec2f, y : vec2f ) -> vec2f { return x - y * floor( x / y ); }'),
    mod_vec3: new CodeNode('fn tsl_mod_vec3( x : vec3f, y : vec3f ) -> vec3f { return x - y * floor( x / y ); }'),
    mod_vec4: new CodeNode('fn tsl_mod_vec4( x : vec4f, y : vec4f ) -> vec4f { return x - y * floor( x / y ); }'),
    equals_bool: new CodeNode('fn tsl_equals_bool( a : bool, b : bool ) -> bool { return a == b; }'),
    equals_bvec2: new CodeNode('fn tsl_equals_bvec2( a : vec2f, b : vec2f ) -> vec2<bool> { return vec2<bool>( a.x == b.x, a.y == b.y ); }'),
    equals_bvec3: new CodeNode('fn tsl_equals_bvec3( a : vec3f, b : vec3f ) -> vec3<bool> { return vec3<bool>( a.x == b.x, a.y == b.y, a.z == b.z ); }'),
    equals_bvec4: new CodeNode('fn tsl_equals_bvec4( a : vec4f, b : vec4f ) -> vec4<bool> { return vec4<bool>( a.x == b.x, a.y == b.y, a.z == b.z, a.w == b.w ); }'),
    repeatWrapping_float: new CodeNode('fn tsl_repeatWrapping_float( coord: f32 ) -> f32 { return fract( coord ); }'),
    mirrorWrapping_float: new CodeNode('fn tsl_mirrorWrapping_float( coord: f32 ) -> f32 { let mirrored = fract( coord * 0.5 ) * 2.0; return 1.0 - abs( 1.0 - mirrored ); }'),
    clampWrapping_float: new CodeNode('fn tsl_clampWrapping_float( coord: f32 ) -> f32 { return clamp( coord, 0.0, 1.0 ); }'),
    biquadraticTexture: new CodeNode(/* wgsl */`
fn tsl_biquadraticTexture( map : texture_2d<f32>, coord : vec2f, iRes : vec2u, level : u32 ) -> vec4f {

	let res = vec2f( iRes );

	let uvScaled = coord * res;
	let uvWrapping = ( ( uvScaled % res ) + res ) % res;

	// https://www.shadertoy.com/view/WtyXRy

	let uv = uvWrapping - 0.5;
	let iuv = floor( uv );
	let f = fract( uv );

	let rg1 = textureLoad( map, vec2u( iuv + vec2( 0.5, 0.5 ) ) % iRes, level );
	let rg2 = textureLoad( map, vec2u( iuv + vec2( 1.5, 0.5 ) ) % iRes, level );
	let rg3 = textureLoad( map, vec2u( iuv + vec2( 0.5, 1.5 ) ) % iRes, level );
	let rg4 = textureLoad( map, vec2u( iuv + vec2( 1.5, 1.5 ) ) % iRes, level );

	return mix( mix( rg1, rg2, f.x ), mix( rg3, rg4, f.x ), f.y );

}
`)
  };
  var wgslMethods = {
    dFdx: 'dpdx',
    dFdy: '- dpdy',
    mod_float: 'tsl_mod_float',
    mod_vec2: 'tsl_mod_vec2',
    mod_vec3: 'tsl_mod_vec3',
    mod_vec4: 'tsl_mod_vec4',
    equals_bool: 'tsl_equals_bool',
    equals_bvec2: 'tsl_equals_bvec2',
    equals_bvec3: 'tsl_equals_bvec3',
    equals_bvec4: 'tsl_equals_bvec4',
    inversesqrt: 'inverseSqrt',
    bitcast: 'bitcast<f32>'
  };

  // WebGPU issue: does not support pow() with negative base on Windows

  if (typeof navigator !== 'undefined' && /Windows/g.test(navigator.userAgent)) {
    wgslPolyfill.pow_float = new CodeNode('fn tsl_pow_float( a : f32, b : f32 ) -> f32 { return select( -pow( -a, b ), pow( a, b ), a > 0.0 ); }');
    wgslPolyfill.pow_vec2 = new CodeNode('fn tsl_pow_vec2( a : vec2f, b : vec2f ) -> vec2f { return vec2f( tsl_pow_float( a.x, b.x ), tsl_pow_float( a.y, b.y ) ); }', [wgslPolyfill.pow_float]);
    wgslPolyfill.pow_vec3 = new CodeNode('fn tsl_pow_vec3( a : vec3f, b : vec3f ) -> vec3f { return vec3f( tsl_pow_float( a.x, b.x ), tsl_pow_float( a.y, b.y ), tsl_pow_float( a.z, b.z ) ); }', [wgslPolyfill.pow_float]);
    wgslPolyfill.pow_vec4 = new CodeNode('fn tsl_pow_vec4( a : vec4f, b : vec4f ) -> vec4f { return vec4f( tsl_pow_float( a.x, b.x ), tsl_pow_float( a.y, b.y ), tsl_pow_float( a.z, b.z ), tsl_pow_float( a.w, b.w ) ); }', [wgslPolyfill.pow_float]);
    wgslMethods.pow_float = 'tsl_pow_float';
    wgslMethods.pow_vec2 = 'tsl_pow_vec2';
    wgslMethods.pow_vec3 = 'tsl_pow_vec3';
    wgslMethods.pow_vec4 = 'tsl_pow_vec4';
  }

  //

  var diagnostics = '';
  if ((typeof navigator !== 'undefined' && /Firefox|Deno/g.test(navigator.userAgent)) !== true) {
    diagnostics += 'diagnostic( off, derivative_uniformity );\n';
  }

  //
  var WGSLNodeBuilder = /*#__PURE__*/function (_NodeBuilder2) {
    function WGSLNodeBuilder(object, renderer) {
      var _this213;
      (0, _classCallCheck2.default)(this, WGSLNodeBuilder);
      _this213 = _callSuper(this, WGSLNodeBuilder, [object, renderer, new WGSLNodeParser()]);
      _this213.uniformGroups = {};
      _this213.builtins = {};
      _this213.directives = {};
      _this213.scopedArrays = new Map();
      return _this213;
    }
    (0, _inherits2.default)(WGSLNodeBuilder, _NodeBuilder2);
    return (0, _createClass2.default)(WGSLNodeBuilder, [{
      key: "needsToWorkingColorSpace",
      value: function needsToWorkingColorSpace(texture) {
        return texture.isVideoTexture === true && texture.colorSpace !== _$$_REQUIRE(_dependencyMap[1], "./three.core.js").NoColorSpace;
      }
    }, {
      key: "_generateTextureSample",
      value: function _generateTextureSample(texture, textureProperty, uvSnippet, depthSnippet) {
        var shaderStage = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : this.shaderStage;
        if (shaderStage === 'fragment') {
          if (depthSnippet) {
            return `textureSample( ${textureProperty}, ${textureProperty}_sampler, ${uvSnippet}, ${depthSnippet} )`;
          } else {
            return `textureSample( ${textureProperty}, ${textureProperty}_sampler, ${uvSnippet} )`;
          }
        } else if (this.isFilteredTexture(texture)) {
          return this.generateFilteredTexture(texture, textureProperty, uvSnippet);
        } else {
          return this.generateTextureLod(texture, textureProperty, uvSnippet, depthSnippet, '0');
        }
      }
    }, {
      key: "_generateVideoSample",
      value: function _generateVideoSample(textureProperty, uvSnippet) {
        var shaderStage = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.shaderStage;
        if (shaderStage === 'fragment') {
          return `textureSampleBaseClampToEdge( ${textureProperty}, ${textureProperty}_sampler, vec2<f32>( ${uvSnippet}.x, 1.0 - ${uvSnippet}.y ) )`;
        } else {
          console.error(`WebGPURenderer: THREE.VideoTexture does not support ${shaderStage} shader.`);
        }
      }
    }, {
      key: "_generateTextureSampleLevel",
      value: function _generateTextureSampleLevel(texture, textureProperty, uvSnippet, levelSnippet, depthSnippet) {
        var shaderStage = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : this.shaderStage;
        if ((shaderStage === 'fragment' || shaderStage === 'compute') && this.isUnfilterable(texture) === false) {
          return `textureSampleLevel( ${textureProperty}, ${textureProperty}_sampler, ${uvSnippet}, ${levelSnippet} )`;
        } else if (this.isFilteredTexture(texture)) {
          return this.generateFilteredTexture(texture, textureProperty, uvSnippet, levelSnippet);
        } else {
          return this.generateTextureLod(texture, textureProperty, uvSnippet, depthSnippet, levelSnippet);
        }
      }
    }, {
      key: "generateWrapFunction",
      value: function generateWrapFunction(texture) {
        var functionName = `tsl_coord_${wrapNames[texture.wrapS]}S_${wrapNames[texture.wrapT]}_${texture.isData3DTexture ? '3d' : '2d'}T`;
        var nodeCode = wgslCodeCache[functionName];
        if (nodeCode === undefined) {
          var includes = [];

          // For 3D textures, use vec3f; for texture arrays, keep vec2f since array index is separate
          var coordType = texture.isData3DTexture ? 'vec3f' : 'vec2f';
          var _code = `fn ${functionName}( coord : ${coordType} ) -> ${coordType} {\n\n\treturn ${coordType}(\n`;
          var addWrapSnippet = function addWrapSnippet(wrap, axis) {
            if (wrap === _$$_REQUIRE(_dependencyMap[1], "./three.core.js").RepeatWrapping) {
              includes.push(wgslPolyfill.repeatWrapping_float);
              _code += `\t\ttsl_repeatWrapping_float( coord.${axis} )`;
            } else if (wrap === _$$_REQUIRE(_dependencyMap[1], "./three.core.js").ClampToEdgeWrapping) {
              includes.push(wgslPolyfill.clampWrapping_float);
              _code += `\t\ttsl_clampWrapping_float( coord.${axis} )`;
            } else if (wrap === _$$_REQUIRE(_dependencyMap[1], "./three.core.js").MirroredRepeatWrapping) {
              includes.push(wgslPolyfill.mirrorWrapping_float);
              _code += `\t\ttsl_mirrorWrapping_float( coord.${axis} )`;
            } else {
              _code += `\t\tcoord.${axis}`;
              console.warn(`WebGPURenderer: Unsupported texture wrap type "${wrap}" for vertex shader.`);
            }
          };
          addWrapSnippet(texture.wrapS, 'x');
          _code += ',\n';
          addWrapSnippet(texture.wrapT, 'y');
          if (texture.isData3DTexture) {
            _code += ',\n';
            addWrapSnippet(texture.wrapR, 'z');
          }
          _code += '\n\t);\n\n}\n';
          wgslCodeCache[functionName] = nodeCode = new CodeNode(_code, includes);
        }
        nodeCode.build(this);
        return functionName;
      }
    }, {
      key: "generateTextureDimension",
      value: function generateTextureDimension(texture, textureProperty, levelSnippet) {
        var textureData = this.getDataFromNode(texture, this.shaderStage, this.globalCache);
        if (textureData.dimensionsSnippet === undefined) textureData.dimensionsSnippet = {};
        var textureDimensionNode = textureData.dimensionsSnippet[levelSnippet];
        if (textureData.dimensionsSnippet[levelSnippet] === undefined) {
          var textureDimensionsParams;
          var dimensionType;
          var _this$renderer$backen = this.renderer.backend.utils.getTextureSampleData(texture),
            primarySamples = _this$renderer$backen.primarySamples;
          var isMultisampled = primarySamples > 1;
          if (texture.isData3DTexture) {
            dimensionType = 'vec3<u32>';
          } else {
            // Regular 2D textures, depth textures, etc.
            dimensionType = 'vec2<u32>';
          }

          // Build parameters string based on texture type and multisampling
          if (isMultisampled || texture.isVideoTexture || texture.isStorageTexture) {
            textureDimensionsParams = textureProperty;
          } else {
            textureDimensionsParams = `${textureProperty}${levelSnippet ? `, u32( ${levelSnippet} )` : ''}`;
          }
          textureDimensionNode = new VarNode(new ExpressionNode(`textureDimensions( ${textureDimensionsParams} )`, dimensionType));
          textureData.dimensionsSnippet[levelSnippet] = textureDimensionNode;
          if (texture.isDataArrayTexture || texture.isData3DTexture) {
            textureData.arrayLayerCount = new VarNode(new ExpressionNode(`textureNumLayers(${textureProperty})`, 'u32'));
          }

          // For cube textures, we know it's always 6 faces
          if (texture.isTextureCube) {
            textureData.cubeFaceCount = new VarNode(new ExpressionNode('6u', 'u32'));
          }
        }
        return textureDimensionNode.build(this);
      }
    }, {
      key: "generateFilteredTexture",
      value: function generateFilteredTexture(texture, textureProperty, uvSnippet) {
        var levelSnippet = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : '0u';
        this._include('biquadraticTexture');
        var wrapFunction = this.generateWrapFunction(texture);
        var textureDimension = this.generateTextureDimension(texture, textureProperty, levelSnippet);
        return `tsl_biquadraticTexture( ${textureProperty}, ${wrapFunction}( ${uvSnippet} ), ${textureDimension}, u32( ${levelSnippet} ) )`;
      }
    }, {
      key: "generateTextureLod",
      value: function generateTextureLod(texture, textureProperty, uvSnippet, depthSnippet) {
        var levelSnippet = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : '0u';
        var wrapFunction = this.generateWrapFunction(texture);
        var textureDimension = this.generateTextureDimension(texture, textureProperty, levelSnippet);
        var vecType = texture.isData3DTexture ? 'vec3' : 'vec2';
        var coordSnippet = `${vecType}<u32>(${wrapFunction}(${uvSnippet}) * ${vecType}<f32>(${textureDimension}))`;
        return this.generateTextureLoad(texture, textureProperty, coordSnippet, depthSnippet, levelSnippet);
      }
    }, {
      key: "generateTextureLoad",
      value: function generateTextureLoad(texture, textureProperty, uvIndexSnippet, depthSnippet) {
        var levelSnippet = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : '0u';
        if (texture.isVideoTexture === true || texture.isStorageTexture === true) {
          return `textureLoad( ${textureProperty}, ${uvIndexSnippet} )`;
        } else if (depthSnippet) {
          return `textureLoad( ${textureProperty}, ${uvIndexSnippet}, ${depthSnippet}, u32( ${levelSnippet} ) )`;
        } else {
          return `textureLoad( ${textureProperty}, ${uvIndexSnippet}, u32( ${levelSnippet} ) )`;
        }
      }
    }, {
      key: "generateTextureStore",
      value: function generateTextureStore(texture, textureProperty, uvIndexSnippet, valueSnippet) {
        return `textureStore( ${textureProperty}, ${uvIndexSnippet}, ${valueSnippet} )`;
      }
    }, {
      key: "isSampleCompare",
      value: function isSampleCompare(texture) {
        return texture.isDepthTexture === true && texture.compareFunction !== null;
      }
    }, {
      key: "isUnfilterable",
      value: function isUnfilterable(texture) {
        return this.getComponentTypeFromTexture(texture) !== 'float' || !this.isAvailable('float32Filterable') && texture.isDataTexture === true && texture.type === _$$_REQUIRE(_dependencyMap[1], "./three.core.js").FloatType || this.isSampleCompare(texture) === false && texture.minFilter === _$$_REQUIRE(_dependencyMap[1], "./three.core.js").NearestFilter && texture.magFilter === _$$_REQUIRE(_dependencyMap[1], "./three.core.js").NearestFilter || this.renderer.backend.utils.getTextureSampleData(texture).primarySamples > 1;
      }
    }, {
      key: "generateTexture",
      value: function generateTexture(texture, textureProperty, uvSnippet, depthSnippet) {
        var shaderStage = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : this.shaderStage;
        var snippet = null;
        if (texture.isVideoTexture === true) {
          snippet = this._generateVideoSample(textureProperty, uvSnippet, shaderStage);
        } else if (this.isUnfilterable(texture)) {
          snippet = this.generateTextureLod(texture, textureProperty, uvSnippet, depthSnippet, '0', shaderStage);
        } else {
          snippet = this._generateTextureSample(texture, textureProperty, uvSnippet, depthSnippet, shaderStage);
        }
        return snippet;
      }
    }, {
      key: "generateTextureGrad",
      value: function generateTextureGrad(texture, textureProperty, uvSnippet, gradSnippet, depthSnippet) {
        var shaderStage = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : this.shaderStage;
        if (shaderStage === 'fragment') {
          // TODO handle i32 or u32 --> uvSnippet, array_index: A, ddx, ddy
          return `textureSampleGrad( ${textureProperty}, ${textureProperty}_sampler, ${uvSnippet},  ${gradSnippet[0]}, ${gradSnippet[1]} )`;
        } else {
          console.error(`WebGPURenderer: THREE.TextureNode.gradient() does not support ${shaderStage} shader.`);
        }
      }
    }, {
      key: "generateTextureCompare",
      value: function generateTextureCompare(texture, textureProperty, uvSnippet, compareSnippet, depthSnippet) {
        var shaderStage = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : this.shaderStage;
        if (shaderStage === 'fragment') {
          return `textureSampleCompare( ${textureProperty}, ${textureProperty}_sampler, ${uvSnippet}, ${compareSnippet} )`;
        } else {
          console.error(`WebGPURenderer: THREE.DepthTexture.compareFunction() does not support ${shaderStage} shader.`);
        }
      }
    }, {
      key: "generateTextureLevel",
      value: function generateTextureLevel(texture, textureProperty, uvSnippet, levelSnippet, depthSnippet) {
        var shaderStage = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : this.shaderStage;
        var snippet = null;
        if (texture.isVideoTexture === true) {
          snippet = this._generateVideoSample(textureProperty, uvSnippet, shaderStage);
        } else {
          snippet = this._generateTextureSampleLevel(texture, textureProperty, uvSnippet, levelSnippet, depthSnippet, shaderStage);
        }
        return snippet;
      }
    }, {
      key: "generateTextureBias",
      value: function generateTextureBias(texture, textureProperty, uvSnippet, biasSnippet, depthSnippet) {
        var shaderStage = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : this.shaderStage;
        if (shaderStage === 'fragment') {
          return `textureSampleBias( ${textureProperty}, ${textureProperty}_sampler, ${uvSnippet}, ${biasSnippet} )`;
        } else {
          console.error(`WebGPURenderer: THREE.TextureNode.biasNode does not support ${shaderStage} shader.`);
        }
      }
    }, {
      key: "getPropertyName",
      value: function getPropertyName(node) {
        var shaderStage = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.shaderStage;
        if (node.isNodeVarying === true && node.needsInterpolation === true) {
          if (shaderStage === 'vertex') {
            return `varyings.${node.name}`;
          }
        } else if (node.isNodeUniform === true) {
          var name = node.name;
          var type = node.type;
          if (type === 'texture' || type === 'cubeTexture' || type === 'storageTexture' || type === 'texture3D') {
            return name;
          } else if (type === 'buffer' || type === 'storageBuffer' || type === 'indirectStorageBuffer') {
            return `NodeBuffer_${node.id}.${name}`;
          } else {
            return node.groupNode.name + '.' + name;
          }
        }
        return _superPropGet(WGSLNodeBuilder, "getPropertyName", this, 3)([node]);
      }
    }, {
      key: "getOutputStructName",
      value: function getOutputStructName() {
        return 'output';
      }
    }, {
      key: "_getUniformGroupCount",
      value: function _getUniformGroupCount(shaderStage) {
        return Object.keys(this.uniforms[shaderStage]).length;
      }
    }, {
      key: "getFunctionOperator",
      value: function getFunctionOperator(op) {
        var fnOp = wgslFnOpLib[op];
        if (fnOp !== undefined) {
          this._include(fnOp);
          return fnOp;
        }
        return null;
      }
    }, {
      key: "getNodeAccess",
      value: function getNodeAccess(node, shaderStage) {
        if (shaderStage !== 'compute') return NodeAccess.READ_ONLY;
        return node.access;
      }
    }, {
      key: "getStorageAccess",
      value: function getStorageAccess(node, shaderStage) {
        return accessNames[this.getNodeAccess(node, shaderStage)];
      }
    }, {
      key: "getUniformFromNode",
      value: function getUniformFromNode(node, type, shaderStage) {
        var name = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
        var uniformNode = _superPropGet(WGSLNodeBuilder, "getUniformFromNode", this, 3)([node, type, shaderStage, name]);
        var nodeData = this.getDataFromNode(node, shaderStage, this.globalCache);
        if (nodeData.uniformGPU === undefined) {
          var uniformGPU;
          var group = node.groupNode;
          var groupName = group.name;
          var bindings = this.getBindGroupArray(groupName, shaderStage);
          if (type === 'texture' || type === 'cubeTexture' || type === 'storageTexture' || type === 'texture3D') {
            var _texture12 = null;
            var access = this.getNodeAccess(node, shaderStage);
            if (type === 'texture' || type === 'storageTexture') {
              _texture12 = new NodeSampledTexture(uniformNode.name, uniformNode.node, group, access);
            } else if (type === 'cubeTexture') {
              _texture12 = new NodeSampledCubeTexture(uniformNode.name, uniformNode.node, group, access);
            } else if (type === 'texture3D') {
              _texture12 = new NodeSampledTexture3D(uniformNode.name, uniformNode.node, group, access);
            }
            _texture12.store = node.isStorageTextureNode === true;
            _texture12.setVisibility(gpuShaderStageLib[shaderStage]);
            if ((shaderStage === 'fragment' || shaderStage === 'compute') && this.isUnfilterable(node.value) === false && _texture12.store === false) {
              var _sampler = new NodeSampler(`${uniformNode.name}_sampler`, uniformNode.node, group);
              _sampler.setVisibility(gpuShaderStageLib[shaderStage]);
              bindings.push(_sampler, _texture12);
              uniformGPU = [_sampler, _texture12];
            } else {
              bindings.push(_texture12);
              uniformGPU = [_texture12];
            }
          } else if (type === 'buffer' || type === 'storageBuffer' || type === 'indirectStorageBuffer') {
            var bufferClass = type === 'buffer' ? NodeUniformBuffer : NodeStorageBuffer;
            var _buffer5 = new bufferClass(node, group);
            _buffer5.setVisibility(gpuShaderStageLib[shaderStage]);
            bindings.push(_buffer5);
            uniformGPU = _buffer5;
          } else {
            var uniformsStage = this.uniformGroups[shaderStage] || (this.uniformGroups[shaderStage] = {});
            var uniformsGroup = uniformsStage[groupName];
            if (uniformsGroup === undefined) {
              uniformsGroup = new NodeUniformsGroup(groupName, group);
              uniformsGroup.setVisibility(gpuShaderStageLib[shaderStage]);
              uniformsStage[groupName] = uniformsGroup;
              bindings.push(uniformsGroup);
            }
            uniformGPU = this.getNodeUniform(uniformNode, type);
            uniformsGroup.addUniform(uniformGPU);
          }
          nodeData.uniformGPU = uniformGPU;
        }
        return uniformNode;
      }
    }, {
      key: "getBuiltin",
      value: function getBuiltin(name, property, type) {
        var shaderStage = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : this.shaderStage;
        var map = this.builtins[shaderStage] || (this.builtins[shaderStage] = new Map());
        if (map.has(name) === false) {
          map.set(name, {
            name: name,
            property: property,
            type: type
          });
        }
        return property;
      }
    }, {
      key: "hasBuiltin",
      value: function hasBuiltin(name) {
        var shaderStage = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.shaderStage;
        return this.builtins[shaderStage] !== undefined && this.builtins[shaderStage].has(name);
      }
    }, {
      key: "getVertexIndex",
      value: function getVertexIndex() {
        if (this.shaderStage === 'vertex') {
          return this.getBuiltin('vertex_index', 'vertexIndex', 'u32', 'attribute');
        }
        return 'vertexIndex';
      }
    }, {
      key: "buildFunctionCode",
      value: function buildFunctionCode(shaderNode) {
        var layout = shaderNode.layout;
        var flowData = this.flowShaderNode(shaderNode);
        var parameters = [];
        for (var input of layout.inputs) {
          parameters.push(input.name + ' : ' + this.getType(input.type));
        }

        //

        var code = `fn ${layout.name}( ${parameters.join(', ')} ) -> ${this.getType(layout.type)} {
${flowData.vars}
${flowData.code}
`;
        if (flowData.result) {
          code += `\treturn ${flowData.result};\n`;
        }
        code += '\n}\n';

        //

        return code;
      }
    }, {
      key: "getInstanceIndex",
      value: function getInstanceIndex() {
        if (this.shaderStage === 'vertex') {
          return this.getBuiltin('instance_index', 'instanceIndex', 'u32', 'attribute');
        }
        return 'instanceIndex';
      }
    }, {
      key: "getInvocationLocalIndex",
      value: function getInvocationLocalIndex() {
        return this.getBuiltin('local_invocation_index', 'invocationLocalIndex', 'u32', 'attribute');
      }
    }, {
      key: "getSubgroupSize",
      value: function getSubgroupSize() {
        this.enableSubGroups();
        return this.getBuiltin('subgroup_size', 'subgroupSize', 'u32', 'attribute');
      }
    }, {
      key: "getInvocationSubgroupIndex",
      value: function getInvocationSubgroupIndex() {
        this.enableSubGroups();
        return this.getBuiltin('subgroup_invocation_id', 'invocationSubgroupIndex', 'u32', 'attribute');
      }
    }, {
      key: "getSubgroupIndex",
      value: function getSubgroupIndex() {
        this.enableSubGroups();
        return this.getBuiltin('subgroup_id', 'subgroupIndex', 'u32', 'attribute');
      }
    }, {
      key: "getDrawIndex",
      value: function getDrawIndex() {
        return null;
      }
    }, {
      key: "getFrontFacing",
      value: function getFrontFacing() {
        return this.getBuiltin('front_facing', 'isFront', 'bool');
      }
    }, {
      key: "getFragCoord",
      value: function getFragCoord() {
        return this.getBuiltin('position', 'fragCoord', 'vec4<f32>') + '.xy';
      }
    }, {
      key: "getFragDepth",
      value: function getFragDepth() {
        return 'output.' + this.getBuiltin('frag_depth', 'depth', 'f32', 'output');
      }
    }, {
      key: "getClipDistance",
      value: function getClipDistance() {
        return 'varyings.hw_clip_distances';
      }
    }, {
      key: "isFlipY",
      value: function isFlipY() {
        return false;
      }
    }, {
      key: "enableDirective",
      value: function enableDirective(name) {
        var shaderStage = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.shaderStage;
        var stage = this.directives[shaderStage] || (this.directives[shaderStage] = new Set());
        stage.add(name);
      }
    }, {
      key: "getDirectives",
      value: function getDirectives(shaderStage) {
        var snippets = [];
        var directives = this.directives[shaderStage];
        if (directives !== undefined) {
          for (var directive of directives) {
            snippets.push(`enable ${directive};`);
          }
        }
        return snippets.join('\n');
      }
    }, {
      key: "enableSubGroups",
      value: function enableSubGroups() {
        this.enableDirective('subgroups');
      }
    }, {
      key: "enableSubgroupsF16",
      value: function enableSubgroupsF16() {
        this.enableDirective('subgroups-f16');
      }
    }, {
      key: "enableClipDistances",
      value: function enableClipDistances() {
        this.enableDirective('clip_distances');
      }
    }, {
      key: "enableShaderF16",
      value: function enableShaderF16() {
        this.enableDirective('f16');
      }
    }, {
      key: "enableDualSourceBlending",
      value: function enableDualSourceBlending() {
        this.enableDirective('dual_source_blending');
      }
    }, {
      key: "enableHardwareClipping",
      value: function enableHardwareClipping(planeCount) {
        this.enableClipDistances();
        this.getBuiltin('clip_distances', 'hw_clip_distances', `array<f32, ${planeCount} >`, 'vertex');
      }
    }, {
      key: "getBuiltins",
      value: function getBuiltins(shaderStage) {
        var snippets = [];
        var builtins = this.builtins[shaderStage];
        if (builtins !== undefined) {
          for (var _ref342 of builtins.values()) {
            var name = _ref342.name;
            var _property11 = _ref342.property;
            var type = _ref342.type;
            snippets.push(`@builtin( ${name} ) ${_property11} : ${type}`);
          }
        }
        return snippets.join(',\n\t');
      }
    }, {
      key: "getScopedArray",
      value: function getScopedArray(name, scope, bufferType, bufferCount) {
        if (this.scopedArrays.has(name) === false) {
          this.scopedArrays.set(name, {
            name: name,
            scope: scope,
            bufferType: bufferType,
            bufferCount: bufferCount
          });
        }
        return name;
      }
    }, {
      key: "getScopedArrays",
      value: function getScopedArrays(shaderStage) {
        if (shaderStage !== 'compute') {
          return;
        }
        var snippets = [];
        for (var _ref343 of this.scopedArrays.values()) {
          var name = _ref343.name;
          var scope = _ref343.scope;
          var bufferType = _ref343.bufferType;
          var bufferCount = _ref343.bufferCount;
          var type = this.getType(bufferType);
          snippets.push(`var<${scope}> ${name}: array< ${type}, ${bufferCount} >;`);
        }
        return snippets.join('\n');
      }
    }, {
      key: "getAttributes",
      value: function getAttributes(shaderStage) {
        var snippets = [];
        if (shaderStage === 'compute') {
          this.getBuiltin('global_invocation_id', 'id', 'vec3<u32>', 'attribute');
          this.getBuiltin('workgroup_id', 'workgroupId', 'vec3<u32>', 'attribute');
          this.getBuiltin('local_invocation_id', 'localId', 'vec3<u32>', 'attribute');
          this.getBuiltin('num_workgroups', 'numWorkgroups', 'vec3<u32>', 'attribute');
          if (this.renderer.hasFeature('subgroups')) {
            this.enableDirective('subgroups', shaderStage);
            this.getBuiltin('subgroup_size', 'subgroupSize', 'u32', 'attribute');
          }
        }
        if (shaderStage === 'vertex' || shaderStage === 'compute') {
          var builtins = this.getBuiltins('attribute');
          if (builtins) snippets.push(builtins);
          var attributes = this.getAttributesArray();
          for (var index = 0, _length3 = attributes.length; index < _length3; index++) {
            var _attribute14 = attributes[index];
            var name = _attribute14.name;
            var type = this.getType(_attribute14.type);
            snippets.push(`@location( ${index} ) ${name} : ${type}`);
          }
        }
        return snippets.join(',\n\t');
      }
    }, {
      key: "getStructMembers",
      value: function getStructMembers(struct) {
        var snippets = [];
        var members = struct.getMemberTypes();
        for (var i = 0; i < members.length; i++) {
          var member = members[i];
          snippets.push(`\t@location( ${i} ) m${i} : ${member}<f32>`);
        }
        var builtins = this.getBuiltins('output');
        if (builtins) snippets.push('\t' + builtins);
        return snippets.join(',\n');
      }
    }, {
      key: "getStructs",
      value: function getStructs(shaderStage) {
        var snippets = [];
        var structs = this.structs[shaderStage];
        for (var index = 0, _length4 = structs.length; index < _length4; index++) {
          var struct = structs[index];
          var name = struct.name;
          var snippet = `\struct ${name} {\n`;
          snippet += this.getStructMembers(struct);
          snippet += '\n}';
          snippets.push(snippet);
          snippets.push(`\nvar<private> output : ${name};\n\n`);
        }
        return snippets.join('\n\n');
      }
    }, {
      key: "getVar",
      value: function getVar(type, name) {
        return `var ${name} : ${this.getType(type)}`;
      }
    }, {
      key: "getVars",
      value: function getVars(shaderStage) {
        var snippets = [];
        var vars = this.vars[shaderStage];
        if (vars !== undefined) {
          for (var variable of vars) {
            snippets.push(`\t${this.getVar(variable.type, variable.name)};`);
          }
        }
        return `\n${snippets.join('\n')}\n`;
      }
    }, {
      key: "getVaryings",
      value: function getVaryings(shaderStage) {
        var snippets = [];
        if (shaderStage === 'vertex') {
          this.getBuiltin('position', 'Vertex', 'vec4<f32>', 'vertex');
        }
        if (shaderStage === 'vertex' || shaderStage === 'fragment') {
          var varyings = this.varyings;
          var vars = this.vars[shaderStage];
          for (var index = 0; index < varyings.length; index++) {
            var _varying3 = varyings[index];
            if (_varying3.needsInterpolation) {
              var attributesSnippet = `@location( ${index} )`;
              if (/^(int|uint|ivec|uvec)/.test(_varying3.type)) {
                attributesSnippet += ' @interpolate( flat )';
              }
              snippets.push(`${attributesSnippet} ${_varying3.name} : ${this.getType(_varying3.type)}`);
            } else if (shaderStage === 'vertex' && vars.includes(_varying3) === false) {
              vars.push(_varying3);
            }
          }
        }
        var builtins = this.getBuiltins(shaderStage);
        if (builtins) snippets.push(builtins);
        var code = snippets.join(',\n\t');
        return shaderStage === 'vertex' ? this._getWGSLStruct('VaryingsStruct', '\t' + code) : code;
      }
    }, {
      key: "getUniforms",
      value: function getUniforms(shaderStage) {
        var uniforms = this.uniforms[shaderStage];
        var bindingSnippets = [];
        var bufferSnippets = [];
        var structSnippets = [];
        var uniformGroups = {};
        for (var _uniform4 of uniforms) {
          var groupName = _uniform4.groupNode.name;
          var uniformIndexes = this.bindingsIndexes[groupName];
          if (_uniform4.type === 'texture' || _uniform4.type === 'cubeTexture' || _uniform4.type === 'storageTexture' || _uniform4.type === 'texture3D') {
            var _texture13 = _uniform4.node.value;
            if ((shaderStage === 'fragment' || shaderStage === 'compute') && this.isUnfilterable(_texture13) === false && _uniform4.node.isStorageTextureNode !== true) {
              if (this.isSampleCompare(_texture13)) {
                bindingSnippets.push(`@binding( ${uniformIndexes.binding++} ) @group( ${uniformIndexes.group} ) var ${_uniform4.name}_sampler : sampler_comparison;`);
              } else {
                bindingSnippets.push(`@binding( ${uniformIndexes.binding++} ) @group( ${uniformIndexes.group} ) var ${_uniform4.name}_sampler : sampler;`);
              }
            }
            var textureType = void 0;
            var multisampled = '';
            var _this$renderer$backen2 = this.renderer.backend.utils.getTextureSampleData(_texture13),
              primarySamples = _this$renderer$backen2.primarySamples;
            if (primarySamples > 1) {
              multisampled = '_multisampled';
            }
            if (_texture13.isCubeTexture === true) {
              textureType = 'texture_cube<f32>';
            } else if (_texture13.isDataArrayTexture === true || _texture13.isCompressedArrayTexture === true) {
              textureType = 'texture_2d_array<f32>';
            } else if (_texture13.isDepthTexture === true) {
              textureType = `texture_depth${multisampled}_2d`;
            } else if (_texture13.isVideoTexture === true) {
              textureType = 'texture_external';
            } else if (_texture13.isData3DTexture === true) {
              textureType = 'texture_3d<f32>';
            } else if (_uniform4.node.isStorageTextureNode === true) {
              var format = getFormat(_texture13);
              var access = this.getStorageAccess(_uniform4.node, shaderStage);
              textureType = `texture_storage_2d<${format}, ${access}>`;
            } else {
              var componentPrefix = this.getComponentTypeFromTexture(_texture13).charAt(0);
              textureType = `texture${multisampled}_2d<${componentPrefix}32>`;
            }
            bindingSnippets.push(`@binding( ${uniformIndexes.binding++} ) @group( ${uniformIndexes.group} ) var ${_uniform4.name} : ${textureType};`);
          } else if (_uniform4.type === 'buffer' || _uniform4.type === 'storageBuffer' || _uniform4.type === 'indirectStorageBuffer') {
            var bufferNode = _uniform4.node;
            var bufferType = this.getType(bufferNode.bufferType);
            var bufferCount = bufferNode.bufferCount;
            var bufferCountSnippet = bufferCount > 0 && _uniform4.type === 'buffer' ? ', ' + bufferCount : '';
            var bufferTypeSnippet = bufferNode.isAtomic ? `atomic<${bufferType}>` : `${bufferType}`;
            var bufferSnippet = `\t${_uniform4.name} : array< ${bufferTypeSnippet}${bufferCountSnippet} >\n`;
            var bufferAccessMode = bufferNode.isStorageBufferNode ? `storage, ${this.getStorageAccess(bufferNode, shaderStage)}` : 'uniform';
            bufferSnippets.push(this._getWGSLStructBinding('NodeBuffer_' + bufferNode.id, bufferSnippet, bufferAccessMode, uniformIndexes.binding++, uniformIndexes.group));
          } else {
            var vectorType = this.getType(this.getVectorType(_uniform4.type));
            var _groupName2 = _uniform4.groupNode.name;
            var group = uniformGroups[_groupName2] || (uniformGroups[_groupName2] = {
              index: uniformIndexes.binding++,
              id: uniformIndexes.group,
              snippets: []
            });
            group.snippets.push(`\t${_uniform4.name} : ${vectorType}`);
          }
        }
        for (var name in uniformGroups) {
          var _group = uniformGroups[name];
          structSnippets.push(this._getWGSLStructBinding(name, _group.snippets.join(',\n'), 'uniform', _group.index, _group.id));
        }
        var code = bindingSnippets.join('\n');
        code += bufferSnippets.join('\n');
        code += structSnippets.join('\n');
        return code;
      }
    }, {
      key: "buildCode",
      value: function buildCode() {
        var shadersData = this.material !== null ? {
          fragment: {},
          vertex: {}
        } : {
          compute: {}
        };
        this.sortBindingGroups();
        for (var shaderStage in shadersData) {
          var stageData = shadersData[shaderStage];
          stageData.uniforms = this.getUniforms(shaderStage);
          stageData.attributes = this.getAttributes(shaderStage);
          stageData.varyings = this.getVaryings(shaderStage);
          stageData.structs = this.getStructs(shaderStage);
          stageData.vars = this.getVars(shaderStage);
          stageData.codes = this.getCodes(shaderStage);
          stageData.directives = this.getDirectives(shaderStage);
          stageData.scopedArrays = this.getScopedArrays(shaderStage);

          //

          var flow = '// code\n\n';
          flow += this.flowCode[shaderStage];
          var flowNodes = this.flowNodes[shaderStage];
          var mainNode = flowNodes[flowNodes.length - 1];
          var outputNode = mainNode.outputNode;
          var isOutputStruct = outputNode !== undefined && outputNode.isOutputStructNode === true;
          for (var node of flowNodes) {
            var flowSlotData = this.getFlowData(node /*, shaderStage*/);
            var slotName = node.name;
            if (slotName) {
              if (flow.length > 0) flow += '\n';
              flow += `\t// flow -> ${slotName}\n\t`;
            }
            flow += `${flowSlotData.code}\n\t`;
            if (node === mainNode && shaderStage !== 'compute') {
              flow += '// result\n\n\t';
              if (shaderStage === 'vertex') {
                flow += `varyings.Vertex = ${flowSlotData.result};`;
              } else if (shaderStage === 'fragment') {
                if (isOutputStruct) {
                  stageData.returnType = outputNode.nodeType;
                  flow += `return ${flowSlotData.result};`;
                } else {
                  var structSnippet = '\t@location(0) color: vec4<f32>';
                  var builtins = this.getBuiltins('output');
                  if (builtins) structSnippet += ',\n\t' + builtins;
                  stageData.returnType = 'OutputStruct';
                  stageData.structs += this._getWGSLStruct('OutputStruct', structSnippet);
                  stageData.structs += '\nvar<private> output : OutputStruct;\n\n';
                  flow += `output.color = ${flowSlotData.result};\n\n\treturn output;`;
                }
              }
            }
          }
          stageData.flow = flow;
        }
        if (this.material !== null) {
          this.vertexShader = this._getWGSLVertexCode(shadersData.vertex);
          this.fragmentShader = this._getWGSLFragmentCode(shadersData.fragment);
        } else {
          this.computeShader = this._getWGSLComputeCode(shadersData.compute, (this.object.workgroupSize || [64]).join(', '));
        }
      }
    }, {
      key: "getMethod",
      value: function getMethod(method) {
        var output = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
        var wgslMethod;
        if (output !== null) {
          wgslMethod = this._getWGSLMethod(method + '_' + output);
        }
        if (wgslMethod === undefined) {
          wgslMethod = this._getWGSLMethod(method);
        }
        return wgslMethod || method;
      }
    }, {
      key: "getType",
      value: function getType(type) {
        return wgslTypeLib[type] || type;
      }
    }, {
      key: "isAvailable",
      value: function isAvailable(name) {
        var result = supports[name];
        if (result === undefined) {
          if (name === 'float32Filterable') {
            result = this.renderer.hasFeature('float32-filterable');
          } else if (name === 'clipDistance') {
            result = this.renderer.hasFeature('clip-distances');
          }
          supports[name] = result;
        }
        return result;
      }
    }, {
      key: "_getWGSLMethod",
      value: function _getWGSLMethod(method) {
        if (wgslPolyfill[method] !== undefined) {
          this._include(method);
        }
        return wgslMethods[method];
      }
    }, {
      key: "_include",
      value: function _include(name) {
        var codeNode = wgslPolyfill[name];
        codeNode.build(this);
        if (this.currentFunctionNode !== null) {
          this.currentFunctionNode.includes.push(codeNode);
        }
        return codeNode;
      }
    }, {
      key: "_getWGSLVertexCode",
      value: function _getWGSLVertexCode(shaderData) {
        return `${this.getSignature()}
// directives
${shaderData.directives}

// uniforms
${shaderData.uniforms}

// varyings
${shaderData.varyings}
var<private> varyings : VaryingsStruct;

// codes
${shaderData.codes}

@vertex
fn main( ${shaderData.attributes} ) -> VaryingsStruct {

	// vars
	${shaderData.vars}

	// flow
	${shaderData.flow}

	return varyings;

}
`;
      }
    }, {
      key: "_getWGSLFragmentCode",
      value: function _getWGSLFragmentCode(shaderData) {
        return `${this.getSignature()}
// global
${diagnostics}

// uniforms
${shaderData.uniforms}

// structs
${shaderData.structs}

// codes
${shaderData.codes}

@fragment
fn main( ${shaderData.varyings} ) -> ${shaderData.returnType} {

	// vars
	${shaderData.vars}

	// flow
	${shaderData.flow}

}
`;
      }
    }, {
      key: "_getWGSLComputeCode",
      value: function _getWGSLComputeCode(shaderData, workgroupSize) {
        return `${this.getSignature()}
// directives
${shaderData.directives}

// system
var<private> instanceIndex : u32;

// locals
${shaderData.scopedArrays}

// uniforms
${shaderData.uniforms}

// codes
${shaderData.codes}

@compute @workgroup_size( ${workgroupSize} )
fn main( ${shaderData.attributes} ) {

	// system
	instanceIndex = id.x + id.y * numWorkgroups.x * u32(${workgroupSize}) + id.z * numWorkgroups.x * numWorkgroups.y * u32(${workgroupSize});

	// vars
	${shaderData.vars}

	// flow
	${shaderData.flow}

}
`;
      }
    }, {
      key: "_getWGSLStruct",
      value: function _getWGSLStruct(name, vars) {
        return `
struct ${name} {
${vars}
};`;
      }
    }, {
      key: "_getWGSLStructBinding",
      value: function _getWGSLStructBinding(name, vars, access) {
        var binding = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
        var group = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
        var structName = name + 'Struct';
        var structSnippet = this._getWGSLStruct(structName, vars);
        return `${structSnippet}
@binding( ${binding} ) @group( ${group} )
var<${access}> ${name} : ${structName};`;
      }
    }]);
  }(NodeBuilder);
  var WebGPUUtils = /*#__PURE__*/function () {
    function WebGPUUtils(backend) {
      (0, _classCallCheck2.default)(this, WebGPUUtils);
      this.backend = backend;
    }
    return (0, _createClass2.default)(WebGPUUtils, [{
      key: "getCurrentDepthStencilFormat",
      value: function getCurrentDepthStencilFormat(renderContext) {
        var format;
        if (renderContext.depthTexture !== null) {
          format = this.getTextureFormatGPU(renderContext.depthTexture);
        } else if (renderContext.depth && renderContext.stencil) {
          format = GPUTextureFormat.Depth24PlusStencil8;
        } else if (renderContext.depth) {
          format = GPUTextureFormat.Depth24Plus;
        }
        return format;
      }
    }, {
      key: "getTextureFormatGPU",
      value: function getTextureFormatGPU(texture) {
        return this.backend.get(texture).format;
      }
    }, {
      key: "getTextureSampleData",
      value: function getTextureSampleData(texture) {
        var samples;
        if (texture.isFramebufferTexture) {
          samples = 1;
        } else if (texture.isDepthTexture && !texture.renderTarget) {
          var renderer = this.backend.renderer;
          var renderTarget = renderer.getRenderTarget();
          samples = renderTarget ? renderTarget.samples : renderer.samples;
        } else if (texture.renderTarget) {
          samples = texture.renderTarget.samples;
        }
        samples = samples || 1;
        var isMSAA = samples > 1 && texture.renderTarget !== null && texture.isDepthTexture !== true && texture.isFramebufferTexture !== true;
        var primarySamples = isMSAA ? 1 : samples;
        return {
          samples: samples,
          primarySamples: primarySamples,
          isMSAA: isMSAA
        };
      }
    }, {
      key: "getCurrentColorFormat",
      value: function getCurrentColorFormat(renderContext) {
        var format;
        if (renderContext.textures !== null) {
          format = this.getTextureFormatGPU(renderContext.textures[0]);
        } else {
          format = this.getPreferredCanvasFormat(); // default context format
        }
        return format;
      }
    }, {
      key: "getCurrentColorSpace",
      value: function getCurrentColorSpace(renderContext) {
        if (renderContext.textures !== null) {
          return renderContext.textures[0].colorSpace;
        }
        return this.backend.renderer.outputColorSpace;
      }
    }, {
      key: "getPrimitiveTopology",
      value: function getPrimitiveTopology(object, material) {
        if (object.isPoints) return GPUPrimitiveTopology.PointList;else if (object.isLineSegments || object.isMesh && material.wireframe === true) return GPUPrimitiveTopology.LineList;else if (object.isLine) return GPUPrimitiveTopology.LineStrip;else if (object.isMesh) return GPUPrimitiveTopology.TriangleList;
      }
    }, {
      key: "getSampleCount",
      value: function getSampleCount(sampleCount) {
        var count = 1;
        if (sampleCount > 1) {
          // WebGPU only supports power-of-two sample counts and 2 is not a valid value
          count = Math.pow(2, Math.floor(Math.log2(sampleCount)));
          if (count === 2) {
            count = 4;
          }
        }
        return count;
      }
    }, {
      key: "getSampleCountRenderContext",
      value: function getSampleCountRenderContext(renderContext) {
        if (renderContext.textures !== null) {
          return this.getSampleCount(renderContext.sampleCount);
        }
        return this.getSampleCount(this.backend.renderer.samples);
      }
    }, {
      key: "getPreferredCanvasFormat",
      value: function getPreferredCanvasFormat() {
        // TODO: Remove this check when Quest 34.5 is out
        // https://github.com/mrdoob/three.js/pull/29221/files#r1731833949

        if (navigator.userAgent.includes('Quest')) {
          return GPUTextureFormat.BGRA8Unorm;
        } else {
          return navigator.gpu.getPreferredCanvasFormat();
        }
      }
    }]);
  }();
  var typedArraysToVertexFormatPrefix = new Map([[Int8Array, ['sint8', 'snorm8']], [Uint8Array, ['uint8', 'unorm8']], [Int16Array, ['sint16', 'snorm16']], [Uint16Array, ['uint16', 'unorm16']], [Int32Array, ['sint32', 'snorm32']], [Uint32Array, ['uint32', 'unorm32']], [Float32Array, ['float32']]]);
  var typedAttributeToVertexFormatPrefix = new Map([[_$$_REQUIRE(_dependencyMap[1], "./three.core.js").Float16BufferAttribute, ['float16']]]);
  var typeArraysToVertexFormatPrefixForItemSize1 = new Map([[Int32Array, 'sint32'], [Int16Array, 'sint32'],
  // patch for INT16
  [Uint32Array, 'uint32'], [Uint16Array, 'uint32'],
  // patch for UINT16
  [Float32Array, 'float32']]);
  var WebGPUAttributeUtils = /*#__PURE__*/function () {
    function WebGPUAttributeUtils(backend) {
      (0, _classCallCheck2.default)(this, WebGPUAttributeUtils);
      this.backend = backend;
    }
    return (0, _createClass2.default)(WebGPUAttributeUtils, [{
      key: "createAttribute",
      value: function createAttribute(attribute, usage) {
        var bufferAttribute = this._getBufferAttribute(attribute);
        var backend = this.backend;
        var bufferData = backend.get(bufferAttribute);
        var buffer = bufferData.buffer;
        if (buffer === undefined) {
          var device = backend.device;
          var array = bufferAttribute.array;

          // patch for INT16 and UINT16
          if (attribute.normalized === false && (array.constructor === Int16Array || array.constructor === Uint16Array)) {
            var tempArray = new Uint32Array(array.length);
            for (var i = 0; i < array.length; i++) {
              tempArray[i] = array[i];
            }
            array = tempArray;
          }
          bufferAttribute.array = array;
          if ((bufferAttribute.isStorageBufferAttribute || bufferAttribute.isStorageInstancedBufferAttribute) && bufferAttribute.itemSize === 3) {
            array = new array.constructor(bufferAttribute.count * 4);
            for (var _i22 = 0; _i22 < bufferAttribute.count; _i22++) {
              array.set(bufferAttribute.array.subarray(_i22 * 3, _i22 * 3 + 3), _i22 * 4);
            }

            // Update BufferAttribute
            bufferAttribute.itemSize = 4;
            bufferAttribute.array = array;
          }
          var size = array.byteLength + (4 - array.byteLength % 4) % 4; // ensure 4 byte alignment, see #20441

          buffer = device.createBuffer({
            label: bufferAttribute.name,
            size: size,
            usage: usage,
            mappedAtCreation: true
          });
          new array.constructor(buffer.getMappedRange()).set(array);
          buffer.unmap();
          bufferData.buffer = buffer;
        }
      }
    }, {
      key: "updateAttribute",
      value: function updateAttribute(attribute) {
        var bufferAttribute = this._getBufferAttribute(attribute);
        var backend = this.backend;
        var device = backend.device;
        var buffer = backend.get(bufferAttribute).buffer;
        var array = bufferAttribute.array;
        var isTypedArray = this._isTypedArray(array);
        var updateRanges = bufferAttribute.updateRanges;
        if (updateRanges.length === 0) {
          // Not using update ranges

          device.queue.writeBuffer(buffer, 0, array, 0);
        } else {
          var byteOffsetFactor = isTypedArray ? 1 : array.BYTES_PER_ELEMENT;
          for (var i = 0, l = updateRanges.length; i < l; i++) {
            var _range2 = updateRanges[i];
            var dataOffset = _range2.start * byteOffsetFactor;
            var size = _range2.count * byteOffsetFactor;
            device.queue.writeBuffer(buffer, 0, array, dataOffset, size);
          }
          bufferAttribute.clearUpdateRanges();
        }
      }
    }, {
      key: "createShaderVertexBuffers",
      value: function createShaderVertexBuffers(renderObject) {
        var attributes = renderObject.getAttributes();
        var vertexBuffers = new Map();
        for (var slot = 0; slot < attributes.length; slot++) {
          var geometryAttribute = attributes[slot];
          var bytesPerElement = geometryAttribute.array.BYTES_PER_ELEMENT;
          var _bufferAttribute4 = this._getBufferAttribute(geometryAttribute);
          var vertexBufferLayout = vertexBuffers.get(_bufferAttribute4);
          if (vertexBufferLayout === undefined) {
            var arrayStride = void 0,
              stepMode = void 0;
            if (geometryAttribute.isInterleavedBufferAttribute === true) {
              arrayStride = geometryAttribute.data.stride * bytesPerElement;
              stepMode = geometryAttribute.data.isInstancedInterleavedBuffer ? GPUInputStepMode.Instance : GPUInputStepMode.Vertex;
            } else {
              arrayStride = geometryAttribute.itemSize * bytesPerElement;
              stepMode = geometryAttribute.isInstancedBufferAttribute ? GPUInputStepMode.Instance : GPUInputStepMode.Vertex;
            }

            // patch for INT16 and UINT16
            if (geometryAttribute.normalized === false && (geometryAttribute.array.constructor === Int16Array || geometryAttribute.array.constructor === Uint16Array)) {
              arrayStride = 4;
            }
            vertexBufferLayout = {
              arrayStride: arrayStride,
              attributes: [],
              stepMode: stepMode
            };
            vertexBuffers.set(_bufferAttribute4, vertexBufferLayout);
          }
          var format = this._getVertexFormat(geometryAttribute);
          var offset = geometryAttribute.isInterleavedBufferAttribute === true ? geometryAttribute.offset * bytesPerElement : 0;
          vertexBufferLayout.attributes.push({
            shaderLocation: slot,
            offset: offset,
            format: format
          });
        }
        return Array.from(vertexBuffers.values());
      }
    }, {
      key: "destroyAttribute",
      value: function destroyAttribute(attribute) {
        var backend = this.backend;
        var data = backend.get(this._getBufferAttribute(attribute));
        data.buffer.destroy();
        backend.delete(attribute);
      }
    }, {
      key: "getArrayBufferAsync",
      value: function () {
        var _getArrayBufferAsync4 = (0, _asyncToGenerator2.default)(function* (attribute) {
          var backend = this.backend;
          var device = backend.device;
          var data = backend.get(this._getBufferAttribute(attribute));
          var bufferGPU = data.buffer;
          var size = bufferGPU.size;
          var readBufferGPU = device.createBuffer({
            label: `${attribute.name}_readback`,
            size: size,
            usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ
          });
          var cmdEncoder = device.createCommandEncoder({
            label: `readback_encoder_${attribute.name}`
          });
          cmdEncoder.copyBufferToBuffer(bufferGPU, 0, readBufferGPU, 0, size);
          var gpuCommands = cmdEncoder.finish();
          device.queue.submit([gpuCommands]);
          yield readBufferGPU.mapAsync(GPUMapMode.READ);
          var arrayBuffer = readBufferGPU.getMappedRange();
          var dstBuffer = new attribute.array.constructor(arrayBuffer.slice(0));
          readBufferGPU.unmap();
          return dstBuffer.buffer;
        });
        function getArrayBufferAsync(_x43) {
          return _getArrayBufferAsync4.apply(this, arguments);
        }
        return getArrayBufferAsync;
      }()
    }, {
      key: "_getVertexFormat",
      value: function _getVertexFormat(geometryAttribute) {
        var itemSize = geometryAttribute.itemSize,
          normalized = geometryAttribute.normalized;
        var ArrayType = geometryAttribute.array.constructor;
        var AttributeType = geometryAttribute.constructor;
        var format;
        if (itemSize === 1) {
          format = typeArraysToVertexFormatPrefixForItemSize1.get(ArrayType);
        } else {
          var prefixOptions = typedAttributeToVertexFormatPrefix.get(AttributeType) || typedArraysToVertexFormatPrefix.get(ArrayType);
          var prefix = prefixOptions[normalized ? 1 : 0];
          if (prefix) {
            var bytesPerUnit = ArrayType.BYTES_PER_ELEMENT * itemSize;
            var paddedBytesPerUnit = Math.floor((bytesPerUnit + 3) / 4) * 4;
            var paddedItemSize = paddedBytesPerUnit / ArrayType.BYTES_PER_ELEMENT;
            if (paddedItemSize % 1) {
              throw new Error('THREE.WebGPUAttributeUtils: Bad vertex format item size.');
            }
            format = `${prefix}x${paddedItemSize}`;
          }
        }
        if (!format) {
          console.error('THREE.WebGPUAttributeUtils: Vertex format not supported yet.');
        }
        return format;
      }
    }, {
      key: "_isTypedArray",
      value: function _isTypedArray(array) {
        return ArrayBuffer.isView(array) && !(array instanceof DataView);
      }
    }, {
      key: "_getBufferAttribute",
      value: function _getBufferAttribute(attribute) {
        if (attribute.isInterleavedBufferAttribute) attribute = attribute.data;
        return attribute;
      }
    }]);
  }();
  var WebGPUBindingUtils = /*#__PURE__*/function () {
    function WebGPUBindingUtils(backend) {
      (0, _classCallCheck2.default)(this, WebGPUBindingUtils);
      this.backend = backend;
      this.bindGroupLayoutCache = new WeakMap();
    }
    return (0, _createClass2.default)(WebGPUBindingUtils, [{
      key: "createBindingsLayout",
      value: function createBindingsLayout(bindGroup) {
        var backend = this.backend;
        var device = backend.device;
        var entries = [];
        var index = 0;
        for (var binding of bindGroup.bindings) {
          var bindingGPU = {
            binding: index++,
            visibility: binding.visibility
          };
          if (binding.isUniformBuffer || binding.isStorageBuffer) {
            var _buffer6 = {}; // GPUBufferBindingLayout

            if (binding.isStorageBuffer) {
              if (binding.visibility & 4) {
                // compute

                if (binding.access === NodeAccess.READ_WRITE || binding.access === NodeAccess.WRITE_ONLY) {
                  _buffer6.type = GPUBufferBindingType.Storage;
                } else {
                  _buffer6.type = GPUBufferBindingType.ReadOnlyStorage;
                }
              } else {
                _buffer6.type = GPUBufferBindingType.ReadOnlyStorage;
              }
            }
            bindingGPU.buffer = _buffer6;
          } else if (binding.isSampler) {
            var _sampler2 = {}; // GPUSamplerBindingLayout

            if (binding.texture.isDepthTexture) {
              if (binding.texture.compareFunction !== null) {
                _sampler2.type = 'comparison';
              }
            }
            bindingGPU.sampler = _sampler2;
          } else if (binding.isSampledTexture && binding.texture.isVideoTexture) {
            bindingGPU.externalTexture = {}; // GPUExternalTextureBindingLayout
          } else if (binding.isSampledTexture && binding.store) {
            var _storageTexture = {}; // GPUStorageTextureBindingLayout
            _storageTexture.format = this.backend.get(binding.texture).texture.format;
            var access = binding.access;
            if (access === NodeAccess.READ_WRITE) {
              _storageTexture.access = GPUStorageTextureAccess.ReadWrite;
            } else if (access === NodeAccess.WRITE_ONLY) {
              _storageTexture.access = GPUStorageTextureAccess.WriteOnly;
            } else {
              _storageTexture.access = GPUStorageTextureAccess.ReadOnly;
            }
            bindingGPU.storageTexture = _storageTexture;
          } else if (binding.isSampledTexture) {
            var _texture14 = {}; // GPUTextureBindingLayout

            var _backend$utils$getTex2 = backend.utils.getTextureSampleData(binding.texture),
              primarySamples = _backend$utils$getTex2.primarySamples;
            if (primarySamples > 1) {
              _texture14.multisampled = true;
              if (!binding.texture.isDepthTexture) {
                _texture14.sampleType = GPUTextureSampleType.UnfilterableFloat;
              }
            }
            if (binding.texture.isDepthTexture) {
              _texture14.sampleType = GPUTextureSampleType.Depth;
            } else if (binding.texture.isDataTexture || binding.texture.isDataArrayTexture || binding.texture.isData3DTexture) {
              var type = binding.texture.type;
              if (type === _$$_REQUIRE(_dependencyMap[1], "./three.core.js").IntType) {
                _texture14.sampleType = GPUTextureSampleType.SInt;
              } else if (type === _$$_REQUIRE(_dependencyMap[1], "./three.core.js").UnsignedIntType) {
                _texture14.sampleType = GPUTextureSampleType.UInt;
              } else if (type === _$$_REQUIRE(_dependencyMap[1], "./three.core.js").FloatType) {
                if (this.backend.hasFeature('float32-filterable')) {
                  _texture14.sampleType = GPUTextureSampleType.Float;
                } else {
                  _texture14.sampleType = GPUTextureSampleType.UnfilterableFloat;
                }
              }
            }
            if (binding.isSampledCubeTexture) {
              _texture14.viewDimension = GPUTextureViewDimension.Cube;
            } else if (binding.texture.isDataArrayTexture || binding.texture.isCompressedArrayTexture) {
              _texture14.viewDimension = GPUTextureViewDimension.TwoDArray;
            } else if (binding.isSampledTexture3D) {
              _texture14.viewDimension = GPUTextureViewDimension.ThreeD;
            }
            bindingGPU.texture = _texture14;
          } else {
            console.error(`WebGPUBindingUtils: Unsupported binding "${binding}".`);
          }
          entries.push(bindingGPU);
        }
        return device.createBindGroupLayout({
          entries: entries
        });
      }
    }, {
      key: "createBindings",
      value: function createBindings(bindGroup, bindings, cacheIndex) {
        var version = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
        var backend = this.backend,
          bindGroupLayoutCache = this.bindGroupLayoutCache;
        var bindingsData = backend.get(bindGroup);

        // setup (static) binding layout and (dynamic) binding group

        var bindLayoutGPU = bindGroupLayoutCache.get(bindGroup.bindingsReference);
        if (bindLayoutGPU === undefined) {
          bindLayoutGPU = this.createBindingsLayout(bindGroup);
          bindGroupLayoutCache.set(bindGroup.bindingsReference, bindLayoutGPU);
        }
        var bindGroupGPU;
        if (cacheIndex > 0) {
          if (bindingsData.groups === undefined) {
            bindingsData.groups = [];
            bindingsData.versions = [];
          }
          if (bindingsData.versions[cacheIndex] === version) {
            bindGroupGPU = bindingsData.groups[cacheIndex];
          }
        }
        if (bindGroupGPU === undefined) {
          bindGroupGPU = this.createBindGroup(bindGroup, bindLayoutGPU);
          if (cacheIndex > 0) {
            bindingsData.groups[cacheIndex] = bindGroupGPU;
            bindingsData.versions[cacheIndex] = version;
          }
        }
        bindingsData.group = bindGroupGPU;
        bindingsData.layout = bindLayoutGPU;
      }
    }, {
      key: "updateBinding",
      value: function updateBinding(binding) {
        var backend = this.backend;
        var device = backend.device;
        var buffer = binding.buffer;
        var bufferGPU = backend.get(binding).buffer;
        device.queue.writeBuffer(bufferGPU, 0, buffer, 0);
      }
    }, {
      key: "createBindGroup",
      value: function createBindGroup(bindGroup, layoutGPU) {
        var backend = this.backend;
        var device = backend.device;
        var bindingPoint = 0;
        var entriesGPU = [];
        for (var binding of bindGroup.bindings) {
          if (binding.isUniformBuffer) {
            var bindingData = backend.get(binding);
            if (bindingData.buffer === undefined) {
              var byteLength = binding.byteLength;
              var usage = GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST;
              var bufferGPU = device.createBuffer({
                label: 'bindingBuffer_' + binding.name,
                size: byteLength,
                usage: usage
              });
              bindingData.buffer = bufferGPU;
            }
            entriesGPU.push({
              binding: bindingPoint,
              resource: {
                buffer: bindingData.buffer
              }
            });
          } else if (binding.isStorageBuffer) {
            var _bindingData = backend.get(binding);
            if (_bindingData.buffer === undefined) {
              var _attribute15 = binding.attribute;
              //const usage = GPUBufferUsage.STORAGE | GPUBufferUsage.VERTEX | /*GPUBufferUsage.COPY_SRC |*/ GPUBufferUsage.COPY_DST;

              //backend.attributeUtils.createAttribute( attribute, usage ); // @TODO: Move it to universal renderer

              _bindingData.buffer = backend.get(_attribute15).buffer;
            }
            entriesGPU.push({
              binding: bindingPoint,
              resource: {
                buffer: _bindingData.buffer
              }
            });
          } else if (binding.isSampler) {
            var textureGPU = backend.get(binding.texture);
            entriesGPU.push({
              binding: bindingPoint,
              resource: textureGPU.sampler
            });
          } else if (binding.isSampledTexture) {
            var textureData = backend.get(binding.texture);
            var resourceGPU = void 0;
            if (textureData.externalTexture !== undefined) {
              resourceGPU = device.importExternalTexture({
                source: textureData.externalTexture
              });
            } else {
              var mipLevelCount = binding.store ? 1 : textureData.texture.mipLevelCount;
              var propertyName = `view-${textureData.texture.width}-${textureData.texture.height}-${mipLevelCount}`;
              resourceGPU = textureData[propertyName];
              if (resourceGPU === undefined) {
                var aspectGPU = GPUTextureAspect.All;
                var dimensionViewGPU = void 0;
                if (binding.isSampledCubeTexture) {
                  dimensionViewGPU = GPUTextureViewDimension.Cube;
                } else if (binding.isSampledTexture3D) {
                  dimensionViewGPU = GPUTextureViewDimension.ThreeD;
                } else if (binding.texture.isDataArrayTexture || binding.texture.isCompressedArrayTexture) {
                  dimensionViewGPU = GPUTextureViewDimension.TwoDArray;
                } else {
                  dimensionViewGPU = GPUTextureViewDimension.TwoD;
                }
                resourceGPU = textureData[propertyName] = textureData.texture.createView({
                  aspect: aspectGPU,
                  dimension: dimensionViewGPU,
                  mipLevelCount: mipLevelCount
                });
              }
            }
            entriesGPU.push({
              binding: bindingPoint,
              resource: resourceGPU
            });
          }
          bindingPoint++;
        }
        return device.createBindGroup({
          label: 'bindGroup_' + bindGroup.name,
          layout: layoutGPU,
          entries: entriesGPU
        });
      }
    }]);
  }();
  var WebGPUPipelineUtils = /*#__PURE__*/function () {
    function WebGPUPipelineUtils(backend) {
      (0, _classCallCheck2.default)(this, WebGPUPipelineUtils);
      this.backend = backend;
    }
    return (0, _createClass2.default)(WebGPUPipelineUtils, [{
      key: "_getSampleCount",
      value: function _getSampleCount(renderObjectContext) {
        return this.backend.utils.getSampleCountRenderContext(renderObjectContext);
      }
    }, {
      key: "createRenderPipeline",
      value: function createRenderPipeline(renderObject, promises) {
        var object = renderObject.object,
          material = renderObject.material,
          geometry = renderObject.geometry,
          pipeline = renderObject.pipeline;
        var vertexProgram = pipeline.vertexProgram,
          fragmentProgram = pipeline.fragmentProgram;
        var backend = this.backend;
        var device = backend.device;
        var utils = backend.utils;
        var pipelineData = backend.get(pipeline);

        // bind group layouts

        var bindGroupLayouts = [];
        for (var bindGroup of renderObject.getBindings()) {
          var bindingsData = backend.get(bindGroup);
          bindGroupLayouts.push(bindingsData.layout);
        }

        // vertex buffers

        var vertexBuffers = backend.attributeUtils.createShaderVertexBuffers(renderObject);

        // blending

        var blending;
        if (material.transparent === true && material.blending !== _$$_REQUIRE(_dependencyMap[1], "./three.core.js").NoBlending) {
          blending = this._getBlending(material);
        }

        // stencil

        var stencilFront = {};
        if (material.stencilWrite === true) {
          stencilFront = {
            compare: this._getStencilCompare(material),
            failOp: this._getStencilOperation(material.stencilFail),
            depthFailOp: this._getStencilOperation(material.stencilZFail),
            passOp: this._getStencilOperation(material.stencilZPass)
          };
        }
        var colorWriteMask = this._getColorWriteMask(material);
        var targets = [];
        if (renderObject.context.textures !== null) {
          var textures = renderObject.context.textures;
          for (var i = 0; i < textures.length; i++) {
            var colorFormat = utils.getTextureFormatGPU(textures[i]);
            targets.push({
              format: colorFormat,
              blend: blending,
              writeMask: colorWriteMask
            });
          }
        } else {
          var _colorFormat = utils.getCurrentColorFormat(renderObject.context);
          targets.push({
            format: _colorFormat,
            blend: blending,
            writeMask: colorWriteMask
          });
        }
        var vertexModule = backend.get(vertexProgram).module;
        var fragmentModule = backend.get(fragmentProgram).module;
        var primitiveState = this._getPrimitiveState(object, geometry, material);
        var depthCompare = this._getDepthCompare(material);
        var depthStencilFormat = utils.getCurrentDepthStencilFormat(renderObject.context);
        var sampleCount = this._getSampleCount(renderObject.context);
        var pipelineDescriptor = {
          label: `renderPipeline_${material.name || material.type}_${material.id}`,
          vertex: Object.assign({}, vertexModule, {
            buffers: vertexBuffers
          }),
          fragment: Object.assign({}, fragmentModule, {
            targets: targets
          }),
          primitive: primitiveState,
          multisample: {
            count: sampleCount,
            alphaToCoverageEnabled: material.alphaToCoverage && sampleCount > 1
          },
          layout: device.createPipelineLayout({
            bindGroupLayouts: bindGroupLayouts
          })
        };
        var depthStencil = {};
        var renderDepth = renderObject.context.depth;
        var renderStencil = renderObject.context.stencil;
        if (renderDepth === true || renderStencil === true) {
          if (renderDepth === true) {
            depthStencil.format = depthStencilFormat;
            depthStencil.depthWriteEnabled = material.depthWrite;
            depthStencil.depthCompare = depthCompare;
          }
          if (renderStencil === true) {
            depthStencil.stencilFront = stencilFront;
            depthStencil.stencilBack = {}; // three.js does not provide an API to configure the back function (gl.stencilFuncSeparate() was never used)
            depthStencil.stencilReadMask = material.stencilFuncMask;
            depthStencil.stencilWriteMask = material.stencilWriteMask;
          }
          pipelineDescriptor.depthStencil = depthStencil;
        }
        if (promises === null) {
          pipelineData.pipeline = device.createRenderPipeline(pipelineDescriptor);
        } else {
          var p = new Promise(function (resolve /*, reject*/) {
            device.createRenderPipelineAsync(pipelineDescriptor).then(function (pipeline) {
              pipelineData.pipeline = pipeline;
              resolve();
            });
          });
          promises.push(p);
        }
      }
    }, {
      key: "createBundleEncoder",
      value: function createBundleEncoder(renderContext) {
        var backend = this.backend;
        var utils = backend.utils,
          device = backend.device;
        var depthStencilFormat = utils.getCurrentDepthStencilFormat(renderContext);
        var colorFormat = utils.getCurrentColorFormat(renderContext);
        var sampleCount = this._getSampleCount(renderContext);
        var descriptor = {
          label: 'renderBundleEncoder',
          colorFormats: [colorFormat],
          depthStencilFormat: depthStencilFormat,
          sampleCount: sampleCount
        };
        return device.createRenderBundleEncoder(descriptor);
      }
    }, {
      key: "createComputePipeline",
      value: function createComputePipeline(pipeline, bindings) {
        var backend = this.backend;
        var device = backend.device;
        var computeProgram = backend.get(pipeline.computeProgram).module;
        var pipelineGPU = backend.get(pipeline);

        // bind group layouts

        var bindGroupLayouts = [];
        for (var bindingsGroup of bindings) {
          var bindingsData = backend.get(bindingsGroup);
          bindGroupLayouts.push(bindingsData.layout);
        }
        pipelineGPU.pipeline = device.createComputePipeline({
          compute: computeProgram,
          layout: device.createPipelineLayout({
            bindGroupLayouts: bindGroupLayouts
          })
        });
      }
    }, {
      key: "_getBlending",
      value: function _getBlending(material) {
        var color, alpha;
        var blending = material.blending;
        var blendSrc = material.blendSrc;
        var blendDst = material.blendDst;
        var blendEquation = material.blendEquation;
        if (blending === _$$_REQUIRE(_dependencyMap[1], "./three.core.js").CustomBlending) {
          var blendSrcAlpha = material.blendSrcAlpha !== null ? material.blendSrcAlpha : blendSrc;
          var blendDstAlpha = material.blendDstAlpha !== null ? material.blendDstAlpha : blendDst;
          var blendEquationAlpha = material.blendEquationAlpha !== null ? material.blendEquationAlpha : blendEquation;
          color = {
            srcFactor: this._getBlendFactor(blendSrc),
            dstFactor: this._getBlendFactor(blendDst),
            operation: this._getBlendOperation(blendEquation)
          };
          alpha = {
            srcFactor: this._getBlendFactor(blendSrcAlpha),
            dstFactor: this._getBlendFactor(blendDstAlpha),
            operation: this._getBlendOperation(blendEquationAlpha)
          };
        } else {
          var premultipliedAlpha = material.premultipliedAlpha;
          var setBlend = function setBlend(srcRGB, dstRGB, srcAlpha, dstAlpha) {
            color = {
              srcFactor: srcRGB,
              dstFactor: dstRGB,
              operation: GPUBlendOperation.Add
            };
            alpha = {
              srcFactor: srcAlpha,
              dstFactor: dstAlpha,
              operation: GPUBlendOperation.Add
            };
          };
          if (premultipliedAlpha) {
            switch (blending) {
              case _$$_REQUIRE(_dependencyMap[1], "./three.core.js").NormalBlending:
                setBlend(GPUBlendFactor.One, GPUBlendFactor.OneMinusSrcAlpha, GPUBlendFactor.One, GPUBlendFactor.OneMinusSrcAlpha);
                break;
              case _$$_REQUIRE(_dependencyMap[1], "./three.core.js").AdditiveBlending:
                setBlend(GPUBlendFactor.One, GPUBlendFactor.One, GPUBlendFactor.One, GPUBlendFactor.One);
                break;
              case _$$_REQUIRE(_dependencyMap[1], "./three.core.js").SubtractiveBlending:
                setBlend(GPUBlendFactor.Zero, GPUBlendFactor.OneMinusSrc, GPUBlendFactor.Zero, GPUBlendFactor.One);
                break;
              case _$$_REQUIRE(_dependencyMap[1], "./three.core.js").MultiplyBlending:
                setBlend(GPUBlendFactor.Zero, GPUBlendFactor.Src, GPUBlendFactor.Zero, GPUBlendFactor.SrcAlpha);
                break;
            }
          } else {
            switch (blending) {
              case _$$_REQUIRE(_dependencyMap[1], "./three.core.js").NormalBlending:
                setBlend(GPUBlendFactor.SrcAlpha, GPUBlendFactor.OneMinusSrcAlpha, GPUBlendFactor.One, GPUBlendFactor.OneMinusSrcAlpha);
                break;
              case _$$_REQUIRE(_dependencyMap[1], "./three.core.js").AdditiveBlending:
                setBlend(GPUBlendFactor.SrcAlpha, GPUBlendFactor.One, GPUBlendFactor.SrcAlpha, GPUBlendFactor.One);
                break;
              case _$$_REQUIRE(_dependencyMap[1], "./three.core.js").SubtractiveBlending:
                setBlend(GPUBlendFactor.Zero, GPUBlendFactor.OneMinusSrc, GPUBlendFactor.Zero, GPUBlendFactor.One);
                break;
              case _$$_REQUIRE(_dependencyMap[1], "./three.core.js").MultiplyBlending:
                setBlend(GPUBlendFactor.Zero, GPUBlendFactor.Src, GPUBlendFactor.Zero, GPUBlendFactor.Src);
                break;
            }
          }
        }
        if (color !== undefined && alpha !== undefined) {
          return {
            color: color,
            alpha: alpha
          };
        } else {
          console.error('THREE.WebGPURenderer: Invalid blending: ', blending);
        }
      }
    }, {
      key: "_getBlendFactor",
      value: function _getBlendFactor(blend) {
        var blendFactor;
        switch (blend) {
          case _$$_REQUIRE(_dependencyMap[1], "./three.core.js").ZeroFactor:
            blendFactor = GPUBlendFactor.Zero;
            break;
          case _$$_REQUIRE(_dependencyMap[1], "./three.core.js").OneFactor:
            blendFactor = GPUBlendFactor.One;
            break;
          case _$$_REQUIRE(_dependencyMap[1], "./three.core.js").SrcColorFactor:
            blendFactor = GPUBlendFactor.Src;
            break;
          case _$$_REQUIRE(_dependencyMap[1], "./three.core.js").OneMinusSrcColorFactor:
            blendFactor = GPUBlendFactor.OneMinusSrc;
            break;
          case _$$_REQUIRE(_dependencyMap[1], "./three.core.js").SrcAlphaFactor:
            blendFactor = GPUBlendFactor.SrcAlpha;
            break;
          case _$$_REQUIRE(_dependencyMap[1], "./three.core.js").OneMinusSrcAlphaFactor:
            blendFactor = GPUBlendFactor.OneMinusSrcAlpha;
            break;
          case _$$_REQUIRE(_dependencyMap[1], "./three.core.js").DstColorFactor:
            blendFactor = GPUBlendFactor.Dst;
            break;
          case _$$_REQUIRE(_dependencyMap[1], "./three.core.js").OneMinusDstColorFactor:
            blendFactor = GPUBlendFactor.OneMinusDstColor;
            break;
          case _$$_REQUIRE(_dependencyMap[1], "./three.core.js").DstAlphaFactor:
            blendFactor = GPUBlendFactor.DstAlpha;
            break;
          case _$$_REQUIRE(_dependencyMap[1], "./three.core.js").OneMinusDstAlphaFactor:
            blendFactor = GPUBlendFactor.OneMinusDstAlpha;
            break;
          case _$$_REQUIRE(_dependencyMap[1], "./three.core.js").SrcAlphaSaturateFactor:
            blendFactor = GPUBlendFactor.SrcAlphaSaturated;
            break;
          case BlendColorFactor:
            blendFactor = GPUBlendFactor.Constant;
            break;
          case OneMinusBlendColorFactor:
            blendFactor = GPUBlendFactor.OneMinusConstant;
            break;
          default:
            console.error('THREE.WebGPURenderer: Blend factor not supported.', blend);
        }
        return blendFactor;
      }
    }, {
      key: "_getStencilCompare",
      value: function _getStencilCompare(material) {
        var stencilCompare;
        var stencilFunc = material.stencilFunc;
        switch (stencilFunc) {
          case _$$_REQUIRE(_dependencyMap[1], "./three.core.js").NeverStencilFunc:
            stencilCompare = GPUCompareFunction.Never;
            break;
          case _$$_REQUIRE(_dependencyMap[1], "./three.core.js").AlwaysStencilFunc:
            stencilCompare = GPUCompareFunction.Always;
            break;
          case _$$_REQUIRE(_dependencyMap[1], "./three.core.js").LessStencilFunc:
            stencilCompare = GPUCompareFunction.Less;
            break;
          case _$$_REQUIRE(_dependencyMap[1], "./three.core.js").LessEqualStencilFunc:
            stencilCompare = GPUCompareFunction.LessEqual;
            break;
          case _$$_REQUIRE(_dependencyMap[1], "./three.core.js").EqualStencilFunc:
            stencilCompare = GPUCompareFunction.Equal;
            break;
          case _$$_REQUIRE(_dependencyMap[1], "./three.core.js").GreaterEqualStencilFunc:
            stencilCompare = GPUCompareFunction.GreaterEqual;
            break;
          case _$$_REQUIRE(_dependencyMap[1], "./three.core.js").GreaterStencilFunc:
            stencilCompare = GPUCompareFunction.Greater;
            break;
          case _$$_REQUIRE(_dependencyMap[1], "./three.core.js").NotEqualStencilFunc:
            stencilCompare = GPUCompareFunction.NotEqual;
            break;
          default:
            console.error('THREE.WebGPURenderer: Invalid stencil function.', stencilFunc);
        }
        return stencilCompare;
      }
    }, {
      key: "_getStencilOperation",
      value: function _getStencilOperation(op) {
        var stencilOperation;
        switch (op) {
          case _$$_REQUIRE(_dependencyMap[1], "./three.core.js").KeepStencilOp:
            stencilOperation = GPUStencilOperation.Keep;
            break;
          case _$$_REQUIRE(_dependencyMap[1], "./three.core.js").ZeroStencilOp:
            stencilOperation = GPUStencilOperation.Zero;
            break;
          case _$$_REQUIRE(_dependencyMap[1], "./three.core.js").ReplaceStencilOp:
            stencilOperation = GPUStencilOperation.Replace;
            break;
          case _$$_REQUIRE(_dependencyMap[1], "./three.core.js").InvertStencilOp:
            stencilOperation = GPUStencilOperation.Invert;
            break;
          case _$$_REQUIRE(_dependencyMap[1], "./three.core.js").IncrementStencilOp:
            stencilOperation = GPUStencilOperation.IncrementClamp;
            break;
          case _$$_REQUIRE(_dependencyMap[1], "./three.core.js").DecrementStencilOp:
            stencilOperation = GPUStencilOperation.DecrementClamp;
            break;
          case _$$_REQUIRE(_dependencyMap[1], "./three.core.js").IncrementWrapStencilOp:
            stencilOperation = GPUStencilOperation.IncrementWrap;
            break;
          case _$$_REQUIRE(_dependencyMap[1], "./three.core.js").DecrementWrapStencilOp:
            stencilOperation = GPUStencilOperation.DecrementWrap;
            break;
          default:
            console.error('THREE.WebGPURenderer: Invalid stencil operation.', stencilOperation);
        }
        return stencilOperation;
      }
    }, {
      key: "_getBlendOperation",
      value: function _getBlendOperation(blendEquation) {
        var blendOperation;
        switch (blendEquation) {
          case _$$_REQUIRE(_dependencyMap[1], "./three.core.js").AddEquation:
            blendOperation = GPUBlendOperation.Add;
            break;
          case _$$_REQUIRE(_dependencyMap[1], "./three.core.js").SubtractEquation:
            blendOperation = GPUBlendOperation.Subtract;
            break;
          case _$$_REQUIRE(_dependencyMap[1], "./three.core.js").ReverseSubtractEquation:
            blendOperation = GPUBlendOperation.ReverseSubtract;
            break;
          case _$$_REQUIRE(_dependencyMap[1], "./three.core.js").MinEquation:
            blendOperation = GPUBlendOperation.Min;
            break;
          case _$$_REQUIRE(_dependencyMap[1], "./three.core.js").MaxEquation:
            blendOperation = GPUBlendOperation.Max;
            break;
          default:
            console.error('THREE.WebGPUPipelineUtils: Blend equation not supported.', blendEquation);
        }
        return blendOperation;
      }
    }, {
      key: "_getPrimitiveState",
      value: function _getPrimitiveState(object, geometry, material) {
        var descriptor = {};
        var utils = this.backend.utils;
        descriptor.topology = utils.getPrimitiveTopology(object, material);
        if (geometry.index !== null && object.isLine === true && object.isLineSegments !== true) {
          descriptor.stripIndexFormat = geometry.index.array instanceof Uint16Array ? GPUIndexFormat.Uint16 : GPUIndexFormat.Uint32;
        }
        switch (material.side) {
          case _$$_REQUIRE(_dependencyMap[1], "./three.core.js").FrontSide:
            descriptor.frontFace = GPUFrontFace.CCW;
            descriptor.cullMode = GPUCullMode.Back;
            break;
          case _$$_REQUIRE(_dependencyMap[1], "./three.core.js").BackSide:
            descriptor.frontFace = GPUFrontFace.CCW;
            descriptor.cullMode = GPUCullMode.Front;
            break;
          case _$$_REQUIRE(_dependencyMap[1], "./three.core.js").DoubleSide:
            descriptor.frontFace = GPUFrontFace.CCW;
            descriptor.cullMode = GPUCullMode.None;
            break;
          default:
            console.error('THREE.WebGPUPipelineUtils: Unknown material.side value.', material.side);
            break;
        }
        return descriptor;
      }
    }, {
      key: "_getColorWriteMask",
      value: function _getColorWriteMask(material) {
        return material.colorWrite === true ? GPUColorWriteFlags.All : GPUColorWriteFlags.None;
      }
    }, {
      key: "_getDepthCompare",
      value: function _getDepthCompare(material) {
        var depthCompare;
        if (material.depthTest === false) {
          depthCompare = GPUCompareFunction.Always;
        } else {
          var depthFunc = material.depthFunc;
          switch (depthFunc) {
            case _$$_REQUIRE(_dependencyMap[1], "./three.core.js").NeverDepth:
              depthCompare = GPUCompareFunction.Never;
              break;
            case _$$_REQUIRE(_dependencyMap[1], "./three.core.js").AlwaysDepth:
              depthCompare = GPUCompareFunction.Always;
              break;
            case _$$_REQUIRE(_dependencyMap[1], "./three.core.js").LessDepth:
              depthCompare = GPUCompareFunction.Less;
              break;
            case _$$_REQUIRE(_dependencyMap[1], "./three.core.js").LessEqualDepth:
              depthCompare = GPUCompareFunction.LessEqual;
              break;
            case _$$_REQUIRE(_dependencyMap[1], "./three.core.js").EqualDepth:
              depthCompare = GPUCompareFunction.Equal;
              break;
            case _$$_REQUIRE(_dependencyMap[1], "./three.core.js").GreaterEqualDepth:
              depthCompare = GPUCompareFunction.GreaterEqual;
              break;
            case _$$_REQUIRE(_dependencyMap[1], "./three.core.js").GreaterDepth:
              depthCompare = GPUCompareFunction.Greater;
              break;
            case _$$_REQUIRE(_dependencyMap[1], "./three.core.js").NotEqualDepth:
              depthCompare = GPUCompareFunction.NotEqual;
              break;
            default:
              console.error('THREE.WebGPUPipelineUtils: Invalid depth function.', depthFunc);
          }
        }
        return depthCompare;
      }
    }]);
  }();
  /*// debugger tools
  import 'https://greggman.github.io/webgpu-avoid-redundant-state-setting/webgpu-check-redundant-state-setting.js';
  //*/
  /**
   * A backend implementation targeting WebGPU.
   *
   * @private
   * @augments Backend
   */
  var WebGPUBackend = /*#__PURE__*/function (_Backend2) {
    /**
     * Constructs a new WebGPU backend.
     *
     * @param {Object} parameters - The configuration parameter.
     * @param {Boolean} [parameters.logarithmicDepthBuffer=false] - Whether logarithmic depth buffer is enabled or not.
     * @param {Boolean} [parameters.alpha=true] - Whether the default framebuffer (which represents the final contents of the canvas) should be transparent or opaque.
     * @param {Boolean} [parameters.depth=true] - Whether the default framebuffer should have a depth buffer or not.
     * @param {Boolean} [parameters.stencil=false] - Whether the default framebuffer should have a stencil buffer or not.
     * @param {Boolean} [parameters.antialias=false] - Whether MSAA as the default anti-aliasing should be enabled or not.
     * @param {Number} [parameters.samples=0] - When `antialias` is `true`, `4` samples are used by default. Set this parameter to any other integer value than 0 to overwrite the default.
     * @param {Boolean} [parameters.forceWebGL=false] - If set to `true`, the renderer uses it WebGL 2 backend no matter if WebGPU is supported or not.
     * @param {Boolean} [parameters.trackTimestamp=false] - Whether to track timestamps with a Timestamp Query API or not.
     * @param {String?} [parameters.powerPreference=null] - The power preference.
     * @param {String?} [parameters.requiredLimits={}] - Specifies the limits that are required by the device request.
     * The request will fail if the adapter cannot provide these limits.
     */
    function WebGPUBackend() {
      var _this214;
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      (0, _classCallCheck2.default)(this, WebGPUBackend);
      _this214 = _callSuper(this, WebGPUBackend, [parameters]);

      /**
       * This flag can be used for type testing.
       *
       * @type {Boolean}
       * @readonly
       * @default true
       */
      _this214.isWebGPUBackend = true;

      // some parameters require default values other than "undefined"
      _this214.parameters.alpha = parameters.alpha === undefined ? true : parameters.alpha;
      _this214.parameters.requiredLimits = parameters.requiredLimits === undefined ? {} : parameters.requiredLimits;

      /**
       * Whether to track timestamps with a Timestamp Query API or not.
       *
       * @type {Boolean}
       * @default false
       */
      _this214.trackTimestamp = parameters.trackTimestamp === true;

      /**
       * A reference to the device.
       *
       * @type {GPUDevice?}
       * @default null
       */
      _this214.device = null;

      /**
       * A reference to the context.
       *
       * @type {GPUCanvasContext?}
       * @default null
       */
      _this214.context = null;

      /**
       * A reference to the color attachment of the default framebuffer.
       *
       * @type {GPUTexture?}
       * @default null
       */
      _this214.colorBuffer = null;

      /**
       * A reference to the default render pass descriptor.
       *
       * @type {Object?}
       * @default null
       */
      _this214.defaultRenderPassdescriptor = null;

      /**
       * A reference to a backend module holding common utility functions.
       *
       * @type {WebGPUUtils}
       */
      _this214.utils = new WebGPUUtils(_this214);

      /**
       * A reference to a backend module holding shader attribute-related
       * utility functions.
       *
       * @type {WebGPUAttributeUtils}
       */
      _this214.attributeUtils = new WebGPUAttributeUtils(_this214);

      /**
       * A reference to a backend module holding shader binding-related
       * utility functions.
       *
       * @type {WebGPUBindingUtils}
       */
      _this214.bindingUtils = new WebGPUBindingUtils(_this214);

      /**
       * A reference to a backend module holding shader pipeline-related
       * utility functions.
       *
       * @type {WebGPUPipelineUtils}
       */
      _this214.pipelineUtils = new WebGPUPipelineUtils(_this214);

      /**
       * A reference to a backend module holding shader texture-related
       * utility functions.
       *
       * @type {WebGPUTextureUtils}
       */
      _this214.textureUtils = new WebGPUTextureUtils(_this214);

      /**
       * A map that manages the resolve buffers for occlusion queries.
       *
       * @type {Map<Number,GPUBuffer>}
       */
      _this214.occludedResolveCache = new Map();
      return _this214;
    }

    /**
     * Initializes the backend so it is ready for usage.
     *
     * @async
     * @param {Renderer} renderer - The renderer.
     * @return {Promise} A Promise that resolves when the backend has been initialized.
     */
    (0, _inherits2.default)(WebGPUBackend, _Backend2);
    return (0, _createClass2.default)(WebGPUBackend, [{
      key: "init",
      value: (function () {
        var _init4 = (0, _asyncToGenerator2.default)(function* (renderer) {
          yield _superPropGet(WebGPUBackend, "init", this, 3)([renderer]);

          //

          var parameters = this.parameters;

          // create the device if it is not passed with parameters

          var device;
          if (parameters.device === undefined) {
            var adapterOptions = {
              powerPreference: parameters.powerPreference
            };
            var adapter = typeof navigator !== 'undefined' ? yield navigator.gpu.requestAdapter(adapterOptions) : null;
            if (adapter === null) {
              throw new Error('WebGPUBackend: Unable to create WebGPU adapter.');
            }

            // feature support

            var features = Object.values(GPUFeatureName);
            var supportedFeatures = [];
            for (var name of features) {
              if (adapter.features.has(name)) {
                supportedFeatures.push(name);
              }
            }
            var deviceDescriptor = {
              requiredFeatures: supportedFeatures,
              requiredLimits: parameters.requiredLimits
            };
            device = yield adapter.requestDevice(deviceDescriptor);
          } else {
            device = parameters.device;
          }
          device.lost.then(function (info) {
            var deviceLossInfo = {
              api: 'WebGPU',
              message: info.message || 'Unknown reason',
              reason: info.reason || null,
              originalEvent: info
            };
            renderer.onDeviceLost(deviceLossInfo);
          });
          var context = parameters.context !== undefined ? parameters.context : renderer.domElement.getContext('webgpu');
          this.device = device;
          this.context = context;
          var alphaMode = parameters.alpha ? 'premultiplied' : 'opaque';
          this.trackTimestamp = this.trackTimestamp && this.hasFeature(GPUFeatureName.TimestampQuery);
          this.context.configure({
            device: this.device,
            format: this.utils.getPreferredCanvasFormat(),
            usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC,
            alphaMode: alphaMode
          });
          this.updateSize();
        });
        function init(_x44) {
          return _init4.apply(this, arguments);
        }
        return init;
      }()
      /**
       * The coordinate system of the backend.
       *
       * @type {Number}
       * @readonly
       */
      )
    }, {
      key: "coordinateSystem",
      get: function get() {
        return _$$_REQUIRE(_dependencyMap[1], "./three.core.js").WebGPUCoordinateSystem;
      }

      /**
       * Transfers buffer data from a storage buffer attribute
       * from the GPU to the CPU in context of compute shaders.
       *
       * @async
       * @param {StorageBufferAttribute} attribute - The storage buffer attribute.
       * @return {Promise<ArrayBuffer>} A promise that resolves with the buffer data when the data are ready.
       */
    }, {
      key: "getArrayBufferAsync",
      value: (function () {
        var _getArrayBufferAsync5 = (0, _asyncToGenerator2.default)(function* (attribute) {
          return yield this.attributeUtils.getArrayBufferAsync(attribute);
        });
        function getArrayBufferAsync(_x45) {
          return _getArrayBufferAsync5.apply(this, arguments);
        }
        return getArrayBufferAsync;
      }()
      /**
       * Returns the backend's rendering context.
       *
       * @return {GPUCanvasContext} The rendering context.
       */
      )
    }, {
      key: "getContext",
      value: function getContext() {
        return this.context;
      }

      /**
       * Returns the default render pass descriptor.
       *
       * In WebGPU, the default framebuffer must be configured
       * like custom fraemebuffers so the backend needs a render
       * pass descriptor even when rendering directly to screen.
       *
       * @private
       * @return {Object} The render pass descriptor.
       */
    }, {
      key: "_getDefaultRenderPassDescriptor",
      value: function _getDefaultRenderPassDescriptor() {
        var descriptor = this.defaultRenderPassdescriptor;
        if (descriptor === null) {
          var renderer = this.renderer;
          descriptor = {
            colorAttachments: [{
              view: null
            }]
          };
          if (this.renderer.depth === true || this.renderer.stencil === true) {
            descriptor.depthStencilAttachment = {
              view: this.textureUtils.getDepthBuffer(renderer.depth, renderer.stencil).createView()
            };
          }
          var _colorAttachment = descriptor.colorAttachments[0];
          if (this.renderer.samples > 0) {
            _colorAttachment.view = this.colorBuffer.createView();
          } else {
            _colorAttachment.resolveTarget = undefined;
          }
          this.defaultRenderPassdescriptor = descriptor;
        }
        var colorAttachment = descriptor.colorAttachments[0];
        if (this.renderer.samples > 0) {
          colorAttachment.resolveTarget = this.context.getCurrentTexture().createView();
        } else {
          colorAttachment.view = this.context.getCurrentTexture().createView();
        }
        return descriptor;
      }

      /**
       * Returns the render pass descriptor for the given render context.
       *
       * @private
       * @param {RenderContext} renderContext - The render context.
       * @param {Object} colorAttachmentsConfig - Configuration object for the color attachments.
       * @return {Object} The render pass descriptor.
       */
    }, {
      key: "_getRenderPassDescriptor",
      value: function _getRenderPassDescriptor(renderContext) {
        var _this215 = this;
        var colorAttachmentsConfig = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        var renderTarget = renderContext.renderTarget;
        var renderTargetData = this.get(renderTarget);
        var descriptors = renderTargetData.descriptors;
        if (descriptors === undefined || renderTargetData.width !== renderTarget.width || renderTargetData.height !== renderTarget.height || renderTargetData.dimensions !== renderTarget.dimensions || renderTargetData.activeMipmapLevel !== renderTarget.activeMipmapLevel || renderTargetData.activeCubeFace !== renderContext.activeCubeFace || renderTargetData.samples !== renderTarget.samples || renderTargetData.loadOp !== colorAttachmentsConfig.loadOp) {
          descriptors = {};
          renderTargetData.descriptors = descriptors;

          // dispose

          var _onDispose4 = function onDispose() {
            renderTarget.removeEventListener('dispose', _onDispose4);
            _this215.delete(renderTarget);
          };
          renderTarget.addEventListener('dispose', _onDispose4);
        }
        var cacheKey = renderContext.getCacheKey();
        var descriptor = descriptors[cacheKey];
        if (descriptor === undefined) {
          var textures = renderContext.textures;
          var colorAttachments = [];
          var sliceIndex;
          for (var i = 0; i < textures.length; i++) {
            var textureData = this.get(textures[i]);
            var viewDescriptor = {
              label: `colorAttachment_${i}`,
              baseMipLevel: renderContext.activeMipmapLevel,
              mipLevelCount: 1,
              baseArrayLayer: renderContext.activeCubeFace,
              arrayLayerCount: 1,
              dimension: GPUTextureViewDimension.TwoD
            };
            if (renderTarget.isRenderTarget3D) {
              sliceIndex = renderContext.activeCubeFace;
              viewDescriptor.baseArrayLayer = 0;
              viewDescriptor.dimension = GPUTextureViewDimension.ThreeD;
              viewDescriptor.depthOrArrayLayers = textures[i].image.depth;
            } else if (renderTarget.isRenderTargetArray) {
              viewDescriptor.dimension = GPUTextureViewDimension.TwoDArray;
              viewDescriptor.depthOrArrayLayers = textures[i].image.depth;
            }
            var textureView = textureData.texture.createView(viewDescriptor);
            var view = void 0,
              resolveTarget = void 0;
            if (textureData.msaaTexture !== undefined) {
              view = textureData.msaaTexture.createView();
              resolveTarget = textureView;
            } else {
              view = textureView;
              resolveTarget = undefined;
            }
            colorAttachments.push(Object.assign({
              view: view,
              depthSlice: sliceIndex,
              resolveTarget: resolveTarget,
              loadOp: GPULoadOp.Load,
              storeOp: GPUStoreOp.Store
            }, colorAttachmentsConfig));
          }
          descriptor = {
            colorAttachments: colorAttachments
          };
          if (renderContext.depth) {
            var depthTextureData = this.get(renderContext.depthTexture);
            var depthStencilAttachment = {
              view: depthTextureData.texture.createView()
            };
            descriptor.depthStencilAttachment = depthStencilAttachment;
          }
          descriptors[cacheKey] = descriptor;
          renderTargetData.width = renderTarget.width;
          renderTargetData.height = renderTarget.height;
          renderTargetData.samples = renderTarget.samples;
          renderTargetData.activeMipmapLevel = renderContext.activeMipmapLevel;
          renderTargetData.activeCubeFace = renderContext.activeCubeFace;
          renderTargetData.dimensions = renderTarget.dimensions;
          renderTargetData.depthSlice = sliceIndex;
          renderTargetData.loadOp = colorAttachments[0].loadOp;
        }
        return descriptor;
      }

      /**
       * This method is executed at the beginning of a render call and prepares
       * the WebGPU state for upcoming render calls
       *
       * @param {RenderContext} renderContext - The render context.
       */
    }, {
      key: "beginRender",
      value: function beginRender(renderContext) {
        var renderContextData = this.get(renderContext);
        var device = this.device;
        var occlusionQueryCount = renderContext.occlusionQueryCount;
        var occlusionQuerySet;
        if (occlusionQueryCount > 0) {
          if (renderContextData.currentOcclusionQuerySet) renderContextData.currentOcclusionQuerySet.destroy();
          if (renderContextData.currentOcclusionQueryBuffer) renderContextData.currentOcclusionQueryBuffer.destroy();

          // Get a reference to the array of objects with queries. The renderContextData property
          // can be changed by another render pass before the buffer.mapAsyc() completes.
          renderContextData.currentOcclusionQuerySet = renderContextData.occlusionQuerySet;
          renderContextData.currentOcclusionQueryBuffer = renderContextData.occlusionQueryBuffer;
          renderContextData.currentOcclusionQueryObjects = renderContextData.occlusionQueryObjects;

          //

          occlusionQuerySet = device.createQuerySet({
            type: 'occlusion',
            count: occlusionQueryCount,
            label: `occlusionQuerySet_${renderContext.id}`
          });
          renderContextData.occlusionQuerySet = occlusionQuerySet;
          renderContextData.occlusionQueryIndex = 0;
          renderContextData.occlusionQueryObjects = new Array(occlusionQueryCount);
          renderContextData.lastOcclusionObject = null;
        }
        var descriptor;
        if (renderContext.textures === null) {
          descriptor = this._getDefaultRenderPassDescriptor();
        } else {
          descriptor = this._getRenderPassDescriptor(renderContext, {
            loadOp: GPULoadOp.Load
          });
        }
        this.initTimestampQuery(renderContext, descriptor);
        descriptor.occlusionQuerySet = occlusionQuerySet;
        var depthStencilAttachment = descriptor.depthStencilAttachment;
        if (renderContext.textures !== null) {
          var colorAttachments = descriptor.colorAttachments;
          for (var i = 0; i < colorAttachments.length; i++) {
            var colorAttachment = colorAttachments[i];
            if (renderContext.clearColor) {
              colorAttachment.clearValue = i === 0 ? renderContext.clearColorValue : {
                r: 0,
                g: 0,
                b: 0,
                a: 1
              };
              colorAttachment.loadOp = GPULoadOp.Clear;
              colorAttachment.storeOp = GPUStoreOp.Store;
            } else {
              colorAttachment.loadOp = GPULoadOp.Load;
              colorAttachment.storeOp = GPUStoreOp.Store;
            }
          }
        } else {
          var _colorAttachment2 = descriptor.colorAttachments[0];
          if (renderContext.clearColor) {
            _colorAttachment2.clearValue = renderContext.clearColorValue;
            _colorAttachment2.loadOp = GPULoadOp.Clear;
            _colorAttachment2.storeOp = GPUStoreOp.Store;
          } else {
            _colorAttachment2.loadOp = GPULoadOp.Load;
            _colorAttachment2.storeOp = GPUStoreOp.Store;
          }
        }

        //

        if (renderContext.depth) {
          if (renderContext.clearDepth) {
            depthStencilAttachment.depthClearValue = renderContext.clearDepthValue;
            depthStencilAttachment.depthLoadOp = GPULoadOp.Clear;
            depthStencilAttachment.depthStoreOp = GPUStoreOp.Store;
          } else {
            depthStencilAttachment.depthLoadOp = GPULoadOp.Load;
            depthStencilAttachment.depthStoreOp = GPUStoreOp.Store;
          }
        }
        if (renderContext.stencil) {
          if (renderContext.clearStencil) {
            depthStencilAttachment.stencilClearValue = renderContext.clearStencilValue;
            depthStencilAttachment.stencilLoadOp = GPULoadOp.Clear;
            depthStencilAttachment.stencilStoreOp = GPUStoreOp.Store;
          } else {
            depthStencilAttachment.stencilLoadOp = GPULoadOp.Load;
            depthStencilAttachment.stencilStoreOp = GPUStoreOp.Store;
          }
        }

        //

        var encoder = device.createCommandEncoder({
          label: 'renderContext_' + renderContext.id
        });
        var currentPass = encoder.beginRenderPass(descriptor);

        //

        renderContextData.descriptor = descriptor;
        renderContextData.encoder = encoder;
        renderContextData.currentPass = currentPass;
        renderContextData.currentSets = {
          attributes: {},
          bindingGroups: [],
          pipeline: null,
          index: null
        };
        renderContextData.renderBundles = [];

        //

        if (renderContext.viewport) {
          this.updateViewport(renderContext);
        }
        if (renderContext.scissor) {
          var _renderContext$scisso3 = renderContext.scissorValue,
            x = _renderContext$scisso3.x,
            y = _renderContext$scisso3.y,
            width = _renderContext$scisso3.width,
            height = _renderContext$scisso3.height;
          currentPass.setScissorRect(x, y, width, height);
        }
      }

      /**
       * This method is executed at the end of a render call and finalizes work
       * after draw calls.
       *
       * @param {RenderContext} renderContext - The render context.
       */
    }, {
      key: "finishRender",
      value: function finishRender(renderContext) {
        var renderContextData = this.get(renderContext);
        var occlusionQueryCount = renderContext.occlusionQueryCount;
        if (renderContextData.renderBundles.length > 0) {
          renderContextData.currentPass.executeBundles(renderContextData.renderBundles);
        }
        if (occlusionQueryCount > renderContextData.occlusionQueryIndex) {
          renderContextData.currentPass.endOcclusionQuery();
        }
        renderContextData.currentPass.end();
        if (occlusionQueryCount > 0) {
          var bufferSize = occlusionQueryCount * 8; // 8 byte entries for query results

          //

          var queryResolveBuffer = this.occludedResolveCache.get(bufferSize);
          if (queryResolveBuffer === undefined) {
            queryResolveBuffer = this.device.createBuffer({
              size: bufferSize,
              usage: GPUBufferUsage.QUERY_RESOLVE | GPUBufferUsage.COPY_SRC
            });
            this.occludedResolveCache.set(bufferSize, queryResolveBuffer);
          }

          //

          var readBuffer = this.device.createBuffer({
            size: bufferSize,
            usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ
          });

          // two buffers required here - WebGPU doesn't allow usage of QUERY_RESOLVE & MAP_READ to be combined
          renderContextData.encoder.resolveQuerySet(renderContextData.occlusionQuerySet, 0, occlusionQueryCount, queryResolveBuffer, 0);
          renderContextData.encoder.copyBufferToBuffer(queryResolveBuffer, 0, readBuffer, 0, bufferSize);
          renderContextData.occlusionQueryBuffer = readBuffer;

          //

          this.resolveOccludedAsync(renderContext);
        }
        this.prepareTimestampBuffer(renderContext, renderContextData.encoder);
        this.device.queue.submit([renderContextData.encoder.finish()]);

        //

        if (renderContext.textures !== null) {
          var textures = renderContext.textures;
          for (var i = 0; i < textures.length; i++) {
            var _texture15 = textures[i];
            if (_texture15.generateMipmaps === true) {
              this.textureUtils.generateMipmaps(_texture15);
            }
          }
        }
      }

      /**
       * Returns `true` if the given 3D object is fully occluded by other
       * 3D objects in the scene.
       *
       * @param {RenderContext} renderContext - The render context.
       * @param {Object3D} object - The 3D object to test.
       * @return {Boolean} Whether the 3D object is fully occluded or not.
       */
    }, {
      key: "isOccluded",
      value: function isOccluded(renderContext, object) {
        var renderContextData = this.get(renderContext);
        return renderContextData.occluded && renderContextData.occluded.has(object);
      }

      /**
       * This method processes the result of occlusion queries and writes it
       * into render context data.
       *
       * @async
       * @param {RenderContext} renderContext - The render context.
       */
    }, {
      key: "resolveOccludedAsync",
      value: (function () {
        var _resolveOccludedAsync = (0, _asyncToGenerator2.default)(function* (renderContext) {
          var renderContextData = this.get(renderContext);

          // handle occlusion query results

          var currentOcclusionQueryBuffer = renderContextData.currentOcclusionQueryBuffer,
            currentOcclusionQueryObjects = renderContextData.currentOcclusionQueryObjects;
          if (currentOcclusionQueryBuffer && currentOcclusionQueryObjects) {
            var occluded = new WeakSet();
            renderContextData.currentOcclusionQueryObjects = null;
            renderContextData.currentOcclusionQueryBuffer = null;
            yield currentOcclusionQueryBuffer.mapAsync(GPUMapMode.READ);
            var _buffer7 = currentOcclusionQueryBuffer.getMappedRange();
            var results = new BigUint64Array(_buffer7);
            for (var i = 0; i < currentOcclusionQueryObjects.length; i++) {
              if (results[i] !== BigInt(0)) {
                occluded.add(currentOcclusionQueryObjects[i]);
              }
            }
            currentOcclusionQueryBuffer.destroy();
            renderContextData.occluded = occluded;
          }
        });
        function resolveOccludedAsync(_x46) {
          return _resolveOccludedAsync.apply(this, arguments);
        }
        return resolveOccludedAsync;
      }()
      /**
       * Updates the viewport with the values from the given render context.
       *
       * @param {RenderContext} renderContext - The render context.
       */
      )
    }, {
      key: "updateViewport",
      value: function updateViewport(renderContext) {
        var _this$get5 = this.get(renderContext),
          currentPass = _this$get5.currentPass;
        var _renderContext$viewpo2 = renderContext.viewportValue,
          x = _renderContext$viewpo2.x,
          y = _renderContext$viewpo2.y,
          width = _renderContext$viewpo2.width,
          height = _renderContext$viewpo2.height,
          minDepth = _renderContext$viewpo2.minDepth,
          maxDepth = _renderContext$viewpo2.maxDepth;
        currentPass.setViewport(x, y, width, height, minDepth, maxDepth);
      }

      /**
       * Performs a clear operation.
       *
       * @param {Boolean} color - Whether the color buffer should be cleared or not.
       * @param {Boolean} depth - Whether the depth buffer should be cleared or not.
       * @param {Boolean} stencil - Whether the stencil buffer should be cleared or not.
       * @param {RenderContext?} [renderTargetContext=null] - The render context of the current set render target.
       */
    }, {
      key: "clear",
      value: function clear(color, depth, stencil) {
        var renderTargetContext = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
        var device = this.device;
        var renderer = this.renderer;
        var colorAttachments = [];
        var depthStencilAttachment;
        var clearValue;
        var supportsDepth;
        var supportsStencil;
        if (color) {
          var clearColor = this.getClearColor();
          if (this.renderer.alpha === true) {
            // premultiply alpha

            var a = clearColor.a;
            clearValue = {
              r: clearColor.r * a,
              g: clearColor.g * a,
              b: clearColor.b * a,
              a: a
            };
          } else {
            clearValue = {
              r: clearColor.r,
              g: clearColor.g,
              b: clearColor.b,
              a: clearColor.a
            };
          }
        }
        if (renderTargetContext === null) {
          supportsDepth = renderer.depth;
          supportsStencil = renderer.stencil;
          var descriptor = this._getDefaultRenderPassDescriptor();
          if (color) {
            colorAttachments = descriptor.colorAttachments;
            var colorAttachment = colorAttachments[0];
            colorAttachment.clearValue = clearValue;
            colorAttachment.loadOp = GPULoadOp.Clear;
            colorAttachment.storeOp = GPUStoreOp.Store;
          }
          if (supportsDepth || supportsStencil) {
            depthStencilAttachment = descriptor.depthStencilAttachment;
          }
        } else {
          supportsDepth = renderTargetContext.depth;
          supportsStencil = renderTargetContext.stencil;
          if (color) {
            var _descriptor = this._getRenderPassDescriptor(renderTargetContext, {
              loadOp: GPULoadOp.Clear
            });
            colorAttachments = _descriptor.colorAttachments;
          }
          if (supportsDepth || supportsStencil) {
            var depthTextureData = this.get(renderTargetContext.depthTexture);
            depthStencilAttachment = {
              view: depthTextureData.texture.createView()
            };
          }
        }

        //

        if (supportsDepth) {
          if (depth) {
            depthStencilAttachment.depthLoadOp = GPULoadOp.Clear;
            depthStencilAttachment.depthClearValue = renderer.getClearDepth();
            depthStencilAttachment.depthStoreOp = GPUStoreOp.Store;
          } else {
            depthStencilAttachment.depthLoadOp = GPULoadOp.Load;
            depthStencilAttachment.depthStoreOp = GPUStoreOp.Store;
          }
        }

        //

        if (supportsStencil) {
          if (stencil) {
            depthStencilAttachment.stencilLoadOp = GPULoadOp.Clear;
            depthStencilAttachment.stencilClearValue = renderer.getClearStencil();
            depthStencilAttachment.stencilStoreOp = GPUStoreOp.Store;
          } else {
            depthStencilAttachment.stencilLoadOp = GPULoadOp.Load;
            depthStencilAttachment.stencilStoreOp = GPUStoreOp.Store;
          }
        }

        //

        var encoder = device.createCommandEncoder({});
        var currentPass = encoder.beginRenderPass({
          colorAttachments: colorAttachments,
          depthStencilAttachment: depthStencilAttachment
        });
        currentPass.end();
        device.queue.submit([encoder.finish()]);
      }

      // compute

      /**
       * This method is executed at the beginning of a compute call and
       * prepares the state for upcoming compute tasks.
       *
       * @param {Node|Array<Node>} computeGroup - The compute node(s).
       */
    }, {
      key: "beginCompute",
      value: function beginCompute(computeGroup) {
        var groupGPU = this.get(computeGroup);
        var descriptor = {};
        this.initTimestampQuery(computeGroup, descriptor);
        groupGPU.cmdEncoderGPU = this.device.createCommandEncoder();
        groupGPU.passEncoderGPU = groupGPU.cmdEncoderGPU.beginComputePass(descriptor);
      }

      /**
       * Executes a compute command for the given compute node.
       *
       * @param {Node|Array<Node>} computeGroup - The group of compute nodes of a compute call. Can be a single compute node.
       * @param {Node} computeNode - The compute node.
       * @param {Array<BindGroup>} bindings - The bindings.
       * @param {ComputePipeline} pipeline - The compute pipeline.
       */
    }, {
      key: "compute",
      value: function compute(computeGroup, computeNode, bindings, pipeline) {
        var _this$get6 = this.get(computeGroup),
          passEncoderGPU = _this$get6.passEncoderGPU;

        // pipeline

        var pipelineGPU = this.get(pipeline).pipeline;
        passEncoderGPU.setPipeline(pipelineGPU);

        // bind groups

        for (var i = 0, l = bindings.length; i < l; i++) {
          var bindGroup = bindings[i];
          var bindingsData = this.get(bindGroup);
          passEncoderGPU.setBindGroup(i, bindingsData.group);
        }
        var maxComputeWorkgroupsPerDimension = this.device.limits.maxComputeWorkgroupsPerDimension;
        var computeNodeData = this.get(computeNode);
        if (computeNodeData.dispatchSize === undefined) computeNodeData.dispatchSize = {
          x: 0,
          y: 1,
          z: 1
        };
        var dispatchSize = computeNodeData.dispatchSize;
        if (computeNode.dispatchCount > maxComputeWorkgroupsPerDimension) {
          dispatchSize.x = Math.min(computeNode.dispatchCount, maxComputeWorkgroupsPerDimension);
          dispatchSize.y = Math.ceil(computeNode.dispatchCount / maxComputeWorkgroupsPerDimension);
        } else {
          dispatchSize.x = computeNode.dispatchCount;
        }
        passEncoderGPU.dispatchWorkgroups(dispatchSize.x, dispatchSize.y, dispatchSize.z);
      }

      /**
       * This method is executed at the end of a compute call and
       * finalizes work after compute tasks.
       *
       * @param {Node|Array<Node>} computeGroup - The compute node(s).
       */
    }, {
      key: "finishCompute",
      value: function finishCompute(computeGroup) {
        var groupData = this.get(computeGroup);
        groupData.passEncoderGPU.end();
        this.prepareTimestampBuffer(computeGroup, groupData.cmdEncoderGPU);
        this.device.queue.submit([groupData.cmdEncoderGPU.finish()]);
      }

      /**
       * Can be used to synchronize CPU operations with GPU tasks. So when this method is called,
       * the CPU waits for the GPU to complete its operation (e.g. a compute task).
       *
       * @async
       * @return {Promise} A Promise that resolves when synchronization has been finished.
       */
    }, {
      key: "waitForGPU",
      value: (function () {
        var _waitForGPU4 = (0, _asyncToGenerator2.default)(function* () {
          yield this.device.queue.onSubmittedWorkDone();
        });
        function waitForGPU() {
          return _waitForGPU4.apply(this, arguments);
        }
        return waitForGPU;
      }() // render object
      /**
       * Executes a draw command for the given render object.
       *
       * @param {RenderObject} renderObject - The render object to draw.
       * @param {Info} info - Holds a series of statistical information about the GPU memory and the rendering process.
       */
      )
    }, {
      key: "draw",
      value: function draw(renderObject, info) {
        var object = renderObject.object,
          context = renderObject.context,
          pipeline = renderObject.pipeline;
        var bindings = renderObject.getBindings();
        var renderContextData = this.get(context);
        var pipelineGPU = this.get(pipeline).pipeline;
        var currentSets = renderContextData.currentSets;
        var passEncoderGPU = renderContextData.currentPass;
        var drawParams = renderObject.getDrawParameters();
        if (drawParams === null) return;

        // pipeline

        if (currentSets.pipeline !== pipelineGPU) {
          passEncoderGPU.setPipeline(pipelineGPU);
          currentSets.pipeline = pipelineGPU;
        }

        // bind groups

        var currentBindingGroups = currentSets.bindingGroups;
        for (var i = 0, l = bindings.length; i < l; i++) {
          var bindGroup = bindings[i];
          var bindingsData = this.get(bindGroup);
          if (currentBindingGroups[bindGroup.index] !== bindGroup.id) {
            passEncoderGPU.setBindGroup(bindGroup.index, bindingsData.group);
            currentBindingGroups[bindGroup.index] = bindGroup.id;
          }
        }

        // attributes

        var index = renderObject.getIndex();
        var hasIndex = index !== null;

        // index

        if (hasIndex === true) {
          if (currentSets.index !== index) {
            var _buffer8 = this.get(index).buffer;
            var indexFormat = index.array instanceof Uint16Array ? GPUIndexFormat.Uint16 : GPUIndexFormat.Uint32;
            passEncoderGPU.setIndexBuffer(_buffer8, indexFormat);
            currentSets.index = index;
          }
        }

        // vertex buffers

        var vertexBuffers = renderObject.getVertexBuffers();
        for (var _i23 = 0, _l4 = vertexBuffers.length; _i23 < _l4; _i23++) {
          var vertexBuffer = vertexBuffers[_i23];
          if (currentSets.attributes[_i23] !== vertexBuffer) {
            var _buffer9 = this.get(vertexBuffer).buffer;
            passEncoderGPU.setVertexBuffer(_i23, _buffer9);
            currentSets.attributes[_i23] = vertexBuffer;
          }
        }

        // occlusion queries - handle multiple consecutive draw calls for an object

        if (renderContextData.occlusionQuerySet !== undefined) {
          var lastObject = renderContextData.lastOcclusionObject;
          if (lastObject !== object) {
            if (lastObject !== null && lastObject.occlusionTest === true) {
              passEncoderGPU.endOcclusionQuery();
              renderContextData.occlusionQueryIndex++;
            }
            if (object.occlusionTest === true) {
              passEncoderGPU.beginOcclusionQuery(renderContextData.occlusionQueryIndex);
              renderContextData.occlusionQueryObjects[renderContextData.occlusionQueryIndex] = object;
            }
            renderContextData.lastOcclusionObject = object;
          }
        }

        // draw

        if (object.isBatchedMesh === true) {
          var starts = object._multiDrawStarts;
          var counts = object._multiDrawCounts;
          var drawCount = object._multiDrawCount;
          var drawInstances = object._multiDrawInstances;
          for (var _i24 = 0; _i24 < drawCount; _i24++) {
            var count = drawInstances ? drawInstances[_i24] : 1;
            var firstInstance = count > 1 ? 0 : _i24;
            if (hasIndex === true) {
              passEncoderGPU.drawIndexed(counts[_i24], count, starts[_i24] / index.array.BYTES_PER_ELEMENT, 0, firstInstance);
            } else {
              passEncoderGPU.draw(counts[_i24], count, starts[_i24], firstInstance);
            }
          }
        } else if (hasIndex === true) {
          var indexCount = drawParams.vertexCount,
            instanceCount = drawParams.instanceCount,
            firstIndex = drawParams.firstVertex;
          var indirect = renderObject.getIndirect();
          if (indirect !== null) {
            var _buffer10 = this.get(indirect).buffer;
            passEncoderGPU.drawIndexedIndirect(_buffer10, 0);
          } else {
            passEncoderGPU.drawIndexed(indexCount, instanceCount, firstIndex, 0, 0);
          }
          info.update(object, indexCount, instanceCount);
        } else {
          var vertexCount = drawParams.vertexCount,
            _instanceCount = drawParams.instanceCount,
            firstVertex = drawParams.firstVertex;
          var _indirect = renderObject.getIndirect();
          if (_indirect !== null) {
            var _buffer11 = this.get(_indirect).buffer;
            passEncoderGPU.drawIndirect(_buffer11, 0);
          } else {
            passEncoderGPU.draw(vertexCount, _instanceCount, firstVertex, 0);
          }
          info.update(object, vertexCount, _instanceCount);
        }
      }

      // cache key

      /**
       * Returns `true` if the render pipeline requires an update.
       *
       * @param {RenderObject} renderObject - The render object.
       * @return {Boolean} Whether the render pipeline requires an update or not.
       */
    }, {
      key: "needsRenderUpdate",
      value: function needsRenderUpdate(renderObject) {
        var data = this.get(renderObject);
        var object = renderObject.object,
          material = renderObject.material;
        var utils = this.utils;
        var sampleCount = utils.getSampleCountRenderContext(renderObject.context);
        var colorSpace = utils.getCurrentColorSpace(renderObject.context);
        var colorFormat = utils.getCurrentColorFormat(renderObject.context);
        var depthStencilFormat = utils.getCurrentDepthStencilFormat(renderObject.context);
        var primitiveTopology = utils.getPrimitiveTopology(object, material);
        var needsUpdate = false;
        if (data.material !== material || data.materialVersion !== material.version || data.transparent !== material.transparent || data.blending !== material.blending || data.premultipliedAlpha !== material.premultipliedAlpha || data.blendSrc !== material.blendSrc || data.blendDst !== material.blendDst || data.blendEquation !== material.blendEquation || data.blendSrcAlpha !== material.blendSrcAlpha || data.blendDstAlpha !== material.blendDstAlpha || data.blendEquationAlpha !== material.blendEquationAlpha || data.colorWrite !== material.colorWrite || data.depthWrite !== material.depthWrite || data.depthTest !== material.depthTest || data.depthFunc !== material.depthFunc || data.stencilWrite !== material.stencilWrite || data.stencilFunc !== material.stencilFunc || data.stencilFail !== material.stencilFail || data.stencilZFail !== material.stencilZFail || data.stencilZPass !== material.stencilZPass || data.stencilFuncMask !== material.stencilFuncMask || data.stencilWriteMask !== material.stencilWriteMask || data.side !== material.side || data.alphaToCoverage !== material.alphaToCoverage || data.sampleCount !== sampleCount || data.colorSpace !== colorSpace || data.colorFormat !== colorFormat || data.depthStencilFormat !== depthStencilFormat || data.primitiveTopology !== primitiveTopology || data.clippingContextCacheKey !== renderObject.clippingContextCacheKey) {
          data.material = material;
          data.materialVersion = material.version;
          data.transparent = material.transparent;
          data.blending = material.blending;
          data.premultipliedAlpha = material.premultipliedAlpha;
          data.blendSrc = material.blendSrc;
          data.blendDst = material.blendDst;
          data.blendEquation = material.blendEquation;
          data.blendSrcAlpha = material.blendSrcAlpha;
          data.blendDstAlpha = material.blendDstAlpha;
          data.blendEquationAlpha = material.blendEquationAlpha;
          data.colorWrite = material.colorWrite;
          data.depthWrite = material.depthWrite;
          data.depthTest = material.depthTest;
          data.depthFunc = material.depthFunc;
          data.stencilWrite = material.stencilWrite;
          data.stencilFunc = material.stencilFunc;
          data.stencilFail = material.stencilFail;
          data.stencilZFail = material.stencilZFail;
          data.stencilZPass = material.stencilZPass;
          data.stencilFuncMask = material.stencilFuncMask;
          data.stencilWriteMask = material.stencilWriteMask;
          data.side = material.side;
          data.alphaToCoverage = material.alphaToCoverage;
          data.sampleCount = sampleCount;
          data.colorSpace = colorSpace;
          data.colorFormat = colorFormat;
          data.depthStencilFormat = depthStencilFormat;
          data.primitiveTopology = primitiveTopology;
          data.clippingContextCacheKey = renderObject.clippingContextCacheKey;
          needsUpdate = true;
        }
        return needsUpdate;
      }

      /**
       * Returns a cache key that is used to identify render pipelines.
       *
       * @param {RenderObject} renderObject - The render object.
       * @return {String} The cache key.
       */
    }, {
      key: "getRenderCacheKey",
      value: function getRenderCacheKey(renderObject) {
        var object = renderObject.object,
          material = renderObject.material;
        var utils = this.utils;
        var renderContext = renderObject.context;
        return [material.transparent, material.blending, material.premultipliedAlpha, material.blendSrc, material.blendDst, material.blendEquation, material.blendSrcAlpha, material.blendDstAlpha, material.blendEquationAlpha, material.colorWrite, material.depthWrite, material.depthTest, material.depthFunc, material.stencilWrite, material.stencilFunc, material.stencilFail, material.stencilZFail, material.stencilZPass, material.stencilFuncMask, material.stencilWriteMask, material.side, utils.getSampleCountRenderContext(renderContext), utils.getCurrentColorSpace(renderContext), utils.getCurrentColorFormat(renderContext), utils.getCurrentDepthStencilFormat(renderContext), utils.getPrimitiveTopology(object, material), renderObject.getGeometryCacheKey(), renderObject.clippingContextCacheKey].join();
      }

      // textures

      /**
       * Creates a sampler for the given texture.
       *
       * @param {Texture} texture - The texture to create the sampler for.
       */
    }, {
      key: "createSampler",
      value: function createSampler(texture) {
        this.textureUtils.createSampler(texture);
      }

      /**
       * Destroys the sampler for the given texture.
       *
       * @param {Texture} texture - The texture to destroy the sampler for.
       */
    }, {
      key: "destroySampler",
      value: function destroySampler(texture) {
        this.textureUtils.destroySampler(texture);
      }

      /**
       * Creates a default texture for the given texture that can be used
       * as a placeholder until the actual texture is ready for usage.
       *
       * @param {Texture} texture - The texture to create a default texture for.
       */
    }, {
      key: "createDefaultTexture",
      value: function createDefaultTexture(texture) {
        this.textureUtils.createDefaultTexture(texture);
      }

      /**
       * Defines a texture on the GPU for the given texture object.
       *
       * @param {Texture} texture - The texture.
       * @param {Object} [options={}] - Optional configuration parameter.
       */
    }, {
      key: "createTexture",
      value: function createTexture(texture, options) {
        this.textureUtils.createTexture(texture, options);
      }

      /**
       * Uploads the updated texture data to the GPU.
       *
       * @param {Texture} texture - The texture.
       * @param {Object} [options={}] - Optional configuration parameter.
       */
    }, {
      key: "updateTexture",
      value: function updateTexture(texture, options) {
        this.textureUtils.updateTexture(texture, options);
      }

      /**
       * Generates mipmaps for the given texture
       *
       * @param {Texture} texture - The texture.
       */
    }, {
      key: "generateMipmaps",
      value: function generateMipmaps(texture) {
        this.textureUtils.generateMipmaps(texture);
      }

      /**
       * Destroys the GPU data for the given texture object.
       *
       * @param {Texture} texture - The texture.
       */
    }, {
      key: "destroyTexture",
      value: function destroyTexture(texture) {
        this.textureUtils.destroyTexture(texture);
      }

      /**
       * Returns texture data as a typed array.
       *
       * @param {Texture} texture - The texture to copy.
       * @param {Number} x - The x coordinate of the copy origin.
       * @param {Number} y - The y coordinate of the copy origin.
       * @param {Number} width - The width of the copy.
       * @param {Number} height - The height of the copy.
       * @param {Number} faceIndex - The face index.
       * @return {TypedArray} The texture data as a typed array.
       */
    }, {
      key: "copyTextureToBuffer",
      value: function copyTextureToBuffer(texture, x, y, width, height, faceIndex) {
        return this.textureUtils.copyTextureToBuffer(texture, x, y, width, height, faceIndex);
      }

      /**
       * Inits a time stamp query for the given render context.
       *
       * @param {RenderContext} renderContext - The render context.
       * @param {Object} descriptor - The query descriptor.
       */
    }, {
      key: "initTimestampQuery",
      value: function initTimestampQuery(renderContext, descriptor) {
        if (!this.trackTimestamp) return;
        var renderContextData = this.get(renderContext);
        if (!renderContextData.timeStampQuerySet) {
          var type = renderContext.isComputeNode ? 'compute' : 'render';
          var timeStampQuerySet = this.device.createQuerySet({
            type: 'timestamp',
            count: 2,
            label: `timestamp_${type}_${renderContext.id}`
          });
          var timestampWrites = {
            querySet: timeStampQuerySet,
            beginningOfPassWriteIndex: 0,
            // Write timestamp in index 0 when pass begins.
            endOfPassWriteIndex: 1 // Write timestamp in index 1 when pass ends.
          };
          Object.assign(descriptor, {
            timestampWrites: timestampWrites
          });
          renderContextData.timeStampQuerySet = timeStampQuerySet;
        }
      }

      /**
       * Prepares the timestamp buffer.
       *
       * @param {RenderContext} renderContext - The render context.
       * @param {GPUCommandEncoder} encoder - The command encoder.
       */
    }, {
      key: "prepareTimestampBuffer",
      value: function prepareTimestampBuffer(renderContext, encoder) {
        if (!this.trackTimestamp) return;
        var renderContextData = this.get(renderContext);
        var size = 2 * BigInt64Array.BYTES_PER_ELEMENT;
        if (renderContextData.currentTimestampQueryBuffers === undefined) {
          renderContextData.currentTimestampQueryBuffers = {
            resolveBuffer: this.device.createBuffer({
              label: 'timestamp resolve buffer',
              size: size,
              usage: GPUBufferUsage.QUERY_RESOLVE | GPUBufferUsage.COPY_SRC
            }),
            resultBuffer: this.device.createBuffer({
              label: 'timestamp result buffer',
              size: size,
              usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ
            })
          };
        }
        var _renderContextData$cu = renderContextData.currentTimestampQueryBuffers,
          resolveBuffer = _renderContextData$cu.resolveBuffer,
          resultBuffer = _renderContextData$cu.resultBuffer;
        encoder.resolveQuerySet(renderContextData.timeStampQuerySet, 0, 2, resolveBuffer, 0);
        if (resultBuffer.mapState === 'unmapped') {
          encoder.copyBufferToBuffer(resolveBuffer, 0, resultBuffer, 0, size);
        }
      }

      /**
       * Resolves the time stamp for the given render context and type.
       *
       * @async
       * @param {RenderContext} renderContext - The render context.
       * @param {String} type - The render context.
       * @return {Promise} A Promise that resolves when the time stamp has been computed.
       */
    }, {
      key: "resolveTimestampAsync",
      value: (function () {
        var _resolveTimestampAsync3 = (0, _asyncToGenerator2.default)(function* (renderContext) {
          var _this216 = this;
          var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'render';
          if (!this.trackTimestamp) return;
          var renderContextData = this.get(renderContext);
          if (renderContextData.currentTimestampQueryBuffers === undefined) return;
          var resultBuffer = renderContextData.currentTimestampQueryBuffers.resultBuffer;
          if (resultBuffer.mapState === 'unmapped') {
            resultBuffer.mapAsync(GPUMapMode.READ).then(function () {
              var times = new BigUint64Array(resultBuffer.getMappedRange());
              var duration = Number(times[1] - times[0]) / 1000000;
              _this216.renderer.info.updateTimestamp(type, duration);
              resultBuffer.unmap();
            });
          }
        });
        function resolveTimestampAsync(_x47) {
          return _resolveTimestampAsync3.apply(this, arguments);
        }
        return resolveTimestampAsync;
      }() // node builder
      /**
       * Returns a node builder for the given render object.
       *
       * @param {RenderObject} object - The render object.
       * @param {Renderer} renderer - The renderer.
       * @return {WGSLNodeBuilder} The node builder.
       */
      )
    }, {
      key: "createNodeBuilder",
      value: function createNodeBuilder(object, renderer) {
        return new WGSLNodeBuilder(object, renderer);
      }

      // program

      /**
       * Creates a shader program from the given programmable stage.
       *
       * @param {ProgrammableStage} program - The programmable stage.
       */
    }, {
      key: "createProgram",
      value: function createProgram(program) {
        var programGPU = this.get(program);
        programGPU.module = {
          module: this.device.createShaderModule({
            code: program.code,
            label: program.stage + (program.name !== '' ? `_${program.name}` : '')
          }),
          entryPoint: 'main'
        };
      }

      /**
       * Destroys the shader program of the given programmable stage.
       *
       * @param {ProgrammableStage} program - The programmable stage.
       */
    }, {
      key: "destroyProgram",
      value: function destroyProgram(program) {
        this.delete(program);
      }

      // pipelines

      /**
       * Creates a render pipeline for the given render object.
       *
       * @param {RenderObject} renderObject - The render object.
       * @param {Array<Promise>} promises - An array of compilation promises which are used in `compileAsync()`.
       */
    }, {
      key: "createRenderPipeline",
      value: function createRenderPipeline(renderObject, promises) {
        this.pipelineUtils.createRenderPipeline(renderObject, promises);
      }

      /**
       * Creates a compute pipeline for the given compute node.
       *
       * @param {ComputePipeline} computePipeline - The compute pipeline.
       * @param {Array<BindGroup>} bindings - The bindings.
       */
    }, {
      key: "createComputePipeline",
      value: function createComputePipeline(computePipeline, bindings) {
        this.pipelineUtils.createComputePipeline(computePipeline, bindings);
      }

      /**
       * Prepares the state for encoding render bundles.
       *
       * @param {RenderContext} renderContext - The render context.
       */
    }, {
      key: "beginBundle",
      value: function beginBundle(renderContext) {
        var renderContextData = this.get(renderContext);
        renderContextData._currentPass = renderContextData.currentPass;
        renderContextData._currentSets = renderContextData.currentSets;
        renderContextData.currentSets = {
          attributes: {},
          bindingGroups: [],
          pipeline: null,
          index: null
        };
        renderContextData.currentPass = this.pipelineUtils.createBundleEncoder(renderContext);
      }

      /**
       * After processing render bundles this method finalizes related work.
       *
       * @param {RenderContext} renderContext - The render context.
       * @param {RenderBundle} bundle - The render bundle.
       */
    }, {
      key: "finishBundle",
      value: function finishBundle(renderContext, bundle) {
        var renderContextData = this.get(renderContext);
        var bundleEncoder = renderContextData.currentPass;
        var bundleGPU = bundleEncoder.finish();
        this.get(bundle).bundleGPU = bundleGPU;

        // restore render pass state

        renderContextData.currentSets = renderContextData._currentSets;
        renderContextData.currentPass = renderContextData._currentPass;
      }

      /**
       * Adds a render bundle to the render context data.
       *
       * @param {RenderContext} renderContext - The render context.
       * @param {RenderBundle} bundle - The render bundle to add.
       */
    }, {
      key: "addBundle",
      value: function addBundle(renderContext, bundle) {
        var renderContextData = this.get(renderContext);
        renderContextData.renderBundles.push(this.get(bundle).bundleGPU);
      }

      // bindings

      /**
       * Creates bindings from the given bind group definition.
       *
       * @param {BindGroup} bindGroup - The bind group.
       * @param {Array<BindGroup>} bindings - Array of bind groups.
       * @param {Number} cacheIndex - The cache index.
       * @param {Number} version - The version.
       */
    }, {
      key: "createBindings",
      value: function createBindings(bindGroup, bindings, cacheIndex, version) {
        this.bindingUtils.createBindings(bindGroup, bindings, cacheIndex, version);
      }

      /**
       * Updates the given bind group definition.
       *
       * @param {BindGroup} bindGroup - The bind group.
       * @param {Array<BindGroup>} bindings - Array of bind groups.
       * @param {Number} cacheIndex - The cache index.
       * @param {Number} version - The version.
       */
    }, {
      key: "updateBindings",
      value: function updateBindings(bindGroup, bindings, cacheIndex, version) {
        this.bindingUtils.createBindings(bindGroup, bindings, cacheIndex, version);
      }

      /**
       * Updates a buffer binding.
       *
       *  @param {Buffer} binding - The buffer binding to update.
       */
    }, {
      key: "updateBinding",
      value: function updateBinding(binding) {
        this.bindingUtils.updateBinding(binding);
      }

      // attributes

      /**
       * Creates the buffer of an indexed shader attribute.
       *
       * @param {BufferAttribute} attribute - The indexed buffer attribute.
       */
    }, {
      key: "createIndexAttribute",
      value: function createIndexAttribute(attribute) {
        this.attributeUtils.createAttribute(attribute, GPUBufferUsage.INDEX | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST);
      }

      /**
       * Creates the buffer of a shader attribute.
       *
       * @param {BufferAttribute} attribute - The buffer attribute.
       */
    }, {
      key: "createAttribute",
      value: function createAttribute(attribute) {
        this.attributeUtils.createAttribute(attribute, GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST);
      }

      /**
       * Creates the buffer of a storage attribute.
       *
       * @param {BufferAttribute} attribute - The buffer attribute.
       */
    }, {
      key: "createStorageAttribute",
      value: function createStorageAttribute(attribute) {
        this.attributeUtils.createAttribute(attribute, GPUBufferUsage.STORAGE | GPUBufferUsage.VERTEX | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST);
      }

      /**
       * Creates the buffer of an indirect storage attribute.
       *
       * @param {BufferAttribute} attribute - The buffer attribute.
       */
    }, {
      key: "createIndirectStorageAttribute",
      value: function createIndirectStorageAttribute(attribute) {
        this.attributeUtils.createAttribute(attribute, GPUBufferUsage.STORAGE | GPUBufferUsage.INDIRECT | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST);
      }

      /**
       * Updates the buffer of a shader attribute.
       *
       * @param {BufferAttribute} attribute - The buffer attribute to update.
       */
    }, {
      key: "updateAttribute",
      value: function updateAttribute(attribute) {
        this.attributeUtils.updateAttribute(attribute);
      }

      /**
       * Destroys the buffer of a shader attribute.
       *
       * @param {BufferAttribute} attribute - The buffer attribute to destroy.
       */
    }, {
      key: "destroyAttribute",
      value: function destroyAttribute(attribute) {
        this.attributeUtils.destroyAttribute(attribute);
      }

      // canvas

      /**
       * Triggers an update of the default render pass descriptor.
       */
    }, {
      key: "updateSize",
      value: function updateSize() {
        this.colorBuffer = this.textureUtils.getColorBuffer();
        this.defaultRenderPassdescriptor = null;
      }

      // utils public

      /**
       * Returns the maximum anisotropy texture filtering value.
       *
       * @return {Number} The maximum anisotropy texture filtering value.
       */
    }, {
      key: "getMaxAnisotropy",
      value: function getMaxAnisotropy() {
        return 16;
      }

      /**
       * Checks if the given feature is supported  by the backend.
       *
       * @param {String} name - The feature's name.
       * @return {Boolean} Whether the feature is supported or not.
       */
    }, {
      key: "hasFeature",
      value: function hasFeature(name) {
        return this.device.features.has(name);
      }

      /**
       * Copies data of the given source texture to the given destination texture.
       *
       * @param {Texture} srcTexture - The source texture.
       * @param {Texture} dstTexture - The destination texture.
       * @param {Vector4?} [srcRegion=null] - The region of the source texture to copy.
       * @param {(Vector2|Vector3)?} [dstPosition=null] - The destination position of the copy.
       * @param {Number} [level=0] - The mip level to copy.
       */
    }, {
      key: "copyTextureToTexture",
      value: function copyTextureToTexture(srcTexture, dstTexture) {
        var srcRegion = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
        var dstPosition = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
        var level = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
        var dstX = 0;
        var dstY = 0;
        var dstLayer = 0;
        var srcX = 0;
        var srcY = 0;
        var srcLayer = 0;
        var srcWidth = srcTexture.image.width;
        var srcHeight = srcTexture.image.height;
        if (srcRegion !== null) {
          srcX = srcRegion.x;
          srcY = srcRegion.y;
          srcLayer = srcRegion.z || 0;
          srcWidth = srcRegion.width;
          srcHeight = srcRegion.height;
        }
        if (dstPosition !== null) {
          dstX = dstPosition.x;
          dstY = dstPosition.y;
          dstLayer = dstPosition.z || 0;
        }
        var encoder = this.device.createCommandEncoder({
          label: 'copyTextureToTexture_' + srcTexture.id + '_' + dstTexture.id
        });
        var sourceGPU = this.get(srcTexture).texture;
        var destinationGPU = this.get(dstTexture).texture;
        encoder.copyTextureToTexture({
          texture: sourceGPU,
          mipLevel: level,
          origin: {
            x: srcX,
            y: srcY,
            z: srcLayer
          }
        }, {
          texture: destinationGPU,
          mipLevel: level,
          origin: {
            x: dstX,
            y: dstY,
            z: dstLayer
          }
        }, [srcWidth, srcHeight, 1]);
        this.device.queue.submit([encoder.finish()]);
      }

      /**
       * Copies the current bound framebuffer to the given texture.
       *
       * @param {Texture} texture - The destination texture.
       * @param {RenderContext} renderContext - The render context.
       * @param {Vector4} rectangle - A four dimensional vector defining the origin and dimension of the copy.
       */
    }, {
      key: "copyFramebufferToTexture",
      value: function copyFramebufferToTexture(texture, renderContext, rectangle) {
        var renderContextData = this.get(renderContext);
        var sourceGPU = null;
        if (renderContext.renderTarget) {
          if (texture.isDepthTexture) {
            sourceGPU = this.get(renderContext.depthTexture).texture;
          } else {
            sourceGPU = this.get(renderContext.textures[0]).texture;
          }
        } else {
          if (texture.isDepthTexture) {
            sourceGPU = this.textureUtils.getDepthBuffer(renderContext.depth, renderContext.stencil);
          } else {
            sourceGPU = this.context.getCurrentTexture();
          }
        }
        var destinationGPU = this.get(texture).texture;
        if (sourceGPU.format !== destinationGPU.format) {
          console.error('WebGPUBackend: copyFramebufferToTexture: Source and destination formats do not match.', sourceGPU.format, destinationGPU.format);
          return;
        }
        var encoder;
        if (renderContextData.currentPass) {
          renderContextData.currentPass.end();
          encoder = renderContextData.encoder;
        } else {
          encoder = this.device.createCommandEncoder({
            label: 'copyFramebufferToTexture_' + texture.id
          });
        }
        encoder.copyTextureToTexture({
          texture: sourceGPU,
          origin: [rectangle.x, rectangle.y, 0]
        }, {
          texture: destinationGPU
        }, [rectangle.z, rectangle.w]);
        if (texture.generateMipmaps) this.textureUtils.generateMipmaps(texture);
        if (renderContextData.currentPass) {
          var descriptor = renderContextData.descriptor;
          for (var i = 0; i < descriptor.colorAttachments.length; i++) {
            descriptor.colorAttachments[i].loadOp = GPULoadOp.Load;
          }
          if (renderContext.depth) descriptor.depthStencilAttachment.depthLoadOp = GPULoadOp.Load;
          if (renderContext.stencil) descriptor.depthStencilAttachment.stencilLoadOp = GPULoadOp.Load;
          renderContextData.currentPass = encoder.beginRenderPass(descriptor);
          renderContextData.currentSets = {
            attributes: {},
            bindingGroups: [],
            pipeline: null,
            index: null
          };
          if (renderContext.viewport) {
            this.updateViewport(renderContext);
          }
          if (renderContext.scissor) {
            var _renderContext$scisso4 = renderContext.scissorValue,
              x = _renderContext$scisso4.x,
              y = _renderContext$scisso4.y,
              width = _renderContext$scisso4.width,
              height = _renderContext$scisso4.height;
            renderContextData.currentPass.setScissorRect(x, y, width, height);
          }
        } else {
          this.device.queue.submit([encoder.finish()]);
        }
      }
    }]);
  }(Backend);
  var IESSpotLight = exports.IESSpotLight = /*#__PURE__*/function (_SpotLight) {
    function IESSpotLight(color, intensity, distance, angle, penumbra, decay) {
      var _this217;
      (0, _classCallCheck2.default)(this, IESSpotLight);
      _this217 = _callSuper(this, IESSpotLight, [color, intensity, distance, angle, penumbra, decay]);
      _this217.iesMap = null;
      return _this217;
    }
    (0, _inherits2.default)(IESSpotLight, _SpotLight);
    return (0, _createClass2.default)(IESSpotLight, [{
      key: "copy",
      value: function copy(source, recursive) {
        _superPropGet(IESSpotLight, "copy", this, 3)([source, recursive]);
        this.iesMap = source.iesMap;
        return this;
      }
    }]);
  }(_$$_REQUIRE(_dependencyMap[1], "./three.core.js").SpotLight);
  /**
   * This version of a node library represents the standard version
   * used in {@link WebGPURenderer}. It maps lights, tone mapping
   * techniques and materials to node-based implementations.
   *
   * @private
   * @augments NodeLibrary
   */
  var StandardNodeLibrary = /*#__PURE__*/function (_NodeLibrary) {
    /**
     * Constructs a new standard node library.
     */
    function StandardNodeLibrary() {
      var _this218;
      (0, _classCallCheck2.default)(this, StandardNodeLibrary);
      _this218 = _callSuper(this, StandardNodeLibrary);
      _this218.addMaterial(MeshPhongNodeMaterial, 'MeshPhongMaterial');
      _this218.addMaterial(MeshStandardNodeMaterial, 'MeshStandardMaterial');
      _this218.addMaterial(MeshPhysicalNodeMaterial, 'MeshPhysicalMaterial');
      _this218.addMaterial(MeshToonNodeMaterial, 'MeshToonMaterial');
      _this218.addMaterial(MeshBasicNodeMaterial, 'MeshBasicMaterial');
      _this218.addMaterial(MeshLambertNodeMaterial, 'MeshLambertMaterial');
      _this218.addMaterial(MeshNormalNodeMaterial, 'MeshNormalMaterial');
      _this218.addMaterial(MeshMatcapNodeMaterial, 'MeshMatcapMaterial');
      _this218.addMaterial(LineBasicNodeMaterial, 'LineBasicMaterial');
      _this218.addMaterial(LineDashedNodeMaterial, 'LineDashedMaterial');
      _this218.addMaterial(PointsNodeMaterial, 'PointsMaterial');
      _this218.addMaterial(SpriteNodeMaterial, 'SpriteMaterial');
      _this218.addMaterial(ShadowNodeMaterial, 'ShadowMaterial');
      _this218.addLight(PointLightNode, _$$_REQUIRE(_dependencyMap[1], "./three.core.js").PointLight);
      _this218.addLight(DirectionalLightNode, _$$_REQUIRE(_dependencyMap[1], "./three.core.js").DirectionalLight);
      _this218.addLight(RectAreaLightNode, _$$_REQUIRE(_dependencyMap[1], "./three.core.js").RectAreaLight);
      _this218.addLight(SpotLightNode, _$$_REQUIRE(_dependencyMap[1], "./three.core.js").SpotLight);
      _this218.addLight(AmbientLightNode, _$$_REQUIRE(_dependencyMap[1], "./three.core.js").AmbientLight);
      _this218.addLight(HemisphereLightNode, _$$_REQUIRE(_dependencyMap[1], "./three.core.js").HemisphereLight);
      _this218.addLight(LightProbeNode, _$$_REQUIRE(_dependencyMap[1], "./three.core.js").LightProbe);
      _this218.addLight(IESSpotLightNode, IESSpotLight);
      _this218.addToneMapping(linearToneMapping, _$$_REQUIRE(_dependencyMap[1], "./three.core.js").LinearToneMapping);
      _this218.addToneMapping(reinhardToneMapping, _$$_REQUIRE(_dependencyMap[1], "./three.core.js").ReinhardToneMapping);
      _this218.addToneMapping(cineonToneMapping, _$$_REQUIRE(_dependencyMap[1], "./three.core.js").CineonToneMapping);
      _this218.addToneMapping(acesFilmicToneMapping, _$$_REQUIRE(_dependencyMap[1], "./three.core.js").ACESFilmicToneMapping);
      _this218.addToneMapping(agxToneMapping, _$$_REQUIRE(_dependencyMap[1], "./three.core.js").AgXToneMapping);
      _this218.addToneMapping(neutralToneMapping, _$$_REQUIRE(_dependencyMap[1], "./three.core.js").NeutralToneMapping);
      return _this218;
    }
    (0, _inherits2.default)(StandardNodeLibrary, _NodeLibrary);
    return (0, _createClass2.default)(StandardNodeLibrary);
  }(NodeLibrary);
  /*
  const debugHandler = {
  
  	get: function ( target, name ) {
  
  		// Add |update
  		if ( /^(create|destroy)/.test( name ) ) console.log( 'WebGPUBackend.' + name );
  
  		return target[ name ];
  
  	}
  
  };
  */
  /**
   * This renderer is the new alternative of `WebGLRenderer`. `WebGPURenderer` has the ability
   * to target different backends. By default, the renderer tries to use a WebGPU backend if the
   * browser supports WebGPU. If not, `WebGPURenderer` falls backs to a WebGL 2 backend.
   *
   * @augments module:Renderer~Renderer
   */
  var WebGPURenderer = exports.WebGPURenderer = /*#__PURE__*/function (_Renderer) {
    /**
     * Constructs a new WebGPU renderer.
     *
     * @param {Object} parameters - The configuration parameter.
     * @param {Boolean} [parameters.logarithmicDepthBuffer=false] - Whether logarithmic depth buffer is enabled or not.
     * @param {Boolean} [parameters.alpha=true] - Whether the default framebuffer (which represents the final contents of the canvas) should be transparent or opaque.
     * @param {Boolean} [parameters.depth=true] - Whether the default framebuffer should have a depth buffer or not.
     * @param {Boolean} [parameters.stencil=false] - Whether the default framebuffer should have a stencil buffer or not.
     * @param {Boolean} [parameters.antialias=false] - Whether MSAA as the default anti-aliasing should be enabled or not.
     * @param {Number} [parameters.samples=0] - When `antialias` is `true`, `4` samples are used by default. Set this parameter to any other integer value than 0
     * to overwrite the default.
     * @param {Boolean} [parameters.forceWebGL=false] - If set to `true`, the renderer uses it
     * WebGL 2 backend no matter if WebGPU is supported or not.
     */
    function WebGPURenderer() {
      var _this219;
      var parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      (0, _classCallCheck2.default)(this, WebGPURenderer);
      var BackendClass;
      if (parameters.forceWebGL) {
        BackendClass = WebGLBackend;
      } else {
        BackendClass = WebGPUBackend;
        parameters.getFallback = function () {
          console.warn('THREE.WebGPURenderer: WebGPU is not available, running under WebGL2 backend.');
          return new WebGLBackend(parameters);
        };
      }
      var backend = new BackendClass(parameters);

      //super( new Proxy( backend, debugHandler ) );
      _this219 = _callSuper(this, WebGPURenderer, [backend, parameters]);

      /**
       * The generic default value is overwritten with the
       * standard node library for type mapping.
       *
       * @type {StandardNodeLibrary}
       */
      _this219.library = new StandardNodeLibrary();

      /**
       * This flag can be used for type testing.
       *
       * @type {Boolean}
       * @readonly
       * @default true
       */
      _this219.isWebGPURenderer = true;
      return _this219;
    }
    (0, _inherits2.default)(WebGPURenderer, _Renderer);
    return (0, _createClass2.default)(WebGPURenderer);
  }(Renderer);
  /**
   * A specialized group which eanbles applications access to the
   * Render Bundle API of WebGPU. The group with all its descendant nodes
   * are considered as one render bundle and processed as such by
   * the renderer.
   *
   * This module is only fully supported by `WebGPURenderer` with a WebGPU backend.
   * With a WebGL backend, the group can technically be rendered but without
   * any performance improvements.
   *
   * @augments Group
   */
  var BundleGroup = exports.BundleGroup = /*#__PURE__*/function (_Group) {
    /**
     * Constructs a new bundle group.
     */
    function BundleGroup() {
      var _this220;
      (0, _classCallCheck2.default)(this, BundleGroup);
      _this220 = _callSuper(this, BundleGroup);

      /**
       * This flag can be used for type testing.
       *
       * @type {Boolean}
       * @readonly
       * @default true
       */
      _this220.isBundleGroup = true;

      /**
       * This property is only relevant for detecting types
       * during serialization/deserialization. It should always
       * match the class name.
       *
       * @type {String}
       * @readonly
       * @default 'BundleGroup'
       */
      _this220.type = 'BundleGroup';

      /**
       * Whether the bundle is static or not. When set to `true`, the structure
       * is assumed to be static and does not change. E.g. no new objects are
       * added to the group
       *
       * If a change is required, an update can still be forced by setting the
       * `needsUpdate` flag to `true`.
       *
       * @type {Boolean}
       * @default true
       */
      _this220.static = true;

      /**
       * The bundle group's version.
       *
       * @type {Number}
       * @readonly
       * @default 0
       */
      _this220.version = 0;
      return _this220;
    }

    /**
     * Set this property to `true` when the bundle group has changed.
     *
     * @type {Boolean}
     * @default false
     * @param {Boolean} value
     */
    (0, _inherits2.default)(BundleGroup, _Group);
    return (0, _createClass2.default)(BundleGroup, [{
      key: "needsUpdate",
      set: function set(value) {
        if (value === true) this.version++;
      }
    }]);
  }(_$$_REQUIRE(_dependencyMap[1], "./three.core.js").Group);
  var _material = /*@__PURE__*/new NodeMaterial();
  var _quadMesh = /*@__PURE__*/new QuadMesh(_material);

  /**
   * This module is responsible to manage the post processing setups in apps.
   * You usually create a single instance of this class and use it to define
   * the output of your post processing effect chain.
   * ```js
   * const postProcessing = new PostProcessing( renderer );
   *
   * const scenePass = pass( scene, camera );
   *
   * postProcessing.outputNode = scenePass;
   * ```
   */
  var PostProcessing = exports.PostProcessing = /*#__PURE__*/function () {
    /**
     * Constructs a new post processing management module.
     *
     * @param {Renderer} renderer - A reference to the renderer.
     * @param {Node<vec4>} outputNode - An optional output node.
     */
    function PostProcessing(renderer) {
      var outputNode = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : vec4(0, 0, 1, 1);
      (0, _classCallCheck2.default)(this, PostProcessing);
      /**
       * A reference to the renderer.
       *
       * @type {Renderer}
       */
      this.renderer = renderer;

      /**
       * A node which defines the final output of the post
       * processing. This is usually the last node in a chain
       * of effect nodes.
       *
       * @type {Node<vec4>}
       */
      this.outputNode = outputNode;

      /**
       * Whether the default output tone mapping and color
       * space transformation should be enabled or not.
       *
       * It is enabled by default by it must be disabled when
       * effects must be executed after tone mapping and color
       * space conversion. A typical example is FXAA which
       * requires sRGB input.
       *
       * When set to `false`, the app must control the output
       * transformation with `RenderOutputNode`.
       *
       * ```js
       * const outputPass = renderOutput( scenePass );
       * ```
       *
       * @type {Boolean}
       */
      this.outputColorTransform = true;

      /**
       * Must be set to `true` when the output node changes.
       *
       * @type {Node<vec4>}
       */
      this.needsUpdate = true;
      _material.name = 'PostProcessing';
    }

    /**
     * When `PostProcessing` is used to apply post processing effects,
     * the application must use this version of `render()` inside
     * its animation loop (not the one from the renderer).
     */
    return (0, _createClass2.default)(PostProcessing, [{
      key: "render",
      value: function render() {
        this._update();
        var renderer = this.renderer;
        var toneMapping = renderer.toneMapping;
        var outputColorSpace = renderer.outputColorSpace;
        renderer.toneMapping = _$$_REQUIRE(_dependencyMap[1], "./three.core.js").NoToneMapping;
        renderer.outputColorSpace = _$$_REQUIRE(_dependencyMap[1], "./three.core.js").LinearSRGBColorSpace;

        //

        _quadMesh.render(renderer);

        //

        renderer.toneMapping = toneMapping;
        renderer.outputColorSpace = outputColorSpace;
      }

      /**
       * Updates the state of the module.
       *
       * @private
       */
    }, {
      key: "_update",
      value: function _update() {
        if (this.needsUpdate === true) {
          var renderer = this.renderer;
          var _toneMapping = renderer.toneMapping;
          var outputColorSpace = renderer.outputColorSpace;
          _quadMesh.material.fragmentNode = this.outputColorTransform === true ? renderOutput(this.outputNode, _toneMapping, outputColorSpace) : this.outputNode.context({
            toneMapping: _toneMapping,
            outputColorSpace: outputColorSpace
          });
          _quadMesh.material.needsUpdate = true;
          this.needsUpdate = false;
        }
      }

      /**
       * When `PostProcessing` is used to apply post processing effects,
       * the application must use this version of `renderAsync()` inside
       * its animation loop (not the one from the renderer).
       *
       * @async
       * @return {Promise} A Promise that resolves when the render has been finished.
       */
    }, {
      key: "renderAsync",
      value: (function () {
        var _renderAsync3 = (0, _asyncToGenerator2.default)(function* () {
          this._update();
          var renderer = this.renderer;
          var toneMapping = renderer.toneMapping;
          var outputColorSpace = renderer.outputColorSpace;
          renderer.toneMapping = _$$_REQUIRE(_dependencyMap[1], "./three.core.js").NoToneMapping;
          renderer.outputColorSpace = _$$_REQUIRE(_dependencyMap[1], "./three.core.js").LinearSRGBColorSpace;

          //

          yield _quadMesh.renderAsync(renderer);

          //

          renderer.toneMapping = toneMapping;
          renderer.outputColorSpace = outputColorSpace;
        });
        function renderAsync() {
          return _renderAsync3.apply(this, arguments);
        }
        return renderAsync;
      }())
    }]);
  }();
  /**
   * This special type of texture is intended for compute shaders.
   * It can be used to compute the data of a texture with a compute shader.
   *
   * Note: This type of texture can only be used with `WebGPURenderer`
   * and a WebGPU backend.
   *
   * @augments Texture
   */
  var StorageTexture = exports.StorageTexture = /*#__PURE__*/function (_Texture) {
    /**
     * Constructs a new storage texture.
     *
     * @param {Number} [width=1] - The storage texture's width.
     * @param {Number} [height=1] - The storage texture's height.
     */
    function StorageTexture() {
      var _this221;
      var width = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
      var height = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
      (0, _classCallCheck2.default)(this, StorageTexture);
      _this221 = _callSuper(this, StorageTexture);

      /**
       * The image object which just represents the texture's dimension.
       *
       * @type {{width: Number, height:Number}}
       */
      _this221.image = {
        width: width,
        height: height
      };

      /**
       * The default `magFilter` for storage textures is `THREE.LinearFilter`.
       *
       * @type {Number}
       */
      _this221.magFilter = _$$_REQUIRE(_dependencyMap[1], "./three.core.js").LinearFilter;

      /**
       * The default `minFilter` for storage textures is `THREE.LinearFilter`.
       *
       * @type {Number}
       */
      _this221.minFilter = _$$_REQUIRE(_dependencyMap[1], "./three.core.js").LinearFilter;

      /**
       * This flag can be used for type testing.
       *
       * @type {Boolean}
       * @readonly
       * @default true
       */
      _this221.isStorageTexture = true;
      return _this221;
    }
    (0, _inherits2.default)(StorageTexture, _Texture);
    return (0, _createClass2.default)(StorageTexture);
  }(_$$_REQUIRE(_dependencyMap[1], "./three.core.js").Texture);
  /**
   * This special type of buffer attribute is intended for compute shaders.
   * It can be used to encode draw parameters for indirect draw calls.
   *
   * Note: This type of buffer attribute can only be used with `WebGPURenderer`
   * and a WebGPU backend.
   *
   * @augments StorageBufferAttribute
   */
  var IndirectStorageBufferAttribute = exports.IndirectStorageBufferAttribute = /*#__PURE__*/function (_StorageBufferAttribu) {
    /**
     * Constructs a new storage buffer attribute.
     *
     * @param {Number|Uint32Array} count - The item count. It is also valid to pass a `Uint32Array` as an argument.
     * The subsequent parameter is then obsolete.
     * @param {Number} itemSize - The item size.
     */
    function IndirectStorageBufferAttribute(count, itemSize) {
      var _this222;
      (0, _classCallCheck2.default)(this, IndirectStorageBufferAttribute);
      _this222 = _callSuper(this, IndirectStorageBufferAttribute, [count, itemSize, Uint32Array]);

      /**
       * This flag can be used for type testing.
       *
       * @type {Boolean}
       * @readonly
       * @default true
       */
      _this222.isIndirectStorageBufferAttribute = true;
      return _this222;
    }
    (0, _inherits2.default)(IndirectStorageBufferAttribute, _StorageBufferAttribu);
    return (0, _createClass2.default)(IndirectStorageBufferAttribute);
  }(StorageBufferAttribute);
  /**
   * A loader for loading node objects in the three.js JSON Object/Scene format.
   *
   * @augments Loader
   */
  var NodeLoader = exports.NodeLoader = /*#__PURE__*/function (_Loader) {
    /**
     * Constructs a new node loader.
     *
     * @param {LoadingManager?} manager - A reference to a loading manager.
     */
    function NodeLoader(manager) {
      var _this223;
      (0, _classCallCheck2.default)(this, NodeLoader);
      _this223 = _callSuper(this, NodeLoader, [manager]);

      /**
       * Represents a dictionary of textures.
       *
       * @type {Object<String,Texture>}
       */
      _this223.textures = {};

      /**
       * Represents a dictionary of node types.
       *
       * @type {Object<String,Node.constructor>}
       */
      _this223.nodes = {};
      return _this223;
    }

    /**
     * Loads the node definitions from the given URL.
     *
     * @param {String} url - The path/URL of the file to be loaded.
     * @param {Function} onLoad - Will be called when load completes.
     * @param {Function} onProgress - Will be called while load progresses.
     * @param {Function} onError - Will be called when errors are thrown during the loading process.
     */
    (0, _inherits2.default)(NodeLoader, _Loader);
    return (0, _createClass2.default)(NodeLoader, [{
      key: "load",
      value: function load(url, onLoad, onProgress, onError) {
        var _this224 = this;
        var loader = new (_$$_REQUIRE(_dependencyMap[1], "./three.core.js").FileLoader)(this.manager);
        loader.setPath(this.path);
        loader.setRequestHeader(this.requestHeader);
        loader.setWithCredentials(this.withCredentials);
        loader.load(url, function (text) {
          try {
            onLoad(_this224.parse(JSON.parse(text)));
          } catch (e) {
            if (onError) {
              onError(e);
            } else {
              console.error(e);
            }
            _this224.manager.itemError(url);
          }
        }, onProgress, onError);
      }

      /**
       * Parse the node dependencies for the loaded node.
       *
       * @param {Object} json - The JSON definition
       * @return {Object<String,Node>} A dictionary with node dependencies.
       */
    }, {
      key: "parseNodes",
      value: function parseNodes(json) {
        var nodes = {};
        if (json !== undefined) {
          for (var nodeJSON of json) {
            var uuid = nodeJSON.uuid,
              type = nodeJSON.type;
            nodes[uuid] = this.createNodeFromType(type);
            nodes[uuid].uuid = uuid;
          }
          var meta = {
            nodes: nodes,
            textures: this.textures
          };
          for (var _nodeJSON of json) {
            _nodeJSON.meta = meta;
            var node = nodes[_nodeJSON.uuid];
            node.deserialize(_nodeJSON);
            delete _nodeJSON.meta;
          }
        }
        return nodes;
      }

      /**
       * Parses the node from the given JSON.
       *
       * @param {Object} json - The JSON definition
       * @return {Node} The parsed node.
       */
    }, {
      key: "parse",
      value: function parse(json) {
        var node = this.createNodeFromType(json.type);
        node.uuid = json.uuid;
        var nodes = this.parseNodes(json.nodes);
        var meta = {
          nodes: nodes,
          textures: this.textures
        };
        json.meta = meta;
        node.deserialize(json);
        delete json.meta;
        return node;
      }

      /**
       * Defines the dictionary of textures.
       *
       * @param {Object<String,Texture>} value - The texture library defines as `<uuid,texture>`.
       * @return {NodeLoader} A reference to this loader.
       */
    }, {
      key: "setTextures",
      value: function setTextures(value) {
        this.textures = value;
        return this;
      }

      /**
       * Defines the dictionary of node types.
       *
       * @param {Object<String,Node.constructor>} value - The node library defined as `<classname,class>`.
       * @return {NodeLoader} A reference to this loader.
       */
    }, {
      key: "setNodes",
      value: function setNodes(value) {
        this.nodes = value;
        return this;
      }

      /**
       * Creates a node object from the given type.
       *
       * @param {String} type - The node type.
       * @return {Node} The created node instance.
       */
    }, {
      key: "createNodeFromType",
      value: function createNodeFromType(type) {
        if (this.nodes[type] === undefined) {
          console.error('THREE.NodeLoader: Node type not found:', type);
          return float();
        }
        return nodeObject(new this.nodes[type]());
      }
    }]);
  }(_$$_REQUIRE(_dependencyMap[1], "./three.core.js").Loader);
  /**
   * A special type of material loader for loading node materials.
   *
   * @augments MaterialLoader
   */
  var NodeMaterialLoader = exports.NodeMaterialLoader = /*#__PURE__*/function (_MaterialLoader) {
    /**
     * Constructs a new node material loader.
     *
     * @param {LoadingManager?} manager - A reference to a loading manager.
     */
    function NodeMaterialLoader(manager) {
      var _this225;
      (0, _classCallCheck2.default)(this, NodeMaterialLoader);
      _this225 = _callSuper(this, NodeMaterialLoader, [manager]);

      /**
       * Represents a dictionary of node types.
       *
       * @type {Object<String,Node.constructor>}
       */
      _this225.nodes = {};

      /**
       * Represents a dictionary of node material types.
       *
       * @type {Object<String,NodeMaterial.constructor>}
       */
      _this225.nodeMaterials = {};
      return _this225;
    }

    /**
     * Parses the node material from the given JSON.
     *
     * @param {Object} json - The JSON definition
     * @return {NodeMaterial}. The parsed material.
     */
    (0, _inherits2.default)(NodeMaterialLoader, _MaterialLoader);
    return (0, _createClass2.default)(NodeMaterialLoader, [{
      key: "parse",
      value: function parse(json) {
        var material = _superPropGet(NodeMaterialLoader, "parse", this, 3)([json]);
        var nodes = this.nodes;
        var inputNodes = json.inputNodes;
        for (var _property12 in inputNodes) {
          var uuid = inputNodes[_property12];
          material[_property12] = nodes[uuid];
        }
        return material;
      }

      /**
       * Defines the dictionary of node types.
       *
       * @param {Object<String,Node.constructor>} value - The node library defined as `<classname,class>`.
       * @return {NodeLoader} A reference to this loader.
       */
    }, {
      key: "setNodes",
      value: function setNodes(value) {
        this.nodes = value;
        return this;
      }

      /**
       * Defines the dictionary of node material types.
       *
       * @param {Object<String,NodeMaterial.constructor>} value - The node material library defined as `<classname,class>`.
       * @return {NodeLoader} A reference to this loader.
       */
    }, {
      key: "setNodeMaterials",
      value: function setNodeMaterials(value) {
        this.nodeMaterials = value;
        return this;
      }

      /**
       * Creates a node material from the given type.
       *
       * @param {String} type - The node material type.
       * @return {Node} The created node material instance.
       */
    }, {
      key: "createMaterialFromType",
      value: function createMaterialFromType(type) {
        var materialClass = this.nodeMaterials[type];
        if (materialClass !== undefined) {
          return new materialClass();
        }
        return _superPropGet(NodeMaterialLoader, "createMaterialFromType", this, 3)([type]);
      }
    }]);
  }(_$$_REQUIRE(_dependencyMap[1], "./three.core.js").MaterialLoader);
  /**
   * A special type of object loader for loading 3D objects using
   * node materials.
   *
   * @augments ObjectLoader
   */
  var NodeObjectLoader = exports.NodeObjectLoader = /*#__PURE__*/function (_ObjectLoader) {
    /**
     * Constructs a new node object loader.
     *
     * @param {LoadingManager?} manager - A reference to a loading manager.
     */
    function NodeObjectLoader(manager) {
      var _this226;
      (0, _classCallCheck2.default)(this, NodeObjectLoader);
      _this226 = _callSuper(this, NodeObjectLoader, [manager]);

      /**
       * Represents a dictionary of node types.
       *
       * @type {Object<String,Node.constructor>}
       */
      _this226.nodes = {};

      /**
       * Represents a dictionary of node material types.
       *
       * @type {Object<String,NodeMaterial.constructor>}
       */
      _this226.nodeMaterials = {};

      /**
       * A reference for holdng the `nodes` JSON property.
       *
       * @private
       * @type {Object?}
       */
      _this226._nodesJSON = null;
      return _this226;
    }

    /**
     * Defines the dictionary of node types.
     *
     * @param {Object<String,Node.constructor>} value - The node library defined as `<classname,class>`.
     * @return {NodeLoader} A reference to this loader.
     */
    (0, _inherits2.default)(NodeObjectLoader, _ObjectLoader);
    return (0, _createClass2.default)(NodeObjectLoader, [{
      key: "setNodes",
      value: function setNodes(value) {
        this.nodes = value;
        return this;
      }

      /**
       * Defines the dictionary of node material types.
       *
       * @param {Object<String,NodeMaterial.constructor>} value - The node material library defined as `<classname,class>`.
       * @return {NodeLoader} A reference to this loader.
       */
    }, {
      key: "setNodeMaterials",
      value: function setNodeMaterials(value) {
        this.nodeMaterials = value;
        return this;
      }

      /**
       * Parses the node objects from the given JSON.
       *
       * @param {Object} json - The JSON definition
       * @param {Function} onLoad - The onLoad callback function.
       * @return {Object3D}. The parsed 3D object.
       */
    }, {
      key: "parse",
      value: function parse(json, onLoad) {
        this._nodesJSON = json.nodes;
        var data = _superPropGet(NodeObjectLoader, "parse", this, 3)([json, onLoad]);
        this._nodesJSON = null; // dispose

        return data;
      }

      /**
       * Parses the node objects from the given JSON and textures.
       *
       * @param {Object} json - The JSON definition
       * @param {Object<String,Texture>} textures - The texture library.
       * @return {Object<String,Node>}. The parsed nodes.
       */
    }, {
      key: "parseNodes",
      value: function parseNodes(json, textures) {
        if (json !== undefined) {
          var loader = new NodeLoader();
          loader.setNodes(this.nodes);
          loader.setTextures(textures);
          return loader.parseNodes(json);
        }
        return {};
      }

      /**
       * Parses the node objects from the given JSON and textures.
       *
       * @param {Object} json - The JSON definition
       * @param {Object<String,Texture>} textures - The texture library.
       * @return {Object<String,NodeMaterial>}. The parsed materials.
       */
    }, {
      key: "parseMaterials",
      value: function parseMaterials(json, textures) {
        var materials = {};
        if (json !== undefined) {
          var nodes = this.parseNodes(this._nodesJSON, textures);
          var loader = new NodeMaterialLoader();
          loader.setTextures(textures);
          loader.setNodes(nodes);
          loader.setNodeMaterials(this.nodeMaterials);
          for (var i = 0, l = json.length; i < l; i++) {
            var data = json[i];
            materials[data.uuid] = loader.parse(data);
          }
        }
        return materials;
      }
    }]);
  }(_$$_REQUIRE(_dependencyMap[1], "./three.core.js").ObjectLoader);
  /**
   * In earlier three.js versions, clipping was defined globally
   * on the renderer or on material level. This special version of
   * `THREE.Group` allows to encode the clipping state into the scene
   * graph. Meaning if you create an instance of this group, all
   * descendant 3D objects will be affected by the respective clipping
   * planes.
   *
   * Note: `ClippingGroup` can only be used with `WebGPURenderer`.
   *
   * @augments Group
   */
  var ClippingGroup = exports.ClippingGroup = /*#__PURE__*/function (_Group2) {
    /**
     * Constructs a new clipping group.
     */
    function ClippingGroup() {
      var _this227;
      (0, _classCallCheck2.default)(this, ClippingGroup);
      _this227 = _callSuper(this, ClippingGroup);

      /**
       * This flag can be used for type testing.
       *
       * @type {Boolean}
       * @readonly
       * @default true
       */
      _this227.isClippingGroup = true;

      /**
       * An array with clipping planes.
       *
       * @type {Array<Plane>}
       */
      _this227.clippingPlanes = [];

      /**
       * Whether clipping should be enabled or not.
       *
       * @type {Boolean}
       * @default true
       */
      _this227.enabled = true;

      /**
       * Whether the intersection of the clipping planes is used to clip objects, rather than their union.
       *
       * @type {Boolean}
       * @default false
       */
      _this227.clipIntersection = false;

      /**
       * Whether shadows should be clipped or not.
       *
       * @type {Boolean}
       * @default false
       */
      _this227.clipShadows = false;
      return _this227;
    }
    (0, _inherits2.default)(ClippingGroup, _Group2);
    return (0, _createClass2.default)(ClippingGroup);
  }(_$$_REQUIRE(_dependencyMap[1], "./three.core.js").Group);
},2,[3,4,28,31,6,5,12,18,24,11,27,8,20,32,33],"../../node_modules/three/build/three.webgpu.js");
global.__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  function _interopRequireDefault(e) {
    return e && e.__esModule ? e : {
      "default": e
    };
  }
  module.exports = _interopRequireDefault, module.exports.__esModule = true, module.exports["default"] = module.exports;
},3,[],"../../node_modules/@babel/runtime/helpers/interopRequireDefault.js");
global.__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.DstAlphaFactor = exports.DoubleSide = exports.DodecahedronGeometry = exports.DiscreteInterpolant = exports.DirectionalLightHelper = exports.DirectionalLight = exports.DetachedBindMode = exports.DepthTexture = exports.DepthStencilFormat = exports.DepthFormat = exports.DefaultLoadingManager = exports.DecrementWrapStencilOp = exports.DecrementStencilOp = exports.DataUtils = exports.DataTextureLoader = exports.DataTexture = exports.DataArrayTexture = exports.Data3DTexture = exports.Cylindrical = exports.CylinderGeometry = exports.CustomToneMapping = exports.CustomBlending = exports.CurvePath = exports.Curve = exports.CullFaceNone = exports.CullFaceFrontBack = exports.CullFaceFront = exports.CullFaceBack = exports.CubicInterpolant = exports.CubicBezierCurve3 = exports.CubicBezierCurve = exports.CubeUVReflectionMapping = exports.CubeTextureLoader = exports.CubeTexture = exports.CubeRefractionMapping = exports.CubeReflectionMapping = exports.CubeCamera = exports.Controls = exports.ConstantColorFactor = exports.ConstantAlphaFactor = exports.ConeGeometry = exports.CompressedTextureLoader = exports.CompressedTexture = exports.CompressedCubeTexture = exports.CompressedArrayTexture = exports.ColorManagement = exports.ColorKeyframeTrack = exports.Color = exports.Clock = exports.ClampToEdgeWrapping = exports.CircleGeometry = exports.CineonToneMapping = exports.CatmullRomCurve3 = exports.CapsuleGeometry = exports.CanvasTexture = exports.CameraHelper = exports.Camera = exports.Cache = exports.ByteType = exports.BufferGeometryLoader = exports.BufferGeometry = exports.BufferAttribute = exports.BoxHelper = exports.BoxGeometry = exports.Box3Helper = exports.Box3 = exports.Box2 = exports.BooleanKeyframeTrack = exports.Bone = exports.BatchedMesh = exports.BasicShadowMap = exports.BasicDepthPacking = exports.BackSide = exports.AxesHelper = exports.AudioLoader = exports.AudioListener = exports.AudioContext = exports.AudioAnalyser = exports.Audio = exports.AttachedBindMode = exports.ArrowHelper = exports.ArrayCamera = exports.ArcCurve = exports.AnimationUtils = exports.AnimationObjectGroup = exports.AnimationMixer = exports.AnimationLoader = exports.AnimationClip = exports.AnimationAction = exports.AmbientLight = exports.AlwaysStencilFunc = exports.AlwaysDepth = exports.AlwaysCompare = exports.AlphaFormat = exports.AgXToneMapping = exports.AdditiveBlending = exports.AdditiveAnimationBlendMode = exports.AddOperation = exports.AddEquation = exports.ACESFilmicToneMapping = void 0;
  exports.MathUtils = exports.MaterialLoader = exports.Material = exports.MOUSE = exports.LuminanceFormat = exports.LuminanceAlphaFormat = exports.LoopRepeat = exports.LoopPingPong = exports.LoopOnce = exports.LoadingManager = exports.LoaderUtils = exports.Loader = exports.LinearTransfer = exports.LinearToneMapping = exports.LinearSRGBColorSpace = exports.LinearMipmapNearestFilter = exports.LinearMipmapLinearFilter = exports.LinearMipMapNearestFilter = exports.LinearMipMapLinearFilter = exports.LinearInterpolant = exports.LinearFilter = exports.LineSegments = exports.LineLoop = exports.LineDashedMaterial = exports.LineCurve3 = exports.LineCurve = exports.LineBasicMaterial = exports.Line3 = exports.Line = exports.LightProbe = exports.Light = exports.LessStencilFunc = exports.LessEqualStencilFunc = exports.LessEqualDepth = exports.LessEqualCompare = exports.LessDepth = exports.LessCompare = exports.Layers = exports.LatheGeometry = exports.LOD = exports.KeyframeTrack = exports.KeepStencilOp = exports.InvertStencilOp = exports.InterpolateSmooth = exports.InterpolateLinear = exports.InterpolateDiscrete = exports.Interpolant = exports.InterleavedBufferAttribute = exports.InterleavedBuffer = exports.IntType = exports.Int8BufferAttribute = exports.Int32BufferAttribute = exports.Int16BufferAttribute = exports.InstancedMesh = exports.InstancedInterleavedBuffer = exports.InstancedBufferGeometry = exports.InstancedBufferAttribute = exports.IncrementWrapStencilOp = exports.IncrementStencilOp = exports.ImageUtils = exports.ImageLoader = exports.ImageBitmapLoader = exports.IcosahedronGeometry = exports.HemisphereLightHelper = exports.HemisphereLight = exports.HalfFloatType = exports.Group = exports.GridHelper = exports.GreaterStencilFunc = exports.GreaterEqualStencilFunc = exports.GreaterEqualDepth = exports.GreaterEqualCompare = exports.GreaterDepth = exports.GreaterCompare = exports.GLSL3 = exports.GLSL1 = exports.GLBufferAttribute = exports.Frustum = exports.FrontSide = exports.FramebufferTexture = exports.FogExp2 = exports.Fog = exports.FloatType = exports.Float32BufferAttribute = exports.Float16BufferAttribute = exports.FileLoader = exports.ExtrudeGeometry = exports.EventDispatcher = exports.Euler = exports.EquirectangularRefractionMapping = exports.EquirectangularReflectionMapping = exports.EqualStencilFunc = exports.EqualDepth = exports.EqualCompare = exports.EllipseCurve = exports.EdgesGeometry = exports.DynamicReadUsage = exports.DynamicDrawUsage = exports.DynamicCopyUsage = exports.DstColorFactor = void 0;
  exports.RGBDepthPacking = exports.RGBA_S3TC_DXT5_Format = exports.RGBA_S3TC_DXT3_Format = exports.RGBA_S3TC_DXT1_Format = exports.RGBA_PVRTC_4BPPV1_Format = exports.RGBA_PVRTC_2BPPV1_Format = exports.RGBA_ETC2_EAC_Format = exports.RGBA_BPTC_Format = exports.RGBA_ASTC_8x8_Format = exports.RGBA_ASTC_8x6_Format = exports.RGBA_ASTC_8x5_Format = exports.RGBA_ASTC_6x6_Format = exports.RGBA_ASTC_6x5_Format = exports.RGBA_ASTC_5x5_Format = exports.RGBA_ASTC_5x4_Format = exports.RGBA_ASTC_4x4_Format = exports.RGBA_ASTC_12x12_Format = exports.RGBA_ASTC_12x10_Format = exports.RGBA_ASTC_10x8_Format = exports.RGBA_ASTC_10x6_Format = exports.RGBA_ASTC_10x5_Format = exports.RGBA_ASTC_10x10_Format = exports.RGBAIntegerFormat = exports.RGBAFormat = exports.RGBADepthPacking = exports.REVISION = exports.RED_RGTC1_Format = exports.RED_GREEN_RGTC2_Format = exports.RAD2DEG = exports.QuaternionLinearInterpolant = exports.QuaternionKeyframeTrack = exports.Quaternion = exports.QuadraticBezierCurve3 = exports.QuadraticBezierCurve = exports.PropertyMixer = exports.PropertyBinding = exports.PositionalAudio = exports.PolyhedronGeometry = exports.PolarGridHelper = exports.PointsMaterial = exports.Points = exports.PointLightHelper = exports.PointLight = exports.PlaneHelper = exports.PlaneGeometry = exports.Plane = exports.PerspectiveCamera = exports.Path = exports.PCFSoftShadowMap = exports.PCFShadowMap = exports.OrthographicCamera = exports.OneMinusSrcColorFactor = exports.OneMinusSrcAlphaFactor = exports.OneMinusDstColorFactor = exports.OneMinusDstAlphaFactor = exports.OneMinusConstantColorFactor = exports.OneMinusConstantAlphaFactor = exports.OneFactor = exports.OctahedronGeometry = exports.ObjectSpaceNormalMap = exports.ObjectLoader = exports.Object3D = exports.NumberKeyframeTrack = exports.NotEqualStencilFunc = exports.NotEqualDepth = exports.NotEqualCompare = exports.NormalBlending = exports.NormalAnimationBlendMode = exports.NoToneMapping = exports.NoColorSpace = exports.NoBlending = exports.NeverStencilFunc = exports.NeverDepth = exports.NeverCompare = exports.NeutralToneMapping = exports.NearestMipmapNearestFilter = exports.NearestMipmapLinearFilter = exports.NearestMipMapNearestFilter = exports.NearestMipMapLinearFilter = exports.NearestFilter = exports.MultiplyOperation = exports.MultiplyBlending = exports.MixOperation = exports.MirroredRepeatWrapping = exports.MinEquation = exports.MeshToonMaterial = exports.MeshStandardMaterial = exports.MeshPhysicalMaterial = exports.MeshPhongMaterial = exports.MeshNormalMaterial = exports.MeshMatcapMaterial = exports.MeshLambertMaterial = exports.MeshDistanceMaterial = exports.MeshDepthMaterial = exports.MeshBasicMaterial = exports.Mesh = exports.MaxEquation = exports.Matrix4 = exports.Matrix3 = exports.Matrix2 = void 0;
  exports.WebGLArrayRenderTarget = exports.WebGL3DRenderTarget = exports.VideoTexture = exports.VectorKeyframeTrack = exports.Vector4 = exports.Vector3 = exports.Vector2 = exports.VSMShadowMap = exports.UnsignedShortType = exports.UnsignedShort5551Type = exports.UnsignedShort4444Type = exports.UnsignedIntType = exports.UnsignedInt5999Type = exports.UnsignedInt248Type = exports.UnsignedByteType = exports.UniformsUtils = exports.UniformsGroup = exports.Uniform = exports.Uint8ClampedBufferAttribute = exports.Uint8BufferAttribute = exports.Uint32BufferAttribute = exports.Uint16BufferAttribute = exports.UVMapping = exports.TubeGeometry = exports.TrianglesDrawMode = exports.TriangleStripDrawMode = exports.TriangleFanDrawMode = exports.Triangle = exports.TorusKnotGeometry = exports.TorusGeometry = exports.TextureUtils = exports.TextureLoader = exports.Texture = exports.TetrahedronGeometry = exports.TangentSpaceNormalMap = exports.TOUCH = exports.SubtractiveBlending = exports.SubtractEquation = exports.StringKeyframeTrack = exports.StreamReadUsage = exports.StreamDrawUsage = exports.StreamCopyUsage = exports.StereoCamera = exports.StaticReadUsage = exports.StaticDrawUsage = exports.StaticCopyUsage = exports.SrcColorFactor = exports.SrcAlphaSaturateFactor = exports.SrcAlphaFactor = exports.SpriteMaterial = exports.Sprite = exports.SpotLightHelper = exports.SpotLight = exports.SplineCurve = exports.SphericalHarmonics3 = exports.Spherical = exports.SphereGeometry = exports.Sphere = exports.Source = exports.SkinnedMesh = exports.SkeletonHelper = exports.Skeleton = exports.ShortType = exports.ShapeUtils = exports.ShapePath = exports.ShapeGeometry = exports.Shape = exports.ShadowMaterial = exports.ShaderMaterial = exports.Scene = exports.SRGBTransfer = exports.SRGBColorSpace = exports.SIGNED_RED_RGTC1_Format = exports.SIGNED_RED_GREEN_RGTC2_Format = exports.RingGeometry = exports.ReverseSubtractEquation = exports.ReplaceStencilOp = exports.RepeatWrapping = exports.RenderTargetArray = exports.RenderTarget3D = exports.RenderTarget = exports.ReinhardToneMapping = exports.RedIntegerFormat = exports.RedFormat = exports.RectAreaLight = exports.Raycaster = exports.Ray = exports.RawShaderMaterial = exports.RGIntegerFormat = exports.RGFormat = exports.RGDepthPacking = exports.RGB_S3TC_DXT1_Format = exports.RGB_PVRTC_4BPPV1_Format = exports.RGB_PVRTC_2BPPV1_Format = exports.RGB_ETC2_Format = exports.RGB_ETC1_Format = exports.RGB_BPTC_UNSIGNED_Format = exports.RGB_BPTC_SIGNED_Format = exports.RGBIntegerFormat = exports.RGBFormat = void 0;
  exports.ZeroStencilOp = exports.ZeroSlopeEnding = exports.ZeroFactor = exports.ZeroCurvatureEnding = exports.WrapAroundEnding = exports.WireframeGeometry = exports.WebGPUCoordinateSystem = exports.WebGLRenderTarget = exports.WebGLCubeRenderTarget = exports.WebGLCoordinateSystem = void 0;
  exports.arrayNeedsUint32 = arrayNeedsUint32;
  exports.cloneUniforms = cloneUniforms;
  exports.createCanvasElement = createCanvasElement;
  exports.createElementNS = createElementNS;
  exports.getByteLength = getByteLength;
  exports.getUnlitUniformColorSpace = getUnlitUniformColorSpace;
  exports.mergeUniforms = mergeUniforms;
  exports.probeAsync = probeAsync;
  exports.toNormalizedProjectionMatrix = toNormalizedProjectionMatrix;
  exports.toReversedProjectionMatrix = toReversedProjectionMatrix;
  exports.warnOnce = warnOnce;
  var _asyncToGenerator2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[1], "@babel/runtime/helpers/asyncToGenerator"));
  var _wrapNativeSuper2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[2], "@babel/runtime/helpers/wrapNativeSuper"));
  var _slicedToArray2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[3], "@babel/runtime/helpers/slicedToArray"));
  var _get2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[4], "@babel/runtime/helpers/get"));
  var _toConsumableArray2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[5], "@babel/runtime/helpers/toConsumableArray"));
  var _possibleConstructorReturn2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[6], "@babel/runtime/helpers/possibleConstructorReturn"));
  var _getPrototypeOf2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[7], "@babel/runtime/helpers/getPrototypeOf"));
  var _inherits2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[8], "@babel/runtime/helpers/inherits"));
  var _defineProperty2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[9], "@babel/runtime/helpers/defineProperty"));
  var _readOnlyError2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[10], "@babel/runtime/helpers/readOnlyError"));
  var _classCallCheck2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[11], "@babel/runtime/helpers/classCallCheck"));
  var _createClass2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[12], "@babel/runtime/helpers/createClass"));
  function _superPropGet(t, o, e, r) { var p = (0, _get2.default)((0, _getPrototypeOf2.default)(1 & r ? t.prototype : t), o, e); return 2 & r && "function" == typeof p ? function (t) { return p.apply(e, t); } : p; }
  function _callSuper(t, o, e) { return o = (0, _getPrototypeOf2.default)(o), (0, _possibleConstructorReturn2.default)(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], (0, _getPrototypeOf2.default)(t).constructor) : o.apply(t, e)); }
  function _isNativeReflectConstruct() { try { var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); } catch (t) {} return (_isNativeReflectConstruct = function _isNativeReflectConstruct() { return !!t; })(); }
  /**
   * @license
   * Copyright 2010-2024 Three.js Authors
   * SPDX-License-Identifier: MIT
   */
  var REVISION = exports.REVISION = '172';
  var MOUSE = exports.MOUSE = {
    LEFT: 0,
    MIDDLE: 1,
    RIGHT: 2,
    ROTATE: 0,
    DOLLY: 1,
    PAN: 2
  };
  var TOUCH = exports.TOUCH = {
    ROTATE: 0,
    PAN: 1,
    DOLLY_PAN: 2,
    DOLLY_ROTATE: 3
  };
  var CullFaceNone = exports.CullFaceNone = 0;
  var CullFaceBack = exports.CullFaceBack = 1;
  var CullFaceFront = exports.CullFaceFront = 2;
  var CullFaceFrontBack = exports.CullFaceFrontBack = 3;
  var BasicShadowMap = exports.BasicShadowMap = 0;
  var PCFShadowMap = exports.PCFShadowMap = 1;
  var PCFSoftShadowMap = exports.PCFSoftShadowMap = 2;
  var VSMShadowMap = exports.VSMShadowMap = 3;
  var FrontSide = exports.FrontSide = 0;
  var BackSide = exports.BackSide = 1;
  var DoubleSide = exports.DoubleSide = 2;
  var NoBlending = exports.NoBlending = 0;
  var NormalBlending = exports.NormalBlending = 1;
  var AdditiveBlending = exports.AdditiveBlending = 2;
  var SubtractiveBlending = exports.SubtractiveBlending = 3;
  var MultiplyBlending = exports.MultiplyBlending = 4;
  var CustomBlending = exports.CustomBlending = 5;
  var AddEquation = exports.AddEquation = 100;
  var SubtractEquation = exports.SubtractEquation = 101;
  var ReverseSubtractEquation = exports.ReverseSubtractEquation = 102;
  var MinEquation = exports.MinEquation = 103;
  var MaxEquation = exports.MaxEquation = 104;
  var ZeroFactor = exports.ZeroFactor = 200;
  var OneFactor = exports.OneFactor = 201;
  var SrcColorFactor = exports.SrcColorFactor = 202;
  var OneMinusSrcColorFactor = exports.OneMinusSrcColorFactor = 203;
  var SrcAlphaFactor = exports.SrcAlphaFactor = 204;
  var OneMinusSrcAlphaFactor = exports.OneMinusSrcAlphaFactor = 205;
  var DstAlphaFactor = exports.DstAlphaFactor = 206;
  var OneMinusDstAlphaFactor = exports.OneMinusDstAlphaFactor = 207;
  var DstColorFactor = exports.DstColorFactor = 208;
  var OneMinusDstColorFactor = exports.OneMinusDstColorFactor = 209;
  var SrcAlphaSaturateFactor = exports.SrcAlphaSaturateFactor = 210;
  var ConstantColorFactor = exports.ConstantColorFactor = 211;
  var OneMinusConstantColorFactor = exports.OneMinusConstantColorFactor = 212;
  var ConstantAlphaFactor = exports.ConstantAlphaFactor = 213;
  var OneMinusConstantAlphaFactor = exports.OneMinusConstantAlphaFactor = 214;
  var NeverDepth = exports.NeverDepth = 0;
  var AlwaysDepth = exports.AlwaysDepth = 1;
  var LessDepth = exports.LessDepth = 2;
  var LessEqualDepth = exports.LessEqualDepth = 3;
  var EqualDepth = exports.EqualDepth = 4;
  var GreaterEqualDepth = exports.GreaterEqualDepth = 5;
  var GreaterDepth = exports.GreaterDepth = 6;
  var NotEqualDepth = exports.NotEqualDepth = 7;
  var MultiplyOperation = exports.MultiplyOperation = 0;
  var MixOperation = exports.MixOperation = 1;
  var AddOperation = exports.AddOperation = 2;
  var NoToneMapping = exports.NoToneMapping = 0;
  var LinearToneMapping = exports.LinearToneMapping = 1;
  var ReinhardToneMapping = exports.ReinhardToneMapping = 2;
  var CineonToneMapping = exports.CineonToneMapping = 3;
  var ACESFilmicToneMapping = exports.ACESFilmicToneMapping = 4;
  var CustomToneMapping = exports.CustomToneMapping = 5;
  var AgXToneMapping = exports.AgXToneMapping = 6;
  var NeutralToneMapping = exports.NeutralToneMapping = 7;
  var AttachedBindMode = exports.AttachedBindMode = 'attached';
  var DetachedBindMode = exports.DetachedBindMode = 'detached';
  var UVMapping = exports.UVMapping = 300;
  var CubeReflectionMapping = exports.CubeReflectionMapping = 301;
  var CubeRefractionMapping = exports.CubeRefractionMapping = 302;
  var EquirectangularReflectionMapping = exports.EquirectangularReflectionMapping = 303;
  var EquirectangularRefractionMapping = exports.EquirectangularRefractionMapping = 304;
  var CubeUVReflectionMapping = exports.CubeUVReflectionMapping = 306;
  var RepeatWrapping = exports.RepeatWrapping = 1000;
  var ClampToEdgeWrapping = exports.ClampToEdgeWrapping = 1001;
  var MirroredRepeatWrapping = exports.MirroredRepeatWrapping = 1002;
  var NearestFilter = exports.NearestFilter = 1003;
  var NearestMipmapNearestFilter = exports.NearestMipmapNearestFilter = 1004;
  var NearestMipMapNearestFilter = exports.NearestMipMapNearestFilter = 1004;
  var NearestMipmapLinearFilter = exports.NearestMipmapLinearFilter = 1005;
  var NearestMipMapLinearFilter = exports.NearestMipMapLinearFilter = 1005;
  var LinearFilter = exports.LinearFilter = 1006;
  var LinearMipmapNearestFilter = exports.LinearMipmapNearestFilter = 1007;
  var LinearMipMapNearestFilter = exports.LinearMipMapNearestFilter = 1007;
  var LinearMipmapLinearFilter = exports.LinearMipmapLinearFilter = 1008;
  var LinearMipMapLinearFilter = exports.LinearMipMapLinearFilter = 1008;
  var UnsignedByteType = exports.UnsignedByteType = 1009;
  var ByteType = exports.ByteType = 1010;
  var ShortType = exports.ShortType = 1011;
  var UnsignedShortType = exports.UnsignedShortType = 1012;
  var IntType = exports.IntType = 1013;
  var UnsignedIntType = exports.UnsignedIntType = 1014;
  var FloatType = exports.FloatType = 1015;
  var HalfFloatType = exports.HalfFloatType = 1016;
  var UnsignedShort4444Type = exports.UnsignedShort4444Type = 1017;
  var UnsignedShort5551Type = exports.UnsignedShort5551Type = 1018;
  var UnsignedInt248Type = exports.UnsignedInt248Type = 1020;
  var UnsignedInt5999Type = exports.UnsignedInt5999Type = 35902;
  var AlphaFormat = exports.AlphaFormat = 1021;
  var RGBFormat = exports.RGBFormat = 1022;
  var RGBAFormat = exports.RGBAFormat = 1023;
  var LuminanceFormat = exports.LuminanceFormat = 1024;
  var LuminanceAlphaFormat = exports.LuminanceAlphaFormat = 1025;
  var DepthFormat = exports.DepthFormat = 1026;
  var DepthStencilFormat = exports.DepthStencilFormat = 1027;
  var RedFormat = exports.RedFormat = 1028;
  var RedIntegerFormat = exports.RedIntegerFormat = 1029;
  var RGFormat = exports.RGFormat = 1030;
  var RGIntegerFormat = exports.RGIntegerFormat = 1031;
  var RGBIntegerFormat = exports.RGBIntegerFormat = 1032;
  var RGBAIntegerFormat = exports.RGBAIntegerFormat = 1033;
  var RGB_S3TC_DXT1_Format = exports.RGB_S3TC_DXT1_Format = 33776;
  var RGBA_S3TC_DXT1_Format = exports.RGBA_S3TC_DXT1_Format = 33777;
  var RGBA_S3TC_DXT3_Format = exports.RGBA_S3TC_DXT3_Format = 33778;
  var RGBA_S3TC_DXT5_Format = exports.RGBA_S3TC_DXT5_Format = 33779;
  var RGB_PVRTC_4BPPV1_Format = exports.RGB_PVRTC_4BPPV1_Format = 35840;
  var RGB_PVRTC_2BPPV1_Format = exports.RGB_PVRTC_2BPPV1_Format = 35841;
  var RGBA_PVRTC_4BPPV1_Format = exports.RGBA_PVRTC_4BPPV1_Format = 35842;
  var RGBA_PVRTC_2BPPV1_Format = exports.RGBA_PVRTC_2BPPV1_Format = 35843;
  var RGB_ETC1_Format = exports.RGB_ETC1_Format = 36196;
  var RGB_ETC2_Format = exports.RGB_ETC2_Format = 37492;
  var RGBA_ETC2_EAC_Format = exports.RGBA_ETC2_EAC_Format = 37496;
  var RGBA_ASTC_4x4_Format = exports.RGBA_ASTC_4x4_Format = 37808;
  var RGBA_ASTC_5x4_Format = exports.RGBA_ASTC_5x4_Format = 37809;
  var RGBA_ASTC_5x5_Format = exports.RGBA_ASTC_5x5_Format = 37810;
  var RGBA_ASTC_6x5_Format = exports.RGBA_ASTC_6x5_Format = 37811;
  var RGBA_ASTC_6x6_Format = exports.RGBA_ASTC_6x6_Format = 37812;
  var RGBA_ASTC_8x5_Format = exports.RGBA_ASTC_8x5_Format = 37813;
  var RGBA_ASTC_8x6_Format = exports.RGBA_ASTC_8x6_Format = 37814;
  var RGBA_ASTC_8x8_Format = exports.RGBA_ASTC_8x8_Format = 37815;
  var RGBA_ASTC_10x5_Format = exports.RGBA_ASTC_10x5_Format = 37816;
  var RGBA_ASTC_10x6_Format = exports.RGBA_ASTC_10x6_Format = 37817;
  var RGBA_ASTC_10x8_Format = exports.RGBA_ASTC_10x8_Format = 37818;
  var RGBA_ASTC_10x10_Format = exports.RGBA_ASTC_10x10_Format = 37819;
  var RGBA_ASTC_12x10_Format = exports.RGBA_ASTC_12x10_Format = 37820;
  var RGBA_ASTC_12x12_Format = exports.RGBA_ASTC_12x12_Format = 37821;
  var RGBA_BPTC_Format = exports.RGBA_BPTC_Format = 36492;
  var RGB_BPTC_SIGNED_Format = exports.RGB_BPTC_SIGNED_Format = 36494;
  var RGB_BPTC_UNSIGNED_Format = exports.RGB_BPTC_UNSIGNED_Format = 36495;
  var RED_RGTC1_Format = exports.RED_RGTC1_Format = 36283;
  var SIGNED_RED_RGTC1_Format = exports.SIGNED_RED_RGTC1_Format = 36284;
  var RED_GREEN_RGTC2_Format = exports.RED_GREEN_RGTC2_Format = 36285;
  var SIGNED_RED_GREEN_RGTC2_Format = exports.SIGNED_RED_GREEN_RGTC2_Format = 36286;
  var LoopOnce = exports.LoopOnce = 2200;
  var LoopRepeat = exports.LoopRepeat = 2201;
  var LoopPingPong = exports.LoopPingPong = 2202;
  var InterpolateDiscrete = exports.InterpolateDiscrete = 2300;
  var InterpolateLinear = exports.InterpolateLinear = 2301;
  var InterpolateSmooth = exports.InterpolateSmooth = 2302;
  var ZeroCurvatureEnding = exports.ZeroCurvatureEnding = 2400;
  var ZeroSlopeEnding = exports.ZeroSlopeEnding = 2401;
  var WrapAroundEnding = exports.WrapAroundEnding = 2402;
  var NormalAnimationBlendMode = exports.NormalAnimationBlendMode = 2500;
  var AdditiveAnimationBlendMode = exports.AdditiveAnimationBlendMode = 2501;
  var TrianglesDrawMode = exports.TrianglesDrawMode = 0;
  var TriangleStripDrawMode = exports.TriangleStripDrawMode = 1;
  var TriangleFanDrawMode = exports.TriangleFanDrawMode = 2;
  var BasicDepthPacking = exports.BasicDepthPacking = 3200;
  var RGBADepthPacking = exports.RGBADepthPacking = 3201;
  var RGBDepthPacking = exports.RGBDepthPacking = 3202;
  var RGDepthPacking = exports.RGDepthPacking = 3203;
  var TangentSpaceNormalMap = exports.TangentSpaceNormalMap = 0;
  var ObjectSpaceNormalMap = exports.ObjectSpaceNormalMap = 1;

  // Color space string identifiers, matching CSS Color Module Level 4 and WebGPU names where available.
  var NoColorSpace = exports.NoColorSpace = '';
  var SRGBColorSpace = exports.SRGBColorSpace = 'srgb';
  var LinearSRGBColorSpace = exports.LinearSRGBColorSpace = 'srgb-linear';
  var LinearTransfer = exports.LinearTransfer = 'linear';
  var SRGBTransfer = exports.SRGBTransfer = 'srgb';
  var ZeroStencilOp = exports.ZeroStencilOp = 0;
  var KeepStencilOp = exports.KeepStencilOp = 7680;
  var ReplaceStencilOp = exports.ReplaceStencilOp = 7681;
  var IncrementStencilOp = exports.IncrementStencilOp = 7682;
  var DecrementStencilOp = exports.DecrementStencilOp = 7683;
  var IncrementWrapStencilOp = exports.IncrementWrapStencilOp = 34055;
  var DecrementWrapStencilOp = exports.DecrementWrapStencilOp = 34056;
  var InvertStencilOp = exports.InvertStencilOp = 5386;
  var NeverStencilFunc = exports.NeverStencilFunc = 512;
  var LessStencilFunc = exports.LessStencilFunc = 513;
  var EqualStencilFunc = exports.EqualStencilFunc = 514;
  var LessEqualStencilFunc = exports.LessEqualStencilFunc = 515;
  var GreaterStencilFunc = exports.GreaterStencilFunc = 516;
  var NotEqualStencilFunc = exports.NotEqualStencilFunc = 517;
  var GreaterEqualStencilFunc = exports.GreaterEqualStencilFunc = 518;
  var AlwaysStencilFunc = exports.AlwaysStencilFunc = 519;
  var NeverCompare = exports.NeverCompare = 512;
  var LessCompare = exports.LessCompare = 513;
  var EqualCompare = exports.EqualCompare = 514;
  var LessEqualCompare = exports.LessEqualCompare = 515;
  var GreaterCompare = exports.GreaterCompare = 516;
  var NotEqualCompare = exports.NotEqualCompare = 517;
  var GreaterEqualCompare = exports.GreaterEqualCompare = 518;
  var AlwaysCompare = exports.AlwaysCompare = 519;
  var StaticDrawUsage = exports.StaticDrawUsage = 35044;
  var DynamicDrawUsage = exports.DynamicDrawUsage = 35048;
  var StreamDrawUsage = exports.StreamDrawUsage = 35040;
  var StaticReadUsage = exports.StaticReadUsage = 35045;
  var DynamicReadUsage = exports.DynamicReadUsage = 35049;
  var StreamReadUsage = exports.StreamReadUsage = 35041;
  var StaticCopyUsage = exports.StaticCopyUsage = 35046;
  var DynamicCopyUsage = exports.DynamicCopyUsage = 35050;
  var StreamCopyUsage = exports.StreamCopyUsage = 35042;
  var GLSL1 = exports.GLSL1 = '100';
  var GLSL3 = exports.GLSL3 = '300 es';
  var WebGLCoordinateSystem = exports.WebGLCoordinateSystem = 2000;
  var WebGPUCoordinateSystem = exports.WebGPUCoordinateSystem = 2001;

  /**
   * https://github.com/mrdoob/eventdispatcher.js/
   */
  var EventDispatcher = exports.EventDispatcher = /*#__PURE__*/function () {
    function EventDispatcher() {
      (0, _classCallCheck2.default)(this, EventDispatcher);
    }
    return (0, _createClass2.default)(EventDispatcher, [{
      key: "addEventListener",
      value: function addEventListener(type, listener) {
        if (this._listeners === undefined) this._listeners = {};
        var listeners = this._listeners;
        if (listeners[type] === undefined) {
          listeners[type] = [];
        }
        if (listeners[type].indexOf(listener) === -1) {
          listeners[type].push(listener);
        }
      }
    }, {
      key: "hasEventListener",
      value: function hasEventListener(type, listener) {
        if (this._listeners === undefined) return false;
        var listeners = this._listeners;
        return listeners[type] !== undefined && listeners[type].indexOf(listener) !== -1;
      }
    }, {
      key: "removeEventListener",
      value: function removeEventListener(type, listener) {
        if (this._listeners === undefined) return;
        var listeners = this._listeners;
        var listenerArray = listeners[type];
        if (listenerArray !== undefined) {
          var index = listenerArray.indexOf(listener);
          if (index !== -1) {
            listenerArray.splice(index, 1);
          }
        }
      }
    }, {
      key: "dispatchEvent",
      value: function dispatchEvent(event) {
        if (this._listeners === undefined) return;
        var listeners = this._listeners;
        var listenerArray = listeners[event.type];
        if (listenerArray !== undefined) {
          event.target = this;

          // Make a copy, in case listeners are removed while iterating.
          var array = listenerArray.slice(0);
          for (var i = 0, l = array.length; i < l; i++) {
            array[i].call(this, event);
          }
          event.target = null;
        }
      }
    }]);
  }();
  var _lut = ['00', '01', '02', '03', '04', '05', '06', '07', '08', '09', '0a', '0b', '0c', '0d', '0e', '0f', '10', '11', '12', '13', '14', '15', '16', '17', '18', '19', '1a', '1b', '1c', '1d', '1e', '1f', '20', '21', '22', '23', '24', '25', '26', '27', '28', '29', '2a', '2b', '2c', '2d', '2e', '2f', '30', '31', '32', '33', '34', '35', '36', '37', '38', '39', '3a', '3b', '3c', '3d', '3e', '3f', '40', '41', '42', '43', '44', '45', '46', '47', '48', '49', '4a', '4b', '4c', '4d', '4e', '4f', '50', '51', '52', '53', '54', '55', '56', '57', '58', '59', '5a', '5b', '5c', '5d', '5e', '5f', '60', '61', '62', '63', '64', '65', '66', '67', '68', '69', '6a', '6b', '6c', '6d', '6e', '6f', '70', '71', '72', '73', '74', '75', '76', '77', '78', '79', '7a', '7b', '7c', '7d', '7e', '7f', '80', '81', '82', '83', '84', '85', '86', '87', '88', '89', '8a', '8b', '8c', '8d', '8e', '8f', '90', '91', '92', '93', '94', '95', '96', '97', '98', '99', '9a', '9b', '9c', '9d', '9e', '9f', 'a0', 'a1', 'a2', 'a3', 'a4', 'a5', 'a6', 'a7', 'a8', 'a9', 'aa', 'ab', 'ac', 'ad', 'ae', 'af', 'b0', 'b1', 'b2', 'b3', 'b4', 'b5', 'b6', 'b7', 'b8', 'b9', 'ba', 'bb', 'bc', 'bd', 'be', 'bf', 'c0', 'c1', 'c2', 'c3', 'c4', 'c5', 'c6', 'c7', 'c8', 'c9', 'ca', 'cb', 'cc', 'cd', 'ce', 'cf', 'd0', 'd1', 'd2', 'd3', 'd4', 'd5', 'd6', 'd7', 'd8', 'd9', 'da', 'db', 'dc', 'dd', 'de', 'df', 'e0', 'e1', 'e2', 'e3', 'e4', 'e5', 'e6', 'e7', 'e8', 'e9', 'ea', 'eb', 'ec', 'ed', 'ee', 'ef', 'f0', 'f1', 'f2', 'f3', 'f4', 'f5', 'f6', 'f7', 'f8', 'f9', 'fa', 'fb', 'fc', 'fd', 'fe', 'ff'];
  var _seed = 1234567;
  var DEG2RAD = Math.PI / 180;
  var RAD2DEG = exports.RAD2DEG = 180 / Math.PI;

  // http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/21963136#21963136
  function generateUUID() {
    var d0 = Math.random() * 0xffffffff | 0;
    var d1 = Math.random() * 0xffffffff | 0;
    var d2 = Math.random() * 0xffffffff | 0;
    var d3 = Math.random() * 0xffffffff | 0;
    var uuid = _lut[d0 & 0xff] + _lut[d0 >> 8 & 0xff] + _lut[d0 >> 16 & 0xff] + _lut[d0 >> 24 & 0xff] + '-' + _lut[d1 & 0xff] + _lut[d1 >> 8 & 0xff] + '-' + _lut[d1 >> 16 & 0x0f | 0x40] + _lut[d1 >> 24 & 0xff] + '-' + _lut[d2 & 0x3f | 0x80] + _lut[d2 >> 8 & 0xff] + '-' + _lut[d2 >> 16 & 0xff] + _lut[d2 >> 24 & 0xff] + _lut[d3 & 0xff] + _lut[d3 >> 8 & 0xff] + _lut[d3 >> 16 & 0xff] + _lut[d3 >> 24 & 0xff];

    // .toLowerCase() here flattens concatenated strings to save heap memory space.
    return uuid.toLowerCase();
  }
  function _clamp(value, min, max) {
    return Math.max(min, Math.min(max, value));
  }

  // compute euclidean modulo of m % n
  // https://en.wikipedia.org/wiki/Modulo_operation
  function euclideanModulo(n, m) {
    return (n % m + m) % m;
  }

  // Linear mapping from range <a1, a2> to range <b1, b2>
  function mapLinear(x, a1, a2, b1, b2) {
    return b1 + (x - a1) * (b2 - b1) / (a2 - a1);
  }

  // https://www.gamedev.net/tutorials/programming/general-and-gameplay-programming/inverse-lerp-a-super-useful-yet-often-overlooked-function-r5230/
  function inverseLerp(x, y, value) {
    if (x !== y) {
      return (value - x) / (y - x);
    } else {
      return 0;
    }
  }

  // https://en.wikipedia.org/wiki/Linear_interpolation
  function lerp(x, y, t) {
    return (1 - t) * x + t * y;
  }

  // http://www.rorydriscoll.com/2016/03/07/frame-rate-independent-damping-using-lerp/
  function damp(x, y, lambda, dt) {
    return lerp(x, y, 1 - Math.exp(-lambda * dt));
  }

  // https://www.desmos.com/calculator/vcsjnyz7x4
  function pingpong(x) {
    var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
    return length - Math.abs(euclideanModulo(x, length * 2) - length);
  }

  // http://en.wikipedia.org/wiki/Smoothstep
  function smoothstep(x, min, max) {
    if (x <= min) return 0;
    if (x >= max) return 1;
    x = (x - min) / (max - min);
    return x * x * (3 - 2 * x);
  }
  function smootherstep(x, min, max) {
    if (x <= min) return 0;
    if (x >= max) return 1;
    x = (x - min) / (max - min);
    return x * x * x * (x * (x * 6 - 15) + 10);
  }

  // Random integer from <low, high> interval
  function randInt(low, high) {
    return low + Math.floor(Math.random() * (high - low + 1));
  }

  // Random float from <low, high> interval
  function randFloat(low, high) {
    return low + Math.random() * (high - low);
  }

  // Random float from <-range/2, range/2> interval
  function randFloatSpread(range) {
    return range * (0.5 - Math.random());
  }

  // Deterministic pseudo-random float in the interval [ 0, 1 ]
  function seededRandom(s) {
    if (s !== undefined) _seed = s;

    // Mulberry32 generator

    var t = _seed += 0x6D2B79F5;
    t = Math.imul(t ^ t >>> 15, t | 1);
    t ^= t + Math.imul(t ^ t >>> 7, t | 61);
    return ((t ^ t >>> 14) >>> 0) / 4294967296;
  }
  function degToRad(degrees) {
    return degrees * DEG2RAD;
  }
  function radToDeg(radians) {
    return radians * RAD2DEG;
  }
  function isPowerOfTwo(value) {
    return (value & value - 1) === 0 && value !== 0;
  }
  function ceilPowerOfTwo(value) {
    return Math.pow(2, Math.ceil(Math.log(value) / Math.LN2));
  }
  function floorPowerOfTwo(value) {
    return Math.pow(2, Math.floor(Math.log(value) / Math.LN2));
  }
  function setQuaternionFromProperEuler(q, a, b, c, order) {
    // Intrinsic Proper Euler Angles - see https://en.wikipedia.org/wiki/Euler_angles

    // rotations are applied to the axes in the order specified by 'order'
    // rotation by angle 'a' is applied first, then by angle 'b', then by angle 'c'
    // angles are in radians

    var cos = Math.cos;
    var sin = Math.sin;
    var c2 = cos(b / 2);
    var s2 = sin(b / 2);
    var c13 = cos((a + c) / 2);
    var s13 = sin((a + c) / 2);
    var c1_3 = cos((a - c) / 2);
    var s1_3 = sin((a - c) / 2);
    var c3_1 = cos((c - a) / 2);
    var s3_1 = sin((c - a) / 2);
    switch (order) {
      case 'XYX':
        q.set(c2 * s13, s2 * c1_3, s2 * s1_3, c2 * c13);
        break;
      case 'YZY':
        q.set(s2 * s1_3, c2 * s13, s2 * c1_3, c2 * c13);
        break;
      case 'ZXZ':
        q.set(s2 * c1_3, s2 * s1_3, c2 * s13, c2 * c13);
        break;
      case 'XZX':
        q.set(c2 * s13, s2 * s3_1, s2 * c3_1, c2 * c13);
        break;
      case 'YXY':
        q.set(s2 * c3_1, c2 * s13, s2 * s3_1, c2 * c13);
        break;
      case 'ZYZ':
        q.set(s2 * s3_1, s2 * c3_1, c2 * s13, c2 * c13);
        break;
      default:
        console.warn('THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: ' + order);
    }
  }
  function denormalize(value, array) {
    switch (array.constructor) {
      case Float32Array:
        return value;
      case Uint32Array:
        return value / 4294967295.0;
      case Uint16Array:
        return value / 65535.0;
      case Uint8Array:
        return value / 255.0;
      case Int32Array:
        return Math.max(value / 2147483647.0, -1.0);
      case Int16Array:
        return Math.max(value / 32767.0, -1.0);
      case Int8Array:
        return Math.max(value / 127.0, -1.0);
      default:
        throw new Error('Invalid component type.');
    }
  }
  function normalize(value, array) {
    switch (array.constructor) {
      case Float32Array:
        return value;
      case Uint32Array:
        return Math.round(value * 4294967295.0);
      case Uint16Array:
        return Math.round(value * 65535.0);
      case Uint8Array:
        return Math.round(value * 255.0);
      case Int32Array:
        return Math.round(value * 2147483647.0);
      case Int16Array:
        return Math.round(value * 32767.0);
      case Int8Array:
        return Math.round(value * 127.0);
      default:
        throw new Error('Invalid component type.');
    }
  }
  var MathUtils = exports.MathUtils = {
    DEG2RAD: DEG2RAD,
    RAD2DEG: RAD2DEG,
    generateUUID: generateUUID,
    clamp: _clamp,
    euclideanModulo: euclideanModulo,
    mapLinear: mapLinear,
    inverseLerp: inverseLerp,
    lerp: lerp,
    damp: damp,
    pingpong: pingpong,
    smoothstep: smoothstep,
    smootherstep: smootherstep,
    randInt: randInt,
    randFloat: randFloat,
    randFloatSpread: randFloatSpread,
    seededRandom: seededRandom,
    degToRad: degToRad,
    radToDeg: radToDeg,
    isPowerOfTwo: isPowerOfTwo,
    ceilPowerOfTwo: ceilPowerOfTwo,
    floorPowerOfTwo: floorPowerOfTwo,
    setQuaternionFromProperEuler: setQuaternionFromProperEuler,
    normalize: normalize,
    denormalize: denormalize
  };
  var Vector2 = exports.Vector2 = /*#__PURE__*/function () {
    function Vector2() {
      var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      (0, _classCallCheck2.default)(this, Vector2);
      Vector2.prototype.isVector2 = true;
      this.x = x;
      this.y = y;
    }
    return (0, _createClass2.default)(Vector2, [{
      key: "width",
      get: function get() {
        return this.x;
      },
      set: function set(value) {
        this.x = value;
      }
    }, {
      key: "height",
      get: function get() {
        return this.y;
      },
      set: function set(value) {
        this.y = value;
      }
    }, {
      key: "set",
      value: function set(x, y) {
        this.x = x;
        this.y = y;
        return this;
      }
    }, {
      key: "setScalar",
      value: function setScalar(scalar) {
        this.x = scalar;
        this.y = scalar;
        return this;
      }
    }, {
      key: "setX",
      value: function setX(x) {
        this.x = x;
        return this;
      }
    }, {
      key: "setY",
      value: function setY(y) {
        this.y = y;
        return this;
      }
    }, {
      key: "setComponent",
      value: function setComponent(index, value) {
        switch (index) {
          case 0:
            this.x = value;
            break;
          case 1:
            this.y = value;
            break;
          default:
            throw new Error('index is out of range: ' + index);
        }
        return this;
      }
    }, {
      key: "getComponent",
      value: function getComponent(index) {
        switch (index) {
          case 0:
            return this.x;
          case 1:
            return this.y;
          default:
            throw new Error('index is out of range: ' + index);
        }
      }
    }, {
      key: "clone",
      value: function clone() {
        return new this.constructor(this.x, this.y);
      }
    }, {
      key: "copy",
      value: function copy(v) {
        this.x = v.x;
        this.y = v.y;
        return this;
      }
    }, {
      key: "add",
      value: function add(v) {
        this.x += v.x;
        this.y += v.y;
        return this;
      }
    }, {
      key: "addScalar",
      value: function addScalar(s) {
        this.x += s;
        this.y += s;
        return this;
      }
    }, {
      key: "addVectors",
      value: function addVectors(a, b) {
        this.x = a.x + b.x;
        this.y = a.y + b.y;
        return this;
      }
    }, {
      key: "addScaledVector",
      value: function addScaledVector(v, s) {
        this.x += v.x * s;
        this.y += v.y * s;
        return this;
      }
    }, {
      key: "sub",
      value: function sub(v) {
        this.x -= v.x;
        this.y -= v.y;
        return this;
      }
    }, {
      key: "subScalar",
      value: function subScalar(s) {
        this.x -= s;
        this.y -= s;
        return this;
      }
    }, {
      key: "subVectors",
      value: function subVectors(a, b) {
        this.x = a.x - b.x;
        this.y = a.y - b.y;
        return this;
      }
    }, {
      key: "multiply",
      value: function multiply(v) {
        this.x *= v.x;
        this.y *= v.y;
        return this;
      }
    }, {
      key: "multiplyScalar",
      value: function multiplyScalar(scalar) {
        this.x *= scalar;
        this.y *= scalar;
        return this;
      }
    }, {
      key: "divide",
      value: function divide(v) {
        this.x /= v.x;
        this.y /= v.y;
        return this;
      }
    }, {
      key: "divideScalar",
      value: function divideScalar(scalar) {
        return this.multiplyScalar(1 / scalar);
      }
    }, {
      key: "applyMatrix3",
      value: function applyMatrix3(m) {
        var x = this.x,
          y = this.y;
        var e = m.elements;
        this.x = e[0] * x + e[3] * y + e[6];
        this.y = e[1] * x + e[4] * y + e[7];
        return this;
      }
    }, {
      key: "min",
      value: function min(v) {
        this.x = Math.min(this.x, v.x);
        this.y = Math.min(this.y, v.y);
        return this;
      }
    }, {
      key: "max",
      value: function max(v) {
        this.x = Math.max(this.x, v.x);
        this.y = Math.max(this.y, v.y);
        return this;
      }
    }, {
      key: "clamp",
      value: function clamp(min, max) {
        // assumes min < max, componentwise

        this.x = _clamp(this.x, min.x, max.x);
        this.y = _clamp(this.y, min.y, max.y);
        return this;
      }
    }, {
      key: "clampScalar",
      value: function clampScalar(minVal, maxVal) {
        this.x = _clamp(this.x, minVal, maxVal);
        this.y = _clamp(this.y, minVal, maxVal);
        return this;
      }
    }, {
      key: "clampLength",
      value: function clampLength(min, max) {
        var length = this.length();
        return this.divideScalar(length || 1).multiplyScalar(_clamp(length, min, max));
      }
    }, {
      key: "floor",
      value: function floor() {
        this.x = Math.floor(this.x);
        this.y = Math.floor(this.y);
        return this;
      }
    }, {
      key: "ceil",
      value: function ceil() {
        this.x = Math.ceil(this.x);
        this.y = Math.ceil(this.y);
        return this;
      }
    }, {
      key: "round",
      value: function round() {
        this.x = Math.round(this.x);
        this.y = Math.round(this.y);
        return this;
      }
    }, {
      key: "roundToZero",
      value: function roundToZero() {
        this.x = Math.trunc(this.x);
        this.y = Math.trunc(this.y);
        return this;
      }
    }, {
      key: "negate",
      value: function negate() {
        this.x = -this.x;
        this.y = -this.y;
        return this;
      }
    }, {
      key: "dot",
      value: function dot(v) {
        return this.x * v.x + this.y * v.y;
      }
    }, {
      key: "cross",
      value: function cross(v) {
        return this.x * v.y - this.y * v.x;
      }
    }, {
      key: "lengthSq",
      value: function lengthSq() {
        return this.x * this.x + this.y * this.y;
      }
    }, {
      key: "length",
      value: function length() {
        return Math.sqrt(this.x * this.x + this.y * this.y);
      }
    }, {
      key: "manhattanLength",
      value: function manhattanLength() {
        return Math.abs(this.x) + Math.abs(this.y);
      }
    }, {
      key: "normalize",
      value: function normalize() {
        return this.divideScalar(this.length() || 1);
      }
    }, {
      key: "angle",
      value: function angle() {
        // computes the angle in radians with respect to the positive x-axis

        var angle = Math.atan2(-this.y, -this.x) + Math.PI;
        return angle;
      }
    }, {
      key: "angleTo",
      value: function angleTo(v) {
        var denominator = Math.sqrt(this.lengthSq() * v.lengthSq());
        if (denominator === 0) return Math.PI / 2;
        var theta = this.dot(v) / denominator;

        // clamp, to handle numerical problems

        return Math.acos(_clamp(theta, -1, 1));
      }
    }, {
      key: "distanceTo",
      value: function distanceTo(v) {
        return Math.sqrt(this.distanceToSquared(v));
      }
    }, {
      key: "distanceToSquared",
      value: function distanceToSquared(v) {
        var dx = this.x - v.x,
          dy = this.y - v.y;
        return dx * dx + dy * dy;
      }
    }, {
      key: "manhattanDistanceTo",
      value: function manhattanDistanceTo(v) {
        return Math.abs(this.x - v.x) + Math.abs(this.y - v.y);
      }
    }, {
      key: "setLength",
      value: function setLength(length) {
        return this.normalize().multiplyScalar(length);
      }
    }, {
      key: "lerp",
      value: function lerp(v, alpha) {
        this.x += (v.x - this.x) * alpha;
        this.y += (v.y - this.y) * alpha;
        return this;
      }
    }, {
      key: "lerpVectors",
      value: function lerpVectors(v1, v2, alpha) {
        this.x = v1.x + (v2.x - v1.x) * alpha;
        this.y = v1.y + (v2.y - v1.y) * alpha;
        return this;
      }
    }, {
      key: "equals",
      value: function equals(v) {
        return v.x === this.x && v.y === this.y;
      }
    }, {
      key: "fromArray",
      value: function fromArray(array) {
        var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        this.x = array[offset];
        this.y = array[offset + 1];
        return this;
      }
    }, {
      key: "toArray",
      value: function toArray() {
        var array = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
        var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        array[offset] = this.x;
        array[offset + 1] = this.y;
        return array;
      }
    }, {
      key: "fromBufferAttribute",
      value: function fromBufferAttribute(attribute, index) {
        this.x = attribute.getX(index);
        this.y = attribute.getY(index);
        return this;
      }
    }, {
      key: "rotateAround",
      value: function rotateAround(center, angle) {
        var c = Math.cos(angle),
          s = Math.sin(angle);
        var x = this.x - center.x;
        var y = this.y - center.y;
        this.x = x * c - y * s + center.x;
        this.y = x * s + y * c + center.y;
        return this;
      }
    }, {
      key: "random",
      value: function random() {
        this.x = Math.random();
        this.y = Math.random();
        return this;
      }
    }, {
      key: Symbol.iterator,
      value: function* value() {
        yield this.x;
        yield this.y;
      }
    }]);
  }();
  var Matrix3 = exports.Matrix3 = /*#__PURE__*/function () {
    function Matrix3(n11, n12, n13, n21, n22, n23, n31, n32, n33) {
      (0, _classCallCheck2.default)(this, Matrix3);
      Matrix3.prototype.isMatrix3 = true;
      this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1];
      if (n11 !== undefined) {
        this.set(n11, n12, n13, n21, n22, n23, n31, n32, n33);
      }
    }
    return (0, _createClass2.default)(Matrix3, [{
      key: "set",
      value: function set(n11, n12, n13, n21, n22, n23, n31, n32, n33) {
        var te = this.elements;
        te[0] = n11;
        te[1] = n21;
        te[2] = n31;
        te[3] = n12;
        te[4] = n22;
        te[5] = n32;
        te[6] = n13;
        te[7] = n23;
        te[8] = n33;
        return this;
      }
    }, {
      key: "identity",
      value: function identity() {
        this.set(1, 0, 0, 0, 1, 0, 0, 0, 1);
        return this;
      }
    }, {
      key: "copy",
      value: function copy(m) {
        var te = this.elements;
        var me = m.elements;
        te[0] = me[0];
        te[1] = me[1];
        te[2] = me[2];
        te[3] = me[3];
        te[4] = me[4];
        te[5] = me[5];
        te[6] = me[6];
        te[7] = me[7];
        te[8] = me[8];
        return this;
      }
    }, {
      key: "extractBasis",
      value: function extractBasis(xAxis, yAxis, zAxis) {
        xAxis.setFromMatrix3Column(this, 0);
        yAxis.setFromMatrix3Column(this, 1);
        zAxis.setFromMatrix3Column(this, 2);
        return this;
      }
    }, {
      key: "setFromMatrix4",
      value: function setFromMatrix4(m) {
        var me = m.elements;
        this.set(me[0], me[4], me[8], me[1], me[5], me[9], me[2], me[6], me[10]);
        return this;
      }
    }, {
      key: "multiply",
      value: function multiply(m) {
        return this.multiplyMatrices(this, m);
      }
    }, {
      key: "premultiply",
      value: function premultiply(m) {
        return this.multiplyMatrices(m, this);
      }
    }, {
      key: "multiplyMatrices",
      value: function multiplyMatrices(a, b) {
        var ae = a.elements;
        var be = b.elements;
        var te = this.elements;
        var a11 = ae[0],
          a12 = ae[3],
          a13 = ae[6];
        var a21 = ae[1],
          a22 = ae[4],
          a23 = ae[7];
        var a31 = ae[2],
          a32 = ae[5],
          a33 = ae[8];
        var b11 = be[0],
          b12 = be[3],
          b13 = be[6];
        var b21 = be[1],
          b22 = be[4],
          b23 = be[7];
        var b31 = be[2],
          b32 = be[5],
          b33 = be[8];
        te[0] = a11 * b11 + a12 * b21 + a13 * b31;
        te[3] = a11 * b12 + a12 * b22 + a13 * b32;
        te[6] = a11 * b13 + a12 * b23 + a13 * b33;
        te[1] = a21 * b11 + a22 * b21 + a23 * b31;
        te[4] = a21 * b12 + a22 * b22 + a23 * b32;
        te[7] = a21 * b13 + a22 * b23 + a23 * b33;
        te[2] = a31 * b11 + a32 * b21 + a33 * b31;
        te[5] = a31 * b12 + a32 * b22 + a33 * b32;
        te[8] = a31 * b13 + a32 * b23 + a33 * b33;
        return this;
      }
    }, {
      key: "multiplyScalar",
      value: function multiplyScalar(s) {
        var te = this.elements;
        te[0] *= s;
        te[3] *= s;
        te[6] *= s;
        te[1] *= s;
        te[4] *= s;
        te[7] *= s;
        te[2] *= s;
        te[5] *= s;
        te[8] *= s;
        return this;
      }
    }, {
      key: "determinant",
      value: function determinant() {
        var te = this.elements;
        var a = te[0],
          b = te[1],
          c = te[2],
          d = te[3],
          e = te[4],
          f = te[5],
          g = te[6],
          h = te[7],
          i = te[8];
        return a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;
      }
    }, {
      key: "invert",
      value: function invert() {
        var te = this.elements,
          n11 = te[0],
          n21 = te[1],
          n31 = te[2],
          n12 = te[3],
          n22 = te[4],
          n32 = te[5],
          n13 = te[6],
          n23 = te[7],
          n33 = te[8],
          t11 = n33 * n22 - n32 * n23,
          t12 = n32 * n13 - n33 * n12,
          t13 = n23 * n12 - n22 * n13,
          det = n11 * t11 + n21 * t12 + n31 * t13;
        if (det === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
        var detInv = 1 / det;
        te[0] = t11 * detInv;
        te[1] = (n31 * n23 - n33 * n21) * detInv;
        te[2] = (n32 * n21 - n31 * n22) * detInv;
        te[3] = t12 * detInv;
        te[4] = (n33 * n11 - n31 * n13) * detInv;
        te[5] = (n31 * n12 - n32 * n11) * detInv;
        te[6] = t13 * detInv;
        te[7] = (n21 * n13 - n23 * n11) * detInv;
        te[8] = (n22 * n11 - n21 * n12) * detInv;
        return this;
      }
    }, {
      key: "transpose",
      value: function transpose() {
        var tmp;
        var m = this.elements;
        tmp = m[1];
        m[1] = m[3];
        m[3] = tmp;
        tmp = m[2];
        m[2] = m[6];
        m[6] = tmp;
        tmp = m[5];
        m[5] = m[7];
        m[7] = tmp;
        return this;
      }
    }, {
      key: "getNormalMatrix",
      value: function getNormalMatrix(matrix4) {
        return this.setFromMatrix4(matrix4).invert().transpose();
      }
    }, {
      key: "transposeIntoArray",
      value: function transposeIntoArray(r) {
        var m = this.elements;
        r[0] = m[0];
        r[1] = m[3];
        r[2] = m[6];
        r[3] = m[1];
        r[4] = m[4];
        r[5] = m[7];
        r[6] = m[2];
        r[7] = m[5];
        r[8] = m[8];
        return this;
      }
    }, {
      key: "setUvTransform",
      value: function setUvTransform(tx, ty, sx, sy, rotation, cx, cy) {
        var c = Math.cos(rotation);
        var s = Math.sin(rotation);
        this.set(sx * c, sx * s, -sx * (c * cx + s * cy) + cx + tx, -sy * s, sy * c, -sy * (-s * cx + c * cy) + cy + ty, 0, 0, 1);
        return this;
      }

      //
    }, {
      key: "scale",
      value: function scale(sx, sy) {
        this.premultiply(_m3.makeScale(sx, sy));
        return this;
      }
    }, {
      key: "rotate",
      value: function rotate(theta) {
        this.premultiply(_m3.makeRotation(-theta));
        return this;
      }
    }, {
      key: "translate",
      value: function translate(tx, ty) {
        this.premultiply(_m3.makeTranslation(tx, ty));
        return this;
      }

      // for 2D Transforms
    }, {
      key: "makeTranslation",
      value: function makeTranslation(x, y) {
        if (x.isVector2) {
          this.set(1, 0, x.x, 0, 1, x.y, 0, 0, 1);
        } else {
          this.set(1, 0, x, 0, 1, y, 0, 0, 1);
        }
        return this;
      }
    }, {
      key: "makeRotation",
      value: function makeRotation(theta) {
        // counterclockwise

        var c = Math.cos(theta);
        var s = Math.sin(theta);
        this.set(c, -s, 0, s, c, 0, 0, 0, 1);
        return this;
      }
    }, {
      key: "makeScale",
      value: function makeScale(x, y) {
        this.set(x, 0, 0, 0, y, 0, 0, 0, 1);
        return this;
      }

      //
    }, {
      key: "equals",
      value: function equals(matrix) {
        var te = this.elements;
        var me = matrix.elements;
        for (var i = 0; i < 9; i++) {
          if (te[i] !== me[i]) return false;
        }
        return true;
      }
    }, {
      key: "fromArray",
      value: function fromArray(array) {
        var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        for (var i = 0; i < 9; i++) {
          this.elements[i] = array[i + offset];
        }
        return this;
      }
    }, {
      key: "toArray",
      value: function toArray() {
        var array = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
        var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        var te = this.elements;
        array[offset] = te[0];
        array[offset + 1] = te[1];
        array[offset + 2] = te[2];
        array[offset + 3] = te[3];
        array[offset + 4] = te[4];
        array[offset + 5] = te[5];
        array[offset + 6] = te[6];
        array[offset + 7] = te[7];
        array[offset + 8] = te[8];
        return array;
      }
    }, {
      key: "clone",
      value: function clone() {
        return new this.constructor().fromArray(this.elements);
      }
    }]);
  }();
  var _m3 = /*@__PURE__*/new Matrix3();
  function arrayNeedsUint32(array) {
    // assumes larger values usually on last

    for (var i = array.length - 1; i >= 0; --i) {
      if (array[i] >= 65535) return true; // account for PRIMITIVE_RESTART_FIXED_INDEX, #24565
    }
    return false;
  }
  var TYPED_ARRAYS = {
    Int8Array: Int8Array,
    Uint8Array: Uint8Array,
    Uint8ClampedArray: Uint8ClampedArray,
    Int16Array: Int16Array,
    Uint16Array: Uint16Array,
    Int32Array: Int32Array,
    Uint32Array: Uint32Array,
    Float32Array: Float32Array,
    Float64Array: Float64Array
  };
  function getTypedArray(type, buffer) {
    return new TYPED_ARRAYS[type](buffer);
  }
  function createElementNS(name) {
    return document.createElementNS('http://www.w3.org/1999/xhtml', name);
  }
  function createCanvasElement() {
    var canvas = createElementNS('canvas');
    canvas.style.display = 'block';
    return canvas;
  }
  var _cache = {};
  function warnOnce(message) {
    if (message in _cache) return;
    _cache[message] = true;
    console.warn(message);
  }
  function probeAsync(gl, sync, interval) {
    return new Promise(function (resolve, reject) {
      function probe() {
        switch (gl.clientWaitSync(sync, gl.SYNC_FLUSH_COMMANDS_BIT, 0)) {
          case gl.WAIT_FAILED:
            reject();
            break;
          case gl.TIMEOUT_EXPIRED:
            setTimeout(probe, interval);
            break;
          default:
            resolve();
        }
      }
      setTimeout(probe, interval);
    });
  }
  function toNormalizedProjectionMatrix(projectionMatrix) {
    var m = projectionMatrix.elements;

    // Convert [-1, 1] to [0, 1] projection matrix
    m[2] = 0.5 * m[2] + 0.5 * m[3];
    m[6] = 0.5 * m[6] + 0.5 * m[7];
    m[10] = 0.5 * m[10] + 0.5 * m[11];
    m[14] = 0.5 * m[14] + 0.5 * m[15];
  }
  function toReversedProjectionMatrix(projectionMatrix) {
    var m = projectionMatrix.elements;
    var isPerspectiveMatrix = m[11] === -1;

    // Reverse [0, 1] projection matrix
    if (isPerspectiveMatrix) {
      m[10] = -m[10] - 1;
      m[14] = -m[14];
    } else {
      m[10] = -m[10];
      m[14] = -m[14] + 1;
    }
  }
  var LINEAR_REC709_TO_XYZ = /*@__PURE__*/new Matrix3().set(0.4123908, 0.3575843, 0.1804808, 0.2126390, 0.7151687, 0.0721923, 0.0193308, 0.1191948, 0.9505322);
  var XYZ_TO_LINEAR_REC709 = /*@__PURE__*/new Matrix3().set(3.2409699, -1.5373832, -0.4986108, -0.9692436, 1.8759675, 0.0415551, 0.0556301, -0.2039770, 1.0569715);
  function createColorManagement() {
    var ColorManagement = {
      enabled: true,
      workingColorSpace: LinearSRGBColorSpace,
      /**
       * Implementations of supported color spaces.
       *
       * Required:
       *	- primaries: chromaticity coordinates [ rx ry gx gy bx by ]
       *	- whitePoint: reference white [ x y ]
       *	- transfer: transfer function (pre-defined)
       *	- toXYZ: Matrix3 RGB to XYZ transform
       *	- fromXYZ: Matrix3 XYZ to RGB transform
       *	- luminanceCoefficients: RGB luminance coefficients
       *
       * Optional:
       *  - outputColorSpaceConfig: { drawingBufferColorSpace: ColorSpace }
       *  - workingColorSpaceConfig: { unpackColorSpace: ColorSpace }
       *
       * Reference:
       * - https://www.russellcottrell.com/photo/matrixCalculator.htm
       */
      spaces: {},
      convert: function convert(color, sourceColorSpace, targetColorSpace) {
        if (this.enabled === false || sourceColorSpace === targetColorSpace || !sourceColorSpace || !targetColorSpace) {
          return color;
        }
        if (this.spaces[sourceColorSpace].transfer === SRGBTransfer) {
          color.r = SRGBToLinear(color.r);
          color.g = SRGBToLinear(color.g);
          color.b = SRGBToLinear(color.b);
        }
        if (this.spaces[sourceColorSpace].primaries !== this.spaces[targetColorSpace].primaries) {
          color.applyMatrix3(this.spaces[sourceColorSpace].toXYZ);
          color.applyMatrix3(this.spaces[targetColorSpace].fromXYZ);
        }
        if (this.spaces[targetColorSpace].transfer === SRGBTransfer) {
          color.r = LinearToSRGB(color.r);
          color.g = LinearToSRGB(color.g);
          color.b = LinearToSRGB(color.b);
        }
        return color;
      },
      fromWorkingColorSpace: function fromWorkingColorSpace(color, targetColorSpace) {
        return this.convert(color, this.workingColorSpace, targetColorSpace);
      },
      toWorkingColorSpace: function toWorkingColorSpace(color, sourceColorSpace) {
        return this.convert(color, sourceColorSpace, this.workingColorSpace);
      },
      getPrimaries: function getPrimaries(colorSpace) {
        return this.spaces[colorSpace].primaries;
      },
      getTransfer: function getTransfer(colorSpace) {
        if (colorSpace === NoColorSpace) return LinearTransfer;
        return this.spaces[colorSpace].transfer;
      },
      getLuminanceCoefficients: function getLuminanceCoefficients(target) {
        var colorSpace = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.workingColorSpace;
        return target.fromArray(this.spaces[colorSpace].luminanceCoefficients);
      },
      define: function define(colorSpaces) {
        Object.assign(this.spaces, colorSpaces);
      },
      // Internal APIs

      _getMatrix: function _getMatrix(targetMatrix, sourceColorSpace, targetColorSpace) {
        return targetMatrix.copy(this.spaces[sourceColorSpace].toXYZ).multiply(this.spaces[targetColorSpace].fromXYZ);
      },
      _getDrawingBufferColorSpace: function _getDrawingBufferColorSpace(colorSpace) {
        return this.spaces[colorSpace].outputColorSpaceConfig.drawingBufferColorSpace;
      },
      _getUnpackColorSpace: function _getUnpackColorSpace() {
        var colorSpace = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.workingColorSpace;
        return this.spaces[colorSpace].workingColorSpaceConfig.unpackColorSpace;
      }
    };

    /******************************************************************************
     * sRGB definitions
     */

    var REC709_PRIMARIES = [0.640, 0.330, 0.300, 0.600, 0.150, 0.060];
    var REC709_LUMINANCE_COEFFICIENTS = [0.2126, 0.7152, 0.0722];
    var D65 = [0.3127, 0.3290];
    ColorManagement.define((0, _defineProperty2.default)((0, _defineProperty2.default)({}, LinearSRGBColorSpace, {
      primaries: REC709_PRIMARIES,
      whitePoint: D65,
      transfer: LinearTransfer,
      toXYZ: LINEAR_REC709_TO_XYZ,
      fromXYZ: XYZ_TO_LINEAR_REC709,
      luminanceCoefficients: REC709_LUMINANCE_COEFFICIENTS,
      workingColorSpaceConfig: {
        unpackColorSpace: SRGBColorSpace
      },
      outputColorSpaceConfig: {
        drawingBufferColorSpace: SRGBColorSpace
      }
    }), SRGBColorSpace, {
      primaries: REC709_PRIMARIES,
      whitePoint: D65,
      transfer: SRGBTransfer,
      toXYZ: LINEAR_REC709_TO_XYZ,
      fromXYZ: XYZ_TO_LINEAR_REC709,
      luminanceCoefficients: REC709_LUMINANCE_COEFFICIENTS,
      outputColorSpaceConfig: {
        drawingBufferColorSpace: SRGBColorSpace
      }
    }));
    return ColorManagement;
  }
  var ColorManagement = exports.ColorManagement = /*@__PURE__*/createColorManagement();
  function SRGBToLinear(c) {
    return c < 0.04045 ? c * 0.0773993808 : Math.pow(c * 0.9478672986 + 0.0521327014, 2.4);
  }
  function LinearToSRGB(c) {
    return c < 0.0031308 ? c * 12.92 : 1.055 * Math.pow(c, 0.41666) - 0.055;
  }
  var _canvas;
  var ImageUtils = exports.ImageUtils = /*#__PURE__*/function () {
    function ImageUtils() {
      (0, _classCallCheck2.default)(this, ImageUtils);
    }
    return (0, _createClass2.default)(ImageUtils, null, [{
      key: "getDataURL",
      value: function getDataURL(image) {
        if (/^data:/i.test(image.src)) {
          return image.src;
        }
        if (typeof HTMLCanvasElement === 'undefined') {
          return image.src;
        }
        var canvas;
        if (image instanceof HTMLCanvasElement) {
          canvas = image;
        } else {
          if (_canvas === undefined) _canvas = createElementNS('canvas');
          _canvas.width = image.width;
          _canvas.height = image.height;
          var context = _canvas.getContext('2d');
          if (image instanceof ImageData) {
            context.putImageData(image, 0, 0);
          } else {
            context.drawImage(image, 0, 0, image.width, image.height);
          }
          canvas = _canvas;
        }
        if (canvas.width > 2048 || canvas.height > 2048) {
          console.warn('THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons', image);
          return canvas.toDataURL('image/jpeg', 0.6);
        } else {
          return canvas.toDataURL('image/png');
        }
      }
    }, {
      key: "sRGBToLinear",
      value: function sRGBToLinear(image) {
        if (typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement || typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap) {
          var canvas = createElementNS('canvas');
          canvas.width = image.width;
          canvas.height = image.height;
          var context = canvas.getContext('2d');
          context.drawImage(image, 0, 0, image.width, image.height);
          var imageData = context.getImageData(0, 0, image.width, image.height);
          var data = imageData.data;
          for (var i = 0; i < data.length; i++) {
            data[i] = SRGBToLinear(data[i] / 255) * 255;
          }
          context.putImageData(imageData, 0, 0);
          return canvas;
        } else if (image.data) {
          var _data = image.data.slice(0);
          for (var _i = 0; _i < _data.length; _i++) {
            if (_data instanceof Uint8Array || _data instanceof Uint8ClampedArray) {
              _data[_i] = Math.floor(SRGBToLinear(_data[_i] / 255) * 255);
            } else {
              // assuming float

              _data[_i] = SRGBToLinear(_data[_i]);
            }
          }
          return {
            data: _data,
            width: image.width,
            height: image.height
          };
        } else {
          console.warn('THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied.');
          return image;
        }
      }
    }]);
  }();
  var _sourceId = 0;
  var Source = exports.Source = /*#__PURE__*/function () {
    function Source() {
      var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      (0, _classCallCheck2.default)(this, Source);
      this.isSource = true;
      Object.defineProperty(this, 'id', {
        value: _sourceId++
      });
      this.uuid = generateUUID();
      this.data = data;
      this.dataReady = true;
      this.version = 0;
    }
    return (0, _createClass2.default)(Source, [{
      key: "needsUpdate",
      set: function set(value) {
        if (value === true) this.version++;
      }
    }, {
      key: "toJSON",
      value: function toJSON(meta) {
        var isRootObject = meta === undefined || typeof meta === 'string';
        if (!isRootObject && meta.images[this.uuid] !== undefined) {
          return meta.images[this.uuid];
        }
        var output = {
          uuid: this.uuid,
          url: ''
        };
        var data = this.data;
        if (data !== null) {
          var url;
          if (Array.isArray(data)) {
            // cube texture

            url = [];
            for (var i = 0, l = data.length; i < l; i++) {
              if (data[i].isDataTexture) {
                url.push(serializeImage(data[i].image));
              } else {
                url.push(serializeImage(data[i]));
              }
            }
          } else {
            // texture

            url = serializeImage(data);
          }
          output.url = url;
        }
        if (!isRootObject) {
          meta.images[this.uuid] = output;
        }
        return output;
      }
    }]);
  }();
  function serializeImage(image) {
    if (typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement || typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement || typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap) {
      // default images

      return ImageUtils.getDataURL(image);
    } else {
      if (image.data) {
        // images of DataTexture

        return {
          data: Array.from(image.data),
          width: image.width,
          height: image.height,
          type: image.data.constructor.name
        };
      } else {
        console.warn('THREE.Texture: Unable to serialize Texture.');
        return {};
      }
    }
  }
  var _textureId = 0;
  var Texture = exports.Texture = /*#__PURE__*/function (_EventDispatcher) {
    function Texture() {
      var _this;
      var image = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : Texture.DEFAULT_IMAGE;
      var mapping = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Texture.DEFAULT_MAPPING;
      var wrapS = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : ClampToEdgeWrapping;
      var wrapT = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : ClampToEdgeWrapping;
      var magFilter = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : LinearFilter;
      var minFilter = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : LinearMipmapLinearFilter;
      var format = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : RGBAFormat;
      var type = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : UnsignedByteType;
      var anisotropy = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : Texture.DEFAULT_ANISOTROPY;
      var colorSpace = arguments.length > 9 && arguments[9] !== undefined ? arguments[9] : NoColorSpace;
      (0, _classCallCheck2.default)(this, Texture);
      _this = _callSuper(this, Texture);
      _this.isTexture = true;
      Object.defineProperty(_this, 'id', {
        value: _textureId++
      });
      _this.uuid = generateUUID();
      _this.name = '';
      _this.source = new Source(image);
      _this.mipmaps = [];
      _this.mapping = mapping;
      _this.channel = 0;
      _this.wrapS = wrapS;
      _this.wrapT = wrapT;
      _this.magFilter = magFilter;
      _this.minFilter = minFilter;
      _this.anisotropy = anisotropy;
      _this.format = format;
      _this.internalFormat = null;
      _this.type = type;
      _this.offset = new Vector2(0, 0);
      _this.repeat = new Vector2(1, 1);
      _this.center = new Vector2(0, 0);
      _this.rotation = 0;
      _this.matrixAutoUpdate = true;
      _this.matrix = new Matrix3();
      _this.generateMipmaps = true;
      _this.premultiplyAlpha = false;
      _this.flipY = true;
      _this.unpackAlignment = 4; // valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)

      _this.colorSpace = colorSpace;
      _this.userData = {};
      _this.version = 0;
      _this.onUpdate = null;
      _this.renderTarget = null; // assign texture to a render target
      _this.isRenderTargetTexture = false; // indicates whether a texture belongs to a render target or not
      _this.pmremVersion = 0; // indicates whether this texture should be processed by PMREMGenerator or not (only relevant for render target textures)
      return _this;
    }
    (0, _inherits2.default)(Texture, _EventDispatcher);
    return (0, _createClass2.default)(Texture, [{
      key: "image",
      get: function get() {
        return this.source.data;
      },
      set: function set() {
        var value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
        this.source.data = value;
      }
    }, {
      key: "updateMatrix",
      value: function updateMatrix() {
        this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y);
      }
    }, {
      key: "clone",
      value: function clone() {
        return new this.constructor().copy(this);
      }
    }, {
      key: "copy",
      value: function copy(source) {
        this.name = source.name;
        this.source = source.source;
        this.mipmaps = source.mipmaps.slice(0);
        this.mapping = source.mapping;
        this.channel = source.channel;
        this.wrapS = source.wrapS;
        this.wrapT = source.wrapT;
        this.magFilter = source.magFilter;
        this.minFilter = source.minFilter;
        this.anisotropy = source.anisotropy;
        this.format = source.format;
        this.internalFormat = source.internalFormat;
        this.type = source.type;
        this.offset.copy(source.offset);
        this.repeat.copy(source.repeat);
        this.center.copy(source.center);
        this.rotation = source.rotation;
        this.matrixAutoUpdate = source.matrixAutoUpdate;
        this.matrix.copy(source.matrix);
        this.generateMipmaps = source.generateMipmaps;
        this.premultiplyAlpha = source.premultiplyAlpha;
        this.flipY = source.flipY;
        this.unpackAlignment = source.unpackAlignment;
        this.colorSpace = source.colorSpace;
        this.renderTarget = source.renderTarget;
        this.isRenderTargetTexture = source.isRenderTargetTexture;
        this.userData = JSON.parse(JSON.stringify(source.userData));
        this.needsUpdate = true;
        return this;
      }
    }, {
      key: "toJSON",
      value: function toJSON(meta) {
        var isRootObject = meta === undefined || typeof meta === 'string';
        if (!isRootObject && meta.textures[this.uuid] !== undefined) {
          return meta.textures[this.uuid];
        }
        var output = {
          metadata: {
            version: 4.6,
            type: 'Texture',
            generator: 'Texture.toJSON'
          },
          uuid: this.uuid,
          name: this.name,
          image: this.source.toJSON(meta).uuid,
          mapping: this.mapping,
          channel: this.channel,
          repeat: [this.repeat.x, this.repeat.y],
          offset: [this.offset.x, this.offset.y],
          center: [this.center.x, this.center.y],
          rotation: this.rotation,
          wrap: [this.wrapS, this.wrapT],
          format: this.format,
          internalFormat: this.internalFormat,
          type: this.type,
          colorSpace: this.colorSpace,
          minFilter: this.minFilter,
          magFilter: this.magFilter,
          anisotropy: this.anisotropy,
          flipY: this.flipY,
          generateMipmaps: this.generateMipmaps,
          premultiplyAlpha: this.premultiplyAlpha,
          unpackAlignment: this.unpackAlignment
        };
        if (Object.keys(this.userData).length > 0) output.userData = this.userData;
        if (!isRootObject) {
          meta.textures[this.uuid] = output;
        }
        return output;
      }
    }, {
      key: "dispose",
      value: function dispose() {
        this.dispatchEvent({
          type: 'dispose'
        });
      }
    }, {
      key: "transformUv",
      value: function transformUv(uv) {
        if (this.mapping !== UVMapping) return uv;
        uv.applyMatrix3(this.matrix);
        if (uv.x < 0 || uv.x > 1) {
          switch (this.wrapS) {
            case RepeatWrapping:
              uv.x = uv.x - Math.floor(uv.x);
              break;
            case ClampToEdgeWrapping:
              uv.x = uv.x < 0 ? 0 : 1;
              break;
            case MirroredRepeatWrapping:
              if (Math.abs(Math.floor(uv.x) % 2) === 1) {
                uv.x = Math.ceil(uv.x) - uv.x;
              } else {
                uv.x = uv.x - Math.floor(uv.x);
              }
              break;
          }
        }
        if (uv.y < 0 || uv.y > 1) {
          switch (this.wrapT) {
            case RepeatWrapping:
              uv.y = uv.y - Math.floor(uv.y);
              break;
            case ClampToEdgeWrapping:
              uv.y = uv.y < 0 ? 0 : 1;
              break;
            case MirroredRepeatWrapping:
              if (Math.abs(Math.floor(uv.y) % 2) === 1) {
                uv.y = Math.ceil(uv.y) - uv.y;
              } else {
                uv.y = uv.y - Math.floor(uv.y);
              }
              break;
          }
        }
        if (this.flipY) {
          uv.y = 1 - uv.y;
        }
        return uv;
      }
    }, {
      key: "needsUpdate",
      set: function set(value) {
        if (value === true) {
          this.version++;
          this.source.needsUpdate = true;
        }
      }
    }, {
      key: "needsPMREMUpdate",
      set: function set(value) {
        if (value === true) {
          this.pmremVersion++;
        }
      }
    }]);
  }(EventDispatcher);
  Texture.DEFAULT_IMAGE = null;
  Texture.DEFAULT_MAPPING = UVMapping;
  Texture.DEFAULT_ANISOTROPY = 1;
  var Vector4 = exports.Vector4 = /*#__PURE__*/function () {
    function Vector4() {
      var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var z = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      var w = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;
      (0, _classCallCheck2.default)(this, Vector4);
      Vector4.prototype.isVector4 = true;
      this.x = x;
      this.y = y;
      this.z = z;
      this.w = w;
    }
    return (0, _createClass2.default)(Vector4, [{
      key: "width",
      get: function get() {
        return this.z;
      },
      set: function set(value) {
        this.z = value;
      }
    }, {
      key: "height",
      get: function get() {
        return this.w;
      },
      set: function set(value) {
        this.w = value;
      }
    }, {
      key: "set",
      value: function set(x, y, z, w) {
        this.x = x;
        this.y = y;
        this.z = z;
        this.w = w;
        return this;
      }
    }, {
      key: "setScalar",
      value: function setScalar(scalar) {
        this.x = scalar;
        this.y = scalar;
        this.z = scalar;
        this.w = scalar;
        return this;
      }
    }, {
      key: "setX",
      value: function setX(x) {
        this.x = x;
        return this;
      }
    }, {
      key: "setY",
      value: function setY(y) {
        this.y = y;
        return this;
      }
    }, {
      key: "setZ",
      value: function setZ(z) {
        this.z = z;
        return this;
      }
    }, {
      key: "setW",
      value: function setW(w) {
        this.w = w;
        return this;
      }
    }, {
      key: "setComponent",
      value: function setComponent(index, value) {
        switch (index) {
          case 0:
            this.x = value;
            break;
          case 1:
            this.y = value;
            break;
          case 2:
            this.z = value;
            break;
          case 3:
            this.w = value;
            break;
          default:
            throw new Error('index is out of range: ' + index);
        }
        return this;
      }
    }, {
      key: "getComponent",
      value: function getComponent(index) {
        switch (index) {
          case 0:
            return this.x;
          case 1:
            return this.y;
          case 2:
            return this.z;
          case 3:
            return this.w;
          default:
            throw new Error('index is out of range: ' + index);
        }
      }
    }, {
      key: "clone",
      value: function clone() {
        return new this.constructor(this.x, this.y, this.z, this.w);
      }
    }, {
      key: "copy",
      value: function copy(v) {
        this.x = v.x;
        this.y = v.y;
        this.z = v.z;
        this.w = v.w !== undefined ? v.w : 1;
        return this;
      }
    }, {
      key: "add",
      value: function add(v) {
        this.x += v.x;
        this.y += v.y;
        this.z += v.z;
        this.w += v.w;
        return this;
      }
    }, {
      key: "addScalar",
      value: function addScalar(s) {
        this.x += s;
        this.y += s;
        this.z += s;
        this.w += s;
        return this;
      }
    }, {
      key: "addVectors",
      value: function addVectors(a, b) {
        this.x = a.x + b.x;
        this.y = a.y + b.y;
        this.z = a.z + b.z;
        this.w = a.w + b.w;
        return this;
      }
    }, {
      key: "addScaledVector",
      value: function addScaledVector(v, s) {
        this.x += v.x * s;
        this.y += v.y * s;
        this.z += v.z * s;
        this.w += v.w * s;
        return this;
      }
    }, {
      key: "sub",
      value: function sub(v) {
        this.x -= v.x;
        this.y -= v.y;
        this.z -= v.z;
        this.w -= v.w;
        return this;
      }
    }, {
      key: "subScalar",
      value: function subScalar(s) {
        this.x -= s;
        this.y -= s;
        this.z -= s;
        this.w -= s;
        return this;
      }
    }, {
      key: "subVectors",
      value: function subVectors(a, b) {
        this.x = a.x - b.x;
        this.y = a.y - b.y;
        this.z = a.z - b.z;
        this.w = a.w - b.w;
        return this;
      }
    }, {
      key: "multiply",
      value: function multiply(v) {
        this.x *= v.x;
        this.y *= v.y;
        this.z *= v.z;
        this.w *= v.w;
        return this;
      }
    }, {
      key: "multiplyScalar",
      value: function multiplyScalar(scalar) {
        this.x *= scalar;
        this.y *= scalar;
        this.z *= scalar;
        this.w *= scalar;
        return this;
      }
    }, {
      key: "applyMatrix4",
      value: function applyMatrix4(m) {
        var x = this.x,
          y = this.y,
          z = this.z,
          w = this.w;
        var e = m.elements;
        this.x = e[0] * x + e[4] * y + e[8] * z + e[12] * w;
        this.y = e[1] * x + e[5] * y + e[9] * z + e[13] * w;
        this.z = e[2] * x + e[6] * y + e[10] * z + e[14] * w;
        this.w = e[3] * x + e[7] * y + e[11] * z + e[15] * w;
        return this;
      }
    }, {
      key: "divide",
      value: function divide(v) {
        this.x /= v.x;
        this.y /= v.y;
        this.z /= v.z;
        this.w /= v.w;
        return this;
      }
    }, {
      key: "divideScalar",
      value: function divideScalar(scalar) {
        return this.multiplyScalar(1 / scalar);
      }
    }, {
      key: "setAxisAngleFromQuaternion",
      value: function setAxisAngleFromQuaternion(q) {
        // http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm

        // q is assumed to be normalized

        this.w = 2 * Math.acos(q.w);
        var s = Math.sqrt(1 - q.w * q.w);
        if (s < 0.0001) {
          this.x = 1;
          this.y = 0;
          this.z = 0;
        } else {
          this.x = q.x / s;
          this.y = q.y / s;
          this.z = q.z / s;
        }
        return this;
      }
    }, {
      key: "setAxisAngleFromRotationMatrix",
      value: function setAxisAngleFromRotationMatrix(m) {
        // http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm

        // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

        var angle, x, y, z; // variables for result
        var epsilon = 0.01,
          // margin to allow for rounding errors
          epsilon2 = 0.1,
          // margin to distinguish between 0 and 180 degrees

          te = m.elements,
          m11 = te[0],
          m12 = te[4],
          m13 = te[8],
          m21 = te[1],
          m22 = te[5],
          m23 = te[9],
          m31 = te[2],
          m32 = te[6],
          m33 = te[10];
        if (Math.abs(m12 - m21) < epsilon && Math.abs(m13 - m31) < epsilon && Math.abs(m23 - m32) < epsilon) {
          // singularity found
          // first check for identity matrix which must have +1 for all terms
          // in leading diagonal and zero in other terms

          if (Math.abs(m12 + m21) < epsilon2 && Math.abs(m13 + m31) < epsilon2 && Math.abs(m23 + m32) < epsilon2 && Math.abs(m11 + m22 + m33 - 3) < epsilon2) {
            // this singularity is identity matrix so angle = 0

            this.set(1, 0, 0, 0);
            return this; // zero angle, arbitrary axis
          }

          // otherwise this singularity is angle = 180

          angle = Math.PI;
          var xx = (m11 + 1) / 2;
          var yy = (m22 + 1) / 2;
          var zz = (m33 + 1) / 2;
          var xy = (m12 + m21) / 4;
          var xz = (m13 + m31) / 4;
          var yz = (m23 + m32) / 4;
          if (xx > yy && xx > zz) {
            // m11 is the largest diagonal term

            if (xx < epsilon) {
              x = 0;
              y = 0.707106781;
              z = 0.707106781;
            } else {
              x = Math.sqrt(xx);
              y = xy / x;
              z = xz / x;
            }
          } else if (yy > zz) {
            // m22 is the largest diagonal term

            if (yy < epsilon) {
              x = 0.707106781;
              y = 0;
              z = 0.707106781;
            } else {
              y = Math.sqrt(yy);
              x = xy / y;
              z = yz / y;
            }
          } else {
            // m33 is the largest diagonal term so base result on this

            if (zz < epsilon) {
              x = 0.707106781;
              y = 0.707106781;
              z = 0;
            } else {
              z = Math.sqrt(zz);
              x = xz / z;
              y = yz / z;
            }
          }
          this.set(x, y, z, angle);
          return this; // return 180 deg rotation
        }

        // as we have reached here there are no singularities so we can handle normally

        var s = Math.sqrt((m32 - m23) * (m32 - m23) + (m13 - m31) * (m13 - m31) + (m21 - m12) * (m21 - m12)); // used to normalize

        if (Math.abs(s) < 0.001) s = 1;

        // prevent divide by zero, should not happen if matrix is orthogonal and should be
        // caught by singularity test above, but I've left it in just in case

        this.x = (m32 - m23) / s;
        this.y = (m13 - m31) / s;
        this.z = (m21 - m12) / s;
        this.w = Math.acos((m11 + m22 + m33 - 1) / 2);
        return this;
      }
    }, {
      key: "setFromMatrixPosition",
      value: function setFromMatrixPosition(m) {
        var e = m.elements;
        this.x = e[12];
        this.y = e[13];
        this.z = e[14];
        this.w = e[15];
        return this;
      }
    }, {
      key: "min",
      value: function min(v) {
        this.x = Math.min(this.x, v.x);
        this.y = Math.min(this.y, v.y);
        this.z = Math.min(this.z, v.z);
        this.w = Math.min(this.w, v.w);
        return this;
      }
    }, {
      key: "max",
      value: function max(v) {
        this.x = Math.max(this.x, v.x);
        this.y = Math.max(this.y, v.y);
        this.z = Math.max(this.z, v.z);
        this.w = Math.max(this.w, v.w);
        return this;
      }
    }, {
      key: "clamp",
      value: function clamp(min, max) {
        // assumes min < max, componentwise

        this.x = _clamp(this.x, min.x, max.x);
        this.y = _clamp(this.y, min.y, max.y);
        this.z = _clamp(this.z, min.z, max.z);
        this.w = _clamp(this.w, min.w, max.w);
        return this;
      }
    }, {
      key: "clampScalar",
      value: function clampScalar(minVal, maxVal) {
        this.x = _clamp(this.x, minVal, maxVal);
        this.y = _clamp(this.y, minVal, maxVal);
        this.z = _clamp(this.z, minVal, maxVal);
        this.w = _clamp(this.w, minVal, maxVal);
        return this;
      }
    }, {
      key: "clampLength",
      value: function clampLength(min, max) {
        var length = this.length();
        return this.divideScalar(length || 1).multiplyScalar(_clamp(length, min, max));
      }
    }, {
      key: "floor",
      value: function floor() {
        this.x = Math.floor(this.x);
        this.y = Math.floor(this.y);
        this.z = Math.floor(this.z);
        this.w = Math.floor(this.w);
        return this;
      }
    }, {
      key: "ceil",
      value: function ceil() {
        this.x = Math.ceil(this.x);
        this.y = Math.ceil(this.y);
        this.z = Math.ceil(this.z);
        this.w = Math.ceil(this.w);
        return this;
      }
    }, {
      key: "round",
      value: function round() {
        this.x = Math.round(this.x);
        this.y = Math.round(this.y);
        this.z = Math.round(this.z);
        this.w = Math.round(this.w);
        return this;
      }
    }, {
      key: "roundToZero",
      value: function roundToZero() {
        this.x = Math.trunc(this.x);
        this.y = Math.trunc(this.y);
        this.z = Math.trunc(this.z);
        this.w = Math.trunc(this.w);
        return this;
      }
    }, {
      key: "negate",
      value: function negate() {
        this.x = -this.x;
        this.y = -this.y;
        this.z = -this.z;
        this.w = -this.w;
        return this;
      }
    }, {
      key: "dot",
      value: function dot(v) {
        return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;
      }
    }, {
      key: "lengthSq",
      value: function lengthSq() {
        return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
      }
    }, {
      key: "length",
      value: function length() {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
      }
    }, {
      key: "manhattanLength",
      value: function manhattanLength() {
        return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w);
      }
    }, {
      key: "normalize",
      value: function normalize() {
        return this.divideScalar(this.length() || 1);
      }
    }, {
      key: "setLength",
      value: function setLength(length) {
        return this.normalize().multiplyScalar(length);
      }
    }, {
      key: "lerp",
      value: function lerp(v, alpha) {
        this.x += (v.x - this.x) * alpha;
        this.y += (v.y - this.y) * alpha;
        this.z += (v.z - this.z) * alpha;
        this.w += (v.w - this.w) * alpha;
        return this;
      }
    }, {
      key: "lerpVectors",
      value: function lerpVectors(v1, v2, alpha) {
        this.x = v1.x + (v2.x - v1.x) * alpha;
        this.y = v1.y + (v2.y - v1.y) * alpha;
        this.z = v1.z + (v2.z - v1.z) * alpha;
        this.w = v1.w + (v2.w - v1.w) * alpha;
        return this;
      }
    }, {
      key: "equals",
      value: function equals(v) {
        return v.x === this.x && v.y === this.y && v.z === this.z && v.w === this.w;
      }
    }, {
      key: "fromArray",
      value: function fromArray(array) {
        var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        this.x = array[offset];
        this.y = array[offset + 1];
        this.z = array[offset + 2];
        this.w = array[offset + 3];
        return this;
      }
    }, {
      key: "toArray",
      value: function toArray() {
        var array = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
        var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        array[offset] = this.x;
        array[offset + 1] = this.y;
        array[offset + 2] = this.z;
        array[offset + 3] = this.w;
        return array;
      }
    }, {
      key: "fromBufferAttribute",
      value: function fromBufferAttribute(attribute, index) {
        this.x = attribute.getX(index);
        this.y = attribute.getY(index);
        this.z = attribute.getZ(index);
        this.w = attribute.getW(index);
        return this;
      }
    }, {
      key: "random",
      value: function random() {
        this.x = Math.random();
        this.y = Math.random();
        this.z = Math.random();
        this.w = Math.random();
        return this;
      }
    }, {
      key: Symbol.iterator,
      value: function* value() {
        yield this.x;
        yield this.y;
        yield this.z;
        yield this.w;
      }
    }]);
  }();
  /*
   In options, we can specify:
   * Texture parameters for an auto-generated target texture
   * depthBuffer/stencilBuffer: Booleans to indicate if we should generate these buffers
  */
  var RenderTarget = exports.RenderTarget = /*#__PURE__*/function (_EventDispatcher2) {
    function RenderTarget() {
      var _this2;
      var width = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
      var height = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      (0, _classCallCheck2.default)(this, RenderTarget);
      _this2 = _callSuper(this, RenderTarget);
      _this2.isRenderTarget = true;
      _this2.width = width;
      _this2.height = height;
      _this2.depth = 1;
      _this2.scissor = new Vector4(0, 0, width, height);
      _this2.scissorTest = false;
      _this2.viewport = new Vector4(0, 0, width, height);
      var image = {
        width: width,
        height: height,
        depth: 1
      };
      options = Object.assign({
        generateMipmaps: false,
        internalFormat: null,
        minFilter: LinearFilter,
        depthBuffer: true,
        stencilBuffer: false,
        resolveDepthBuffer: true,
        resolveStencilBuffer: true,
        depthTexture: null,
        samples: 0,
        count: 1
      }, options);
      var texture = new Texture(image, options.mapping, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.colorSpace);
      texture.flipY = false;
      texture.generateMipmaps = options.generateMipmaps;
      texture.internalFormat = options.internalFormat;
      _this2.textures = [];
      var count = options.count;
      for (var i = 0; i < count; i++) {
        _this2.textures[i] = texture.clone();
        _this2.textures[i].isRenderTargetTexture = true;
        _this2.textures[i].renderTarget = _this2;
      }
      _this2.depthBuffer = options.depthBuffer;
      _this2.stencilBuffer = options.stencilBuffer;
      _this2.resolveDepthBuffer = options.resolveDepthBuffer;
      _this2.resolveStencilBuffer = options.resolveStencilBuffer;
      _this2._depthTexture = null;
      _this2.depthTexture = options.depthTexture;
      _this2.samples = options.samples;
      return _this2;
    }
    (0, _inherits2.default)(RenderTarget, _EventDispatcher2);
    return (0, _createClass2.default)(RenderTarget, [{
      key: "texture",
      get: function get() {
        return this.textures[0];
      },
      set: function set(value) {
        this.textures[0] = value;
      }
    }, {
      key: "depthTexture",
      get: function get() {
        return this._depthTexture;
      },
      set: function set(current) {
        if (this._depthTexture !== null) this._depthTexture.renderTarget = null;
        if (current !== null) current.renderTarget = this;
        this._depthTexture = current;
      }
    }, {
      key: "setSize",
      value: function setSize(width, height) {
        var depth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
        if (this.width !== width || this.height !== height || this.depth !== depth) {
          this.width = width;
          this.height = height;
          this.depth = depth;
          for (var i = 0, il = this.textures.length; i < il; i++) {
            this.textures[i].image.width = width;
            this.textures[i].image.height = height;
            this.textures[i].image.depth = depth;
          }
          this.dispose();
        }
        this.viewport.set(0, 0, width, height);
        this.scissor.set(0, 0, width, height);
      }
    }, {
      key: "clone",
      value: function clone() {
        return new this.constructor().copy(this);
      }
    }, {
      key: "copy",
      value: function copy(source) {
        this.width = source.width;
        this.height = source.height;
        this.depth = source.depth;
        this.scissor.copy(source.scissor);
        this.scissorTest = source.scissorTest;
        this.viewport.copy(source.viewport);
        this.textures.length = 0;
        for (var i = 0, il = source.textures.length; i < il; i++) {
          this.textures[i] = source.textures[i].clone();
          this.textures[i].isRenderTargetTexture = true;
          this.textures[i].renderTarget = this;
        }

        // ensure image object is not shared, see #20328

        var image = Object.assign({}, source.texture.image);
        this.texture.source = new Source(image);
        this.depthBuffer = source.depthBuffer;
        this.stencilBuffer = source.stencilBuffer;
        this.resolveDepthBuffer = source.resolveDepthBuffer;
        this.resolveStencilBuffer = source.resolveStencilBuffer;
        if (source.depthTexture !== null) this.depthTexture = source.depthTexture.clone();
        this.samples = source.samples;
        return this;
      }
    }, {
      key: "dispose",
      value: function dispose() {
        this.dispatchEvent({
          type: 'dispose'
        });
      }
    }]);
  }(EventDispatcher);
  var WebGLRenderTarget = exports.WebGLRenderTarget = /*#__PURE__*/function (_RenderTarget) {
    function WebGLRenderTarget() {
      var _this3;
      var width = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
      var height = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      (0, _classCallCheck2.default)(this, WebGLRenderTarget);
      _this3 = _callSuper(this, WebGLRenderTarget, [width, height, options]);
      _this3.isWebGLRenderTarget = true;
      return _this3;
    }
    (0, _inherits2.default)(WebGLRenderTarget, _RenderTarget);
    return (0, _createClass2.default)(WebGLRenderTarget);
  }(RenderTarget);
  var DataArrayTexture = exports.DataArrayTexture = /*#__PURE__*/function (_Texture) {
    function DataArrayTexture() {
      var _this4;
      var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      var width = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
      var height = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
      var depth = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;
      (0, _classCallCheck2.default)(this, DataArrayTexture);
      _this4 = _callSuper(this, DataArrayTexture, [null]);
      _this4.isDataArrayTexture = true;
      _this4.image = {
        data: data,
        width: width,
        height: height,
        depth: depth
      };
      _this4.magFilter = NearestFilter;
      _this4.minFilter = NearestFilter;
      _this4.wrapR = ClampToEdgeWrapping;
      _this4.generateMipmaps = false;
      _this4.flipY = false;
      _this4.unpackAlignment = 1;
      _this4.layerUpdates = new Set();
      return _this4;
    }
    (0, _inherits2.default)(DataArrayTexture, _Texture);
    return (0, _createClass2.default)(DataArrayTexture, [{
      key: "addLayerUpdate",
      value: function addLayerUpdate(layerIndex) {
        this.layerUpdates.add(layerIndex);
      }
    }, {
      key: "clearLayerUpdates",
      value: function clearLayerUpdates() {
        this.layerUpdates.clear();
      }
    }]);
  }(Texture);
  var WebGLArrayRenderTarget = exports.WebGLArrayRenderTarget = /*#__PURE__*/function (_WebGLRenderTarget) {
    function WebGLArrayRenderTarget() {
      var _this5;
      var width = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
      var height = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
      var depth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
      var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
      (0, _classCallCheck2.default)(this, WebGLArrayRenderTarget);
      _this5 = _callSuper(this, WebGLArrayRenderTarget, [width, height, options]);
      _this5.isWebGLArrayRenderTarget = true;
      _this5.depth = depth;
      _this5.texture = new DataArrayTexture(null, width, height, depth);
      _this5.texture.isRenderTargetTexture = true;
      return _this5;
    }
    (0, _inherits2.default)(WebGLArrayRenderTarget, _WebGLRenderTarget);
    return (0, _createClass2.default)(WebGLArrayRenderTarget);
  }(WebGLRenderTarget);
  var Data3DTexture = exports.Data3DTexture = /*#__PURE__*/function (_Texture2) {
    function Data3DTexture() {
      var _this6;
      var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      var width = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
      var height = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
      var depth = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;
      (0, _classCallCheck2.default)(this, Data3DTexture);
      // We're going to add .setXXX() methods for setting properties later.
      // Users can still set in Data3DTexture directly.
      //
      //	const texture = new THREE.Data3DTexture( data, width, height, depth );
      // 	texture.anisotropy = 16;
      //
      // See #14839

      _this6 = _callSuper(this, Data3DTexture, [null]);
      _this6.isData3DTexture = true;
      _this6.image = {
        data: data,
        width: width,
        height: height,
        depth: depth
      };
      _this6.magFilter = NearestFilter;
      _this6.minFilter = NearestFilter;
      _this6.wrapR = ClampToEdgeWrapping;
      _this6.generateMipmaps = false;
      _this6.flipY = false;
      _this6.unpackAlignment = 1;
      return _this6;
    }
    (0, _inherits2.default)(Data3DTexture, _Texture2);
    return (0, _createClass2.default)(Data3DTexture);
  }(Texture);
  var WebGL3DRenderTarget = exports.WebGL3DRenderTarget = /*#__PURE__*/function (_WebGLRenderTarget2) {
    function WebGL3DRenderTarget() {
      var _this7;
      var width = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
      var height = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
      var depth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
      var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
      (0, _classCallCheck2.default)(this, WebGL3DRenderTarget);
      _this7 = _callSuper(this, WebGL3DRenderTarget, [width, height, options]);
      _this7.isWebGL3DRenderTarget = true;
      _this7.depth = depth;
      _this7.texture = new Data3DTexture(null, width, height, depth);
      _this7.texture.isRenderTargetTexture = true;
      return _this7;
    }
    (0, _inherits2.default)(WebGL3DRenderTarget, _WebGLRenderTarget2);
    return (0, _createClass2.default)(WebGL3DRenderTarget);
  }(WebGLRenderTarget);
  var Quaternion = exports.Quaternion = /*#__PURE__*/function () {
    function Quaternion() {
      var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var z = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      var w = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;
      (0, _classCallCheck2.default)(this, Quaternion);
      this.isQuaternion = true;
      this._x = x;
      this._y = y;
      this._z = z;
      this._w = w;
    }
    return (0, _createClass2.default)(Quaternion, [{
      key: "x",
      get: function get() {
        return this._x;
      },
      set: function set(value) {
        this._x = value;
        this._onChangeCallback();
      }
    }, {
      key: "y",
      get: function get() {
        return this._y;
      },
      set: function set(value) {
        this._y = value;
        this._onChangeCallback();
      }
    }, {
      key: "z",
      get: function get() {
        return this._z;
      },
      set: function set(value) {
        this._z = value;
        this._onChangeCallback();
      }
    }, {
      key: "w",
      get: function get() {
        return this._w;
      },
      set: function set(value) {
        this._w = value;
        this._onChangeCallback();
      }
    }, {
      key: "set",
      value: function set(x, y, z, w) {
        this._x = x;
        this._y = y;
        this._z = z;
        this._w = w;
        this._onChangeCallback();
        return this;
      }
    }, {
      key: "clone",
      value: function clone() {
        return new this.constructor(this._x, this._y, this._z, this._w);
      }
    }, {
      key: "copy",
      value: function copy(quaternion) {
        this._x = quaternion.x;
        this._y = quaternion.y;
        this._z = quaternion.z;
        this._w = quaternion.w;
        this._onChangeCallback();
        return this;
      }
    }, {
      key: "setFromEuler",
      value: function setFromEuler(euler) {
        var update = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
        var x = euler._x,
          y = euler._y,
          z = euler._z,
          order = euler._order;

        // http://www.mathworks.com/matlabcentral/fileexchange/
        // 	20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/
        //	content/SpinCalc.m

        var cos = Math.cos;
        var sin = Math.sin;
        var c1 = cos(x / 2);
        var c2 = cos(y / 2);
        var c3 = cos(z / 2);
        var s1 = sin(x / 2);
        var s2 = sin(y / 2);
        var s3 = sin(z / 2);
        switch (order) {
          case 'XYZ':
            this._x = s1 * c2 * c3 + c1 * s2 * s3;
            this._y = c1 * s2 * c3 - s1 * c2 * s3;
            this._z = c1 * c2 * s3 + s1 * s2 * c3;
            this._w = c1 * c2 * c3 - s1 * s2 * s3;
            break;
          case 'YXZ':
            this._x = s1 * c2 * c3 + c1 * s2 * s3;
            this._y = c1 * s2 * c3 - s1 * c2 * s3;
            this._z = c1 * c2 * s3 - s1 * s2 * c3;
            this._w = c1 * c2 * c3 + s1 * s2 * s3;
            break;
          case 'ZXY':
            this._x = s1 * c2 * c3 - c1 * s2 * s3;
            this._y = c1 * s2 * c3 + s1 * c2 * s3;
            this._z = c1 * c2 * s3 + s1 * s2 * c3;
            this._w = c1 * c2 * c3 - s1 * s2 * s3;
            break;
          case 'ZYX':
            this._x = s1 * c2 * c3 - c1 * s2 * s3;
            this._y = c1 * s2 * c3 + s1 * c2 * s3;
            this._z = c1 * c2 * s3 - s1 * s2 * c3;
            this._w = c1 * c2 * c3 + s1 * s2 * s3;
            break;
          case 'YZX':
            this._x = s1 * c2 * c3 + c1 * s2 * s3;
            this._y = c1 * s2 * c3 + s1 * c2 * s3;
            this._z = c1 * c2 * s3 - s1 * s2 * c3;
            this._w = c1 * c2 * c3 - s1 * s2 * s3;
            break;
          case 'XZY':
            this._x = s1 * c2 * c3 - c1 * s2 * s3;
            this._y = c1 * s2 * c3 - s1 * c2 * s3;
            this._z = c1 * c2 * s3 + s1 * s2 * c3;
            this._w = c1 * c2 * c3 + s1 * s2 * s3;
            break;
          default:
            console.warn('THREE.Quaternion: .setFromEuler() encountered an unknown order: ' + order);
        }
        if (update === true) this._onChangeCallback();
        return this;
      }
    }, {
      key: "setFromAxisAngle",
      value: function setFromAxisAngle(axis, angle) {
        // http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm

        // assumes axis is normalized

        var halfAngle = angle / 2,
          s = Math.sin(halfAngle);
        this._x = axis.x * s;
        this._y = axis.y * s;
        this._z = axis.z * s;
        this._w = Math.cos(halfAngle);
        this._onChangeCallback();
        return this;
      }
    }, {
      key: "setFromRotationMatrix",
      value: function setFromRotationMatrix(m) {
        // http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm

        // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

        var te = m.elements,
          m11 = te[0],
          m12 = te[4],
          m13 = te[8],
          m21 = te[1],
          m22 = te[5],
          m23 = te[9],
          m31 = te[2],
          m32 = te[6],
          m33 = te[10],
          trace = m11 + m22 + m33;
        if (trace > 0) {
          var s = 0.5 / Math.sqrt(trace + 1.0);
          this._w = 0.25 / s;
          this._x = (m32 - m23) * s;
          this._y = (m13 - m31) * s;
          this._z = (m21 - m12) * s;
        } else if (m11 > m22 && m11 > m33) {
          var _s = 2.0 * Math.sqrt(1.0 + m11 - m22 - m33);
          this._w = (m32 - m23) / _s;
          this._x = 0.25 * _s;
          this._y = (m12 + m21) / _s;
          this._z = (m13 + m31) / _s;
        } else if (m22 > m33) {
          var _s2 = 2.0 * Math.sqrt(1.0 + m22 - m11 - m33);
          this._w = (m13 - m31) / _s2;
          this._x = (m12 + m21) / _s2;
          this._y = 0.25 * _s2;
          this._z = (m23 + m32) / _s2;
        } else {
          var _s3 = 2.0 * Math.sqrt(1.0 + m33 - m11 - m22);
          this._w = (m21 - m12) / _s3;
          this._x = (m13 + m31) / _s3;
          this._y = (m23 + m32) / _s3;
          this._z = 0.25 * _s3;
        }
        this._onChangeCallback();
        return this;
      }
    }, {
      key: "setFromUnitVectors",
      value: function setFromUnitVectors(vFrom, vTo) {
        // assumes direction vectors vFrom and vTo are normalized

        var r = vFrom.dot(vTo) + 1;
        if (r < Number.EPSILON) {
          // vFrom and vTo point in opposite directions

          r = 0;
          if (Math.abs(vFrom.x) > Math.abs(vFrom.z)) {
            this._x = -vFrom.y;
            this._y = vFrom.x;
            this._z = 0;
            this._w = r;
          } else {
            this._x = 0;
            this._y = -vFrom.z;
            this._z = vFrom.y;
            this._w = r;
          }
        } else {
          // crossVectors( vFrom, vTo ); // inlined to avoid cyclic dependency on Vector3

          this._x = vFrom.y * vTo.z - vFrom.z * vTo.y;
          this._y = vFrom.z * vTo.x - vFrom.x * vTo.z;
          this._z = vFrom.x * vTo.y - vFrom.y * vTo.x;
          this._w = r;
        }
        return this.normalize();
      }
    }, {
      key: "angleTo",
      value: function angleTo(q) {
        return 2 * Math.acos(Math.abs(_clamp(this.dot(q), -1, 1)));
      }
    }, {
      key: "rotateTowards",
      value: function rotateTowards(q, step) {
        var angle = this.angleTo(q);
        if (angle === 0) return this;
        var t = Math.min(1, step / angle);
        this.slerp(q, t);
        return this;
      }
    }, {
      key: "identity",
      value: function identity() {
        return this.set(0, 0, 0, 1);
      }
    }, {
      key: "invert",
      value: function invert() {
        // quaternion is assumed to have unit length

        return this.conjugate();
      }
    }, {
      key: "conjugate",
      value: function conjugate() {
        this._x *= -1;
        this._y *= -1;
        this._z *= -1;
        this._onChangeCallback();
        return this;
      }
    }, {
      key: "dot",
      value: function dot(v) {
        return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;
      }
    }, {
      key: "lengthSq",
      value: function lengthSq() {
        return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
      }
    }, {
      key: "length",
      value: function length() {
        return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w);
      }
    }, {
      key: "normalize",
      value: function normalize() {
        var l = this.length();
        if (l === 0) {
          this._x = 0;
          this._y = 0;
          this._z = 0;
          this._w = 1;
        } else {
          l = 1 / l;
          this._x = this._x * l;
          this._y = this._y * l;
          this._z = this._z * l;
          this._w = this._w * l;
        }
        this._onChangeCallback();
        return this;
      }
    }, {
      key: "multiply",
      value: function multiply(q) {
        return this.multiplyQuaternions(this, q);
      }
    }, {
      key: "premultiply",
      value: function premultiply(q) {
        return this.multiplyQuaternions(q, this);
      }
    }, {
      key: "multiplyQuaternions",
      value: function multiplyQuaternions(a, b) {
        // from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm

        var qax = a._x,
          qay = a._y,
          qaz = a._z,
          qaw = a._w;
        var qbx = b._x,
          qby = b._y,
          qbz = b._z,
          qbw = b._w;
        this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
        this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
        this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
        this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;
        this._onChangeCallback();
        return this;
      }
    }, {
      key: "slerp",
      value: function slerp(qb, t) {
        if (t === 0) return this;
        if (t === 1) return this.copy(qb);
        var x = this._x,
          y = this._y,
          z = this._z,
          w = this._w;

        // http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/

        var cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;
        if (cosHalfTheta < 0) {
          this._w = -qb._w;
          this._x = -qb._x;
          this._y = -qb._y;
          this._z = -qb._z;
          cosHalfTheta = -cosHalfTheta;
        } else {
          this.copy(qb);
        }
        if (cosHalfTheta >= 1.0) {
          this._w = w;
          this._x = x;
          this._y = y;
          this._z = z;
          return this;
        }
        var sqrSinHalfTheta = 1.0 - cosHalfTheta * cosHalfTheta;
        if (sqrSinHalfTheta <= Number.EPSILON) {
          var s = 1 - t;
          this._w = s * w + t * this._w;
          this._x = s * x + t * this._x;
          this._y = s * y + t * this._y;
          this._z = s * z + t * this._z;
          this.normalize(); // normalize calls _onChangeCallback()

          return this;
        }
        var sinHalfTheta = Math.sqrt(sqrSinHalfTheta);
        var halfTheta = Math.atan2(sinHalfTheta, cosHalfTheta);
        var ratioA = Math.sin((1 - t) * halfTheta) / sinHalfTheta,
          ratioB = Math.sin(t * halfTheta) / sinHalfTheta;
        this._w = w * ratioA + this._w * ratioB;
        this._x = x * ratioA + this._x * ratioB;
        this._y = y * ratioA + this._y * ratioB;
        this._z = z * ratioA + this._z * ratioB;
        this._onChangeCallback();
        return this;
      }
    }, {
      key: "slerpQuaternions",
      value: function slerpQuaternions(qa, qb, t) {
        return this.copy(qa).slerp(qb, t);
      }
    }, {
      key: "random",
      value: function random() {
        // sets this quaternion to a uniform random unit quaternnion

        // Ken Shoemake
        // Uniform random rotations
        // D. Kirk, editor, Graphics Gems III, pages 124-132. Academic Press, New York, 1992.

        var theta1 = 2 * Math.PI * Math.random();
        var theta2 = 2 * Math.PI * Math.random();
        var x0 = Math.random();
        var r1 = Math.sqrt(1 - x0);
        var r2 = Math.sqrt(x0);
        return this.set(r1 * Math.sin(theta1), r1 * Math.cos(theta1), r2 * Math.sin(theta2), r2 * Math.cos(theta2));
      }
    }, {
      key: "equals",
      value: function equals(quaternion) {
        return quaternion._x === this._x && quaternion._y === this._y && quaternion._z === this._z && quaternion._w === this._w;
      }
    }, {
      key: "fromArray",
      value: function fromArray(array) {
        var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        this._x = array[offset];
        this._y = array[offset + 1];
        this._z = array[offset + 2];
        this._w = array[offset + 3];
        this._onChangeCallback();
        return this;
      }
    }, {
      key: "toArray",
      value: function toArray() {
        var array = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
        var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        array[offset] = this._x;
        array[offset + 1] = this._y;
        array[offset + 2] = this._z;
        array[offset + 3] = this._w;
        return array;
      }
    }, {
      key: "fromBufferAttribute",
      value: function fromBufferAttribute(attribute, index) {
        this._x = attribute.getX(index);
        this._y = attribute.getY(index);
        this._z = attribute.getZ(index);
        this._w = attribute.getW(index);
        this._onChangeCallback();
        return this;
      }
    }, {
      key: "toJSON",
      value: function toJSON() {
        return this.toArray();
      }
    }, {
      key: "_onChange",
      value: function _onChange(callback) {
        this._onChangeCallback = callback;
        return this;
      }
    }, {
      key: "_onChangeCallback",
      value: function _onChangeCallback() {}
    }, {
      key: Symbol.iterator,
      value: function* value() {
        yield this._x;
        yield this._y;
        yield this._z;
        yield this._w;
      }
    }], [{
      key: "slerpFlat",
      value: function slerpFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t) {
        // fuzz-free, array-based Quaternion SLERP operation

        var x0 = src0[srcOffset0 + 0],
          y0 = src0[srcOffset0 + 1],
          z0 = src0[srcOffset0 + 2],
          w0 = src0[srcOffset0 + 3];
        var x1 = src1[srcOffset1 + 0],
          y1 = src1[srcOffset1 + 1],
          z1 = src1[srcOffset1 + 2],
          w1 = src1[srcOffset1 + 3];
        if (t === 0) {
          dst[dstOffset + 0] = x0;
          dst[dstOffset + 1] = y0;
          dst[dstOffset + 2] = z0;
          dst[dstOffset + 3] = w0;
          return;
        }
        if (t === 1) {
          dst[dstOffset + 0] = x1;
          dst[dstOffset + 1] = y1;
          dst[dstOffset + 2] = z1;
          dst[dstOffset + 3] = w1;
          return;
        }
        if (w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1) {
          var s = 1 - t;
          var cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1,
            dir = cos >= 0 ? 1 : -1,
            sqrSin = 1 - cos * cos;

          // Skip the Slerp for tiny steps to avoid numeric problems:
          if (sqrSin > Number.EPSILON) {
            var sin = Math.sqrt(sqrSin),
              len = Math.atan2(sin, cos * dir);
            s = Math.sin(s * len) / sin;
            t = Math.sin(t * len) / sin;
          }
          var tDir = t * dir;
          x0 = x0 * s + x1 * tDir;
          y0 = y0 * s + y1 * tDir;
          z0 = z0 * s + z1 * tDir;
          w0 = w0 * s + w1 * tDir;

          // Normalize in case we just did a lerp:
          if (s === 1 - t) {
            var f = 1 / Math.sqrt(x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0);
            x0 *= f;
            y0 *= f;
            z0 *= f;
            w0 *= f;
          }
        }
        dst[dstOffset] = x0;
        dst[dstOffset + 1] = y0;
        dst[dstOffset + 2] = z0;
        dst[dstOffset + 3] = w0;
      }
    }, {
      key: "multiplyQuaternionsFlat",
      value: function multiplyQuaternionsFlat(dst, dstOffset, src0, srcOffset0, src1, srcOffset1) {
        var x0 = src0[srcOffset0];
        var y0 = src0[srcOffset0 + 1];
        var z0 = src0[srcOffset0 + 2];
        var w0 = src0[srcOffset0 + 3];
        var x1 = src1[srcOffset1];
        var y1 = src1[srcOffset1 + 1];
        var z1 = src1[srcOffset1 + 2];
        var w1 = src1[srcOffset1 + 3];
        dst[dstOffset] = x0 * w1 + w0 * x1 + y0 * z1 - z0 * y1;
        dst[dstOffset + 1] = y0 * w1 + w0 * y1 + z0 * x1 - x0 * z1;
        dst[dstOffset + 2] = z0 * w1 + w0 * z1 + x0 * y1 - y0 * x1;
        dst[dstOffset + 3] = w0 * w1 - x0 * x1 - y0 * y1 - z0 * z1;
        return dst;
      }
    }]);
  }();
  var Vector3 = exports.Vector3 = /*#__PURE__*/function () {
    function Vector3() {
      var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var z = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      (0, _classCallCheck2.default)(this, Vector3);
      Vector3.prototype.isVector3 = true;
      this.x = x;
      this.y = y;
      this.z = z;
    }
    return (0, _createClass2.default)(Vector3, [{
      key: "set",
      value: function set(x, y, z) {
        if (z === undefined) z = this.z; // sprite.scale.set(x,y)

        this.x = x;
        this.y = y;
        this.z = z;
        return this;
      }
    }, {
      key: "setScalar",
      value: function setScalar(scalar) {
        this.x = scalar;
        this.y = scalar;
        this.z = scalar;
        return this;
      }
    }, {
      key: "setX",
      value: function setX(x) {
        this.x = x;
        return this;
      }
    }, {
      key: "setY",
      value: function setY(y) {
        this.y = y;
        return this;
      }
    }, {
      key: "setZ",
      value: function setZ(z) {
        this.z = z;
        return this;
      }
    }, {
      key: "setComponent",
      value: function setComponent(index, value) {
        switch (index) {
          case 0:
            this.x = value;
            break;
          case 1:
            this.y = value;
            break;
          case 2:
            this.z = value;
            break;
          default:
            throw new Error('index is out of range: ' + index);
        }
        return this;
      }
    }, {
      key: "getComponent",
      value: function getComponent(index) {
        switch (index) {
          case 0:
            return this.x;
          case 1:
            return this.y;
          case 2:
            return this.z;
          default:
            throw new Error('index is out of range: ' + index);
        }
      }
    }, {
      key: "clone",
      value: function clone() {
        return new this.constructor(this.x, this.y, this.z);
      }
    }, {
      key: "copy",
      value: function copy(v) {
        this.x = v.x;
        this.y = v.y;
        this.z = v.z;
        return this;
      }
    }, {
      key: "add",
      value: function add(v) {
        this.x += v.x;
        this.y += v.y;
        this.z += v.z;
        return this;
      }
    }, {
      key: "addScalar",
      value: function addScalar(s) {
        this.x += s;
        this.y += s;
        this.z += s;
        return this;
      }
    }, {
      key: "addVectors",
      value: function addVectors(a, b) {
        this.x = a.x + b.x;
        this.y = a.y + b.y;
        this.z = a.z + b.z;
        return this;
      }
    }, {
      key: "addScaledVector",
      value: function addScaledVector(v, s) {
        this.x += v.x * s;
        this.y += v.y * s;
        this.z += v.z * s;
        return this;
      }
    }, {
      key: "sub",
      value: function sub(v) {
        this.x -= v.x;
        this.y -= v.y;
        this.z -= v.z;
        return this;
      }
    }, {
      key: "subScalar",
      value: function subScalar(s) {
        this.x -= s;
        this.y -= s;
        this.z -= s;
        return this;
      }
    }, {
      key: "subVectors",
      value: function subVectors(a, b) {
        this.x = a.x - b.x;
        this.y = a.y - b.y;
        this.z = a.z - b.z;
        return this;
      }
    }, {
      key: "multiply",
      value: function multiply(v) {
        this.x *= v.x;
        this.y *= v.y;
        this.z *= v.z;
        return this;
      }
    }, {
      key: "multiplyScalar",
      value: function multiplyScalar(scalar) {
        this.x *= scalar;
        this.y *= scalar;
        this.z *= scalar;
        return this;
      }
    }, {
      key: "multiplyVectors",
      value: function multiplyVectors(a, b) {
        this.x = a.x * b.x;
        this.y = a.y * b.y;
        this.z = a.z * b.z;
        return this;
      }
    }, {
      key: "applyEuler",
      value: function applyEuler(euler) {
        return this.applyQuaternion(_quaternion$4.setFromEuler(euler));
      }
    }, {
      key: "applyAxisAngle",
      value: function applyAxisAngle(axis, angle) {
        return this.applyQuaternion(_quaternion$4.setFromAxisAngle(axis, angle));
      }
    }, {
      key: "applyMatrix3",
      value: function applyMatrix3(m) {
        var x = this.x,
          y = this.y,
          z = this.z;
        var e = m.elements;
        this.x = e[0] * x + e[3] * y + e[6] * z;
        this.y = e[1] * x + e[4] * y + e[7] * z;
        this.z = e[2] * x + e[5] * y + e[8] * z;
        return this;
      }
    }, {
      key: "applyNormalMatrix",
      value: function applyNormalMatrix(m) {
        return this.applyMatrix3(m).normalize();
      }
    }, {
      key: "applyMatrix4",
      value: function applyMatrix4(m) {
        var x = this.x,
          y = this.y,
          z = this.z;
        var e = m.elements;
        var w = 1 / (e[3] * x + e[7] * y + e[11] * z + e[15]);
        this.x = (e[0] * x + e[4] * y + e[8] * z + e[12]) * w;
        this.y = (e[1] * x + e[5] * y + e[9] * z + e[13]) * w;
        this.z = (e[2] * x + e[6] * y + e[10] * z + e[14]) * w;
        return this;
      }
    }, {
      key: "applyQuaternion",
      value: function applyQuaternion(q) {
        // quaternion q is assumed to have unit length

        var vx = this.x,
          vy = this.y,
          vz = this.z;
        var qx = q.x,
          qy = q.y,
          qz = q.z,
          qw = q.w;

        // t = 2 * cross( q.xyz, v );
        var tx = 2 * (qy * vz - qz * vy);
        var ty = 2 * (qz * vx - qx * vz);
        var tz = 2 * (qx * vy - qy * vx);

        // v + q.w * t + cross( q.xyz, t );
        this.x = vx + qw * tx + qy * tz - qz * ty;
        this.y = vy + qw * ty + qz * tx - qx * tz;
        this.z = vz + qw * tz + qx * ty - qy * tx;
        return this;
      }
    }, {
      key: "project",
      value: function project(camera) {
        return this.applyMatrix4(camera.matrixWorldInverse).applyMatrix4(camera.projectionMatrix);
      }
    }, {
      key: "unproject",
      value: function unproject(camera) {
        return this.applyMatrix4(camera.projectionMatrixInverse).applyMatrix4(camera.matrixWorld);
      }
    }, {
      key: "transformDirection",
      value: function transformDirection(m) {
        // input: THREE.Matrix4 affine matrix
        // vector interpreted as a direction

        var x = this.x,
          y = this.y,
          z = this.z;
        var e = m.elements;
        this.x = e[0] * x + e[4] * y + e[8] * z;
        this.y = e[1] * x + e[5] * y + e[9] * z;
        this.z = e[2] * x + e[6] * y + e[10] * z;
        return this.normalize();
      }
    }, {
      key: "divide",
      value: function divide(v) {
        this.x /= v.x;
        this.y /= v.y;
        this.z /= v.z;
        return this;
      }
    }, {
      key: "divideScalar",
      value: function divideScalar(scalar) {
        return this.multiplyScalar(1 / scalar);
      }
    }, {
      key: "min",
      value: function min(v) {
        this.x = Math.min(this.x, v.x);
        this.y = Math.min(this.y, v.y);
        this.z = Math.min(this.z, v.z);
        return this;
      }
    }, {
      key: "max",
      value: function max(v) {
        this.x = Math.max(this.x, v.x);
        this.y = Math.max(this.y, v.y);
        this.z = Math.max(this.z, v.z);
        return this;
      }
    }, {
      key: "clamp",
      value: function clamp(min, max) {
        // assumes min < max, componentwise

        this.x = _clamp(this.x, min.x, max.x);
        this.y = _clamp(this.y, min.y, max.y);
        this.z = _clamp(this.z, min.z, max.z);
        return this;
      }
    }, {
      key: "clampScalar",
      value: function clampScalar(minVal, maxVal) {
        this.x = _clamp(this.x, minVal, maxVal);
        this.y = _clamp(this.y, minVal, maxVal);
        this.z = _clamp(this.z, minVal, maxVal);
        return this;
      }
    }, {
      key: "clampLength",
      value: function clampLength(min, max) {
        var length = this.length();
        return this.divideScalar(length || 1).multiplyScalar(_clamp(length, min, max));
      }
    }, {
      key: "floor",
      value: function floor() {
        this.x = Math.floor(this.x);
        this.y = Math.floor(this.y);
        this.z = Math.floor(this.z);
        return this;
      }
    }, {
      key: "ceil",
      value: function ceil() {
        this.x = Math.ceil(this.x);
        this.y = Math.ceil(this.y);
        this.z = Math.ceil(this.z);
        return this;
      }
    }, {
      key: "round",
      value: function round() {
        this.x = Math.round(this.x);
        this.y = Math.round(this.y);
        this.z = Math.round(this.z);
        return this;
      }
    }, {
      key: "roundToZero",
      value: function roundToZero() {
        this.x = Math.trunc(this.x);
        this.y = Math.trunc(this.y);
        this.z = Math.trunc(this.z);
        return this;
      }
    }, {
      key: "negate",
      value: function negate() {
        this.x = -this.x;
        this.y = -this.y;
        this.z = -this.z;
        return this;
      }
    }, {
      key: "dot",
      value: function dot(v) {
        return this.x * v.x + this.y * v.y + this.z * v.z;
      }

      // TODO lengthSquared?
    }, {
      key: "lengthSq",
      value: function lengthSq() {
        return this.x * this.x + this.y * this.y + this.z * this.z;
      }
    }, {
      key: "length",
      value: function length() {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
      }
    }, {
      key: "manhattanLength",
      value: function manhattanLength() {
        return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
      }
    }, {
      key: "normalize",
      value: function normalize() {
        return this.divideScalar(this.length() || 1);
      }
    }, {
      key: "setLength",
      value: function setLength(length) {
        return this.normalize().multiplyScalar(length);
      }
    }, {
      key: "lerp",
      value: function lerp(v, alpha) {
        this.x += (v.x - this.x) * alpha;
        this.y += (v.y - this.y) * alpha;
        this.z += (v.z - this.z) * alpha;
        return this;
      }
    }, {
      key: "lerpVectors",
      value: function lerpVectors(v1, v2, alpha) {
        this.x = v1.x + (v2.x - v1.x) * alpha;
        this.y = v1.y + (v2.y - v1.y) * alpha;
        this.z = v1.z + (v2.z - v1.z) * alpha;
        return this;
      }
    }, {
      key: "cross",
      value: function cross(v) {
        return this.crossVectors(this, v);
      }
    }, {
      key: "crossVectors",
      value: function crossVectors(a, b) {
        var ax = a.x,
          ay = a.y,
          az = a.z;
        var bx = b.x,
          by = b.y,
          bz = b.z;
        this.x = ay * bz - az * by;
        this.y = az * bx - ax * bz;
        this.z = ax * by - ay * bx;
        return this;
      }
    }, {
      key: "projectOnVector",
      value: function projectOnVector(v) {
        var denominator = v.lengthSq();
        if (denominator === 0) return this.set(0, 0, 0);
        var scalar = v.dot(this) / denominator;
        return this.copy(v).multiplyScalar(scalar);
      }
    }, {
      key: "projectOnPlane",
      value: function projectOnPlane(planeNormal) {
        _vector$c.copy(this).projectOnVector(planeNormal);
        return this.sub(_vector$c);
      }
    }, {
      key: "reflect",
      value: function reflect(normal) {
        // reflect incident vector off plane orthogonal to normal
        // normal is assumed to have unit length

        return this.sub(_vector$c.copy(normal).multiplyScalar(2 * this.dot(normal)));
      }
    }, {
      key: "angleTo",
      value: function angleTo(v) {
        var denominator = Math.sqrt(this.lengthSq() * v.lengthSq());
        if (denominator === 0) return Math.PI / 2;
        var theta = this.dot(v) / denominator;

        // clamp, to handle numerical problems

        return Math.acos(_clamp(theta, -1, 1));
      }
    }, {
      key: "distanceTo",
      value: function distanceTo(v) {
        return Math.sqrt(this.distanceToSquared(v));
      }
    }, {
      key: "distanceToSquared",
      value: function distanceToSquared(v) {
        var dx = this.x - v.x,
          dy = this.y - v.y,
          dz = this.z - v.z;
        return dx * dx + dy * dy + dz * dz;
      }
    }, {
      key: "manhattanDistanceTo",
      value: function manhattanDistanceTo(v) {
        return Math.abs(this.x - v.x) + Math.abs(this.y - v.y) + Math.abs(this.z - v.z);
      }
    }, {
      key: "setFromSpherical",
      value: function setFromSpherical(s) {
        return this.setFromSphericalCoords(s.radius, s.phi, s.theta);
      }
    }, {
      key: "setFromSphericalCoords",
      value: function setFromSphericalCoords(radius, phi, theta) {
        var sinPhiRadius = Math.sin(phi) * radius;
        this.x = sinPhiRadius * Math.sin(theta);
        this.y = Math.cos(phi) * radius;
        this.z = sinPhiRadius * Math.cos(theta);
        return this;
      }
    }, {
      key: "setFromCylindrical",
      value: function setFromCylindrical(c) {
        return this.setFromCylindricalCoords(c.radius, c.theta, c.y);
      }
    }, {
      key: "setFromCylindricalCoords",
      value: function setFromCylindricalCoords(radius, theta, y) {
        this.x = radius * Math.sin(theta);
        this.y = y;
        this.z = radius * Math.cos(theta);
        return this;
      }
    }, {
      key: "setFromMatrixPosition",
      value: function setFromMatrixPosition(m) {
        var e = m.elements;
        this.x = e[12];
        this.y = e[13];
        this.z = e[14];
        return this;
      }
    }, {
      key: "setFromMatrixScale",
      value: function setFromMatrixScale(m) {
        var sx = this.setFromMatrixColumn(m, 0).length();
        var sy = this.setFromMatrixColumn(m, 1).length();
        var sz = this.setFromMatrixColumn(m, 2).length();
        this.x = sx;
        this.y = sy;
        this.z = sz;
        return this;
      }
    }, {
      key: "setFromMatrixColumn",
      value: function setFromMatrixColumn(m, index) {
        return this.fromArray(m.elements, index * 4);
      }
    }, {
      key: "setFromMatrix3Column",
      value: function setFromMatrix3Column(m, index) {
        return this.fromArray(m.elements, index * 3);
      }
    }, {
      key: "setFromEuler",
      value: function setFromEuler(e) {
        this.x = e._x;
        this.y = e._y;
        this.z = e._z;
        return this;
      }
    }, {
      key: "setFromColor",
      value: function setFromColor(c) {
        this.x = c.r;
        this.y = c.g;
        this.z = c.b;
        return this;
      }
    }, {
      key: "equals",
      value: function equals(v) {
        return v.x === this.x && v.y === this.y && v.z === this.z;
      }
    }, {
      key: "fromArray",
      value: function fromArray(array) {
        var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        this.x = array[offset];
        this.y = array[offset + 1];
        this.z = array[offset + 2];
        return this;
      }
    }, {
      key: "toArray",
      value: function toArray() {
        var array = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
        var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        array[offset] = this.x;
        array[offset + 1] = this.y;
        array[offset + 2] = this.z;
        return array;
      }
    }, {
      key: "fromBufferAttribute",
      value: function fromBufferAttribute(attribute, index) {
        this.x = attribute.getX(index);
        this.y = attribute.getY(index);
        this.z = attribute.getZ(index);
        return this;
      }
    }, {
      key: "random",
      value: function random() {
        this.x = Math.random();
        this.y = Math.random();
        this.z = Math.random();
        return this;
      }
    }, {
      key: "randomDirection",
      value: function randomDirection() {
        // https://mathworld.wolfram.com/SpherePointPicking.html

        var theta = Math.random() * Math.PI * 2;
        var u = Math.random() * 2 - 1;
        var c = Math.sqrt(1 - u * u);
        this.x = c * Math.cos(theta);
        this.y = u;
        this.z = c * Math.sin(theta);
        return this;
      }
    }, {
      key: Symbol.iterator,
      value: function* value() {
        yield this.x;
        yield this.y;
        yield this.z;
      }
    }]);
  }();
  var _vector$c = /*@__PURE__*/new Vector3();
  var _quaternion$4 = /*@__PURE__*/new Quaternion();
  var Box3 = exports.Box3 = /*#__PURE__*/function () {
    function Box3() {
      var min = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Vector3(+Infinity, +Infinity, +Infinity);
      var max = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Vector3(-Infinity, -Infinity, -Infinity);
      (0, _classCallCheck2.default)(this, Box3);
      this.isBox3 = true;
      this.min = min;
      this.max = max;
    }
    return (0, _createClass2.default)(Box3, [{
      key: "set",
      value: function set(min, max) {
        this.min.copy(min);
        this.max.copy(max);
        return this;
      }
    }, {
      key: "setFromArray",
      value: function setFromArray(array) {
        this.makeEmpty();
        for (var i = 0, il = array.length; i < il; i += 3) {
          this.expandByPoint(_vector$b.fromArray(array, i));
        }
        return this;
      }
    }, {
      key: "setFromBufferAttribute",
      value: function setFromBufferAttribute(attribute) {
        this.makeEmpty();
        for (var i = 0, il = attribute.count; i < il; i++) {
          this.expandByPoint(_vector$b.fromBufferAttribute(attribute, i));
        }
        return this;
      }
    }, {
      key: "setFromPoints",
      value: function setFromPoints(points) {
        this.makeEmpty();
        for (var i = 0, il = points.length; i < il; i++) {
          this.expandByPoint(points[i]);
        }
        return this;
      }
    }, {
      key: "setFromCenterAndSize",
      value: function setFromCenterAndSize(center, size) {
        var halfSize = _vector$b.copy(size).multiplyScalar(0.5);
        this.min.copy(center).sub(halfSize);
        this.max.copy(center).add(halfSize);
        return this;
      }
    }, {
      key: "setFromObject",
      value: function setFromObject(object) {
        var precise = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
        this.makeEmpty();
        return this.expandByObject(object, precise);
      }
    }, {
      key: "clone",
      value: function clone() {
        return new this.constructor().copy(this);
      }
    }, {
      key: "copy",
      value: function copy(box) {
        this.min.copy(box.min);
        this.max.copy(box.max);
        return this;
      }
    }, {
      key: "makeEmpty",
      value: function makeEmpty() {
        this.min.x = this.min.y = this.min.z = +Infinity;
        this.max.x = this.max.y = this.max.z = -Infinity;
        return this;
      }
    }, {
      key: "isEmpty",
      value: function isEmpty() {
        // this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes

        return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z;
      }
    }, {
      key: "getCenter",
      value: function getCenter(target) {
        return this.isEmpty() ? target.set(0, 0, 0) : target.addVectors(this.min, this.max).multiplyScalar(0.5);
      }
    }, {
      key: "getSize",
      value: function getSize(target) {
        return this.isEmpty() ? target.set(0, 0, 0) : target.subVectors(this.max, this.min);
      }
    }, {
      key: "expandByPoint",
      value: function expandByPoint(point) {
        this.min.min(point);
        this.max.max(point);
        return this;
      }
    }, {
      key: "expandByVector",
      value: function expandByVector(vector) {
        this.min.sub(vector);
        this.max.add(vector);
        return this;
      }
    }, {
      key: "expandByScalar",
      value: function expandByScalar(scalar) {
        this.min.addScalar(-scalar);
        this.max.addScalar(scalar);
        return this;
      }
    }, {
      key: "expandByObject",
      value: function expandByObject(object) {
        var precise = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
        // Computes the world-axis-aligned bounding box of an object (including its children),
        // accounting for both the object's, and children's, world transforms

        object.updateWorldMatrix(false, false);
        var geometry = object.geometry;
        if (geometry !== undefined) {
          var positionAttribute = geometry.getAttribute('position');

          // precise AABB computation based on vertex data requires at least a position attribute.
          // instancing isn't supported so far and uses the normal (conservative) code path.

          if (precise === true && positionAttribute !== undefined && object.isInstancedMesh !== true) {
            for (var i = 0, l = positionAttribute.count; i < l; i++) {
              if (object.isMesh === true) {
                object.getVertexPosition(i, _vector$b);
              } else {
                _vector$b.fromBufferAttribute(positionAttribute, i);
              }
              _vector$b.applyMatrix4(object.matrixWorld);
              this.expandByPoint(_vector$b);
            }
          } else {
            if (object.boundingBox !== undefined) {
              // object-level bounding box

              if (object.boundingBox === null) {
                object.computeBoundingBox();
              }
              _box$4.copy(object.boundingBox);
            } else {
              // geometry-level bounding box

              if (geometry.boundingBox === null) {
                geometry.computeBoundingBox();
              }
              _box$4.copy(geometry.boundingBox);
            }
            _box$4.applyMatrix4(object.matrixWorld);
            this.union(_box$4);
          }
        }
        var children = object.children;
        for (var _i2 = 0, _l = children.length; _i2 < _l; _i2++) {
          this.expandByObject(children[_i2], precise);
        }
        return this;
      }
    }, {
      key: "containsPoint",
      value: function containsPoint(point) {
        return point.x >= this.min.x && point.x <= this.max.x && point.y >= this.min.y && point.y <= this.max.y && point.z >= this.min.z && point.z <= this.max.z;
      }
    }, {
      key: "containsBox",
      value: function containsBox(box) {
        return this.min.x <= box.min.x && box.max.x <= this.max.x && this.min.y <= box.min.y && box.max.y <= this.max.y && this.min.z <= box.min.z && box.max.z <= this.max.z;
      }
    }, {
      key: "getParameter",
      value: function getParameter(point, target) {
        // This can potentially have a divide by zero if the box
        // has a size dimension of 0.

        return target.set((point.x - this.min.x) / (this.max.x - this.min.x), (point.y - this.min.y) / (this.max.y - this.min.y), (point.z - this.min.z) / (this.max.z - this.min.z));
      }
    }, {
      key: "intersectsBox",
      value: function intersectsBox(box) {
        // using 6 splitting planes to rule out intersections.
        return box.max.x >= this.min.x && box.min.x <= this.max.x && box.max.y >= this.min.y && box.min.y <= this.max.y && box.max.z >= this.min.z && box.min.z <= this.max.z;
      }
    }, {
      key: "intersectsSphere",
      value: function intersectsSphere(sphere) {
        // Find the point on the AABB closest to the sphere center.
        this.clampPoint(sphere.center, _vector$b);

        // If that point is inside the sphere, the AABB and sphere intersect.
        return _vector$b.distanceToSquared(sphere.center) <= sphere.radius * sphere.radius;
      }
    }, {
      key: "intersectsPlane",
      value: function intersectsPlane(plane) {
        // We compute the minimum and maximum dot product values. If those values
        // are on the same side (back or front) of the plane, then there is no intersection.

        var min, max;
        if (plane.normal.x > 0) {
          min = plane.normal.x * this.min.x;
          max = plane.normal.x * this.max.x;
        } else {
          min = plane.normal.x * this.max.x;
          max = plane.normal.x * this.min.x;
        }
        if (plane.normal.y > 0) {
          min += plane.normal.y * this.min.y;
          max += plane.normal.y * this.max.y;
        } else {
          min += plane.normal.y * this.max.y;
          max += plane.normal.y * this.min.y;
        }
        if (plane.normal.z > 0) {
          min += plane.normal.z * this.min.z;
          max += plane.normal.z * this.max.z;
        } else {
          min += plane.normal.z * this.max.z;
          max += plane.normal.z * this.min.z;
        }
        return min <= -plane.constant && max >= -plane.constant;
      }
    }, {
      key: "intersectsTriangle",
      value: function intersectsTriangle(triangle) {
        if (this.isEmpty()) {
          return false;
        }

        // compute box center and extents
        this.getCenter(_center);
        _extents.subVectors(this.max, _center);

        // translate triangle to aabb origin
        _v0$2.subVectors(triangle.a, _center);
        _v1$7.subVectors(triangle.b, _center);
        _v2$4.subVectors(triangle.c, _center);

        // compute edge vectors for triangle
        _f0.subVectors(_v1$7, _v0$2);
        _f1.subVectors(_v2$4, _v1$7);
        _f2.subVectors(_v0$2, _v2$4);

        // test against axes that are given by cross product combinations of the edges of the triangle and the edges of the aabb
        // make an axis testing of each of the 3 sides of the aabb against each of the 3 sides of the triangle = 9 axis of separation
        // axis_ij = u_i x f_j (u0, u1, u2 = face normals of aabb = x,y,z axes vectors since aabb is axis aligned)
        var axes = [0, -_f0.z, _f0.y, 0, -_f1.z, _f1.y, 0, -_f2.z, _f2.y, _f0.z, 0, -_f0.x, _f1.z, 0, -_f1.x, _f2.z, 0, -_f2.x, -_f0.y, _f0.x, 0, -_f1.y, _f1.x, 0, -_f2.y, _f2.x, 0];
        if (!satForAxes(axes, _v0$2, _v1$7, _v2$4, _extents)) {
          return false;
        }

        // test 3 face normals from the aabb
        axes = [1, 0, 0, 0, 1, 0, 0, 0, 1];
        if (!satForAxes(axes, _v0$2, _v1$7, _v2$4, _extents)) {
          return false;
        }

        // finally testing the face normal of the triangle
        // use already existing triangle edge vectors here
        _triangleNormal.crossVectors(_f0, _f1);
        axes = [_triangleNormal.x, _triangleNormal.y, _triangleNormal.z];
        return satForAxes(axes, _v0$2, _v1$7, _v2$4, _extents);
      }
    }, {
      key: "clampPoint",
      value: function clampPoint(point, target) {
        return target.copy(point).clamp(this.min, this.max);
      }
    }, {
      key: "distanceToPoint",
      value: function distanceToPoint(point) {
        return this.clampPoint(point, _vector$b).distanceTo(point);
      }
    }, {
      key: "getBoundingSphere",
      value: function getBoundingSphere(target) {
        if (this.isEmpty()) {
          target.makeEmpty();
        } else {
          this.getCenter(target.center);
          target.radius = this.getSize(_vector$b).length() * 0.5;
        }
        return target;
      }
    }, {
      key: "intersect",
      value: function intersect(box) {
        this.min.max(box.min);
        this.max.min(box.max);

        // ensure that if there is no overlap, the result is fully empty, not slightly empty with non-inf/+inf values that will cause subsequence intersects to erroneously return valid values.
        if (this.isEmpty()) this.makeEmpty();
        return this;
      }
    }, {
      key: "union",
      value: function union(box) {
        this.min.min(box.min);
        this.max.max(box.max);
        return this;
      }
    }, {
      key: "applyMatrix4",
      value: function applyMatrix4(matrix) {
        // transform of empty box is an empty box.
        if (this.isEmpty()) return this;

        // NOTE: I am using a binary pattern to specify all 2^3 combinations below
        _points[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(matrix); // 000
        _points[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(matrix); // 001
        _points[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(matrix); // 010
        _points[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(matrix); // 011
        _points[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(matrix); // 100
        _points[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(matrix); // 101
        _points[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(matrix); // 110
        _points[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(matrix); // 111

        this.setFromPoints(_points);
        return this;
      }
    }, {
      key: "translate",
      value: function translate(offset) {
        this.min.add(offset);
        this.max.add(offset);
        return this;
      }
    }, {
      key: "equals",
      value: function equals(box) {
        return box.min.equals(this.min) && box.max.equals(this.max);
      }
    }]);
  }();
  var _points = [/*@__PURE__*/new Vector3(), /*@__PURE__*/new Vector3(), /*@__PURE__*/new Vector3(), /*@__PURE__*/new Vector3(), /*@__PURE__*/new Vector3(), /*@__PURE__*/new Vector3(), /*@__PURE__*/new Vector3(), /*@__PURE__*/new Vector3()];
  var _vector$b = /*@__PURE__*/new Vector3();
  var _box$4 = /*@__PURE__*/new Box3();

  // triangle centered vertices

  var _v0$2 = /*@__PURE__*/new Vector3();
  var _v1$7 = /*@__PURE__*/new Vector3();
  var _v2$4 = /*@__PURE__*/new Vector3();

  // triangle edge vectors

  var _f0 = /*@__PURE__*/new Vector3();
  var _f1 = /*@__PURE__*/new Vector3();
  var _f2 = /*@__PURE__*/new Vector3();
  var _center = /*@__PURE__*/new Vector3();
  var _extents = /*@__PURE__*/new Vector3();
  var _triangleNormal = /*@__PURE__*/new Vector3();
  var _testAxis = /*@__PURE__*/new Vector3();
  function satForAxes(axes, v0, v1, v2, extents) {
    for (var i = 0, j = axes.length - 3; i <= j; i += 3) {
      _testAxis.fromArray(axes, i);
      // project the aabb onto the separating axis
      var r = extents.x * Math.abs(_testAxis.x) + extents.y * Math.abs(_testAxis.y) + extents.z * Math.abs(_testAxis.z);
      // project all 3 vertices of the triangle onto the separating axis
      var p0 = v0.dot(_testAxis);
      var p1 = v1.dot(_testAxis);
      var p2 = v2.dot(_testAxis);
      // actual test, basically see if either of the most extreme of the triangle points intersects r
      if (Math.max(-Math.max(p0, p1, p2), Math.min(p0, p1, p2)) > r) {
        // points of the projected triangle are outside the projected half-length of the aabb
        // the axis is separating and we can exit
        return false;
      }
    }
    return true;
  }
  var _box$3 = /*@__PURE__*/new Box3();
  var _v1$6 = /*@__PURE__*/new Vector3();
  var _v2$3 = /*@__PURE__*/new Vector3();
  var Sphere = exports.Sphere = /*#__PURE__*/function () {
    function Sphere() {
      var center = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Vector3();
      var radius = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : -1;
      (0, _classCallCheck2.default)(this, Sphere);
      this.isSphere = true;
      this.center = center;
      this.radius = radius;
    }
    return (0, _createClass2.default)(Sphere, [{
      key: "set",
      value: function set(center, radius) {
        this.center.copy(center);
        this.radius = radius;
        return this;
      }
    }, {
      key: "setFromPoints",
      value: function setFromPoints(points, optionalCenter) {
        var center = this.center;
        if (optionalCenter !== undefined) {
          center.copy(optionalCenter);
        } else {
          _box$3.setFromPoints(points).getCenter(center);
        }
        var maxRadiusSq = 0;
        for (var i = 0, il = points.length; i < il; i++) {
          maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(points[i]));
        }
        this.radius = Math.sqrt(maxRadiusSq);
        return this;
      }
    }, {
      key: "copy",
      value: function copy(sphere) {
        this.center.copy(sphere.center);
        this.radius = sphere.radius;
        return this;
      }
    }, {
      key: "isEmpty",
      value: function isEmpty() {
        return this.radius < 0;
      }
    }, {
      key: "makeEmpty",
      value: function makeEmpty() {
        this.center.set(0, 0, 0);
        this.radius = -1;
        return this;
      }
    }, {
      key: "containsPoint",
      value: function containsPoint(point) {
        return point.distanceToSquared(this.center) <= this.radius * this.radius;
      }
    }, {
      key: "distanceToPoint",
      value: function distanceToPoint(point) {
        return point.distanceTo(this.center) - this.radius;
      }
    }, {
      key: "intersectsSphere",
      value: function intersectsSphere(sphere) {
        var radiusSum = this.radius + sphere.radius;
        return sphere.center.distanceToSquared(this.center) <= radiusSum * radiusSum;
      }
    }, {
      key: "intersectsBox",
      value: function intersectsBox(box) {
        return box.intersectsSphere(this);
      }
    }, {
      key: "intersectsPlane",
      value: function intersectsPlane(plane) {
        return Math.abs(plane.distanceToPoint(this.center)) <= this.radius;
      }
    }, {
      key: "clampPoint",
      value: function clampPoint(point, target) {
        var deltaLengthSq = this.center.distanceToSquared(point);
        target.copy(point);
        if (deltaLengthSq > this.radius * this.radius) {
          target.sub(this.center).normalize();
          target.multiplyScalar(this.radius).add(this.center);
        }
        return target;
      }
    }, {
      key: "getBoundingBox",
      value: function getBoundingBox(target) {
        if (this.isEmpty()) {
          // Empty sphere produces empty bounding box
          target.makeEmpty();
          return target;
        }
        target.set(this.center, this.center);
        target.expandByScalar(this.radius);
        return target;
      }
    }, {
      key: "applyMatrix4",
      value: function applyMatrix4(matrix) {
        this.center.applyMatrix4(matrix);
        this.radius = this.radius * matrix.getMaxScaleOnAxis();
        return this;
      }
    }, {
      key: "translate",
      value: function translate(offset) {
        this.center.add(offset);
        return this;
      }
    }, {
      key: "expandByPoint",
      value: function expandByPoint(point) {
        if (this.isEmpty()) {
          this.center.copy(point);
          this.radius = 0;
          return this;
        }
        _v1$6.subVectors(point, this.center);
        var lengthSq = _v1$6.lengthSq();
        if (lengthSq > this.radius * this.radius) {
          // calculate the minimal sphere

          var length = Math.sqrt(lengthSq);
          var delta = (length - this.radius) * 0.5;
          this.center.addScaledVector(_v1$6, delta / length);
          this.radius += delta;
        }
        return this;
      }
    }, {
      key: "union",
      value: function union(sphere) {
        if (sphere.isEmpty()) {
          return this;
        }
        if (this.isEmpty()) {
          this.copy(sphere);
          return this;
        }
        if (this.center.equals(sphere.center) === true) {
          this.radius = Math.max(this.radius, sphere.radius);
        } else {
          _v2$3.subVectors(sphere.center, this.center).setLength(sphere.radius);
          this.expandByPoint(_v1$6.copy(sphere.center).add(_v2$3));
          this.expandByPoint(_v1$6.copy(sphere.center).sub(_v2$3));
        }
        return this;
      }
    }, {
      key: "equals",
      value: function equals(sphere) {
        return sphere.center.equals(this.center) && sphere.radius === this.radius;
      }
    }, {
      key: "clone",
      value: function clone() {
        return new this.constructor().copy(this);
      }
    }]);
  }();
  var _vector$a = /*@__PURE__*/new Vector3();
  var _segCenter = /*@__PURE__*/new Vector3();
  var _segDir = /*@__PURE__*/new Vector3();
  var _diff = /*@__PURE__*/new Vector3();
  var _edge1 = /*@__PURE__*/new Vector3();
  var _edge2 = /*@__PURE__*/new Vector3();
  var _normal$1 = /*@__PURE__*/new Vector3();
  var Ray = exports.Ray = /*#__PURE__*/function () {
    function Ray() {
      var origin = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Vector3();
      var direction = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Vector3(0, 0, -1);
      (0, _classCallCheck2.default)(this, Ray);
      this.origin = origin;
      this.direction = direction;
    }
    return (0, _createClass2.default)(Ray, [{
      key: "set",
      value: function set(origin, direction) {
        this.origin.copy(origin);
        this.direction.copy(direction);
        return this;
      }
    }, {
      key: "copy",
      value: function copy(ray) {
        this.origin.copy(ray.origin);
        this.direction.copy(ray.direction);
        return this;
      }
    }, {
      key: "at",
      value: function at(t, target) {
        return target.copy(this.origin).addScaledVector(this.direction, t);
      }
    }, {
      key: "lookAt",
      value: function lookAt(v) {
        this.direction.copy(v).sub(this.origin).normalize();
        return this;
      }
    }, {
      key: "recast",
      value: function recast(t) {
        this.origin.copy(this.at(t, _vector$a));
        return this;
      }
    }, {
      key: "closestPointToPoint",
      value: function closestPointToPoint(point, target) {
        target.subVectors(point, this.origin);
        var directionDistance = target.dot(this.direction);
        if (directionDistance < 0) {
          return target.copy(this.origin);
        }
        return target.copy(this.origin).addScaledVector(this.direction, directionDistance);
      }
    }, {
      key: "distanceToPoint",
      value: function distanceToPoint(point) {
        return Math.sqrt(this.distanceSqToPoint(point));
      }
    }, {
      key: "distanceSqToPoint",
      value: function distanceSqToPoint(point) {
        var directionDistance = _vector$a.subVectors(point, this.origin).dot(this.direction);

        // point behind the ray

        if (directionDistance < 0) {
          return this.origin.distanceToSquared(point);
        }
        _vector$a.copy(this.origin).addScaledVector(this.direction, directionDistance);
        return _vector$a.distanceToSquared(point);
      }
    }, {
      key: "distanceSqToSegment",
      value: function distanceSqToSegment(v0, v1, optionalPointOnRay, optionalPointOnSegment) {
        // from https://github.com/pmjoniak/GeometricTools/blob/master/GTEngine/Include/Mathematics/GteDistRaySegment.h
        // It returns the min distance between the ray and the segment
        // defined by v0 and v1
        // It can also set two optional targets :
        // - The closest point on the ray
        // - The closest point on the segment

        _segCenter.copy(v0).add(v1).multiplyScalar(0.5);
        _segDir.copy(v1).sub(v0).normalize();
        _diff.copy(this.origin).sub(_segCenter);
        var segExtent = v0.distanceTo(v1) * 0.5;
        var a01 = -this.direction.dot(_segDir);
        var b0 = _diff.dot(this.direction);
        var b1 = -_diff.dot(_segDir);
        var c = _diff.lengthSq();
        var det = Math.abs(1 - a01 * a01);
        var s0, s1, sqrDist, extDet;
        if (det > 0) {
          // The ray and segment are not parallel.

          s0 = a01 * b1 - b0;
          s1 = a01 * b0 - b1;
          extDet = segExtent * det;
          if (s0 >= 0) {
            if (s1 >= -extDet) {
              if (s1 <= extDet) {
                // region 0
                // Minimum at interior points of ray and segment.

                var invDet = 1 / det;
                s0 *= invDet;
                s1 *= invDet;
                sqrDist = s0 * (s0 + a01 * s1 + 2 * b0) + s1 * (a01 * s0 + s1 + 2 * b1) + c;
              } else {
                // region 1

                s1 = segExtent;
                s0 = Math.max(0, -(a01 * s1 + b0));
                sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
              }
            } else {
              // region 5

              s1 = -segExtent;
              s0 = Math.max(0, -(a01 * s1 + b0));
              sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
            }
          } else {
            if (s1 <= -extDet) {
              // region 4

              s0 = Math.max(0, -(-a01 * segExtent + b0));
              s1 = s0 > 0 ? -segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);
              sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
            } else if (s1 <= extDet) {
              // region 3

              s0 = 0;
              s1 = Math.min(Math.max(-segExtent, -b1), segExtent);
              sqrDist = s1 * (s1 + 2 * b1) + c;
            } else {
              // region 2

              s0 = Math.max(0, -(a01 * segExtent + b0));
              s1 = s0 > 0 ? segExtent : Math.min(Math.max(-segExtent, -b1), segExtent);
              sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
            }
          }
        } else {
          // Ray and segment are parallel.

          s1 = a01 > 0 ? -segExtent : segExtent;
          s0 = Math.max(0, -(a01 * s1 + b0));
          sqrDist = -s0 * s0 + s1 * (s1 + 2 * b1) + c;
        }
        if (optionalPointOnRay) {
          optionalPointOnRay.copy(this.origin).addScaledVector(this.direction, s0);
        }
        if (optionalPointOnSegment) {
          optionalPointOnSegment.copy(_segCenter).addScaledVector(_segDir, s1);
        }
        return sqrDist;
      }
    }, {
      key: "intersectSphere",
      value: function intersectSphere(sphere, target) {
        _vector$a.subVectors(sphere.center, this.origin);
        var tca = _vector$a.dot(this.direction);
        var d2 = _vector$a.dot(_vector$a) - tca * tca;
        var radius2 = sphere.radius * sphere.radius;
        if (d2 > radius2) return null;
        var thc = Math.sqrt(radius2 - d2);

        // t0 = first intersect point - entrance on front of sphere
        var t0 = tca - thc;

        // t1 = second intersect point - exit point on back of sphere
        var t1 = tca + thc;

        // test to see if t1 is behind the ray - if so, return null
        if (t1 < 0) return null;

        // test to see if t0 is behind the ray:
        // if it is, the ray is inside the sphere, so return the second exit point scaled by t1,
        // in order to always return an intersect point that is in front of the ray.
        if (t0 < 0) return this.at(t1, target);

        // else t0 is in front of the ray, so return the first collision point scaled by t0
        return this.at(t0, target);
      }
    }, {
      key: "intersectsSphere",
      value: function intersectsSphere(sphere) {
        return this.distanceSqToPoint(sphere.center) <= sphere.radius * sphere.radius;
      }
    }, {
      key: "distanceToPlane",
      value: function distanceToPlane(plane) {
        var denominator = plane.normal.dot(this.direction);
        if (denominator === 0) {
          // line is coplanar, return origin
          if (plane.distanceToPoint(this.origin) === 0) {
            return 0;
          }

          // Null is preferable to undefined since undefined means.... it is undefined

          return null;
        }
        var t = -(this.origin.dot(plane.normal) + plane.constant) / denominator;

        // Return if the ray never intersects the plane

        return t >= 0 ? t : null;
      }
    }, {
      key: "intersectPlane",
      value: function intersectPlane(plane, target) {
        var t = this.distanceToPlane(plane);
        if (t === null) {
          return null;
        }
        return this.at(t, target);
      }
    }, {
      key: "intersectsPlane",
      value: function intersectsPlane(plane) {
        // check if the ray lies on the plane first

        var distToPoint = plane.distanceToPoint(this.origin);
        if (distToPoint === 0) {
          return true;
        }
        var denominator = plane.normal.dot(this.direction);
        if (denominator * distToPoint < 0) {
          return true;
        }

        // ray origin is behind the plane (and is pointing behind it)

        return false;
      }
    }, {
      key: "intersectBox",
      value: function intersectBox(box, target) {
        var tmin, tmax, tymin, tymax, tzmin, tzmax;
        var invdirx = 1 / this.direction.x,
          invdiry = 1 / this.direction.y,
          invdirz = 1 / this.direction.z;
        var origin = this.origin;
        if (invdirx >= 0) {
          tmin = (box.min.x - origin.x) * invdirx;
          tmax = (box.max.x - origin.x) * invdirx;
        } else {
          tmin = (box.max.x - origin.x) * invdirx;
          tmax = (box.min.x - origin.x) * invdirx;
        }
        if (invdiry >= 0) {
          tymin = (box.min.y - origin.y) * invdiry;
          tymax = (box.max.y - origin.y) * invdiry;
        } else {
          tymin = (box.max.y - origin.y) * invdiry;
          tymax = (box.min.y - origin.y) * invdiry;
        }
        if (tmin > tymax || tymin > tmax) return null;
        if (tymin > tmin || isNaN(tmin)) tmin = tymin;
        if (tymax < tmax || isNaN(tmax)) tmax = tymax;
        if (invdirz >= 0) {
          tzmin = (box.min.z - origin.z) * invdirz;
          tzmax = (box.max.z - origin.z) * invdirz;
        } else {
          tzmin = (box.max.z - origin.z) * invdirz;
          tzmax = (box.min.z - origin.z) * invdirz;
        }
        if (tmin > tzmax || tzmin > tmax) return null;
        if (tzmin > tmin || tmin !== tmin) tmin = tzmin;
        if (tzmax < tmax || tmax !== tmax) tmax = tzmax;

        //return point closest to the ray (positive side)

        if (tmax < 0) return null;
        return this.at(tmin >= 0 ? tmin : tmax, target);
      }
    }, {
      key: "intersectsBox",
      value: function intersectsBox(box) {
        return this.intersectBox(box, _vector$a) !== null;
      }
    }, {
      key: "intersectTriangle",
      value: function intersectTriangle(a, b, c, backfaceCulling, target) {
        // Compute the offset origin, edges, and normal.

        // from https://github.com/pmjoniak/GeometricTools/blob/master/GTEngine/Include/Mathematics/GteIntrRay3Triangle3.h

        _edge1.subVectors(b, a);
        _edge2.subVectors(c, a);
        _normal$1.crossVectors(_edge1, _edge2);

        // Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,
        // E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by
        //   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))
        //   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))
        //   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)
        var DdN = this.direction.dot(_normal$1);
        var sign;
        if (DdN > 0) {
          if (backfaceCulling) return null;
          sign = 1;
        } else if (DdN < 0) {
          sign = -1;
          DdN = -DdN;
        } else {
          return null;
        }
        _diff.subVectors(this.origin, a);
        var DdQxE2 = sign * this.direction.dot(_edge2.crossVectors(_diff, _edge2));

        // b1 < 0, no intersection
        if (DdQxE2 < 0) {
          return null;
        }
        var DdE1xQ = sign * this.direction.dot(_edge1.cross(_diff));

        // b2 < 0, no intersection
        if (DdE1xQ < 0) {
          return null;
        }

        // b1+b2 > 1, no intersection
        if (DdQxE2 + DdE1xQ > DdN) {
          return null;
        }

        // Line intersects triangle, check if ray does.
        var QdN = -sign * _diff.dot(_normal$1);

        // t < 0, no intersection
        if (QdN < 0) {
          return null;
        }

        // Ray intersects triangle.
        return this.at(QdN / DdN, target);
      }
    }, {
      key: "applyMatrix4",
      value: function applyMatrix4(matrix4) {
        this.origin.applyMatrix4(matrix4);
        this.direction.transformDirection(matrix4);
        return this;
      }
    }, {
      key: "equals",
      value: function equals(ray) {
        return ray.origin.equals(this.origin) && ray.direction.equals(this.direction);
      }
    }, {
      key: "clone",
      value: function clone() {
        return new this.constructor().copy(this);
      }
    }]);
  }();
  var Matrix4 = exports.Matrix4 = /*#__PURE__*/function () {
    function Matrix4(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44) {
      (0, _classCallCheck2.default)(this, Matrix4);
      Matrix4.prototype.isMatrix4 = true;
      this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];
      if (n11 !== undefined) {
        this.set(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44);
      }
    }
    return (0, _createClass2.default)(Matrix4, [{
      key: "set",
      value: function set(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44) {
        var te = this.elements;
        te[0] = n11;
        te[4] = n12;
        te[8] = n13;
        te[12] = n14;
        te[1] = n21;
        te[5] = n22;
        te[9] = n23;
        te[13] = n24;
        te[2] = n31;
        te[6] = n32;
        te[10] = n33;
        te[14] = n34;
        te[3] = n41;
        te[7] = n42;
        te[11] = n43;
        te[15] = n44;
        return this;
      }
    }, {
      key: "identity",
      value: function identity() {
        this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
        return this;
      }
    }, {
      key: "clone",
      value: function clone() {
        return new Matrix4().fromArray(this.elements);
      }
    }, {
      key: "copy",
      value: function copy(m) {
        var te = this.elements;
        var me = m.elements;
        te[0] = me[0];
        te[1] = me[1];
        te[2] = me[2];
        te[3] = me[3];
        te[4] = me[4];
        te[5] = me[5];
        te[6] = me[6];
        te[7] = me[7];
        te[8] = me[8];
        te[9] = me[9];
        te[10] = me[10];
        te[11] = me[11];
        te[12] = me[12];
        te[13] = me[13];
        te[14] = me[14];
        te[15] = me[15];
        return this;
      }
    }, {
      key: "copyPosition",
      value: function copyPosition(m) {
        var te = this.elements,
          me = m.elements;
        te[12] = me[12];
        te[13] = me[13];
        te[14] = me[14];
        return this;
      }
    }, {
      key: "setFromMatrix3",
      value: function setFromMatrix3(m) {
        var me = m.elements;
        this.set(me[0], me[3], me[6], 0, me[1], me[4], me[7], 0, me[2], me[5], me[8], 0, 0, 0, 0, 1);
        return this;
      }
    }, {
      key: "extractBasis",
      value: function extractBasis(xAxis, yAxis, zAxis) {
        xAxis.setFromMatrixColumn(this, 0);
        yAxis.setFromMatrixColumn(this, 1);
        zAxis.setFromMatrixColumn(this, 2);
        return this;
      }
    }, {
      key: "makeBasis",
      value: function makeBasis(xAxis, yAxis, zAxis) {
        this.set(xAxis.x, yAxis.x, zAxis.x, 0, xAxis.y, yAxis.y, zAxis.y, 0, xAxis.z, yAxis.z, zAxis.z, 0, 0, 0, 0, 1);
        return this;
      }
    }, {
      key: "extractRotation",
      value: function extractRotation(m) {
        // this method does not support reflection matrices

        var te = this.elements;
        var me = m.elements;
        var scaleX = 1 / _v1$5.setFromMatrixColumn(m, 0).length();
        var scaleY = 1 / _v1$5.setFromMatrixColumn(m, 1).length();
        var scaleZ = 1 / _v1$5.setFromMatrixColumn(m, 2).length();
        te[0] = me[0] * scaleX;
        te[1] = me[1] * scaleX;
        te[2] = me[2] * scaleX;
        te[3] = 0;
        te[4] = me[4] * scaleY;
        te[5] = me[5] * scaleY;
        te[6] = me[6] * scaleY;
        te[7] = 0;
        te[8] = me[8] * scaleZ;
        te[9] = me[9] * scaleZ;
        te[10] = me[10] * scaleZ;
        te[11] = 0;
        te[12] = 0;
        te[13] = 0;
        te[14] = 0;
        te[15] = 1;
        return this;
      }
    }, {
      key: "makeRotationFromEuler",
      value: function makeRotationFromEuler(euler) {
        var te = this.elements;
        var x = euler.x,
          y = euler.y,
          z = euler.z;
        var a = Math.cos(x),
          b = Math.sin(x);
        var c = Math.cos(y),
          d = Math.sin(y);
        var e = Math.cos(z),
          f = Math.sin(z);
        if (euler.order === 'XYZ') {
          var ae = a * e,
            af = a * f,
            be = b * e,
            bf = b * f;
          te[0] = c * e;
          te[4] = -c * f;
          te[8] = d;
          te[1] = af + be * d;
          te[5] = ae - bf * d;
          te[9] = -b * c;
          te[2] = bf - ae * d;
          te[6] = be + af * d;
          te[10] = a * c;
        } else if (euler.order === 'YXZ') {
          var ce = c * e,
            cf = c * f,
            de = d * e,
            df = d * f;
          te[0] = ce + df * b;
          te[4] = de * b - cf;
          te[8] = a * d;
          te[1] = a * f;
          te[5] = a * e;
          te[9] = -b;
          te[2] = cf * b - de;
          te[6] = df + ce * b;
          te[10] = a * c;
        } else if (euler.order === 'ZXY') {
          var _ce = c * e,
            _cf = c * f,
            _de = d * e,
            _df = d * f;
          te[0] = _ce - _df * b;
          te[4] = -a * f;
          te[8] = _de + _cf * b;
          te[1] = _cf + _de * b;
          te[5] = a * e;
          te[9] = _df - _ce * b;
          te[2] = -a * d;
          te[6] = b;
          te[10] = a * c;
        } else if (euler.order === 'ZYX') {
          var _ae = a * e,
            _af = a * f,
            _be = b * e,
            _bf = b * f;
          te[0] = c * e;
          te[4] = _be * d - _af;
          te[8] = _ae * d + _bf;
          te[1] = c * f;
          te[5] = _bf * d + _ae;
          te[9] = _af * d - _be;
          te[2] = -d;
          te[6] = b * c;
          te[10] = a * c;
        } else if (euler.order === 'YZX') {
          var ac = a * c,
            ad = a * d,
            bc = b * c,
            bd = b * d;
          te[0] = c * e;
          te[4] = bd - ac * f;
          te[8] = bc * f + ad;
          te[1] = f;
          te[5] = a * e;
          te[9] = -b * e;
          te[2] = -d * e;
          te[6] = ad * f + bc;
          te[10] = ac - bd * f;
        } else if (euler.order === 'XZY') {
          var _ac = a * c,
            _ad = a * d,
            _bc = b * c,
            _bd = b * d;
          te[0] = c * e;
          te[4] = -f;
          te[8] = d * e;
          te[1] = _ac * f + _bd;
          te[5] = a * e;
          te[9] = _ad * f - _bc;
          te[2] = _bc * f - _ad;
          te[6] = b * e;
          te[10] = _bd * f + _ac;
        }

        // bottom row
        te[3] = 0;
        te[7] = 0;
        te[11] = 0;

        // last column
        te[12] = 0;
        te[13] = 0;
        te[14] = 0;
        te[15] = 1;
        return this;
      }
    }, {
      key: "makeRotationFromQuaternion",
      value: function makeRotationFromQuaternion(q) {
        return this.compose(_zero, q, _one);
      }
    }, {
      key: "lookAt",
      value: function lookAt(eye, target, up) {
        var te = this.elements;
        _z.subVectors(eye, target);
        if (_z.lengthSq() === 0) {
          // eye and target are in the same position

          _z.z = 1;
        }
        _z.normalize();
        _x.crossVectors(up, _z);
        if (_x.lengthSq() === 0) {
          // up and z are parallel

          if (Math.abs(up.z) === 1) {
            _z.x += 0.0001;
          } else {
            _z.z += 0.0001;
          }
          _z.normalize();
          _x.crossVectors(up, _z);
        }
        _x.normalize();
        _y.crossVectors(_z, _x);
        te[0] = _x.x;
        te[4] = _y.x;
        te[8] = _z.x;
        te[1] = _x.y;
        te[5] = _y.y;
        te[9] = _z.y;
        te[2] = _x.z;
        te[6] = _y.z;
        te[10] = _z.z;
        return this;
      }
    }, {
      key: "multiply",
      value: function multiply(m) {
        return this.multiplyMatrices(this, m);
      }
    }, {
      key: "premultiply",
      value: function premultiply(m) {
        return this.multiplyMatrices(m, this);
      }
    }, {
      key: "multiplyMatrices",
      value: function multiplyMatrices(a, b) {
        var ae = a.elements;
        var be = b.elements;
        var te = this.elements;
        var a11 = ae[0],
          a12 = ae[4],
          a13 = ae[8],
          a14 = ae[12];
        var a21 = ae[1],
          a22 = ae[5],
          a23 = ae[9],
          a24 = ae[13];
        var a31 = ae[2],
          a32 = ae[6],
          a33 = ae[10],
          a34 = ae[14];
        var a41 = ae[3],
          a42 = ae[7],
          a43 = ae[11],
          a44 = ae[15];
        var b11 = be[0],
          b12 = be[4],
          b13 = be[8],
          b14 = be[12];
        var b21 = be[1],
          b22 = be[5],
          b23 = be[9],
          b24 = be[13];
        var b31 = be[2],
          b32 = be[6],
          b33 = be[10],
          b34 = be[14];
        var b41 = be[3],
          b42 = be[7],
          b43 = be[11],
          b44 = be[15];
        te[0] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
        te[4] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
        te[8] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
        te[12] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;
        te[1] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
        te[5] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
        te[9] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
        te[13] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;
        te[2] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
        te[6] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
        te[10] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
        te[14] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;
        te[3] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
        te[7] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
        te[11] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
        te[15] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;
        return this;
      }
    }, {
      key: "multiplyScalar",
      value: function multiplyScalar(s) {
        var te = this.elements;
        te[0] *= s;
        te[4] *= s;
        te[8] *= s;
        te[12] *= s;
        te[1] *= s;
        te[5] *= s;
        te[9] *= s;
        te[13] *= s;
        te[2] *= s;
        te[6] *= s;
        te[10] *= s;
        te[14] *= s;
        te[3] *= s;
        te[7] *= s;
        te[11] *= s;
        te[15] *= s;
        return this;
      }
    }, {
      key: "determinant",
      value: function determinant() {
        var te = this.elements;
        var n11 = te[0],
          n12 = te[4],
          n13 = te[8],
          n14 = te[12];
        var n21 = te[1],
          n22 = te[5],
          n23 = te[9],
          n24 = te[13];
        var n31 = te[2],
          n32 = te[6],
          n33 = te[10],
          n34 = te[14];
        var n41 = te[3],
          n42 = te[7],
          n43 = te[11],
          n44 = te[15];

        //TODO: make this more efficient
        //( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )

        return n41 * (+n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34) + n42 * (+n11 * n23 * n34 - n11 * n24 * n33 + n14 * n21 * n33 - n13 * n21 * n34 + n13 * n24 * n31 - n14 * n23 * n31) + n43 * (+n11 * n24 * n32 - n11 * n22 * n34 - n14 * n21 * n32 + n12 * n21 * n34 + n14 * n22 * n31 - n12 * n24 * n31) + n44 * (-n13 * n22 * n31 - n11 * n23 * n32 + n11 * n22 * n33 + n13 * n21 * n32 - n12 * n21 * n33 + n12 * n23 * n31);
      }
    }, {
      key: "transpose",
      value: function transpose() {
        var te = this.elements;
        var tmp;
        tmp = te[1];
        te[1] = te[4];
        te[4] = tmp;
        tmp = te[2];
        te[2] = te[8];
        te[8] = tmp;
        tmp = te[6];
        te[6] = te[9];
        te[9] = tmp;
        tmp = te[3];
        te[3] = te[12];
        te[12] = tmp;
        tmp = te[7];
        te[7] = te[13];
        te[13] = tmp;
        tmp = te[11];
        te[11] = te[14];
        te[14] = tmp;
        return this;
      }
    }, {
      key: "setPosition",
      value: function setPosition(x, y, z) {
        var te = this.elements;
        if (x.isVector3) {
          te[12] = x.x;
          te[13] = x.y;
          te[14] = x.z;
        } else {
          te[12] = x;
          te[13] = y;
          te[14] = z;
        }
        return this;
      }
    }, {
      key: "invert",
      value: function invert() {
        // based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm
        var te = this.elements,
          n11 = te[0],
          n21 = te[1],
          n31 = te[2],
          n41 = te[3],
          n12 = te[4],
          n22 = te[5],
          n32 = te[6],
          n42 = te[7],
          n13 = te[8],
          n23 = te[9],
          n33 = te[10],
          n43 = te[11],
          n14 = te[12],
          n24 = te[13],
          n34 = te[14],
          n44 = te[15],
          t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44,
          t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44,
          t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44,
          t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;
        var det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;
        if (det === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
        var detInv = 1 / det;
        te[0] = t11 * detInv;
        te[1] = (n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44) * detInv;
        te[2] = (n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44) * detInv;
        te[3] = (n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43) * detInv;
        te[4] = t12 * detInv;
        te[5] = (n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44) * detInv;
        te[6] = (n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44) * detInv;
        te[7] = (n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43) * detInv;
        te[8] = t13 * detInv;
        te[9] = (n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44) * detInv;
        te[10] = (n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44) * detInv;
        te[11] = (n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43) * detInv;
        te[12] = t14 * detInv;
        te[13] = (n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34) * detInv;
        te[14] = (n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34) * detInv;
        te[15] = (n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33) * detInv;
        return this;
      }
    }, {
      key: "scale",
      value: function scale(v) {
        var te = this.elements;
        var x = v.x,
          y = v.y,
          z = v.z;
        te[0] *= x;
        te[4] *= y;
        te[8] *= z;
        te[1] *= x;
        te[5] *= y;
        te[9] *= z;
        te[2] *= x;
        te[6] *= y;
        te[10] *= z;
        te[3] *= x;
        te[7] *= y;
        te[11] *= z;
        return this;
      }
    }, {
      key: "getMaxScaleOnAxis",
      value: function getMaxScaleOnAxis() {
        var te = this.elements;
        var scaleXSq = te[0] * te[0] + te[1] * te[1] + te[2] * te[2];
        var scaleYSq = te[4] * te[4] + te[5] * te[5] + te[6] * te[6];
        var scaleZSq = te[8] * te[8] + te[9] * te[9] + te[10] * te[10];
        return Math.sqrt(Math.max(scaleXSq, scaleYSq, scaleZSq));
      }
    }, {
      key: "makeTranslation",
      value: function makeTranslation(x, y, z) {
        if (x.isVector3) {
          this.set(1, 0, 0, x.x, 0, 1, 0, x.y, 0, 0, 1, x.z, 0, 0, 0, 1);
        } else {
          this.set(1, 0, 0, x, 0, 1, 0, y, 0, 0, 1, z, 0, 0, 0, 1);
        }
        return this;
      }
    }, {
      key: "makeRotationX",
      value: function makeRotationX(theta) {
        var c = Math.cos(theta),
          s = Math.sin(theta);
        this.set(1, 0, 0, 0, 0, c, -s, 0, 0, s, c, 0, 0, 0, 0, 1);
        return this;
      }
    }, {
      key: "makeRotationY",
      value: function makeRotationY(theta) {
        var c = Math.cos(theta),
          s = Math.sin(theta);
        this.set(c, 0, s, 0, 0, 1, 0, 0, -s, 0, c, 0, 0, 0, 0, 1);
        return this;
      }
    }, {
      key: "makeRotationZ",
      value: function makeRotationZ(theta) {
        var c = Math.cos(theta),
          s = Math.sin(theta);
        this.set(c, -s, 0, 0, s, c, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
        return this;
      }
    }, {
      key: "makeRotationAxis",
      value: function makeRotationAxis(axis, angle) {
        // Based on http://www.gamedev.net/reference/articles/article1199.asp

        var c = Math.cos(angle);
        var s = Math.sin(angle);
        var t = 1 - c;
        var x = axis.x,
          y = axis.y,
          z = axis.z;
        var tx = t * x,
          ty = t * y;
        this.set(tx * x + c, tx * y - s * z, tx * z + s * y, 0, tx * y + s * z, ty * y + c, ty * z - s * x, 0, tx * z - s * y, ty * z + s * x, t * z * z + c, 0, 0, 0, 0, 1);
        return this;
      }
    }, {
      key: "makeScale",
      value: function makeScale(x, y, z) {
        this.set(x, 0, 0, 0, 0, y, 0, 0, 0, 0, z, 0, 0, 0, 0, 1);
        return this;
      }
    }, {
      key: "makeShear",
      value: function makeShear(xy, xz, yx, yz, zx, zy) {
        this.set(1, yx, zx, 0, xy, 1, zy, 0, xz, yz, 1, 0, 0, 0, 0, 1);
        return this;
      }
    }, {
      key: "compose",
      value: function compose(position, quaternion, scale) {
        var te = this.elements;
        var x = quaternion._x,
          y = quaternion._y,
          z = quaternion._z,
          w = quaternion._w;
        var x2 = x + x,
          y2 = y + y,
          z2 = z + z;
        var xx = x * x2,
          xy = x * y2,
          xz = x * z2;
        var yy = y * y2,
          yz = y * z2,
          zz = z * z2;
        var wx = w * x2,
          wy = w * y2,
          wz = w * z2;
        var sx = scale.x,
          sy = scale.y,
          sz = scale.z;
        te[0] = (1 - (yy + zz)) * sx;
        te[1] = (xy + wz) * sx;
        te[2] = (xz - wy) * sx;
        te[3] = 0;
        te[4] = (xy - wz) * sy;
        te[5] = (1 - (xx + zz)) * sy;
        te[6] = (yz + wx) * sy;
        te[7] = 0;
        te[8] = (xz + wy) * sz;
        te[9] = (yz - wx) * sz;
        te[10] = (1 - (xx + yy)) * sz;
        te[11] = 0;
        te[12] = position.x;
        te[13] = position.y;
        te[14] = position.z;
        te[15] = 1;
        return this;
      }
    }, {
      key: "decompose",
      value: function decompose(position, quaternion, scale) {
        var te = this.elements;
        var sx = _v1$5.set(te[0], te[1], te[2]).length();
        var sy = _v1$5.set(te[4], te[5], te[6]).length();
        var sz = _v1$5.set(te[8], te[9], te[10]).length();

        // if determine is negative, we need to invert one scale
        var det = this.determinant();
        if (det < 0) sx = -sx;
        position.x = te[12];
        position.y = te[13];
        position.z = te[14];

        // scale the rotation part
        _m1$2.copy(this);
        var invSX = 1 / sx;
        var invSY = 1 / sy;
        var invSZ = 1 / sz;
        _m1$2.elements[0] *= invSX;
        _m1$2.elements[1] *= invSX;
        _m1$2.elements[2] *= invSX;
        _m1$2.elements[4] *= invSY;
        _m1$2.elements[5] *= invSY;
        _m1$2.elements[6] *= invSY;
        _m1$2.elements[8] *= invSZ;
        _m1$2.elements[9] *= invSZ;
        _m1$2.elements[10] *= invSZ;
        quaternion.setFromRotationMatrix(_m1$2);
        scale.x = sx;
        scale.y = sy;
        scale.z = sz;
        return this;
      }
    }, {
      key: "makePerspective",
      value: function makePerspective(left, right, top, bottom, near, far) {
        var coordinateSystem = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : WebGLCoordinateSystem;
        var te = this.elements;
        var x = 2 * near / (right - left);
        var y = 2 * near / (top - bottom);
        var a = (right + left) / (right - left);
        var b = (top + bottom) / (top - bottom);
        var c, d;
        if (coordinateSystem === WebGLCoordinateSystem) {
          c = -(far + near) / (far - near);
          d = -2 * far * near / (far - near);
        } else if (coordinateSystem === WebGPUCoordinateSystem) {
          c = -far / (far - near);
          d = -far * near / (far - near);
        } else {
          throw new Error('THREE.Matrix4.makePerspective(): Invalid coordinate system: ' + coordinateSystem);
        }
        te[0] = x;
        te[4] = 0;
        te[8] = a;
        te[12] = 0;
        te[1] = 0;
        te[5] = y;
        te[9] = b;
        te[13] = 0;
        te[2] = 0;
        te[6] = 0;
        te[10] = c;
        te[14] = d;
        te[3] = 0;
        te[7] = 0;
        te[11] = -1;
        te[15] = 0;
        return this;
      }
    }, {
      key: "makeOrthographic",
      value: function makeOrthographic(left, right, top, bottom, near, far) {
        var coordinateSystem = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : WebGLCoordinateSystem;
        var te = this.elements;
        var w = 1.0 / (right - left);
        var h = 1.0 / (top - bottom);
        var p = 1.0 / (far - near);
        var x = (right + left) * w;
        var y = (top + bottom) * h;
        var z, zInv;
        if (coordinateSystem === WebGLCoordinateSystem) {
          z = (far + near) * p;
          zInv = -2 * p;
        } else if (coordinateSystem === WebGPUCoordinateSystem) {
          z = near * p;
          zInv = -1 * p;
        } else {
          throw new Error('THREE.Matrix4.makeOrthographic(): Invalid coordinate system: ' + coordinateSystem);
        }
        te[0] = 2 * w;
        te[4] = 0;
        te[8] = 0;
        te[12] = -x;
        te[1] = 0;
        te[5] = 2 * h;
        te[9] = 0;
        te[13] = -y;
        te[2] = 0;
        te[6] = 0;
        te[10] = zInv;
        te[14] = -z;
        te[3] = 0;
        te[7] = 0;
        te[11] = 0;
        te[15] = 1;
        return this;
      }
    }, {
      key: "equals",
      value: function equals(matrix) {
        var te = this.elements;
        var me = matrix.elements;
        for (var i = 0; i < 16; i++) {
          if (te[i] !== me[i]) return false;
        }
        return true;
      }
    }, {
      key: "fromArray",
      value: function fromArray(array) {
        var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        for (var i = 0; i < 16; i++) {
          this.elements[i] = array[i + offset];
        }
        return this;
      }
    }, {
      key: "toArray",
      value: function toArray() {
        var array = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
        var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        var te = this.elements;
        array[offset] = te[0];
        array[offset + 1] = te[1];
        array[offset + 2] = te[2];
        array[offset + 3] = te[3];
        array[offset + 4] = te[4];
        array[offset + 5] = te[5];
        array[offset + 6] = te[6];
        array[offset + 7] = te[7];
        array[offset + 8] = te[8];
        array[offset + 9] = te[9];
        array[offset + 10] = te[10];
        array[offset + 11] = te[11];
        array[offset + 12] = te[12];
        array[offset + 13] = te[13];
        array[offset + 14] = te[14];
        array[offset + 15] = te[15];
        return array;
      }
    }]);
  }();
  var _v1$5 = /*@__PURE__*/new Vector3();
  var _m1$2 = /*@__PURE__*/new Matrix4();
  var _zero = /*@__PURE__*/new Vector3(0, 0, 0);
  var _one = /*@__PURE__*/new Vector3(1, 1, 1);
  var _x = /*@__PURE__*/new Vector3();
  var _y = /*@__PURE__*/new Vector3();
  var _z = /*@__PURE__*/new Vector3();
  var _matrix$2 = /*@__PURE__*/new Matrix4();
  var _quaternion$3 = /*@__PURE__*/new Quaternion();
  var Euler = exports.Euler = /*#__PURE__*/function () {
    function Euler() {
      var x = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      var y = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var z = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      var order = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : Euler.DEFAULT_ORDER;
      (0, _classCallCheck2.default)(this, Euler);
      this.isEuler = true;
      this._x = x;
      this._y = y;
      this._z = z;
      this._order = order;
    }
    return (0, _createClass2.default)(Euler, [{
      key: "x",
      get: function get() {
        return this._x;
      },
      set: function set(value) {
        this._x = value;
        this._onChangeCallback();
      }
    }, {
      key: "y",
      get: function get() {
        return this._y;
      },
      set: function set(value) {
        this._y = value;
        this._onChangeCallback();
      }
    }, {
      key: "z",
      get: function get() {
        return this._z;
      },
      set: function set(value) {
        this._z = value;
        this._onChangeCallback();
      }
    }, {
      key: "order",
      get: function get() {
        return this._order;
      },
      set: function set(value) {
        this._order = value;
        this._onChangeCallback();
      }
    }, {
      key: "set",
      value: function set(x, y, z) {
        var order = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : this._order;
        this._x = x;
        this._y = y;
        this._z = z;
        this._order = order;
        this._onChangeCallback();
        return this;
      }
    }, {
      key: "clone",
      value: function clone() {
        return new this.constructor(this._x, this._y, this._z, this._order);
      }
    }, {
      key: "copy",
      value: function copy(euler) {
        this._x = euler._x;
        this._y = euler._y;
        this._z = euler._z;
        this._order = euler._order;
        this._onChangeCallback();
        return this;
      }
    }, {
      key: "setFromRotationMatrix",
      value: function setFromRotationMatrix(m) {
        var order = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this._order;
        var update = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
        // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

        var te = m.elements;
        var m11 = te[0],
          m12 = te[4],
          m13 = te[8];
        var m21 = te[1],
          m22 = te[5],
          m23 = te[9];
        var m31 = te[2],
          m32 = te[6],
          m33 = te[10];
        switch (order) {
          case 'XYZ':
            this._y = Math.asin(_clamp(m13, -1, 1));
            if (Math.abs(m13) < 0.9999999) {
              this._x = Math.atan2(-m23, m33);
              this._z = Math.atan2(-m12, m11);
            } else {
              this._x = Math.atan2(m32, m22);
              this._z = 0;
            }
            break;
          case 'YXZ':
            this._x = Math.asin(-_clamp(m23, -1, 1));
            if (Math.abs(m23) < 0.9999999) {
              this._y = Math.atan2(m13, m33);
              this._z = Math.atan2(m21, m22);
            } else {
              this._y = Math.atan2(-m31, m11);
              this._z = 0;
            }
            break;
          case 'ZXY':
            this._x = Math.asin(_clamp(m32, -1, 1));
            if (Math.abs(m32) < 0.9999999) {
              this._y = Math.atan2(-m31, m33);
              this._z = Math.atan2(-m12, m22);
            } else {
              this._y = 0;
              this._z = Math.atan2(m21, m11);
            }
            break;
          case 'ZYX':
            this._y = Math.asin(-_clamp(m31, -1, 1));
            if (Math.abs(m31) < 0.9999999) {
              this._x = Math.atan2(m32, m33);
              this._z = Math.atan2(m21, m11);
            } else {
              this._x = 0;
              this._z = Math.atan2(-m12, m22);
            }
            break;
          case 'YZX':
            this._z = Math.asin(_clamp(m21, -1, 1));
            if (Math.abs(m21) < 0.9999999) {
              this._x = Math.atan2(-m23, m22);
              this._y = Math.atan2(-m31, m11);
            } else {
              this._x = 0;
              this._y = Math.atan2(m13, m33);
            }
            break;
          case 'XZY':
            this._z = Math.asin(-_clamp(m12, -1, 1));
            if (Math.abs(m12) < 0.9999999) {
              this._x = Math.atan2(m32, m22);
              this._y = Math.atan2(m13, m11);
            } else {
              this._x = Math.atan2(-m23, m33);
              this._y = 0;
            }
            break;
          default:
            console.warn('THREE.Euler: .setFromRotationMatrix() encountered an unknown order: ' + order);
        }
        this._order = order;
        if (update === true) this._onChangeCallback();
        return this;
      }
    }, {
      key: "setFromQuaternion",
      value: function setFromQuaternion(q, order, update) {
        _matrix$2.makeRotationFromQuaternion(q);
        return this.setFromRotationMatrix(_matrix$2, order, update);
      }
    }, {
      key: "setFromVector3",
      value: function setFromVector3(v) {
        var order = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this._order;
        return this.set(v.x, v.y, v.z, order);
      }
    }, {
      key: "reorder",
      value: function reorder(newOrder) {
        // WARNING: this discards revolution information -bhouston

        _quaternion$3.setFromEuler(this);
        return this.setFromQuaternion(_quaternion$3, newOrder);
      }
    }, {
      key: "equals",
      value: function equals(euler) {
        return euler._x === this._x && euler._y === this._y && euler._z === this._z && euler._order === this._order;
      }
    }, {
      key: "fromArray",
      value: function fromArray(array) {
        this._x = array[0];
        this._y = array[1];
        this._z = array[2];
        if (array[3] !== undefined) this._order = array[3];
        this._onChangeCallback();
        return this;
      }
    }, {
      key: "toArray",
      value: function toArray() {
        var array = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
        var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        array[offset] = this._x;
        array[offset + 1] = this._y;
        array[offset + 2] = this._z;
        array[offset + 3] = this._order;
        return array;
      }
    }, {
      key: "_onChange",
      value: function _onChange(callback) {
        this._onChangeCallback = callback;
        return this;
      }
    }, {
      key: "_onChangeCallback",
      value: function _onChangeCallback() {}
    }, {
      key: Symbol.iterator,
      value: function* value() {
        yield this._x;
        yield this._y;
        yield this._z;
        yield this._order;
      }
    }]);
  }();
  Euler.DEFAULT_ORDER = 'XYZ';
  var Layers = exports.Layers = /*#__PURE__*/function () {
    function Layers() {
      (0, _classCallCheck2.default)(this, Layers);
      this.mask = 1 | 0;
    }
    return (0, _createClass2.default)(Layers, [{
      key: "set",
      value: function set(channel) {
        this.mask = (1 << channel | 0) >>> 0;
      }
    }, {
      key: "enable",
      value: function enable(channel) {
        this.mask |= 1 << channel | 0;
      }
    }, {
      key: "enableAll",
      value: function enableAll() {
        this.mask = 0xffffffff | 0;
      }
    }, {
      key: "toggle",
      value: function toggle(channel) {
        this.mask ^= 1 << channel | 0;
      }
    }, {
      key: "disable",
      value: function disable(channel) {
        this.mask &= ~(1 << channel | 0);
      }
    }, {
      key: "disableAll",
      value: function disableAll() {
        this.mask = 0;
      }
    }, {
      key: "test",
      value: function test(layers) {
        return (this.mask & layers.mask) !== 0;
      }
    }, {
      key: "isEnabled",
      value: function isEnabled(channel) {
        return (this.mask & (1 << channel | 0)) !== 0;
      }
    }]);
  }();
  var _object3DId = 0;
  var _v1$4 = /*@__PURE__*/new Vector3();
  var _q1 = /*@__PURE__*/new Quaternion();
  var _m1$1 = /*@__PURE__*/new Matrix4();
  var _target = /*@__PURE__*/new Vector3();
  var _position$3 = /*@__PURE__*/new Vector3();
  var _scale$2 = /*@__PURE__*/new Vector3();
  var _quaternion$2 = /*@__PURE__*/new Quaternion();
  var _xAxis = /*@__PURE__*/new Vector3(1, 0, 0);
  var _yAxis = /*@__PURE__*/new Vector3(0, 1, 0);
  var _zAxis = /*@__PURE__*/new Vector3(0, 0, 1);
  var _addedEvent = {
    type: 'added'
  };
  var _removedEvent = {
    type: 'removed'
  };
  var _childaddedEvent = {
    type: 'childadded',
    child: null
  };
  var _childremovedEvent = {
    type: 'childremoved',
    child: null
  };
  var Object3D = exports.Object3D = /*#__PURE__*/function (_EventDispatcher3) {
    function Object3D() {
      var _this8;
      (0, _classCallCheck2.default)(this, Object3D);
      _this8 = _callSuper(this, Object3D);
      _this8.isObject3D = true;
      Object.defineProperty(_this8, 'id', {
        value: _object3DId++
      });
      _this8.uuid = generateUUID();
      _this8.name = '';
      _this8.type = 'Object3D';
      _this8.parent = null;
      _this8.children = [];
      _this8.up = Object3D.DEFAULT_UP.clone();
      var position = new Vector3();
      var rotation = new Euler();
      var quaternion = new Quaternion();
      var scale = new Vector3(1, 1, 1);
      function onRotationChange() {
        quaternion.setFromEuler(rotation, false);
      }
      function onQuaternionChange() {
        rotation.setFromQuaternion(quaternion, undefined, false);
      }
      rotation._onChange(onRotationChange);
      quaternion._onChange(onQuaternionChange);
      Object.defineProperties(_this8, {
        position: {
          configurable: true,
          enumerable: true,
          value: position
        },
        rotation: {
          configurable: true,
          enumerable: true,
          value: rotation
        },
        quaternion: {
          configurable: true,
          enumerable: true,
          value: quaternion
        },
        scale: {
          configurable: true,
          enumerable: true,
          value: scale
        },
        modelViewMatrix: {
          value: new Matrix4()
        },
        normalMatrix: {
          value: new Matrix3()
        }
      });
      _this8.matrix = new Matrix4();
      _this8.matrixWorld = new Matrix4();
      _this8.matrixAutoUpdate = Object3D.DEFAULT_MATRIX_AUTO_UPDATE;
      _this8.matrixWorldAutoUpdate = Object3D.DEFAULT_MATRIX_WORLD_AUTO_UPDATE; // checked by the renderer
      _this8.matrixWorldNeedsUpdate = false;
      _this8.layers = new Layers();
      _this8.visible = true;
      _this8.castShadow = false;
      _this8.receiveShadow = false;
      _this8.frustumCulled = true;
      _this8.renderOrder = 0;
      _this8.animations = [];
      _this8.userData = {};
      return _this8;
    }
    (0, _inherits2.default)(Object3D, _EventDispatcher3);
    return (0, _createClass2.default)(Object3D, [{
      key: "onBeforeShadow",
      value: function onBeforeShadow(/* renderer, object, camera, shadowCamera, geometry, depthMaterial, group */) {}
    }, {
      key: "onAfterShadow",
      value: function onAfterShadow(/* renderer, object, camera, shadowCamera, geometry, depthMaterial, group */) {}
    }, {
      key: "onBeforeRender",
      value: function onBeforeRender(/* renderer, scene, camera, geometry, material, group */) {}
    }, {
      key: "onAfterRender",
      value: function onAfterRender(/* renderer, scene, camera, geometry, material, group */) {}
    }, {
      key: "applyMatrix4",
      value: function applyMatrix4(matrix) {
        if (this.matrixAutoUpdate) this.updateMatrix();
        this.matrix.premultiply(matrix);
        this.matrix.decompose(this.position, this.quaternion, this.scale);
      }
    }, {
      key: "applyQuaternion",
      value: function applyQuaternion(q) {
        this.quaternion.premultiply(q);
        return this;
      }
    }, {
      key: "setRotationFromAxisAngle",
      value: function setRotationFromAxisAngle(axis, angle) {
        // assumes axis is normalized

        this.quaternion.setFromAxisAngle(axis, angle);
      }
    }, {
      key: "setRotationFromEuler",
      value: function setRotationFromEuler(euler) {
        this.quaternion.setFromEuler(euler, true);
      }
    }, {
      key: "setRotationFromMatrix",
      value: function setRotationFromMatrix(m) {
        // assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

        this.quaternion.setFromRotationMatrix(m);
      }
    }, {
      key: "setRotationFromQuaternion",
      value: function setRotationFromQuaternion(q) {
        // assumes q is normalized

        this.quaternion.copy(q);
      }
    }, {
      key: "rotateOnAxis",
      value: function rotateOnAxis(axis, angle) {
        // rotate object on axis in object space
        // axis is assumed to be normalized

        _q1.setFromAxisAngle(axis, angle);
        this.quaternion.multiply(_q1);
        return this;
      }
    }, {
      key: "rotateOnWorldAxis",
      value: function rotateOnWorldAxis(axis, angle) {
        // rotate object on axis in world space
        // axis is assumed to be normalized
        // method assumes no rotated parent

        _q1.setFromAxisAngle(axis, angle);
        this.quaternion.premultiply(_q1);
        return this;
      }
    }, {
      key: "rotateX",
      value: function rotateX(angle) {
        return this.rotateOnAxis(_xAxis, angle);
      }
    }, {
      key: "rotateY",
      value: function rotateY(angle) {
        return this.rotateOnAxis(_yAxis, angle);
      }
    }, {
      key: "rotateZ",
      value: function rotateZ(angle) {
        return this.rotateOnAxis(_zAxis, angle);
      }
    }, {
      key: "translateOnAxis",
      value: function translateOnAxis(axis, distance) {
        // translate object by distance along axis in object space
        // axis is assumed to be normalized

        _v1$4.copy(axis).applyQuaternion(this.quaternion);
        this.position.add(_v1$4.multiplyScalar(distance));
        return this;
      }
    }, {
      key: "translateX",
      value: function translateX(distance) {
        return this.translateOnAxis(_xAxis, distance);
      }
    }, {
      key: "translateY",
      value: function translateY(distance) {
        return this.translateOnAxis(_yAxis, distance);
      }
    }, {
      key: "translateZ",
      value: function translateZ(distance) {
        return this.translateOnAxis(_zAxis, distance);
      }
    }, {
      key: "localToWorld",
      value: function localToWorld(vector) {
        this.updateWorldMatrix(true, false);
        return vector.applyMatrix4(this.matrixWorld);
      }
    }, {
      key: "worldToLocal",
      value: function worldToLocal(vector) {
        this.updateWorldMatrix(true, false);
        return vector.applyMatrix4(_m1$1.copy(this.matrixWorld).invert());
      }
    }, {
      key: "lookAt",
      value: function lookAt(x, y, z) {
        // This method does not support objects having non-uniformly-scaled parent(s)

        if (x.isVector3) {
          _target.copy(x);
        } else {
          _target.set(x, y, z);
        }
        var parent = this.parent;
        this.updateWorldMatrix(true, false);
        _position$3.setFromMatrixPosition(this.matrixWorld);
        if (this.isCamera || this.isLight) {
          _m1$1.lookAt(_position$3, _target, this.up);
        } else {
          _m1$1.lookAt(_target, _position$3, this.up);
        }
        this.quaternion.setFromRotationMatrix(_m1$1);
        if (parent) {
          _m1$1.extractRotation(parent.matrixWorld);
          _q1.setFromRotationMatrix(_m1$1);
          this.quaternion.premultiply(_q1.invert());
        }
      }
    }, {
      key: "add",
      value: function add(object) {
        if (arguments.length > 1) {
          for (var i = 0; i < arguments.length; i++) {
            this.add(arguments[i]);
          }
          return this;
        }
        if (object === this) {
          console.error('THREE.Object3D.add: object can\'t be added as a child of itself.', object);
          return this;
        }
        if (object && object.isObject3D) {
          object.removeFromParent();
          object.parent = this;
          this.children.push(object);
          object.dispatchEvent(_addedEvent);
          _childaddedEvent.child = object;
          this.dispatchEvent(_childaddedEvent);
          _childaddedEvent.child = null;
        } else {
          console.error('THREE.Object3D.add: object not an instance of THREE.Object3D.', object);
        }
        return this;
      }
    }, {
      key: "remove",
      value: function remove(object) {
        if (arguments.length > 1) {
          for (var i = 0; i < arguments.length; i++) {
            this.remove(arguments[i]);
          }
          return this;
        }
        var index = this.children.indexOf(object);
        if (index !== -1) {
          object.parent = null;
          this.children.splice(index, 1);
          object.dispatchEvent(_removedEvent);
          _childremovedEvent.child = object;
          this.dispatchEvent(_childremovedEvent);
          _childremovedEvent.child = null;
        }
        return this;
      }
    }, {
      key: "removeFromParent",
      value: function removeFromParent() {
        var parent = this.parent;
        if (parent !== null) {
          parent.remove(this);
        }
        return this;
      }
    }, {
      key: "clear",
      value: function clear() {
        return this.remove.apply(this, (0, _toConsumableArray2.default)(this.children));
      }
    }, {
      key: "attach",
      value: function attach(object) {
        // adds object as a child of this, while maintaining the object's world transform

        // Note: This method does not support scene graphs having non-uniformly-scaled nodes(s)

        this.updateWorldMatrix(true, false);
        _m1$1.copy(this.matrixWorld).invert();
        if (object.parent !== null) {
          object.parent.updateWorldMatrix(true, false);
          _m1$1.multiply(object.parent.matrixWorld);
        }
        object.applyMatrix4(_m1$1);
        object.removeFromParent();
        object.parent = this;
        this.children.push(object);
        object.updateWorldMatrix(false, true);
        object.dispatchEvent(_addedEvent);
        _childaddedEvent.child = object;
        this.dispatchEvent(_childaddedEvent);
        _childaddedEvent.child = null;
        return this;
      }
    }, {
      key: "getObjectById",
      value: function getObjectById(id) {
        return this.getObjectByProperty('id', id);
      }
    }, {
      key: "getObjectByName",
      value: function getObjectByName(name) {
        return this.getObjectByProperty('name', name);
      }
    }, {
      key: "getObjectByProperty",
      value: function getObjectByProperty(name, value) {
        if (this[name] === value) return this;
        for (var i = 0, l = this.children.length; i < l; i++) {
          var child = this.children[i];
          var object = child.getObjectByProperty(name, value);
          if (object !== undefined) {
            return object;
          }
        }
        return undefined;
      }
    }, {
      key: "getObjectsByProperty",
      value: function getObjectsByProperty(name, value) {
        var result = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
        if (this[name] === value) result.push(this);
        var children = this.children;
        for (var i = 0, l = children.length; i < l; i++) {
          children[i].getObjectsByProperty(name, value, result);
        }
        return result;
      }
    }, {
      key: "getWorldPosition",
      value: function getWorldPosition(target) {
        this.updateWorldMatrix(true, false);
        return target.setFromMatrixPosition(this.matrixWorld);
      }
    }, {
      key: "getWorldQuaternion",
      value: function getWorldQuaternion(target) {
        this.updateWorldMatrix(true, false);
        this.matrixWorld.decompose(_position$3, target, _scale$2);
        return target;
      }
    }, {
      key: "getWorldScale",
      value: function getWorldScale(target) {
        this.updateWorldMatrix(true, false);
        this.matrixWorld.decompose(_position$3, _quaternion$2, target);
        return target;
      }
    }, {
      key: "getWorldDirection",
      value: function getWorldDirection(target) {
        this.updateWorldMatrix(true, false);
        var e = this.matrixWorld.elements;
        return target.set(e[8], e[9], e[10]).normalize();
      }
    }, {
      key: "raycast",
      value: function raycast(/* raycaster, intersects */) {}
    }, {
      key: "traverse",
      value: function traverse(callback) {
        callback(this);
        var children = this.children;
        for (var i = 0, l = children.length; i < l; i++) {
          children[i].traverse(callback);
        }
      }
    }, {
      key: "traverseVisible",
      value: function traverseVisible(callback) {
        if (this.visible === false) return;
        callback(this);
        var children = this.children;
        for (var i = 0, l = children.length; i < l; i++) {
          children[i].traverseVisible(callback);
        }
      }
    }, {
      key: "traverseAncestors",
      value: function traverseAncestors(callback) {
        var parent = this.parent;
        if (parent !== null) {
          callback(parent);
          parent.traverseAncestors(callback);
        }
      }
    }, {
      key: "updateMatrix",
      value: function updateMatrix() {
        this.matrix.compose(this.position, this.quaternion, this.scale);
        this.matrixWorldNeedsUpdate = true;
      }
    }, {
      key: "updateMatrixWorld",
      value: function updateMatrixWorld(force) {
        if (this.matrixAutoUpdate) this.updateMatrix();
        if (this.matrixWorldNeedsUpdate || force) {
          if (this.matrixWorldAutoUpdate === true) {
            if (this.parent === null) {
              this.matrixWorld.copy(this.matrix);
            } else {
              this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
            }
          }
          this.matrixWorldNeedsUpdate = false;
          force = true;
        }

        // make sure descendants are updated if required

        var children = this.children;
        for (var i = 0, l = children.length; i < l; i++) {
          var child = children[i];
          child.updateMatrixWorld(force);
        }
      }
    }, {
      key: "updateWorldMatrix",
      value: function updateWorldMatrix(updateParents, updateChildren) {
        var parent = this.parent;
        if (updateParents === true && parent !== null) {
          parent.updateWorldMatrix(true, false);
        }
        if (this.matrixAutoUpdate) this.updateMatrix();
        if (this.matrixWorldAutoUpdate === true) {
          if (this.parent === null) {
            this.matrixWorld.copy(this.matrix);
          } else {
            this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix);
          }
        }

        // make sure descendants are updated

        if (updateChildren === true) {
          var children = this.children;
          for (var i = 0, l = children.length; i < l; i++) {
            var child = children[i];
            child.updateWorldMatrix(false, true);
          }
        }
      }
    }, {
      key: "toJSON",
      value: function toJSON(meta) {
        // meta is a string when called from JSON.stringify
        var isRootObject = meta === undefined || typeof meta === 'string';
        var output = {};

        // meta is a hash used to collect geometries, materials.
        // not providing it implies that this is the root object
        // being serialized.
        if (isRootObject) {
          // initialize meta obj
          meta = {
            geometries: {},
            materials: {},
            textures: {},
            images: {},
            shapes: {},
            skeletons: {},
            animations: {},
            nodes: {}
          };
          output.metadata = {
            version: 4.6,
            type: 'Object',
            generator: 'Object3D.toJSON'
          };
        }

        // standard Object3D serialization

        var object = {};
        object.uuid = this.uuid;
        object.type = this.type;
        if (this.name !== '') object.name = this.name;
        if (this.castShadow === true) object.castShadow = true;
        if (this.receiveShadow === true) object.receiveShadow = true;
        if (this.visible === false) object.visible = false;
        if (this.frustumCulled === false) object.frustumCulled = false;
        if (this.renderOrder !== 0) object.renderOrder = this.renderOrder;
        if (Object.keys(this.userData).length > 0) object.userData = this.userData;
        object.layers = this.layers.mask;
        object.matrix = this.matrix.toArray();
        object.up = this.up.toArray();
        if (this.matrixAutoUpdate === false) object.matrixAutoUpdate = false;

        // object specific properties

        if (this.isInstancedMesh) {
          object.type = 'InstancedMesh';
          object.count = this.count;
          object.instanceMatrix = this.instanceMatrix.toJSON();
          if (this.instanceColor !== null) object.instanceColor = this.instanceColor.toJSON();
        }
        if (this.isBatchedMesh) {
          object.type = 'BatchedMesh';
          object.perObjectFrustumCulled = this.perObjectFrustumCulled;
          object.sortObjects = this.sortObjects;
          object.drawRanges = this._drawRanges;
          object.reservedRanges = this._reservedRanges;
          object.visibility = this._visibility;
          object.active = this._active;
          object.bounds = this._bounds.map(function (bound) {
            return {
              boxInitialized: bound.boxInitialized,
              boxMin: bound.box.min.toArray(),
              boxMax: bound.box.max.toArray(),
              sphereInitialized: bound.sphereInitialized,
              sphereRadius: bound.sphere.radius,
              sphereCenter: bound.sphere.center.toArray()
            };
          });
          object.maxInstanceCount = this._maxInstanceCount;
          object.maxVertexCount = this._maxVertexCount;
          object.maxIndexCount = this._maxIndexCount;
          object.geometryInitialized = this._geometryInitialized;
          object.geometryCount = this._geometryCount;
          object.matricesTexture = this._matricesTexture.toJSON(meta);
          if (this._colorsTexture !== null) object.colorsTexture = this._colorsTexture.toJSON(meta);
          if (this.boundingSphere !== null) {
            object.boundingSphere = {
              center: object.boundingSphere.center.toArray(),
              radius: object.boundingSphere.radius
            };
          }
          if (this.boundingBox !== null) {
            object.boundingBox = {
              min: object.boundingBox.min.toArray(),
              max: object.boundingBox.max.toArray()
            };
          }
        }

        //

        function serialize(library, element) {
          if (library[element.uuid] === undefined) {
            library[element.uuid] = element.toJSON(meta);
          }
          return element.uuid;
        }
        if (this.isScene) {
          if (this.background) {
            if (this.background.isColor) {
              object.background = this.background.toJSON();
            } else if (this.background.isTexture) {
              object.background = this.background.toJSON(meta).uuid;
            }
          }
          if (this.environment && this.environment.isTexture && this.environment.isRenderTargetTexture !== true) {
            object.environment = this.environment.toJSON(meta).uuid;
          }
        } else if (this.isMesh || this.isLine || this.isPoints) {
          object.geometry = serialize(meta.geometries, this.geometry);
          var parameters = this.geometry.parameters;
          if (parameters !== undefined && parameters.shapes !== undefined) {
            var shapes = parameters.shapes;
            if (Array.isArray(shapes)) {
              for (var i = 0, l = shapes.length; i < l; i++) {
                var shape = shapes[i];
                serialize(meta.shapes, shape);
              }
            } else {
              serialize(meta.shapes, shapes);
            }
          }
        }
        if (this.isSkinnedMesh) {
          object.bindMode = this.bindMode;
          object.bindMatrix = this.bindMatrix.toArray();
          if (this.skeleton !== undefined) {
            serialize(meta.skeletons, this.skeleton);
            object.skeleton = this.skeleton.uuid;
          }
        }
        if (this.material !== undefined) {
          if (Array.isArray(this.material)) {
            var uuids = [];
            for (var _i3 = 0, _l2 = this.material.length; _i3 < _l2; _i3++) {
              uuids.push(serialize(meta.materials, this.material[_i3]));
            }
            object.material = uuids;
          } else {
            object.material = serialize(meta.materials, this.material);
          }
        }

        //

        if (this.children.length > 0) {
          object.children = [];
          for (var _i4 = 0; _i4 < this.children.length; _i4++) {
            object.children.push(this.children[_i4].toJSON(meta).object);
          }
        }

        //

        if (this.animations.length > 0) {
          object.animations = [];
          for (var _i5 = 0; _i5 < this.animations.length; _i5++) {
            var animation = this.animations[_i5];
            object.animations.push(serialize(meta.animations, animation));
          }
        }
        if (isRootObject) {
          var geometries = extractFromCache(meta.geometries);
          var materials = extractFromCache(meta.materials);
          var textures = extractFromCache(meta.textures);
          var images = extractFromCache(meta.images);
          var _shapes = extractFromCache(meta.shapes);
          var skeletons = extractFromCache(meta.skeletons);
          var animations = extractFromCache(meta.animations);
          var nodes = extractFromCache(meta.nodes);
          if (geometries.length > 0) output.geometries = geometries;
          if (materials.length > 0) output.materials = materials;
          if (textures.length > 0) output.textures = textures;
          if (images.length > 0) output.images = images;
          if (_shapes.length > 0) output.shapes = _shapes;
          if (skeletons.length > 0) output.skeletons = skeletons;
          if (animations.length > 0) output.animations = animations;
          if (nodes.length > 0) output.nodes = nodes;
        }
        output.object = object;
        return output;

        // extract data from the cache hash
        // remove metadata on each item
        // and return as array
        function extractFromCache(cache) {
          var values = [];
          for (var key in cache) {
            var data = cache[key];
            delete data.metadata;
            values.push(data);
          }
          return values;
        }
      }
    }, {
      key: "clone",
      value: function clone(recursive) {
        return new this.constructor().copy(this, recursive);
      }
    }, {
      key: "copy",
      value: function copy(source) {
        var recursive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
        this.name = source.name;
        this.up.copy(source.up);
        this.position.copy(source.position);
        this.rotation.order = source.rotation.order;
        this.quaternion.copy(source.quaternion);
        this.scale.copy(source.scale);
        this.matrix.copy(source.matrix);
        this.matrixWorld.copy(source.matrixWorld);
        this.matrixAutoUpdate = source.matrixAutoUpdate;
        this.matrixWorldAutoUpdate = source.matrixWorldAutoUpdate;
        this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;
        this.layers.mask = source.layers.mask;
        this.visible = source.visible;
        this.castShadow = source.castShadow;
        this.receiveShadow = source.receiveShadow;
        this.frustumCulled = source.frustumCulled;
        this.renderOrder = source.renderOrder;
        this.animations = source.animations.slice();
        this.userData = JSON.parse(JSON.stringify(source.userData));
        if (recursive === true) {
          for (var i = 0; i < source.children.length; i++) {
            var child = source.children[i];
            this.add(child.clone());
          }
        }
        return this;
      }
    }]);
  }(EventDispatcher);
  Object3D.DEFAULT_UP = /*@__PURE__*/new Vector3(0, 1, 0);
  Object3D.DEFAULT_MATRIX_AUTO_UPDATE = true;
  Object3D.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = true;
  var _v0$1 = /*@__PURE__*/new Vector3();
  var _v1$3 = /*@__PURE__*/new Vector3();
  var _v2$2 = /*@__PURE__*/new Vector3();
  var _v3$2 = /*@__PURE__*/new Vector3();
  var _vab = /*@__PURE__*/new Vector3();
  var _vac = /*@__PURE__*/new Vector3();
  var _vbc = /*@__PURE__*/new Vector3();
  var _vap = /*@__PURE__*/new Vector3();
  var _vbp = /*@__PURE__*/new Vector3();
  var _vcp = /*@__PURE__*/new Vector3();
  var _v40 = /*@__PURE__*/new Vector4();
  var _v41 = /*@__PURE__*/new Vector4();
  var _v42 = /*@__PURE__*/new Vector4();
  var Triangle = exports.Triangle = /*#__PURE__*/function () {
    function Triangle() {
      var a = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Vector3();
      var b = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Vector3();
      var c = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new Vector3();
      (0, _classCallCheck2.default)(this, Triangle);
      this.a = a;
      this.b = b;
      this.c = c;
    }
    return (0, _createClass2.default)(Triangle, [{
      key: "set",
      value: function set(a, b, c) {
        this.a.copy(a);
        this.b.copy(b);
        this.c.copy(c);
        return this;
      }
    }, {
      key: "setFromPointsAndIndices",
      value: function setFromPointsAndIndices(points, i0, i1, i2) {
        this.a.copy(points[i0]);
        this.b.copy(points[i1]);
        this.c.copy(points[i2]);
        return this;
      }
    }, {
      key: "setFromAttributeAndIndices",
      value: function setFromAttributeAndIndices(attribute, i0, i1, i2) {
        this.a.fromBufferAttribute(attribute, i0);
        this.b.fromBufferAttribute(attribute, i1);
        this.c.fromBufferAttribute(attribute, i2);
        return this;
      }
    }, {
      key: "clone",
      value: function clone() {
        return new this.constructor().copy(this);
      }
    }, {
      key: "copy",
      value: function copy(triangle) {
        this.a.copy(triangle.a);
        this.b.copy(triangle.b);
        this.c.copy(triangle.c);
        return this;
      }
    }, {
      key: "getArea",
      value: function getArea() {
        _v0$1.subVectors(this.c, this.b);
        _v1$3.subVectors(this.a, this.b);
        return _v0$1.cross(_v1$3).length() * 0.5;
      }
    }, {
      key: "getMidpoint",
      value: function getMidpoint(target) {
        return target.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3);
      }
    }, {
      key: "getNormal",
      value: function getNormal(target) {
        return Triangle.getNormal(this.a, this.b, this.c, target);
      }
    }, {
      key: "getPlane",
      value: function getPlane(target) {
        return target.setFromCoplanarPoints(this.a, this.b, this.c);
      }
    }, {
      key: "getBarycoord",
      value: function getBarycoord(point, target) {
        return Triangle.getBarycoord(point, this.a, this.b, this.c, target);
      }
    }, {
      key: "getInterpolation",
      value: function getInterpolation(point, v1, v2, v3, target) {
        return Triangle.getInterpolation(point, this.a, this.b, this.c, v1, v2, v3, target);
      }
    }, {
      key: "containsPoint",
      value: function containsPoint(point) {
        return Triangle.containsPoint(point, this.a, this.b, this.c);
      }
    }, {
      key: "isFrontFacing",
      value: function isFrontFacing(direction) {
        return Triangle.isFrontFacing(this.a, this.b, this.c, direction);
      }
    }, {
      key: "intersectsBox",
      value: function intersectsBox(box) {
        return box.intersectsTriangle(this);
      }
    }, {
      key: "closestPointToPoint",
      value: function closestPointToPoint(p, target) {
        var a = this.a,
          b = this.b,
          c = this.c;
        var v, w;

        // algorithm thanks to Real-Time Collision Detection by Christer Ericson,
        // published by Morgan Kaufmann Publishers, (c) 2005 Elsevier Inc.,
        // under the accompanying license; see chapter 5.1.5 for detailed explanation.
        // basically, we're distinguishing which of the voronoi regions of the triangle
        // the point lies in with the minimum amount of redundant computation.

        _vab.subVectors(b, a);
        _vac.subVectors(c, a);
        _vap.subVectors(p, a);
        var d1 = _vab.dot(_vap);
        var d2 = _vac.dot(_vap);
        if (d1 <= 0 && d2 <= 0) {
          // vertex region of A; barycentric coords (1, 0, 0)
          return target.copy(a);
        }
        _vbp.subVectors(p, b);
        var d3 = _vab.dot(_vbp);
        var d4 = _vac.dot(_vbp);
        if (d3 >= 0 && d4 <= d3) {
          // vertex region of B; barycentric coords (0, 1, 0)
          return target.copy(b);
        }
        var vc = d1 * d4 - d3 * d2;
        if (vc <= 0 && d1 >= 0 && d3 <= 0) {
          v = d1 / (d1 - d3);
          // edge region of AB; barycentric coords (1-v, v, 0)
          return target.copy(a).addScaledVector(_vab, v);
        }
        _vcp.subVectors(p, c);
        var d5 = _vab.dot(_vcp);
        var d6 = _vac.dot(_vcp);
        if (d6 >= 0 && d5 <= d6) {
          // vertex region of C; barycentric coords (0, 0, 1)
          return target.copy(c);
        }
        var vb = d5 * d2 - d1 * d6;
        if (vb <= 0 && d2 >= 0 && d6 <= 0) {
          w = d2 / (d2 - d6);
          // edge region of AC; barycentric coords (1-w, 0, w)
          return target.copy(a).addScaledVector(_vac, w);
        }
        var va = d3 * d6 - d5 * d4;
        if (va <= 0 && d4 - d3 >= 0 && d5 - d6 >= 0) {
          _vbc.subVectors(c, b);
          w = (d4 - d3) / (d4 - d3 + (d5 - d6));
          // edge region of BC; barycentric coords (0, 1-w, w)
          return target.copy(b).addScaledVector(_vbc, w); // edge region of BC
        }

        // face region
        var denom = 1 / (va + vb + vc);
        // u = va * denom
        v = vb * denom;
        w = vc * denom;
        return target.copy(a).addScaledVector(_vab, v).addScaledVector(_vac, w);
      }
    }, {
      key: "equals",
      value: function equals(triangle) {
        return triangle.a.equals(this.a) && triangle.b.equals(this.b) && triangle.c.equals(this.c);
      }
    }], [{
      key: "getNormal",
      value: function getNormal(a, b, c, target) {
        target.subVectors(c, b);
        _v0$1.subVectors(a, b);
        target.cross(_v0$1);
        var targetLengthSq = target.lengthSq();
        if (targetLengthSq > 0) {
          return target.multiplyScalar(1 / Math.sqrt(targetLengthSq));
        }
        return target.set(0, 0, 0);
      }

      // static/instance method to calculate barycentric coordinates
      // based on: http://www.blackpawn.com/texts/pointinpoly/default.html
    }, {
      key: "getBarycoord",
      value: function getBarycoord(point, a, b, c, target) {
        _v0$1.subVectors(c, a);
        _v1$3.subVectors(b, a);
        _v2$2.subVectors(point, a);
        var dot00 = _v0$1.dot(_v0$1);
        var dot01 = _v0$1.dot(_v1$3);
        var dot02 = _v0$1.dot(_v2$2);
        var dot11 = _v1$3.dot(_v1$3);
        var dot12 = _v1$3.dot(_v2$2);
        var denom = dot00 * dot11 - dot01 * dot01;

        // collinear or singular triangle
        if (denom === 0) {
          target.set(0, 0, 0);
          return null;
        }
        var invDenom = 1 / denom;
        var u = (dot11 * dot02 - dot01 * dot12) * invDenom;
        var v = (dot00 * dot12 - dot01 * dot02) * invDenom;

        // barycentric coordinates must always sum to 1
        return target.set(1 - u - v, v, u);
      }
    }, {
      key: "containsPoint",
      value: function containsPoint(point, a, b, c) {
        // if the triangle is degenerate then we can't contain a point
        if (this.getBarycoord(point, a, b, c, _v3$2) === null) {
          return false;
        }
        return _v3$2.x >= 0 && _v3$2.y >= 0 && _v3$2.x + _v3$2.y <= 1;
      }
    }, {
      key: "getInterpolation",
      value: function getInterpolation(point, p1, p2, p3, v1, v2, v3, target) {
        if (this.getBarycoord(point, p1, p2, p3, _v3$2) === null) {
          target.x = 0;
          target.y = 0;
          if ('z' in target) target.z = 0;
          if ('w' in target) target.w = 0;
          return null;
        }
        target.setScalar(0);
        target.addScaledVector(v1, _v3$2.x);
        target.addScaledVector(v2, _v3$2.y);
        target.addScaledVector(v3, _v3$2.z);
        return target;
      }
    }, {
      key: "getInterpolatedAttribute",
      value: function getInterpolatedAttribute(attr, i1, i2, i3, barycoord, target) {
        _v40.setScalar(0);
        _v41.setScalar(0);
        _v42.setScalar(0);
        _v40.fromBufferAttribute(attr, i1);
        _v41.fromBufferAttribute(attr, i2);
        _v42.fromBufferAttribute(attr, i3);
        target.setScalar(0);
        target.addScaledVector(_v40, barycoord.x);
        target.addScaledVector(_v41, barycoord.y);
        target.addScaledVector(_v42, barycoord.z);
        return target;
      }
    }, {
      key: "isFrontFacing",
      value: function isFrontFacing(a, b, c, direction) {
        _v0$1.subVectors(c, b);
        _v1$3.subVectors(a, b);

        // strictly front facing
        return _v0$1.cross(_v1$3).dot(direction) < 0 ? true : false;
      }
    }]);
  }();
  var _colorKeywords = {
    'aliceblue': 0xF0F8FF,
    'antiquewhite': 0xFAEBD7,
    'aqua': 0x00FFFF,
    'aquamarine': 0x7FFFD4,
    'azure': 0xF0FFFF,
    'beige': 0xF5F5DC,
    'bisque': 0xFFE4C4,
    'black': 0x000000,
    'blanchedalmond': 0xFFEBCD,
    'blue': 0x0000FF,
    'blueviolet': 0x8A2BE2,
    'brown': 0xA52A2A,
    'burlywood': 0xDEB887,
    'cadetblue': 0x5F9EA0,
    'chartreuse': 0x7FFF00,
    'chocolate': 0xD2691E,
    'coral': 0xFF7F50,
    'cornflowerblue': 0x6495ED,
    'cornsilk': 0xFFF8DC,
    'crimson': 0xDC143C,
    'cyan': 0x00FFFF,
    'darkblue': 0x00008B,
    'darkcyan': 0x008B8B,
    'darkgoldenrod': 0xB8860B,
    'darkgray': 0xA9A9A9,
    'darkgreen': 0x006400,
    'darkgrey': 0xA9A9A9,
    'darkkhaki': 0xBDB76B,
    'darkmagenta': 0x8B008B,
    'darkolivegreen': 0x556B2F,
    'darkorange': 0xFF8C00,
    'darkorchid': 0x9932CC,
    'darkred': 0x8B0000,
    'darksalmon': 0xE9967A,
    'darkseagreen': 0x8FBC8F,
    'darkslateblue': 0x483D8B,
    'darkslategray': 0x2F4F4F,
    'darkslategrey': 0x2F4F4F,
    'darkturquoise': 0x00CED1,
    'darkviolet': 0x9400D3,
    'deeppink': 0xFF1493,
    'deepskyblue': 0x00BFFF,
    'dimgray': 0x696969,
    'dimgrey': 0x696969,
    'dodgerblue': 0x1E90FF,
    'firebrick': 0xB22222,
    'floralwhite': 0xFFFAF0,
    'forestgreen': 0x228B22,
    'fuchsia': 0xFF00FF,
    'gainsboro': 0xDCDCDC,
    'ghostwhite': 0xF8F8FF,
    'gold': 0xFFD700,
    'goldenrod': 0xDAA520,
    'gray': 0x808080,
    'green': 0x008000,
    'greenyellow': 0xADFF2F,
    'grey': 0x808080,
    'honeydew': 0xF0FFF0,
    'hotpink': 0xFF69B4,
    'indianred': 0xCD5C5C,
    'indigo': 0x4B0082,
    'ivory': 0xFFFFF0,
    'khaki': 0xF0E68C,
    'lavender': 0xE6E6FA,
    'lavenderblush': 0xFFF0F5,
    'lawngreen': 0x7CFC00,
    'lemonchiffon': 0xFFFACD,
    'lightblue': 0xADD8E6,
    'lightcoral': 0xF08080,
    'lightcyan': 0xE0FFFF,
    'lightgoldenrodyellow': 0xFAFAD2,
    'lightgray': 0xD3D3D3,
    'lightgreen': 0x90EE90,
    'lightgrey': 0xD3D3D3,
    'lightpink': 0xFFB6C1,
    'lightsalmon': 0xFFA07A,
    'lightseagreen': 0x20B2AA,
    'lightskyblue': 0x87CEFA,
    'lightslategray': 0x778899,
    'lightslategrey': 0x778899,
    'lightsteelblue': 0xB0C4DE,
    'lightyellow': 0xFFFFE0,
    'lime': 0x00FF00,
    'limegreen': 0x32CD32,
    'linen': 0xFAF0E6,
    'magenta': 0xFF00FF,
    'maroon': 0x800000,
    'mediumaquamarine': 0x66CDAA,
    'mediumblue': 0x0000CD,
    'mediumorchid': 0xBA55D3,
    'mediumpurple': 0x9370DB,
    'mediumseagreen': 0x3CB371,
    'mediumslateblue': 0x7B68EE,
    'mediumspringgreen': 0x00FA9A,
    'mediumturquoise': 0x48D1CC,
    'mediumvioletred': 0xC71585,
    'midnightblue': 0x191970,
    'mintcream': 0xF5FFFA,
    'mistyrose': 0xFFE4E1,
    'moccasin': 0xFFE4B5,
    'navajowhite': 0xFFDEAD,
    'navy': 0x000080,
    'oldlace': 0xFDF5E6,
    'olive': 0x808000,
    'olivedrab': 0x6B8E23,
    'orange': 0xFFA500,
    'orangered': 0xFF4500,
    'orchid': 0xDA70D6,
    'palegoldenrod': 0xEEE8AA,
    'palegreen': 0x98FB98,
    'paleturquoise': 0xAFEEEE,
    'palevioletred': 0xDB7093,
    'papayawhip': 0xFFEFD5,
    'peachpuff': 0xFFDAB9,
    'peru': 0xCD853F,
    'pink': 0xFFC0CB,
    'plum': 0xDDA0DD,
    'powderblue': 0xB0E0E6,
    'purple': 0x800080,
    'rebeccapurple': 0x663399,
    'red': 0xFF0000,
    'rosybrown': 0xBC8F8F,
    'royalblue': 0x4169E1,
    'saddlebrown': 0x8B4513,
    'salmon': 0xFA8072,
    'sandybrown': 0xF4A460,
    'seagreen': 0x2E8B57,
    'seashell': 0xFFF5EE,
    'sienna': 0xA0522D,
    'silver': 0xC0C0C0,
    'skyblue': 0x87CEEB,
    'slateblue': 0x6A5ACD,
    'slategray': 0x708090,
    'slategrey': 0x708090,
    'snow': 0xFFFAFA,
    'springgreen': 0x00FF7F,
    'steelblue': 0x4682B4,
    'tan': 0xD2B48C,
    'teal': 0x008080,
    'thistle': 0xD8BFD8,
    'tomato': 0xFF6347,
    'turquoise': 0x40E0D0,
    'violet': 0xEE82EE,
    'wheat': 0xF5DEB3,
    'white': 0xFFFFFF,
    'whitesmoke': 0xF5F5F5,
    'yellow': 0xFFFF00,
    'yellowgreen': 0x9ACD32
  };
  var _hslA = {
    h: 0,
    s: 0,
    l: 0
  };
  var _hslB = {
    h: 0,
    s: 0,
    l: 0
  };
  function hue2rgb(p, q, t) {
    if (t < 0) t += 1;
    if (t > 1) t -= 1;
    if (t < 1 / 6) return p + (q - p) * 6 * t;
    if (t < 1 / 2) return q;
    if (t < 2 / 3) return p + (q - p) * 6 * (2 / 3 - t);
    return p;
  }
  var Color = exports.Color = /*#__PURE__*/function () {
    function Color(r, g, b) {
      (0, _classCallCheck2.default)(this, Color);
      this.isColor = true;
      this.r = 1;
      this.g = 1;
      this.b = 1;
      return this.set(r, g, b);
    }
    return (0, _createClass2.default)(Color, [{
      key: "set",
      value: function set(r, g, b) {
        if (g === undefined && b === undefined) {
          // r is THREE.Color, hex or string

          var value = r;
          if (value && value.isColor) {
            this.copy(value);
          } else if (typeof value === 'number') {
            this.setHex(value);
          } else if (typeof value === 'string') {
            this.setStyle(value);
          }
        } else {
          this.setRGB(r, g, b);
        }
        return this;
      }
    }, {
      key: "setScalar",
      value: function setScalar(scalar) {
        this.r = scalar;
        this.g = scalar;
        this.b = scalar;
        return this;
      }
    }, {
      key: "setHex",
      value: function setHex(hex) {
        var colorSpace = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : SRGBColorSpace;
        hex = Math.floor(hex);
        this.r = (hex >> 16 & 255) / 255;
        this.g = (hex >> 8 & 255) / 255;
        this.b = (hex & 255) / 255;
        ColorManagement.toWorkingColorSpace(this, colorSpace);
        return this;
      }
    }, {
      key: "setRGB",
      value: function setRGB(r, g, b) {
        var colorSpace = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : ColorManagement.workingColorSpace;
        this.r = r;
        this.g = g;
        this.b = b;
        ColorManagement.toWorkingColorSpace(this, colorSpace);
        return this;
      }
    }, {
      key: "setHSL",
      value: function setHSL(h, s, l) {
        var colorSpace = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : ColorManagement.workingColorSpace;
        // h,s,l ranges are in 0.0 - 1.0
        h = euclideanModulo(h, 1);
        s = _clamp(s, 0, 1);
        l = _clamp(l, 0, 1);
        if (s === 0) {
          this.r = this.g = this.b = l;
        } else {
          var p = l <= 0.5 ? l * (1 + s) : l + s - l * s;
          var q = 2 * l - p;
          this.r = hue2rgb(q, p, h + 1 / 3);
          this.g = hue2rgb(q, p, h);
          this.b = hue2rgb(q, p, h - 1 / 3);
        }
        ColorManagement.toWorkingColorSpace(this, colorSpace);
        return this;
      }
    }, {
      key: "setStyle",
      value: function setStyle(style) {
        var colorSpace = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : SRGBColorSpace;
        function handleAlpha(string) {
          if (string === undefined) return;
          if (parseFloat(string) < 1) {
            console.warn('THREE.Color: Alpha component of ' + style + ' will be ignored.');
          }
        }
        var m;
        if (m = /^(\w+)\(([^\)]*)\)/.exec(style)) {
          // rgb / hsl

          var color;
          var name = m[1];
          var components = m[2];
          switch (name) {
            case 'rgb':
            case 'rgba':
              if (color = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components)) {
                // rgb(255,0,0) rgba(255,0,0,0.5)

                handleAlpha(color[4]);
                return this.setRGB(Math.min(255, parseInt(color[1], 10)) / 255, Math.min(255, parseInt(color[2], 10)) / 255, Math.min(255, parseInt(color[3], 10)) / 255, colorSpace);
              }
              if (color = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components)) {
                // rgb(100%,0%,0%) rgba(100%,0%,0%,0.5)

                handleAlpha(color[4]);
                return this.setRGB(Math.min(100, parseInt(color[1], 10)) / 100, Math.min(100, parseInt(color[2], 10)) / 100, Math.min(100, parseInt(color[3], 10)) / 100, colorSpace);
              }
              break;
            case 'hsl':
            case 'hsla':
              if (color = /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components)) {
                // hsl(120,50%,50%) hsla(120,50%,50%,0.5)

                handleAlpha(color[4]);
                return this.setHSL(parseFloat(color[1]) / 360, parseFloat(color[2]) / 100, parseFloat(color[3]) / 100, colorSpace);
              }
              break;
            default:
              console.warn('THREE.Color: Unknown color model ' + style);
          }
        } else if (m = /^\#([A-Fa-f\d]+)$/.exec(style)) {
          // hex color

          var hex = m[1];
          var size = hex.length;
          if (size === 3) {
            // #ff0
            return this.setRGB(parseInt(hex.charAt(0), 16) / 15, parseInt(hex.charAt(1), 16) / 15, parseInt(hex.charAt(2), 16) / 15, colorSpace);
          } else if (size === 6) {
            // #ff0000
            return this.setHex(parseInt(hex, 16), colorSpace);
          } else {
            console.warn('THREE.Color: Invalid hex color ' + style);
          }
        } else if (style && style.length > 0) {
          return this.setColorName(style, colorSpace);
        }
        return this;
      }
    }, {
      key: "setColorName",
      value: function setColorName(style) {
        var colorSpace = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : SRGBColorSpace;
        // color keywords
        var hex = _colorKeywords[style.toLowerCase()];
        if (hex !== undefined) {
          // red
          this.setHex(hex, colorSpace);
        } else {
          // unknown color
          console.warn('THREE.Color: Unknown color ' + style);
        }
        return this;
      }
    }, {
      key: "clone",
      value: function clone() {
        return new this.constructor(this.r, this.g, this.b);
      }
    }, {
      key: "copy",
      value: function copy(color) {
        this.r = color.r;
        this.g = color.g;
        this.b = color.b;
        return this;
      }
    }, {
      key: "copySRGBToLinear",
      value: function copySRGBToLinear(color) {
        this.r = SRGBToLinear(color.r);
        this.g = SRGBToLinear(color.g);
        this.b = SRGBToLinear(color.b);
        return this;
      }
    }, {
      key: "copyLinearToSRGB",
      value: function copyLinearToSRGB(color) {
        this.r = LinearToSRGB(color.r);
        this.g = LinearToSRGB(color.g);
        this.b = LinearToSRGB(color.b);
        return this;
      }
    }, {
      key: "convertSRGBToLinear",
      value: function convertSRGBToLinear() {
        this.copySRGBToLinear(this);
        return this;
      }
    }, {
      key: "convertLinearToSRGB",
      value: function convertLinearToSRGB() {
        this.copyLinearToSRGB(this);
        return this;
      }
    }, {
      key: "getHex",
      value: function getHex() {
        var colorSpace = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : SRGBColorSpace;
        ColorManagement.fromWorkingColorSpace(_color.copy(this), colorSpace);
        return Math.round(_clamp(_color.r * 255, 0, 255)) * 65536 + Math.round(_clamp(_color.g * 255, 0, 255)) * 256 + Math.round(_clamp(_color.b * 255, 0, 255));
      }
    }, {
      key: "getHexString",
      value: function getHexString() {
        var colorSpace = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : SRGBColorSpace;
        return ('000000' + this.getHex(colorSpace).toString(16)).slice(-6);
      }
    }, {
      key: "getHSL",
      value: function getHSL(target) {
        var colorSpace = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ColorManagement.workingColorSpace;
        // h,s,l ranges are in 0.0 - 1.0

        ColorManagement.fromWorkingColorSpace(_color.copy(this), colorSpace);
        var r = _color.r,
          g = _color.g,
          b = _color.b;
        var max = Math.max(r, g, b);
        var min = Math.min(r, g, b);
        var hue, saturation;
        var lightness = (min + max) / 2.0;
        if (min === max) {
          hue = 0;
          saturation = 0;
        } else {
          var delta = max - min;
          saturation = lightness <= 0.5 ? delta / (max + min) : delta / (2 - max - min);
          switch (max) {
            case r:
              hue = (g - b) / delta + (g < b ? 6 : 0);
              break;
            case g:
              hue = (b - r) / delta + 2;
              break;
            case b:
              hue = (r - g) / delta + 4;
              break;
          }
          hue /= 6;
        }
        target.h = hue;
        target.s = saturation;
        target.l = lightness;
        return target;
      }
    }, {
      key: "getRGB",
      value: function getRGB(target) {
        var colorSpace = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ColorManagement.workingColorSpace;
        ColorManagement.fromWorkingColorSpace(_color.copy(this), colorSpace);
        target.r = _color.r;
        target.g = _color.g;
        target.b = _color.b;
        return target;
      }
    }, {
      key: "getStyle",
      value: function getStyle() {
        var colorSpace = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : SRGBColorSpace;
        ColorManagement.fromWorkingColorSpace(_color.copy(this), colorSpace);
        var r = _color.r,
          g = _color.g,
          b = _color.b;
        if (colorSpace !== SRGBColorSpace) {
          // Requires CSS Color Module Level 4 (https://www.w3.org/TR/css-color-4/).
          return `color(${colorSpace} ${r.toFixed(3)} ${g.toFixed(3)} ${b.toFixed(3)})`;
        }
        return `rgb(${Math.round(r * 255)},${Math.round(g * 255)},${Math.round(b * 255)})`;
      }
    }, {
      key: "offsetHSL",
      value: function offsetHSL(h, s, l) {
        this.getHSL(_hslA);
        return this.setHSL(_hslA.h + h, _hslA.s + s, _hslA.l + l);
      }
    }, {
      key: "add",
      value: function add(color) {
        this.r += color.r;
        this.g += color.g;
        this.b += color.b;
        return this;
      }
    }, {
      key: "addColors",
      value: function addColors(color1, color2) {
        this.r = color1.r + color2.r;
        this.g = color1.g + color2.g;
        this.b = color1.b + color2.b;
        return this;
      }
    }, {
      key: "addScalar",
      value: function addScalar(s) {
        this.r += s;
        this.g += s;
        this.b += s;
        return this;
      }
    }, {
      key: "sub",
      value: function sub(color) {
        this.r = Math.max(0, this.r - color.r);
        this.g = Math.max(0, this.g - color.g);
        this.b = Math.max(0, this.b - color.b);
        return this;
      }
    }, {
      key: "multiply",
      value: function multiply(color) {
        this.r *= color.r;
        this.g *= color.g;
        this.b *= color.b;
        return this;
      }
    }, {
      key: "multiplyScalar",
      value: function multiplyScalar(s) {
        this.r *= s;
        this.g *= s;
        this.b *= s;
        return this;
      }
    }, {
      key: "lerp",
      value: function lerp(color, alpha) {
        this.r += (color.r - this.r) * alpha;
        this.g += (color.g - this.g) * alpha;
        this.b += (color.b - this.b) * alpha;
        return this;
      }
    }, {
      key: "lerpColors",
      value: function lerpColors(color1, color2, alpha) {
        this.r = color1.r + (color2.r - color1.r) * alpha;
        this.g = color1.g + (color2.g - color1.g) * alpha;
        this.b = color1.b + (color2.b - color1.b) * alpha;
        return this;
      }
    }, {
      key: "lerpHSL",
      value: function lerpHSL(color, alpha) {
        this.getHSL(_hslA);
        color.getHSL(_hslB);
        var h = lerp(_hslA.h, _hslB.h, alpha);
        var s = lerp(_hslA.s, _hslB.s, alpha);
        var l = lerp(_hslA.l, _hslB.l, alpha);
        this.setHSL(h, s, l);
        return this;
      }
    }, {
      key: "setFromVector3",
      value: function setFromVector3(v) {
        this.r = v.x;
        this.g = v.y;
        this.b = v.z;
        return this;
      }
    }, {
      key: "applyMatrix3",
      value: function applyMatrix3(m) {
        var r = this.r,
          g = this.g,
          b = this.b;
        var e = m.elements;
        this.r = e[0] * r + e[3] * g + e[6] * b;
        this.g = e[1] * r + e[4] * g + e[7] * b;
        this.b = e[2] * r + e[5] * g + e[8] * b;
        return this;
      }
    }, {
      key: "equals",
      value: function equals(c) {
        return c.r === this.r && c.g === this.g && c.b === this.b;
      }
    }, {
      key: "fromArray",
      value: function fromArray(array) {
        var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        this.r = array[offset];
        this.g = array[offset + 1];
        this.b = array[offset + 2];
        return this;
      }
    }, {
      key: "toArray",
      value: function toArray() {
        var array = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
        var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        array[offset] = this.r;
        array[offset + 1] = this.g;
        array[offset + 2] = this.b;
        return array;
      }
    }, {
      key: "fromBufferAttribute",
      value: function fromBufferAttribute(attribute, index) {
        this.r = attribute.getX(index);
        this.g = attribute.getY(index);
        this.b = attribute.getZ(index);
        return this;
      }
    }, {
      key: "toJSON",
      value: function toJSON() {
        return this.getHex();
      }
    }, {
      key: Symbol.iterator,
      value: function* value() {
        yield this.r;
        yield this.g;
        yield this.b;
      }
    }]);
  }();
  var _color = /*@__PURE__*/new Color();
  Color.NAMES = _colorKeywords;
  var _materialId = 0;
  var Material = exports.Material = /*#__PURE__*/function (_EventDispatcher4) {
    function Material() {
      var _this9;
      (0, _classCallCheck2.default)(this, Material);
      _this9 = _callSuper(this, Material);
      _this9.isMaterial = true;
      Object.defineProperty(_this9, 'id', {
        value: _materialId++
      });
      _this9.uuid = generateUUID();
      _this9.name = '';
      _this9.type = 'Material';
      _this9.blending = NormalBlending;
      _this9.side = FrontSide;
      _this9.vertexColors = false;
      _this9.opacity = 1;
      _this9.transparent = false;
      _this9.alphaHash = false;
      _this9.blendSrc = SrcAlphaFactor;
      _this9.blendDst = OneMinusSrcAlphaFactor;
      _this9.blendEquation = AddEquation;
      _this9.blendSrcAlpha = null;
      _this9.blendDstAlpha = null;
      _this9.blendEquationAlpha = null;
      _this9.blendColor = new Color(0, 0, 0);
      _this9.blendAlpha = 0;
      _this9.depthFunc = LessEqualDepth;
      _this9.depthTest = true;
      _this9.depthWrite = true;
      _this9.stencilWriteMask = 0xff;
      _this9.stencilFunc = AlwaysStencilFunc;
      _this9.stencilRef = 0;
      _this9.stencilFuncMask = 0xff;
      _this9.stencilFail = KeepStencilOp;
      _this9.stencilZFail = KeepStencilOp;
      _this9.stencilZPass = KeepStencilOp;
      _this9.stencilWrite = false;
      _this9.clippingPlanes = null;
      _this9.clipIntersection = false;
      _this9.clipShadows = false;
      _this9.shadowSide = null;
      _this9.colorWrite = true;
      _this9.precision = null; // override the renderer's default precision for this material

      _this9.polygonOffset = false;
      _this9.polygonOffsetFactor = 0;
      _this9.polygonOffsetUnits = 0;
      _this9.dithering = false;
      _this9.alphaToCoverage = false;
      _this9.premultipliedAlpha = false;
      _this9.forceSinglePass = false;
      _this9.visible = true;
      _this9.toneMapped = true;
      _this9.userData = {};
      _this9.version = 0;
      _this9._alphaTest = 0;
      return _this9;
    }
    (0, _inherits2.default)(Material, _EventDispatcher4);
    return (0, _createClass2.default)(Material, [{
      key: "alphaTest",
      get: function get() {
        return this._alphaTest;
      },
      set: function set(value) {
        if (this._alphaTest > 0 !== value > 0) {
          this.version++;
        }
        this._alphaTest = value;
      }

      // onBeforeRender and onBeforeCompile only supported in WebGLRenderer
    }, {
      key: "onBeforeRender",
      value: function onBeforeRender(/* renderer, scene, camera, geometry, object, group */) {}
    }, {
      key: "onBeforeCompile",
      value: function onBeforeCompile(/* shaderobject, renderer */) {}
    }, {
      key: "customProgramCacheKey",
      value: function customProgramCacheKey() {
        return this.onBeforeCompile.toString();
      }
    }, {
      key: "setValues",
      value: function setValues(values) {
        if (values === undefined) return;
        for (var key in values) {
          var newValue = values[key];
          if (newValue === undefined) {
            console.warn(`THREE.Material: parameter '${key}' has value of undefined.`);
            continue;
          }
          var currentValue = this[key];
          if (currentValue === undefined) {
            console.warn(`THREE.Material: '${key}' is not a property of THREE.${this.type}.`);
            continue;
          }
          if (currentValue && currentValue.isColor) {
            currentValue.set(newValue);
          } else if (currentValue && currentValue.isVector3 && newValue && newValue.isVector3) {
            currentValue.copy(newValue);
          } else {
            this[key] = newValue;
          }
        }
      }
    }, {
      key: "toJSON",
      value: function toJSON(meta) {
        var isRootObject = meta === undefined || typeof meta === 'string';
        if (isRootObject) {
          meta = {
            textures: {},
            images: {}
          };
        }
        var data = {
          metadata: {
            version: 4.6,
            type: 'Material',
            generator: 'Material.toJSON'
          }
        };

        // standard Material serialization
        data.uuid = this.uuid;
        data.type = this.type;
        if (this.name !== '') data.name = this.name;
        if (this.color && this.color.isColor) data.color = this.color.getHex();
        if (this.roughness !== undefined) data.roughness = this.roughness;
        if (this.metalness !== undefined) data.metalness = this.metalness;
        if (this.sheen !== undefined) data.sheen = this.sheen;
        if (this.sheenColor && this.sheenColor.isColor) data.sheenColor = this.sheenColor.getHex();
        if (this.sheenRoughness !== undefined) data.sheenRoughness = this.sheenRoughness;
        if (this.emissive && this.emissive.isColor) data.emissive = this.emissive.getHex();
        if (this.emissiveIntensity !== undefined && this.emissiveIntensity !== 1) data.emissiveIntensity = this.emissiveIntensity;
        if (this.specular && this.specular.isColor) data.specular = this.specular.getHex();
        if (this.specularIntensity !== undefined) data.specularIntensity = this.specularIntensity;
        if (this.specularColor && this.specularColor.isColor) data.specularColor = this.specularColor.getHex();
        if (this.shininess !== undefined) data.shininess = this.shininess;
        if (this.clearcoat !== undefined) data.clearcoat = this.clearcoat;
        if (this.clearcoatRoughness !== undefined) data.clearcoatRoughness = this.clearcoatRoughness;
        if (this.clearcoatMap && this.clearcoatMap.isTexture) {
          data.clearcoatMap = this.clearcoatMap.toJSON(meta).uuid;
        }
        if (this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture) {
          data.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(meta).uuid;
        }
        if (this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture) {
          data.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(meta).uuid;
          data.clearcoatNormalScale = this.clearcoatNormalScale.toArray();
        }
        if (this.dispersion !== undefined) data.dispersion = this.dispersion;
        if (this.iridescence !== undefined) data.iridescence = this.iridescence;
        if (this.iridescenceIOR !== undefined) data.iridescenceIOR = this.iridescenceIOR;
        if (this.iridescenceThicknessRange !== undefined) data.iridescenceThicknessRange = this.iridescenceThicknessRange;
        if (this.iridescenceMap && this.iridescenceMap.isTexture) {
          data.iridescenceMap = this.iridescenceMap.toJSON(meta).uuid;
        }
        if (this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture) {
          data.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON(meta).uuid;
        }
        if (this.anisotropy !== undefined) data.anisotropy = this.anisotropy;
        if (this.anisotropyRotation !== undefined) data.anisotropyRotation = this.anisotropyRotation;
        if (this.anisotropyMap && this.anisotropyMap.isTexture) {
          data.anisotropyMap = this.anisotropyMap.toJSON(meta).uuid;
        }
        if (this.map && this.map.isTexture) data.map = this.map.toJSON(meta).uuid;
        if (this.matcap && this.matcap.isTexture) data.matcap = this.matcap.toJSON(meta).uuid;
        if (this.alphaMap && this.alphaMap.isTexture) data.alphaMap = this.alphaMap.toJSON(meta).uuid;
        if (this.lightMap && this.lightMap.isTexture) {
          data.lightMap = this.lightMap.toJSON(meta).uuid;
          data.lightMapIntensity = this.lightMapIntensity;
        }
        if (this.aoMap && this.aoMap.isTexture) {
          data.aoMap = this.aoMap.toJSON(meta).uuid;
          data.aoMapIntensity = this.aoMapIntensity;
        }
        if (this.bumpMap && this.bumpMap.isTexture) {
          data.bumpMap = this.bumpMap.toJSON(meta).uuid;
          data.bumpScale = this.bumpScale;
        }
        if (this.normalMap && this.normalMap.isTexture) {
          data.normalMap = this.normalMap.toJSON(meta).uuid;
          data.normalMapType = this.normalMapType;
          data.normalScale = this.normalScale.toArray();
        }
        if (this.displacementMap && this.displacementMap.isTexture) {
          data.displacementMap = this.displacementMap.toJSON(meta).uuid;
          data.displacementScale = this.displacementScale;
          data.displacementBias = this.displacementBias;
        }
        if (this.roughnessMap && this.roughnessMap.isTexture) data.roughnessMap = this.roughnessMap.toJSON(meta).uuid;
        if (this.metalnessMap && this.metalnessMap.isTexture) data.metalnessMap = this.metalnessMap.toJSON(meta).uuid;
        if (this.emissiveMap && this.emissiveMap.isTexture) data.emissiveMap = this.emissiveMap.toJSON(meta).uuid;
        if (this.specularMap && this.specularMap.isTexture) data.specularMap = this.specularMap.toJSON(meta).uuid;
        if (this.specularIntensityMap && this.specularIntensityMap.isTexture) data.specularIntensityMap = this.specularIntensityMap.toJSON(meta).uuid;
        if (this.specularColorMap && this.specularColorMap.isTexture) data.specularColorMap = this.specularColorMap.toJSON(meta).uuid;
        if (this.envMap && this.envMap.isTexture) {
          data.envMap = this.envMap.toJSON(meta).uuid;
          if (this.combine !== undefined) data.combine = this.combine;
        }
        if (this.envMapRotation !== undefined) data.envMapRotation = this.envMapRotation.toArray();
        if (this.envMapIntensity !== undefined) data.envMapIntensity = this.envMapIntensity;
        if (this.reflectivity !== undefined) data.reflectivity = this.reflectivity;
        if (this.refractionRatio !== undefined) data.refractionRatio = this.refractionRatio;
        if (this.gradientMap && this.gradientMap.isTexture) {
          data.gradientMap = this.gradientMap.toJSON(meta).uuid;
        }
        if (this.transmission !== undefined) data.transmission = this.transmission;
        if (this.transmissionMap && this.transmissionMap.isTexture) data.transmissionMap = this.transmissionMap.toJSON(meta).uuid;
        if (this.thickness !== undefined) data.thickness = this.thickness;
        if (this.thicknessMap && this.thicknessMap.isTexture) data.thicknessMap = this.thicknessMap.toJSON(meta).uuid;
        if (this.attenuationDistance !== undefined && this.attenuationDistance !== Infinity) data.attenuationDistance = this.attenuationDistance;
        if (this.attenuationColor !== undefined) data.attenuationColor = this.attenuationColor.getHex();
        if (this.size !== undefined) data.size = this.size;
        if (this.shadowSide !== null) data.shadowSide = this.shadowSide;
        if (this.sizeAttenuation !== undefined) data.sizeAttenuation = this.sizeAttenuation;
        if (this.blending !== NormalBlending) data.blending = this.blending;
        if (this.side !== FrontSide) data.side = this.side;
        if (this.vertexColors === true) data.vertexColors = true;
        if (this.opacity < 1) data.opacity = this.opacity;
        if (this.transparent === true) data.transparent = true;
        if (this.blendSrc !== SrcAlphaFactor) data.blendSrc = this.blendSrc;
        if (this.blendDst !== OneMinusSrcAlphaFactor) data.blendDst = this.blendDst;
        if (this.blendEquation !== AddEquation) data.blendEquation = this.blendEquation;
        if (this.blendSrcAlpha !== null) data.blendSrcAlpha = this.blendSrcAlpha;
        if (this.blendDstAlpha !== null) data.blendDstAlpha = this.blendDstAlpha;
        if (this.blendEquationAlpha !== null) data.blendEquationAlpha = this.blendEquationAlpha;
        if (this.blendColor && this.blendColor.isColor) data.blendColor = this.blendColor.getHex();
        if (this.blendAlpha !== 0) data.blendAlpha = this.blendAlpha;
        if (this.depthFunc !== LessEqualDepth) data.depthFunc = this.depthFunc;
        if (this.depthTest === false) data.depthTest = this.depthTest;
        if (this.depthWrite === false) data.depthWrite = this.depthWrite;
        if (this.colorWrite === false) data.colorWrite = this.colorWrite;
        if (this.stencilWriteMask !== 0xff) data.stencilWriteMask = this.stencilWriteMask;
        if (this.stencilFunc !== AlwaysStencilFunc) data.stencilFunc = this.stencilFunc;
        if (this.stencilRef !== 0) data.stencilRef = this.stencilRef;
        if (this.stencilFuncMask !== 0xff) data.stencilFuncMask = this.stencilFuncMask;
        if (this.stencilFail !== KeepStencilOp) data.stencilFail = this.stencilFail;
        if (this.stencilZFail !== KeepStencilOp) data.stencilZFail = this.stencilZFail;
        if (this.stencilZPass !== KeepStencilOp) data.stencilZPass = this.stencilZPass;
        if (this.stencilWrite === true) data.stencilWrite = this.stencilWrite;

        // rotation (SpriteMaterial)
        if (this.rotation !== undefined && this.rotation !== 0) data.rotation = this.rotation;
        if (this.polygonOffset === true) data.polygonOffset = true;
        if (this.polygonOffsetFactor !== 0) data.polygonOffsetFactor = this.polygonOffsetFactor;
        if (this.polygonOffsetUnits !== 0) data.polygonOffsetUnits = this.polygonOffsetUnits;
        if (this.linewidth !== undefined && this.linewidth !== 1) data.linewidth = this.linewidth;
        if (this.dashSize !== undefined) data.dashSize = this.dashSize;
        if (this.gapSize !== undefined) data.gapSize = this.gapSize;
        if (this.scale !== undefined) data.scale = this.scale;
        if (this.dithering === true) data.dithering = true;
        if (this.alphaTest > 0) data.alphaTest = this.alphaTest;
        if (this.alphaHash === true) data.alphaHash = true;
        if (this.alphaToCoverage === true) data.alphaToCoverage = true;
        if (this.premultipliedAlpha === true) data.premultipliedAlpha = true;
        if (this.forceSinglePass === true) data.forceSinglePass = true;
        if (this.wireframe === true) data.wireframe = true;
        if (this.wireframeLinewidth > 1) data.wireframeLinewidth = this.wireframeLinewidth;
        if (this.wireframeLinecap !== 'round') data.wireframeLinecap = this.wireframeLinecap;
        if (this.wireframeLinejoin !== 'round') data.wireframeLinejoin = this.wireframeLinejoin;
        if (this.flatShading === true) data.flatShading = true;
        if (this.visible === false) data.visible = false;
        if (this.toneMapped === false) data.toneMapped = false;
        if (this.fog === false) data.fog = false;
        if (Object.keys(this.userData).length > 0) data.userData = this.userData;

        // TODO: Copied from Object3D.toJSON

        function extractFromCache(cache) {
          var values = [];
          for (var key in cache) {
            var _data2 = cache[key];
            delete _data2.metadata;
            values.push(_data2);
          }
          return values;
        }
        if (isRootObject) {
          var textures = extractFromCache(meta.textures);
          var images = extractFromCache(meta.images);
          if (textures.length > 0) data.textures = textures;
          if (images.length > 0) data.images = images;
        }
        return data;
      }
    }, {
      key: "clone",
      value: function clone() {
        return new this.constructor().copy(this);
      }
    }, {
      key: "copy",
      value: function copy(source) {
        this.name = source.name;
        this.blending = source.blending;
        this.side = source.side;
        this.vertexColors = source.vertexColors;
        this.opacity = source.opacity;
        this.transparent = source.transparent;
        this.blendSrc = source.blendSrc;
        this.blendDst = source.blendDst;
        this.blendEquation = source.blendEquation;
        this.blendSrcAlpha = source.blendSrcAlpha;
        this.blendDstAlpha = source.blendDstAlpha;
        this.blendEquationAlpha = source.blendEquationAlpha;
        this.blendColor.copy(source.blendColor);
        this.blendAlpha = source.blendAlpha;
        this.depthFunc = source.depthFunc;
        this.depthTest = source.depthTest;
        this.depthWrite = source.depthWrite;
        this.stencilWriteMask = source.stencilWriteMask;
        this.stencilFunc = source.stencilFunc;
        this.stencilRef = source.stencilRef;
        this.stencilFuncMask = source.stencilFuncMask;
        this.stencilFail = source.stencilFail;
        this.stencilZFail = source.stencilZFail;
        this.stencilZPass = source.stencilZPass;
        this.stencilWrite = source.stencilWrite;
        var srcPlanes = source.clippingPlanes;
        var dstPlanes = null;
        if (srcPlanes !== null) {
          var n = srcPlanes.length;
          dstPlanes = new Array(n);
          for (var i = 0; i !== n; ++i) {
            dstPlanes[i] = srcPlanes[i].clone();
          }
        }
        this.clippingPlanes = dstPlanes;
        this.clipIntersection = source.clipIntersection;
        this.clipShadows = source.clipShadows;
        this.shadowSide = source.shadowSide;
        this.colorWrite = source.colorWrite;
        this.precision = source.precision;
        this.polygonOffset = source.polygonOffset;
        this.polygonOffsetFactor = source.polygonOffsetFactor;
        this.polygonOffsetUnits = source.polygonOffsetUnits;
        this.dithering = source.dithering;
        this.alphaTest = source.alphaTest;
        this.alphaHash = source.alphaHash;
        this.alphaToCoverage = source.alphaToCoverage;
        this.premultipliedAlpha = source.premultipliedAlpha;
        this.forceSinglePass = source.forceSinglePass;
        this.visible = source.visible;
        this.toneMapped = source.toneMapped;
        this.userData = JSON.parse(JSON.stringify(source.userData));
        return this;
      }
    }, {
      key: "dispose",
      value: function dispose() {
        this.dispatchEvent({
          type: 'dispose'
        });
      }
    }, {
      key: "needsUpdate",
      set: function set(value) {
        if (value === true) this.version++;
      }
    }, {
      key: "onBuild",
      value: function onBuild(/* shaderobject, renderer */
      ) {
        console.warn('Material: onBuild() has been removed.'); // @deprecated, r166
      }
    }]);
  }(EventDispatcher);
  var MeshBasicMaterial = exports.MeshBasicMaterial = /*#__PURE__*/function (_Material) {
    function MeshBasicMaterial(parameters) {
      var _this10;
      (0, _classCallCheck2.default)(this, MeshBasicMaterial);
      _this10 = _callSuper(this, MeshBasicMaterial);
      _this10.isMeshBasicMaterial = true;
      _this10.type = 'MeshBasicMaterial';
      _this10.color = new Color(0xffffff); // emissive

      _this10.map = null;
      _this10.lightMap = null;
      _this10.lightMapIntensity = 1.0;
      _this10.aoMap = null;
      _this10.aoMapIntensity = 1.0;
      _this10.specularMap = null;
      _this10.alphaMap = null;
      _this10.envMap = null;
      _this10.envMapRotation = new Euler();
      _this10.combine = MultiplyOperation;
      _this10.reflectivity = 1;
      _this10.refractionRatio = 0.98;
      _this10.wireframe = false;
      _this10.wireframeLinewidth = 1;
      _this10.wireframeLinecap = 'round';
      _this10.wireframeLinejoin = 'round';
      _this10.fog = true;
      _this10.setValues(parameters);
      return _this10;
    }
    (0, _inherits2.default)(MeshBasicMaterial, _Material);
    return (0, _createClass2.default)(MeshBasicMaterial, [{
      key: "copy",
      value: function copy(source) {
        _superPropGet(MeshBasicMaterial, "copy", this, 3)([source]);
        this.color.copy(source.color);
        this.map = source.map;
        this.lightMap = source.lightMap;
        this.lightMapIntensity = source.lightMapIntensity;
        this.aoMap = source.aoMap;
        this.aoMapIntensity = source.aoMapIntensity;
        this.specularMap = source.specularMap;
        this.alphaMap = source.alphaMap;
        this.envMap = source.envMap;
        this.envMapRotation.copy(source.envMapRotation);
        this.combine = source.combine;
        this.reflectivity = source.reflectivity;
        this.refractionRatio = source.refractionRatio;
        this.wireframe = source.wireframe;
        this.wireframeLinewidth = source.wireframeLinewidth;
        this.wireframeLinecap = source.wireframeLinecap;
        this.wireframeLinejoin = source.wireframeLinejoin;
        this.fog = source.fog;
        return this;
      }
    }]);
  }(Material); // Fast Half Float Conversions, http://www.fox-toolkit.org/ftp/fasthalffloatconversion.pdf
  var _tables = /*@__PURE__*/_generateTables();
  function _generateTables() {
    // float32 to float16 helpers

    var buffer = new ArrayBuffer(4);
    var floatView = new Float32Array(buffer);
    var uint32View = new Uint32Array(buffer);
    var baseTable = new Uint32Array(512);
    var shiftTable = new Uint32Array(512);
    for (var i = 0; i < 256; ++i) {
      var e = i - 127;

      // very small number (0, -0)

      if (e < -27) {
        baseTable[i] = 0x0000;
        baseTable[i | 0x100] = 0x8000;
        shiftTable[i] = 24;
        shiftTable[i | 0x100] = 24;

        // small number (denorm)
      } else if (e < -14) {
        baseTable[i] = 0x0400 >> -e - 14;
        baseTable[i | 0x100] = 0x0400 >> -e - 14 | 0x8000;
        shiftTable[i] = -e - 1;
        shiftTable[i | 0x100] = -e - 1;

        // normal number
      } else if (e <= 15) {
        baseTable[i] = e + 15 << 10;
        baseTable[i | 0x100] = e + 15 << 10 | 0x8000;
        shiftTable[i] = 13;
        shiftTable[i | 0x100] = 13;

        // large number (Infinity, -Infinity)
      } else if (e < 128) {
        baseTable[i] = 0x7c00;
        baseTable[i | 0x100] = 0xfc00;
        shiftTable[i] = 24;
        shiftTable[i | 0x100] = 24;

        // stay (NaN, Infinity, -Infinity)
      } else {
        baseTable[i] = 0x7c00;
        baseTable[i | 0x100] = 0xfc00;
        shiftTable[i] = 13;
        shiftTable[i | 0x100] = 13;
      }
    }

    // float16 to float32 helpers

    var mantissaTable = new Uint32Array(2048);
    var exponentTable = new Uint32Array(64);
    var offsetTable = new Uint32Array(64);
    for (var _i6 = 1; _i6 < 1024; ++_i6) {
      var m = _i6 << 13; // zero pad mantissa bits
      var _e = 0; // zero exponent

      // normalized
      while ((m & 0x00800000) === 0) {
        m <<= 1;
        _e -= 0x00800000; // decrement exponent
      }
      m &= ~0x00800000; // clear leading 1 bit
      _e += 0x38800000; // adjust bias

      mantissaTable[_i6] = m | _e;
    }
    for (var _i7 = 1024; _i7 < 2048; ++_i7) {
      mantissaTable[_i7] = 0x38000000 + (_i7 - 1024 << 13);
    }
    for (var _i8 = 1; _i8 < 31; ++_i8) {
      exponentTable[_i8] = _i8 << 23;
    }
    exponentTable[31] = 0x47800000;
    exponentTable[32] = 0x80000000;
    for (var _i9 = 33; _i9 < 63; ++_i9) {
      exponentTable[_i9] = 0x80000000 + (_i9 - 32 << 23);
    }
    exponentTable[63] = 0xc7800000;
    for (var _i10 = 1; _i10 < 64; ++_i10) {
      if (_i10 !== 32) {
        offsetTable[_i10] = 1024;
      }
    }
    return {
      floatView: floatView,
      uint32View: uint32View,
      baseTable: baseTable,
      shiftTable: shiftTable,
      mantissaTable: mantissaTable,
      exponentTable: exponentTable,
      offsetTable: offsetTable
    };
  }

  // float32 to float16

  function toHalfFloat(val) {
    if (Math.abs(val) > 65504) console.warn('THREE.DataUtils.toHalfFloat(): Value out of range.');
    val = _clamp(val, -65504, 65504);
    _tables.floatView[0] = val;
    var f = _tables.uint32View[0];
    var e = f >> 23 & 0x1ff;
    return _tables.baseTable[e] + ((f & 0x007fffff) >> _tables.shiftTable[e]);
  }

  // float16 to float32

  function fromHalfFloat(val) {
    var m = val >> 10;
    _tables.uint32View[0] = _tables.mantissaTable[_tables.offsetTable[m] + (val & 0x3ff)] + _tables.exponentTable[m];
    return _tables.floatView[0];
  }
  var DataUtils = exports.DataUtils = {
    toHalfFloat: toHalfFloat,
    fromHalfFloat: fromHalfFloat
  };
  var _vector$9 = /*@__PURE__*/new Vector3();
  var _vector2$1 = /*@__PURE__*/new Vector2();
  var BufferAttribute = exports.BufferAttribute = /*#__PURE__*/function () {
    function BufferAttribute(array, itemSize) {
      var normalized = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      (0, _classCallCheck2.default)(this, BufferAttribute);
      if (Array.isArray(array)) {
        throw new TypeError('THREE.BufferAttribute: array should be a Typed Array.');
      }
      this.isBufferAttribute = true;
      this.name = '';
      this.array = array;
      this.itemSize = itemSize;
      this.count = array !== undefined ? array.length / itemSize : 0;
      this.normalized = normalized;
      this.usage = StaticDrawUsage;
      this.updateRanges = [];
      this.gpuType = FloatType;
      this.version = 0;
    }
    return (0, _createClass2.default)(BufferAttribute, [{
      key: "onUploadCallback",
      value: function onUploadCallback() {}
    }, {
      key: "needsUpdate",
      set: function set(value) {
        if (value === true) this.version++;
      }
    }, {
      key: "setUsage",
      value: function setUsage(value) {
        this.usage = value;
        return this;
      }
    }, {
      key: "addUpdateRange",
      value: function addUpdateRange(start, count) {
        this.updateRanges.push({
          start: start,
          count: count
        });
      }
    }, {
      key: "clearUpdateRanges",
      value: function clearUpdateRanges() {
        this.updateRanges.length = 0;
      }
    }, {
      key: "copy",
      value: function copy(source) {
        this.name = source.name;
        this.array = new source.array.constructor(source.array);
        this.itemSize = source.itemSize;
        this.count = source.count;
        this.normalized = source.normalized;
        this.usage = source.usage;
        this.gpuType = source.gpuType;
        return this;
      }
    }, {
      key: "copyAt",
      value: function copyAt(index1, attribute, index2) {
        index1 *= this.itemSize;
        index2 *= attribute.itemSize;
        for (var i = 0, l = this.itemSize; i < l; i++) {
          this.array[index1 + i] = attribute.array[index2 + i];
        }
        return this;
      }
    }, {
      key: "copyArray",
      value: function copyArray(array) {
        this.array.set(array);
        return this;
      }
    }, {
      key: "applyMatrix3",
      value: function applyMatrix3(m) {
        if (this.itemSize === 2) {
          for (var i = 0, l = this.count; i < l; i++) {
            _vector2$1.fromBufferAttribute(this, i);
            _vector2$1.applyMatrix3(m);
            this.setXY(i, _vector2$1.x, _vector2$1.y);
          }
        } else if (this.itemSize === 3) {
          for (var _i11 = 0, _l3 = this.count; _i11 < _l3; _i11++) {
            _vector$9.fromBufferAttribute(this, _i11);
            _vector$9.applyMatrix3(m);
            this.setXYZ(_i11, _vector$9.x, _vector$9.y, _vector$9.z);
          }
        }
        return this;
      }
    }, {
      key: "applyMatrix4",
      value: function applyMatrix4(m) {
        for (var i = 0, l = this.count; i < l; i++) {
          _vector$9.fromBufferAttribute(this, i);
          _vector$9.applyMatrix4(m);
          this.setXYZ(i, _vector$9.x, _vector$9.y, _vector$9.z);
        }
        return this;
      }
    }, {
      key: "applyNormalMatrix",
      value: function applyNormalMatrix(m) {
        for (var i = 0, l = this.count; i < l; i++) {
          _vector$9.fromBufferAttribute(this, i);
          _vector$9.applyNormalMatrix(m);
          this.setXYZ(i, _vector$9.x, _vector$9.y, _vector$9.z);
        }
        return this;
      }
    }, {
      key: "transformDirection",
      value: function transformDirection(m) {
        for (var i = 0, l = this.count; i < l; i++) {
          _vector$9.fromBufferAttribute(this, i);
          _vector$9.transformDirection(m);
          this.setXYZ(i, _vector$9.x, _vector$9.y, _vector$9.z);
        }
        return this;
      }
    }, {
      key: "set",
      value: function set(value) {
        var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        // Matching BufferAttribute constructor, do not normalize the array.
        this.array.set(value, offset);
        return this;
      }
    }, {
      key: "getComponent",
      value: function getComponent(index, component) {
        var value = this.array[index * this.itemSize + component];
        if (this.normalized) value = denormalize(value, this.array);
        return value;
      }
    }, {
      key: "setComponent",
      value: function setComponent(index, component, value) {
        if (this.normalized) value = normalize(value, this.array);
        this.array[index * this.itemSize + component] = value;
        return this;
      }
    }, {
      key: "getX",
      value: function getX(index) {
        var x = this.array[index * this.itemSize];
        if (this.normalized) x = denormalize(x, this.array);
        return x;
      }
    }, {
      key: "setX",
      value: function setX(index, x) {
        if (this.normalized) x = normalize(x, this.array);
        this.array[index * this.itemSize] = x;
        return this;
      }
    }, {
      key: "getY",
      value: function getY(index) {
        var y = this.array[index * this.itemSize + 1];
        if (this.normalized) y = denormalize(y, this.array);
        return y;
      }
    }, {
      key: "setY",
      value: function setY(index, y) {
        if (this.normalized) y = normalize(y, this.array);
        this.array[index * this.itemSize + 1] = y;
        return this;
      }
    }, {
      key: "getZ",
      value: function getZ(index) {
        var z = this.array[index * this.itemSize + 2];
        if (this.normalized) z = denormalize(z, this.array);
        return z;
      }
    }, {
      key: "setZ",
      value: function setZ(index, z) {
        if (this.normalized) z = normalize(z, this.array);
        this.array[index * this.itemSize + 2] = z;
        return this;
      }
    }, {
      key: "getW",
      value: function getW(index) {
        var w = this.array[index * this.itemSize + 3];
        if (this.normalized) w = denormalize(w, this.array);
        return w;
      }
    }, {
      key: "setW",
      value: function setW(index, w) {
        if (this.normalized) w = normalize(w, this.array);
        this.array[index * this.itemSize + 3] = w;
        return this;
      }
    }, {
      key: "setXY",
      value: function setXY(index, x, y) {
        index *= this.itemSize;
        if (this.normalized) {
          x = normalize(x, this.array);
          y = normalize(y, this.array);
        }
        this.array[index + 0] = x;
        this.array[index + 1] = y;
        return this;
      }
    }, {
      key: "setXYZ",
      value: function setXYZ(index, x, y, z) {
        index *= this.itemSize;
        if (this.normalized) {
          x = normalize(x, this.array);
          y = normalize(y, this.array);
          z = normalize(z, this.array);
        }
        this.array[index + 0] = x;
        this.array[index + 1] = y;
        this.array[index + 2] = z;
        return this;
      }
    }, {
      key: "setXYZW",
      value: function setXYZW(index, x, y, z, w) {
        index *= this.itemSize;
        if (this.normalized) {
          x = normalize(x, this.array);
          y = normalize(y, this.array);
          z = normalize(z, this.array);
          w = normalize(w, this.array);
        }
        this.array[index + 0] = x;
        this.array[index + 1] = y;
        this.array[index + 2] = z;
        this.array[index + 3] = w;
        return this;
      }
    }, {
      key: "onUpload",
      value: function onUpload(callback) {
        this.onUploadCallback = callback;
        return this;
      }
    }, {
      key: "clone",
      value: function clone() {
        return new this.constructor(this.array, this.itemSize).copy(this);
      }
    }, {
      key: "toJSON",
      value: function toJSON() {
        var data = {
          itemSize: this.itemSize,
          type: this.array.constructor.name,
          array: Array.from(this.array),
          normalized: this.normalized
        };
        if (this.name !== '') data.name = this.name;
        if (this.usage !== StaticDrawUsage) data.usage = this.usage;
        return data;
      }
    }]);
  }(); //
  var Int8BufferAttribute = exports.Int8BufferAttribute = /*#__PURE__*/function (_BufferAttribute) {
    function Int8BufferAttribute(array, itemSize, normalized) {
      (0, _classCallCheck2.default)(this, Int8BufferAttribute);
      return _callSuper(this, Int8BufferAttribute, [new Int8Array(array), itemSize, normalized]);
    }
    (0, _inherits2.default)(Int8BufferAttribute, _BufferAttribute);
    return (0, _createClass2.default)(Int8BufferAttribute);
  }(BufferAttribute);
  var Uint8BufferAttribute = exports.Uint8BufferAttribute = /*#__PURE__*/function (_BufferAttribute2) {
    function Uint8BufferAttribute(array, itemSize, normalized) {
      (0, _classCallCheck2.default)(this, Uint8BufferAttribute);
      return _callSuper(this, Uint8BufferAttribute, [new Uint8Array(array), itemSize, normalized]);
    }
    (0, _inherits2.default)(Uint8BufferAttribute, _BufferAttribute2);
    return (0, _createClass2.default)(Uint8BufferAttribute);
  }(BufferAttribute);
  var Uint8ClampedBufferAttribute = exports.Uint8ClampedBufferAttribute = /*#__PURE__*/function (_BufferAttribute3) {
    function Uint8ClampedBufferAttribute(array, itemSize, normalized) {
      (0, _classCallCheck2.default)(this, Uint8ClampedBufferAttribute);
      return _callSuper(this, Uint8ClampedBufferAttribute, [new Uint8ClampedArray(array), itemSize, normalized]);
    }
    (0, _inherits2.default)(Uint8ClampedBufferAttribute, _BufferAttribute3);
    return (0, _createClass2.default)(Uint8ClampedBufferAttribute);
  }(BufferAttribute);
  var Int16BufferAttribute = exports.Int16BufferAttribute = /*#__PURE__*/function (_BufferAttribute4) {
    function Int16BufferAttribute(array, itemSize, normalized) {
      (0, _classCallCheck2.default)(this, Int16BufferAttribute);
      return _callSuper(this, Int16BufferAttribute, [new Int16Array(array), itemSize, normalized]);
    }
    (0, _inherits2.default)(Int16BufferAttribute, _BufferAttribute4);
    return (0, _createClass2.default)(Int16BufferAttribute);
  }(BufferAttribute);
  var Uint16BufferAttribute = exports.Uint16BufferAttribute = /*#__PURE__*/function (_BufferAttribute5) {
    function Uint16BufferAttribute(array, itemSize, normalized) {
      (0, _classCallCheck2.default)(this, Uint16BufferAttribute);
      return _callSuper(this, Uint16BufferAttribute, [new Uint16Array(array), itemSize, normalized]);
    }
    (0, _inherits2.default)(Uint16BufferAttribute, _BufferAttribute5);
    return (0, _createClass2.default)(Uint16BufferAttribute);
  }(BufferAttribute);
  var Int32BufferAttribute = exports.Int32BufferAttribute = /*#__PURE__*/function (_BufferAttribute6) {
    function Int32BufferAttribute(array, itemSize, normalized) {
      (0, _classCallCheck2.default)(this, Int32BufferAttribute);
      return _callSuper(this, Int32BufferAttribute, [new Int32Array(array), itemSize, normalized]);
    }
    (0, _inherits2.default)(Int32BufferAttribute, _BufferAttribute6);
    return (0, _createClass2.default)(Int32BufferAttribute);
  }(BufferAttribute);
  var Uint32BufferAttribute = exports.Uint32BufferAttribute = /*#__PURE__*/function (_BufferAttribute7) {
    function Uint32BufferAttribute(array, itemSize, normalized) {
      (0, _classCallCheck2.default)(this, Uint32BufferAttribute);
      return _callSuper(this, Uint32BufferAttribute, [new Uint32Array(array), itemSize, normalized]);
    }
    (0, _inherits2.default)(Uint32BufferAttribute, _BufferAttribute7);
    return (0, _createClass2.default)(Uint32BufferAttribute);
  }(BufferAttribute);
  var Float16BufferAttribute = exports.Float16BufferAttribute = /*#__PURE__*/function (_BufferAttribute8) {
    function Float16BufferAttribute(array, itemSize, normalized) {
      var _this11;
      (0, _classCallCheck2.default)(this, Float16BufferAttribute);
      _this11 = _callSuper(this, Float16BufferAttribute, [new Uint16Array(array), itemSize, normalized]);
      _this11.isFloat16BufferAttribute = true;
      return _this11;
    }
    (0, _inherits2.default)(Float16BufferAttribute, _BufferAttribute8);
    return (0, _createClass2.default)(Float16BufferAttribute, [{
      key: "getX",
      value: function getX(index) {
        var x = fromHalfFloat(this.array[index * this.itemSize]);
        if (this.normalized) x = denormalize(x, this.array);
        return x;
      }
    }, {
      key: "setX",
      value: function setX(index, x) {
        if (this.normalized) x = normalize(x, this.array);
        this.array[index * this.itemSize] = toHalfFloat(x);
        return this;
      }
    }, {
      key: "getY",
      value: function getY(index) {
        var y = fromHalfFloat(this.array[index * this.itemSize + 1]);
        if (this.normalized) y = denormalize(y, this.array);
        return y;
      }
    }, {
      key: "setY",
      value: function setY(index, y) {
        if (this.normalized) y = normalize(y, this.array);
        this.array[index * this.itemSize + 1] = toHalfFloat(y);
        return this;
      }
    }, {
      key: "getZ",
      value: function getZ(index) {
        var z = fromHalfFloat(this.array[index * this.itemSize + 2]);
        if (this.normalized) z = denormalize(z, this.array);
        return z;
      }
    }, {
      key: "setZ",
      value: function setZ(index, z) {
        if (this.normalized) z = normalize(z, this.array);
        this.array[index * this.itemSize + 2] = toHalfFloat(z);
        return this;
      }
    }, {
      key: "getW",
      value: function getW(index) {
        var w = fromHalfFloat(this.array[index * this.itemSize + 3]);
        if (this.normalized) w = denormalize(w, this.array);
        return w;
      }
    }, {
      key: "setW",
      value: function setW(index, w) {
        if (this.normalized) w = normalize(w, this.array);
        this.array[index * this.itemSize + 3] = toHalfFloat(w);
        return this;
      }
    }, {
      key: "setXY",
      value: function setXY(index, x, y) {
        index *= this.itemSize;
        if (this.normalized) {
          x = normalize(x, this.array);
          y = normalize(y, this.array);
        }
        this.array[index + 0] = toHalfFloat(x);
        this.array[index + 1] = toHalfFloat(y);
        return this;
      }
    }, {
      key: "setXYZ",
      value: function setXYZ(index, x, y, z) {
        index *= this.itemSize;
        if (this.normalized) {
          x = normalize(x, this.array);
          y = normalize(y, this.array);
          z = normalize(z, this.array);
        }
        this.array[index + 0] = toHalfFloat(x);
        this.array[index + 1] = toHalfFloat(y);
        this.array[index + 2] = toHalfFloat(z);
        return this;
      }
    }, {
      key: "setXYZW",
      value: function setXYZW(index, x, y, z, w) {
        index *= this.itemSize;
        if (this.normalized) {
          x = normalize(x, this.array);
          y = normalize(y, this.array);
          z = normalize(z, this.array);
          w = normalize(w, this.array);
        }
        this.array[index + 0] = toHalfFloat(x);
        this.array[index + 1] = toHalfFloat(y);
        this.array[index + 2] = toHalfFloat(z);
        this.array[index + 3] = toHalfFloat(w);
        return this;
      }
    }]);
  }(BufferAttribute);
  var Float32BufferAttribute = exports.Float32BufferAttribute = /*#__PURE__*/function (_BufferAttribute9) {
    function Float32BufferAttribute(array, itemSize, normalized) {
      (0, _classCallCheck2.default)(this, Float32BufferAttribute);
      return _callSuper(this, Float32BufferAttribute, [new Float32Array(array), itemSize, normalized]);
    }
    (0, _inherits2.default)(Float32BufferAttribute, _BufferAttribute9);
    return (0, _createClass2.default)(Float32BufferAttribute);
  }(BufferAttribute);
  var _id$1 = 0;
  var _m1 = /*@__PURE__*/new Matrix4();
  var _obj = /*@__PURE__*/new Object3D();
  var _offset = /*@__PURE__*/new Vector3();
  var _box$2 = /*@__PURE__*/new Box3();
  var _boxMorphTargets = /*@__PURE__*/new Box3();
  var _vector$8 = /*@__PURE__*/new Vector3();
  var BufferGeometry = exports.BufferGeometry = /*#__PURE__*/function (_EventDispatcher5) {
    function BufferGeometry() {
      var _this12;
      (0, _classCallCheck2.default)(this, BufferGeometry);
      _this12 = _callSuper(this, BufferGeometry);
      _this12.isBufferGeometry = true;
      Object.defineProperty(_this12, 'id', {
        value: _id$1++
      });
      _this12.uuid = generateUUID();
      _this12.name = '';
      _this12.type = 'BufferGeometry';
      _this12.index = null;
      _this12.indirect = null;
      _this12.attributes = {};
      _this12.morphAttributes = {};
      _this12.morphTargetsRelative = false;
      _this12.groups = [];
      _this12.boundingBox = null;
      _this12.boundingSphere = null;
      _this12.drawRange = {
        start: 0,
        count: Infinity
      };
      _this12.userData = {};
      return _this12;
    }
    (0, _inherits2.default)(BufferGeometry, _EventDispatcher5);
    return (0, _createClass2.default)(BufferGeometry, [{
      key: "getIndex",
      value: function getIndex() {
        return this.index;
      }
    }, {
      key: "setIndex",
      value: function setIndex(index) {
        if (Array.isArray(index)) {
          this.index = new (arrayNeedsUint32(index) ? Uint32BufferAttribute : Uint16BufferAttribute)(index, 1);
        } else {
          this.index = index;
        }
        return this;
      }
    }, {
      key: "setIndirect",
      value: function setIndirect(indirect) {
        this.indirect = indirect;
        return this;
      }
    }, {
      key: "getIndirect",
      value: function getIndirect() {
        return this.indirect;
      }
    }, {
      key: "getAttribute",
      value: function getAttribute(name) {
        return this.attributes[name];
      }
    }, {
      key: "setAttribute",
      value: function setAttribute(name, attribute) {
        this.attributes[name] = attribute;
        return this;
      }
    }, {
      key: "deleteAttribute",
      value: function deleteAttribute(name) {
        delete this.attributes[name];
        return this;
      }
    }, {
      key: "hasAttribute",
      value: function hasAttribute(name) {
        return this.attributes[name] !== undefined;
      }
    }, {
      key: "addGroup",
      value: function addGroup(start, count) {
        var materialIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
        this.groups.push({
          start: start,
          count: count,
          materialIndex: materialIndex
        });
      }
    }, {
      key: "clearGroups",
      value: function clearGroups() {
        this.groups = [];
      }
    }, {
      key: "setDrawRange",
      value: function setDrawRange(start, count) {
        this.drawRange.start = start;
        this.drawRange.count = count;
      }
    }, {
      key: "applyMatrix4",
      value: function applyMatrix4(matrix) {
        var position = this.attributes.position;
        if (position !== undefined) {
          position.applyMatrix4(matrix);
          position.needsUpdate = true;
        }
        var normal = this.attributes.normal;
        if (normal !== undefined) {
          var normalMatrix = new Matrix3().getNormalMatrix(matrix);
          normal.applyNormalMatrix(normalMatrix);
          normal.needsUpdate = true;
        }
        var tangent = this.attributes.tangent;
        if (tangent !== undefined) {
          tangent.transformDirection(matrix);
          tangent.needsUpdate = true;
        }
        if (this.boundingBox !== null) {
          this.computeBoundingBox();
        }
        if (this.boundingSphere !== null) {
          this.computeBoundingSphere();
        }
        return this;
      }
    }, {
      key: "applyQuaternion",
      value: function applyQuaternion(q) {
        _m1.makeRotationFromQuaternion(q);
        this.applyMatrix4(_m1);
        return this;
      }
    }, {
      key: "rotateX",
      value: function rotateX(angle) {
        // rotate geometry around world x-axis

        _m1.makeRotationX(angle);
        this.applyMatrix4(_m1);
        return this;
      }
    }, {
      key: "rotateY",
      value: function rotateY(angle) {
        // rotate geometry around world y-axis

        _m1.makeRotationY(angle);
        this.applyMatrix4(_m1);
        return this;
      }
    }, {
      key: "rotateZ",
      value: function rotateZ(angle) {
        // rotate geometry around world z-axis

        _m1.makeRotationZ(angle);
        this.applyMatrix4(_m1);
        return this;
      }
    }, {
      key: "translate",
      value: function translate(x, y, z) {
        // translate geometry

        _m1.makeTranslation(x, y, z);
        this.applyMatrix4(_m1);
        return this;
      }
    }, {
      key: "scale",
      value: function scale(x, y, z) {
        // scale geometry

        _m1.makeScale(x, y, z);
        this.applyMatrix4(_m1);
        return this;
      }
    }, {
      key: "lookAt",
      value: function lookAt(vector) {
        _obj.lookAt(vector);
        _obj.updateMatrix();
        this.applyMatrix4(_obj.matrix);
        return this;
      }
    }, {
      key: "center",
      value: function center() {
        this.computeBoundingBox();
        this.boundingBox.getCenter(_offset).negate();
        this.translate(_offset.x, _offset.y, _offset.z);
        return this;
      }
    }, {
      key: "setFromPoints",
      value: function setFromPoints(points) {
        var positionAttribute = this.getAttribute('position');
        if (positionAttribute === undefined) {
          var position = [];
          for (var i = 0, l = points.length; i < l; i++) {
            var point = points[i];
            position.push(point.x, point.y, point.z || 0);
          }
          this.setAttribute('position', new Float32BufferAttribute(position, 3));
        } else {
          var _l4 = Math.min(points.length, positionAttribute.count); // make sure data do not exceed buffer size

          for (var _i12 = 0; _i12 < _l4; _i12++) {
            var _point = points[_i12];
            positionAttribute.setXYZ(_i12, _point.x, _point.y, _point.z || 0);
          }
          if (points.length > positionAttribute.count) {
            console.warn('THREE.BufferGeometry: Buffer size too small for points data. Use .dispose() and create a new geometry.');
          }
          positionAttribute.needsUpdate = true;
        }
        return this;
      }
    }, {
      key: "computeBoundingBox",
      value: function computeBoundingBox() {
        if (this.boundingBox === null) {
          this.boundingBox = new Box3();
        }
        var position = this.attributes.position;
        var morphAttributesPosition = this.morphAttributes.position;
        if (position && position.isGLBufferAttribute) {
          console.error('THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.', this);
          this.boundingBox.set(new Vector3(-Infinity, -Infinity, -Infinity), new Vector3(+Infinity, +Infinity, +Infinity));
          return;
        }
        if (position !== undefined) {
          this.boundingBox.setFromBufferAttribute(position);

          // process morph attributes if present

          if (morphAttributesPosition) {
            for (var i = 0, il = morphAttributesPosition.length; i < il; i++) {
              var morphAttribute = morphAttributesPosition[i];
              _box$2.setFromBufferAttribute(morphAttribute);
              if (this.morphTargetsRelative) {
                _vector$8.addVectors(this.boundingBox.min, _box$2.min);
                this.boundingBox.expandByPoint(_vector$8);
                _vector$8.addVectors(this.boundingBox.max, _box$2.max);
                this.boundingBox.expandByPoint(_vector$8);
              } else {
                this.boundingBox.expandByPoint(_box$2.min);
                this.boundingBox.expandByPoint(_box$2.max);
              }
            }
          }
        } else {
          this.boundingBox.makeEmpty();
        }
        if (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) {
          console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this);
        }
      }
    }, {
      key: "computeBoundingSphere",
      value: function computeBoundingSphere() {
        if (this.boundingSphere === null) {
          this.boundingSphere = new Sphere();
        }
        var position = this.attributes.position;
        var morphAttributesPosition = this.morphAttributes.position;
        if (position && position.isGLBufferAttribute) {
          console.error('THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.', this);
          this.boundingSphere.set(new Vector3(), Infinity);
          return;
        }
        if (position) {
          // first, find the center of the bounding sphere

          var center = this.boundingSphere.center;
          _box$2.setFromBufferAttribute(position);

          // process morph attributes if present

          if (morphAttributesPosition) {
            for (var i = 0, il = morphAttributesPosition.length; i < il; i++) {
              var morphAttribute = morphAttributesPosition[i];
              _boxMorphTargets.setFromBufferAttribute(morphAttribute);
              if (this.morphTargetsRelative) {
                _vector$8.addVectors(_box$2.min, _boxMorphTargets.min);
                _box$2.expandByPoint(_vector$8);
                _vector$8.addVectors(_box$2.max, _boxMorphTargets.max);
                _box$2.expandByPoint(_vector$8);
              } else {
                _box$2.expandByPoint(_boxMorphTargets.min);
                _box$2.expandByPoint(_boxMorphTargets.max);
              }
            }
          }
          _box$2.getCenter(center);

          // second, try to find a boundingSphere with a radius smaller than the
          // boundingSphere of the boundingBox: sqrt(3) smaller in the best case

          var maxRadiusSq = 0;
          for (var _i13 = 0, _il = position.count; _i13 < _il; _i13++) {
            _vector$8.fromBufferAttribute(position, _i13);
            maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector$8));
          }

          // process morph attributes if present

          if (morphAttributesPosition) {
            for (var _i14 = 0, _il2 = morphAttributesPosition.length; _i14 < _il2; _i14++) {
              var _morphAttribute = morphAttributesPosition[_i14];
              var morphTargetsRelative = this.morphTargetsRelative;
              for (var j = 0, jl = _morphAttribute.count; j < jl; j++) {
                _vector$8.fromBufferAttribute(_morphAttribute, j);
                if (morphTargetsRelative) {
                  _offset.fromBufferAttribute(position, j);
                  _vector$8.add(_offset);
                }
                maxRadiusSq = Math.max(maxRadiusSq, center.distanceToSquared(_vector$8));
              }
            }
          }
          this.boundingSphere.radius = Math.sqrt(maxRadiusSq);
          if (isNaN(this.boundingSphere.radius)) {
            console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this);
          }
        }
      }
    }, {
      key: "computeTangents",
      value: function computeTangents() {
        var index = this.index;
        var attributes = this.attributes;

        // based on http://www.terathon.com/code/tangent.html
        // (per vertex tangents)

        if (index === null || attributes.position === undefined || attributes.normal === undefined || attributes.uv === undefined) {
          console.error('THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)');
          return;
        }
        var positionAttribute = attributes.position;
        var normalAttribute = attributes.normal;
        var uvAttribute = attributes.uv;
        if (this.hasAttribute('tangent') === false) {
          this.setAttribute('tangent', new BufferAttribute(new Float32Array(4 * positionAttribute.count), 4));
        }
        var tangentAttribute = this.getAttribute('tangent');
        var tan1 = [],
          tan2 = [];
        for (var i = 0; i < positionAttribute.count; i++) {
          tan1[i] = new Vector3();
          tan2[i] = new Vector3();
        }
        var vA = new Vector3(),
          vB = new Vector3(),
          vC = new Vector3(),
          uvA = new Vector2(),
          uvB = new Vector2(),
          uvC = new Vector2(),
          sdir = new Vector3(),
          tdir = new Vector3();
        function handleTriangle(a, b, c) {
          vA.fromBufferAttribute(positionAttribute, a);
          vB.fromBufferAttribute(positionAttribute, b);
          vC.fromBufferAttribute(positionAttribute, c);
          uvA.fromBufferAttribute(uvAttribute, a);
          uvB.fromBufferAttribute(uvAttribute, b);
          uvC.fromBufferAttribute(uvAttribute, c);
          vB.sub(vA);
          vC.sub(vA);
          uvB.sub(uvA);
          uvC.sub(uvA);
          var r = 1.0 / (uvB.x * uvC.y - uvC.x * uvB.y);

          // silently ignore degenerate uv triangles having coincident or colinear vertices

          if (!isFinite(r)) return;
          sdir.copy(vB).multiplyScalar(uvC.y).addScaledVector(vC, -uvB.y).multiplyScalar(r);
          tdir.copy(vC).multiplyScalar(uvB.x).addScaledVector(vB, -uvC.x).multiplyScalar(r);
          tan1[a].add(sdir);
          tan1[b].add(sdir);
          tan1[c].add(sdir);
          tan2[a].add(tdir);
          tan2[b].add(tdir);
          tan2[c].add(tdir);
        }
        var groups = this.groups;
        if (groups.length === 0) {
          groups = [{
            start: 0,
            count: index.count
          }];
        }
        for (var _i15 = 0, il = groups.length; _i15 < il; ++_i15) {
          var group = groups[_i15];
          var start = group.start;
          var count = group.count;
          for (var j = start, jl = start + count; j < jl; j += 3) {
            handleTriangle(index.getX(j + 0), index.getX(j + 1), index.getX(j + 2));
          }
        }
        var tmp = new Vector3(),
          tmp2 = new Vector3();
        var n = new Vector3(),
          n2 = new Vector3();
        function handleVertex(v) {
          n.fromBufferAttribute(normalAttribute, v);
          n2.copy(n);
          var t = tan1[v];

          // Gram-Schmidt orthogonalize

          tmp.copy(t);
          tmp.sub(n.multiplyScalar(n.dot(t))).normalize();

          // Calculate handedness

          tmp2.crossVectors(n2, t);
          var test = tmp2.dot(tan2[v]);
          var w = test < 0.0 ? -1.0 : 1.0;
          tangentAttribute.setXYZW(v, tmp.x, tmp.y, tmp.z, w);
        }
        for (var _i16 = 0, _il3 = groups.length; _i16 < _il3; ++_i16) {
          var _group = groups[_i16];
          var _start2 = _group.start;
          var _count = _group.count;
          for (var _j = _start2, _jl = _start2 + _count; _j < _jl; _j += 3) {
            handleVertex(index.getX(_j + 0));
            handleVertex(index.getX(_j + 1));
            handleVertex(index.getX(_j + 2));
          }
        }
      }
    }, {
      key: "computeVertexNormals",
      value: function computeVertexNormals() {
        var index = this.index;
        var positionAttribute = this.getAttribute('position');
        if (positionAttribute !== undefined) {
          var normalAttribute = this.getAttribute('normal');
          if (normalAttribute === undefined) {
            normalAttribute = new BufferAttribute(new Float32Array(positionAttribute.count * 3), 3);
            this.setAttribute('normal', normalAttribute);
          } else {
            // reset existing normals to zero

            for (var i = 0, il = normalAttribute.count; i < il; i++) {
              normalAttribute.setXYZ(i, 0, 0, 0);
            }
          }
          var pA = new Vector3(),
            pB = new Vector3(),
            pC = new Vector3();
          var nA = new Vector3(),
            nB = new Vector3(),
            nC = new Vector3();
          var cb = new Vector3(),
            ab = new Vector3();

          // indexed elements

          if (index) {
            for (var _i17 = 0, _il4 = index.count; _i17 < _il4; _i17 += 3) {
              var vA = index.getX(_i17 + 0);
              var vB = index.getX(_i17 + 1);
              var vC = index.getX(_i17 + 2);
              pA.fromBufferAttribute(positionAttribute, vA);
              pB.fromBufferAttribute(positionAttribute, vB);
              pC.fromBufferAttribute(positionAttribute, vC);
              cb.subVectors(pC, pB);
              ab.subVectors(pA, pB);
              cb.cross(ab);
              nA.fromBufferAttribute(normalAttribute, vA);
              nB.fromBufferAttribute(normalAttribute, vB);
              nC.fromBufferAttribute(normalAttribute, vC);
              nA.add(cb);
              nB.add(cb);
              nC.add(cb);
              normalAttribute.setXYZ(vA, nA.x, nA.y, nA.z);
              normalAttribute.setXYZ(vB, nB.x, nB.y, nB.z);
              normalAttribute.setXYZ(vC, nC.x, nC.y, nC.z);
            }
          } else {
            // non-indexed elements (unconnected triangle soup)

            for (var _i18 = 0, _il5 = positionAttribute.count; _i18 < _il5; _i18 += 3) {
              pA.fromBufferAttribute(positionAttribute, _i18 + 0);
              pB.fromBufferAttribute(positionAttribute, _i18 + 1);
              pC.fromBufferAttribute(positionAttribute, _i18 + 2);
              cb.subVectors(pC, pB);
              ab.subVectors(pA, pB);
              cb.cross(ab);
              normalAttribute.setXYZ(_i18 + 0, cb.x, cb.y, cb.z);
              normalAttribute.setXYZ(_i18 + 1, cb.x, cb.y, cb.z);
              normalAttribute.setXYZ(_i18 + 2, cb.x, cb.y, cb.z);
            }
          }
          this.normalizeNormals();
          normalAttribute.needsUpdate = true;
        }
      }
    }, {
      key: "normalizeNormals",
      value: function normalizeNormals() {
        var normals = this.attributes.normal;
        for (var i = 0, il = normals.count; i < il; i++) {
          _vector$8.fromBufferAttribute(normals, i);
          _vector$8.normalize();
          normals.setXYZ(i, _vector$8.x, _vector$8.y, _vector$8.z);
        }
      }
    }, {
      key: "toNonIndexed",
      value: function toNonIndexed() {
        function convertBufferAttribute(attribute, indices) {
          var array = attribute.array;
          var itemSize = attribute.itemSize;
          var normalized = attribute.normalized;
          var array2 = new array.constructor(indices.length * itemSize);
          var index = 0,
            index2 = 0;
          for (var i = 0, l = indices.length; i < l; i++) {
            if (attribute.isInterleavedBufferAttribute) {
              index = indices[i] * attribute.data.stride + attribute.offset;
            } else {
              index = indices[i] * itemSize;
            }
            for (var j = 0; j < itemSize; j++) {
              array2[index2++] = array[index++];
            }
          }
          return new BufferAttribute(array2, itemSize, normalized);
        }

        //

        if (this.index === null) {
          console.warn('THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed.');
          return this;
        }
        var geometry2 = new BufferGeometry();
        var indices = this.index.array;
        var attributes = this.attributes;

        // attributes

        for (var name in attributes) {
          var attribute = attributes[name];
          var newAttribute = convertBufferAttribute(attribute, indices);
          geometry2.setAttribute(name, newAttribute);
        }

        // morph attributes

        var morphAttributes = this.morphAttributes;
        for (var _name in morphAttributes) {
          var morphArray = [];
          var morphAttribute = morphAttributes[_name]; // morphAttribute: array of Float32BufferAttributes

          for (var i = 0, il = morphAttribute.length; i < il; i++) {
            var _attribute = morphAttribute[i];
            var _newAttribute = convertBufferAttribute(_attribute, indices);
            morphArray.push(_newAttribute);
          }
          geometry2.morphAttributes[_name] = morphArray;
        }
        geometry2.morphTargetsRelative = this.morphTargetsRelative;

        // groups

        var groups = this.groups;
        for (var _i19 = 0, l = groups.length; _i19 < l; _i19++) {
          var group = groups[_i19];
          geometry2.addGroup(group.start, group.count, group.materialIndex);
        }
        return geometry2;
      }
    }, {
      key: "toJSON",
      value: function toJSON() {
        var data = {
          metadata: {
            version: 4.6,
            type: 'BufferGeometry',
            generator: 'BufferGeometry.toJSON'
          }
        };

        // standard BufferGeometry serialization

        data.uuid = this.uuid;
        data.type = this.type;
        if (this.name !== '') data.name = this.name;
        if (Object.keys(this.userData).length > 0) data.userData = this.userData;
        if (this.parameters !== undefined) {
          var parameters = this.parameters;
          for (var key in parameters) {
            if (parameters[key] !== undefined) data[key] = parameters[key];
          }
          return data;
        }

        // for simplicity the code assumes attributes are not shared across geometries, see #15811

        data.data = {
          attributes: {}
        };
        var index = this.index;
        if (index !== null) {
          data.data.index = {
            type: index.array.constructor.name,
            array: Array.prototype.slice.call(index.array)
          };
        }
        var attributes = this.attributes;
        for (var _key in attributes) {
          var attribute = attributes[_key];
          data.data.attributes[_key] = attribute.toJSON(data.data);
        }
        var morphAttributes = {};
        var hasMorphAttributes = false;
        for (var _key2 in this.morphAttributes) {
          var attributeArray = this.morphAttributes[_key2];
          var array = [];
          for (var i = 0, il = attributeArray.length; i < il; i++) {
            var _attribute2 = attributeArray[i];
            array.push(_attribute2.toJSON(data.data));
          }
          if (array.length > 0) {
            morphAttributes[_key2] = array;
            hasMorphAttributes = true;
          }
        }
        if (hasMorphAttributes) {
          data.data.morphAttributes = morphAttributes;
          data.data.morphTargetsRelative = this.morphTargetsRelative;
        }
        var groups = this.groups;
        if (groups.length > 0) {
          data.data.groups = JSON.parse(JSON.stringify(groups));
        }
        var boundingSphere = this.boundingSphere;
        if (boundingSphere !== null) {
          data.data.boundingSphere = {
            center: boundingSphere.center.toArray(),
            radius: boundingSphere.radius
          };
        }
        return data;
      }
    }, {
      key: "clone",
      value: function clone() {
        return new this.constructor().copy(this);
      }
    }, {
      key: "copy",
      value: function copy(source) {
        // reset

        this.index = null;
        this.attributes = {};
        this.morphAttributes = {};
        this.groups = [];
        this.boundingBox = null;
        this.boundingSphere = null;

        // used for storing cloned, shared data

        var data = {};

        // name

        this.name = source.name;

        // index

        var index = source.index;
        if (index !== null) {
          this.setIndex(index.clone(data));
        }

        // attributes

        var attributes = source.attributes;
        for (var name in attributes) {
          var attribute = attributes[name];
          this.setAttribute(name, attribute.clone(data));
        }

        // morph attributes

        var morphAttributes = source.morphAttributes;
        for (var _name2 in morphAttributes) {
          var array = [];
          var morphAttribute = morphAttributes[_name2]; // morphAttribute: array of Float32BufferAttributes

          for (var i = 0, l = morphAttribute.length; i < l; i++) {
            array.push(morphAttribute[i].clone(data));
          }
          this.morphAttributes[_name2] = array;
        }
        this.morphTargetsRelative = source.morphTargetsRelative;

        // groups

        var groups = source.groups;
        for (var _i20 = 0, _l5 = groups.length; _i20 < _l5; _i20++) {
          var group = groups[_i20];
          this.addGroup(group.start, group.count, group.materialIndex);
        }

        // bounding box

        var boundingBox = source.boundingBox;
        if (boundingBox !== null) {
          this.boundingBox = boundingBox.clone();
        }

        // bounding sphere

        var boundingSphere = source.boundingSphere;
        if (boundingSphere !== null) {
          this.boundingSphere = boundingSphere.clone();
        }

        // draw range

        this.drawRange.start = source.drawRange.start;
        this.drawRange.count = source.drawRange.count;

        // user data

        this.userData = source.userData;
        return this;
      }
    }, {
      key: "dispose",
      value: function dispose() {
        this.dispatchEvent({
          type: 'dispose'
        });
      }
    }]);
  }(EventDispatcher);
  var _inverseMatrix$3 = /*@__PURE__*/new Matrix4();
  var _ray$3 = /*@__PURE__*/new Ray();
  var _sphere$6 = /*@__PURE__*/new Sphere();
  var _sphereHitAt = /*@__PURE__*/new Vector3();
  var _vA$1 = /*@__PURE__*/new Vector3();
  var _vB$1 = /*@__PURE__*/new Vector3();
  var _vC$1 = /*@__PURE__*/new Vector3();
  var _tempA = /*@__PURE__*/new Vector3();
  var _morphA = /*@__PURE__*/new Vector3();
  var _intersectionPoint = /*@__PURE__*/new Vector3();
  var _intersectionPointWorld = /*@__PURE__*/new Vector3();
  var Mesh = exports.Mesh = /*#__PURE__*/function (_Object3D) {
    function Mesh() {
      var _this13;
      var geometry = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new BufferGeometry();
      var material = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new MeshBasicMaterial();
      (0, _classCallCheck2.default)(this, Mesh);
      _this13 = _callSuper(this, Mesh);
      _this13.isMesh = true;
      _this13.type = 'Mesh';
      _this13.geometry = geometry;
      _this13.material = material;
      _this13.updateMorphTargets();
      return _this13;
    }
    (0, _inherits2.default)(Mesh, _Object3D);
    return (0, _createClass2.default)(Mesh, [{
      key: "copy",
      value: function copy(source, recursive) {
        _superPropGet(Mesh, "copy", this, 3)([source, recursive]);
        if (source.morphTargetInfluences !== undefined) {
          this.morphTargetInfluences = source.morphTargetInfluences.slice();
        }
        if (source.morphTargetDictionary !== undefined) {
          this.morphTargetDictionary = Object.assign({}, source.morphTargetDictionary);
        }
        this.material = Array.isArray(source.material) ? source.material.slice() : source.material;
        this.geometry = source.geometry;
        return this;
      }
    }, {
      key: "updateMorphTargets",
      value: function updateMorphTargets() {
        var geometry = this.geometry;
        var morphAttributes = geometry.morphAttributes;
        var keys = Object.keys(morphAttributes);
        if (keys.length > 0) {
          var morphAttribute = morphAttributes[keys[0]];
          if (morphAttribute !== undefined) {
            this.morphTargetInfluences = [];
            this.morphTargetDictionary = {};
            for (var m = 0, ml = morphAttribute.length; m < ml; m++) {
              var name = morphAttribute[m].name || String(m);
              this.morphTargetInfluences.push(0);
              this.morphTargetDictionary[name] = m;
            }
          }
        }
      }
    }, {
      key: "getVertexPosition",
      value: function getVertexPosition(index, target) {
        var geometry = this.geometry;
        var position = geometry.attributes.position;
        var morphPosition = geometry.morphAttributes.position;
        var morphTargetsRelative = geometry.morphTargetsRelative;
        target.fromBufferAttribute(position, index);
        var morphInfluences = this.morphTargetInfluences;
        if (morphPosition && morphInfluences) {
          _morphA.set(0, 0, 0);
          for (var i = 0, il = morphPosition.length; i < il; i++) {
            var influence = morphInfluences[i];
            var morphAttribute = morphPosition[i];
            if (influence === 0) continue;
            _tempA.fromBufferAttribute(morphAttribute, index);
            if (morphTargetsRelative) {
              _morphA.addScaledVector(_tempA, influence);
            } else {
              _morphA.addScaledVector(_tempA.sub(target), influence);
            }
          }
          target.add(_morphA);
        }
        return target;
      }
    }, {
      key: "raycast",
      value: function raycast(raycaster, intersects) {
        var geometry = this.geometry;
        var material = this.material;
        var matrixWorld = this.matrixWorld;
        if (material === undefined) return;

        // test with bounding sphere in world space

        if (geometry.boundingSphere === null) geometry.computeBoundingSphere();
        _sphere$6.copy(geometry.boundingSphere);
        _sphere$6.applyMatrix4(matrixWorld);

        // check distance from ray origin to bounding sphere

        _ray$3.copy(raycaster.ray).recast(raycaster.near);
        if (_sphere$6.containsPoint(_ray$3.origin) === false) {
          if (_ray$3.intersectSphere(_sphere$6, _sphereHitAt) === null) return;
          if (_ray$3.origin.distanceToSquared(_sphereHitAt) > (raycaster.far - raycaster.near) ** 2) return;
        }

        // convert ray to local space of mesh

        _inverseMatrix$3.copy(matrixWorld).invert();
        _ray$3.copy(raycaster.ray).applyMatrix4(_inverseMatrix$3);

        // test with bounding box in local space

        if (geometry.boundingBox !== null) {
          if (_ray$3.intersectsBox(geometry.boundingBox) === false) return;
        }

        // test for intersections with geometry

        this._computeIntersections(raycaster, intersects, _ray$3);
      }
    }, {
      key: "_computeIntersections",
      value: function _computeIntersections(raycaster, intersects, rayLocalSpace) {
        var intersection;
        var geometry = this.geometry;
        var material = this.material;
        var index = geometry.index;
        var position = geometry.attributes.position;
        var uv = geometry.attributes.uv;
        var uv1 = geometry.attributes.uv1;
        var normal = geometry.attributes.normal;
        var groups = geometry.groups;
        var drawRange = geometry.drawRange;
        if (index !== null) {
          // indexed buffer geometry

          if (Array.isArray(material)) {
            for (var i = 0, il = groups.length; i < il; i++) {
              var group = groups[i];
              var groupMaterial = material[group.materialIndex];
              var start = Math.max(group.start, drawRange.start);
              var end = Math.min(index.count, Math.min(group.start + group.count, drawRange.start + drawRange.count));
              for (var j = start, jl = end; j < jl; j += 3) {
                var a = index.getX(j);
                var b = index.getX(j + 1);
                var c = index.getX(j + 2);
                intersection = checkGeometryIntersection(this, groupMaterial, raycaster, rayLocalSpace, uv, uv1, normal, a, b, c);
                if (intersection) {
                  intersection.faceIndex = Math.floor(j / 3); // triangle number in indexed buffer semantics
                  intersection.face.materialIndex = group.materialIndex;
                  intersects.push(intersection);
                }
              }
            }
          } else {
            var _start3 = Math.max(0, drawRange.start);
            var _end2 = Math.min(index.count, drawRange.start + drawRange.count);
            for (var _i21 = _start3, _il6 = _end2; _i21 < _il6; _i21 += 3) {
              var _a = index.getX(_i21);
              var _b = index.getX(_i21 + 1);
              var _c = index.getX(_i21 + 2);
              intersection = checkGeometryIntersection(this, material, raycaster, rayLocalSpace, uv, uv1, normal, _a, _b, _c);
              if (intersection) {
                intersection.faceIndex = Math.floor(_i21 / 3); // triangle number in indexed buffer semantics
                intersects.push(intersection);
              }
            }
          }
        } else if (position !== undefined) {
          // non-indexed buffer geometry

          if (Array.isArray(material)) {
            for (var _i22 = 0, _il7 = groups.length; _i22 < _il7; _i22++) {
              var _group2 = groups[_i22];
              var _groupMaterial = material[_group2.materialIndex];
              var _start4 = Math.max(_group2.start, drawRange.start);
              var _end3 = Math.min(position.count, Math.min(_group2.start + _group2.count, drawRange.start + drawRange.count));
              for (var _j2 = _start4, _jl2 = _end3; _j2 < _jl2; _j2 += 3) {
                var _a2 = _j2;
                var _b2 = _j2 + 1;
                var _c2 = _j2 + 2;
                intersection = checkGeometryIntersection(this, _groupMaterial, raycaster, rayLocalSpace, uv, uv1, normal, _a2, _b2, _c2);
                if (intersection) {
                  intersection.faceIndex = Math.floor(_j2 / 3); // triangle number in non-indexed buffer semantics
                  intersection.face.materialIndex = _group2.materialIndex;
                  intersects.push(intersection);
                }
              }
            }
          } else {
            var _start5 = Math.max(0, drawRange.start);
            var _end4 = Math.min(position.count, drawRange.start + drawRange.count);
            for (var _i23 = _start5, _il8 = _end4; _i23 < _il8; _i23 += 3) {
              var _a3 = _i23;
              var _b3 = _i23 + 1;
              var _c3 = _i23 + 2;
              intersection = checkGeometryIntersection(this, material, raycaster, rayLocalSpace, uv, uv1, normal, _a3, _b3, _c3);
              if (intersection) {
                intersection.faceIndex = Math.floor(_i23 / 3); // triangle number in non-indexed buffer semantics
                intersects.push(intersection);
              }
            }
          }
        }
      }
    }]);
  }(Object3D);
  function checkIntersection$1(object, material, raycaster, ray, pA, pB, pC, point) {
    var intersect;
    if (material.side === BackSide) {
      intersect = ray.intersectTriangle(pC, pB, pA, true, point);
    } else {
      intersect = ray.intersectTriangle(pA, pB, pC, material.side === FrontSide, point);
    }
    if (intersect === null) return null;
    _intersectionPointWorld.copy(point);
    _intersectionPointWorld.applyMatrix4(object.matrixWorld);
    var distance = raycaster.ray.origin.distanceTo(_intersectionPointWorld);
    if (distance < raycaster.near || distance > raycaster.far) return null;
    return {
      distance: distance,
      point: _intersectionPointWorld.clone(),
      object: object
    };
  }
  function checkGeometryIntersection(object, material, raycaster, ray, uv, uv1, normal, a, b, c) {
    object.getVertexPosition(a, _vA$1);
    object.getVertexPosition(b, _vB$1);
    object.getVertexPosition(c, _vC$1);
    var intersection = checkIntersection$1(object, material, raycaster, ray, _vA$1, _vB$1, _vC$1, _intersectionPoint);
    if (intersection) {
      var barycoord = new Vector3();
      Triangle.getBarycoord(_intersectionPoint, _vA$1, _vB$1, _vC$1, barycoord);
      if (uv) {
        intersection.uv = Triangle.getInterpolatedAttribute(uv, a, b, c, barycoord, new Vector2());
      }
      if (uv1) {
        intersection.uv1 = Triangle.getInterpolatedAttribute(uv1, a, b, c, barycoord, new Vector2());
      }
      if (normal) {
        intersection.normal = Triangle.getInterpolatedAttribute(normal, a, b, c, barycoord, new Vector3());
        if (intersection.normal.dot(ray.direction) > 0) {
          intersection.normal.multiplyScalar(-1);
        }
      }
      var face = {
        a: a,
        b: b,
        c: c,
        normal: new Vector3(),
        materialIndex: 0
      };
      Triangle.getNormal(_vA$1, _vB$1, _vC$1, face.normal);
      intersection.face = face;
      intersection.barycoord = barycoord;
    }
    return intersection;
  }
  var BoxGeometry = exports.BoxGeometry = /*#__PURE__*/function (_BufferGeometry) {
    function BoxGeometry() {
      var _this14;
      var width = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
      var height = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
      var depth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
      var widthSegments = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;
      var heightSegments = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 1;
      var depthSegments = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 1;
      (0, _classCallCheck2.default)(this, BoxGeometry);
      _this14 = _callSuper(this, BoxGeometry);
      _this14.type = 'BoxGeometry';
      _this14.parameters = {
        width: width,
        height: height,
        depth: depth,
        widthSegments: widthSegments,
        heightSegments: heightSegments,
        depthSegments: depthSegments
      };
      var scope = _this14;

      // segments

      widthSegments = Math.floor(widthSegments);
      heightSegments = Math.floor(heightSegments);
      depthSegments = Math.floor(depthSegments);

      // buffers

      var indices = [];
      var vertices = [];
      var normals = [];
      var uvs = [];

      // helper variables

      var numberOfVertices = 0;
      var groupStart = 0;

      // build each side of the box geometry

      buildPlane('z', 'y', 'x', -1, -1, depth, height, width, depthSegments, heightSegments, 0); // px
      buildPlane('z', 'y', 'x', 1, -1, depth, height, -width, depthSegments, heightSegments, 1); // nx
      buildPlane('x', 'z', 'y', 1, 1, width, depth, height, widthSegments, depthSegments, 2); // py
      buildPlane('x', 'z', 'y', 1, -1, width, depth, -height, widthSegments, depthSegments, 3); // ny
      buildPlane('x', 'y', 'z', 1, -1, width, height, depth, widthSegments, heightSegments, 4); // pz
      buildPlane('x', 'y', 'z', -1, -1, width, height, -depth, widthSegments, heightSegments, 5); // nz

      // build geometry

      _this14.setIndex(indices);
      _this14.setAttribute('position', new Float32BufferAttribute(vertices, 3));
      _this14.setAttribute('normal', new Float32BufferAttribute(normals, 3));
      _this14.setAttribute('uv', new Float32BufferAttribute(uvs, 2));
      function buildPlane(u, v, w, udir, vdir, width, height, depth, gridX, gridY, materialIndex) {
        var segmentWidth = width / gridX;
        var segmentHeight = height / gridY;
        var widthHalf = width / 2;
        var heightHalf = height / 2;
        var depthHalf = depth / 2;
        var gridX1 = gridX + 1;
        var gridY1 = gridY + 1;
        var vertexCounter = 0;
        var groupCount = 0;
        var vector = new Vector3();

        // generate vertices, normals and uvs

        for (var iy = 0; iy < gridY1; iy++) {
          var y = iy * segmentHeight - heightHalf;
          for (var ix = 0; ix < gridX1; ix++) {
            var x = ix * segmentWidth - widthHalf;

            // set values to correct vector component

            vector[u] = x * udir;
            vector[v] = y * vdir;
            vector[w] = depthHalf;

            // now apply vector to vertex buffer

            vertices.push(vector.x, vector.y, vector.z);

            // set values to correct vector component

            vector[u] = 0;
            vector[v] = 0;
            vector[w] = depth > 0 ? 1 : -1;

            // now apply vector to normal buffer

            normals.push(vector.x, vector.y, vector.z);

            // uvs

            uvs.push(ix / gridX);
            uvs.push(1 - iy / gridY);

            // counters

            vertexCounter += 1;
          }
        }

        // indices

        // 1. you need three indices to draw a single face
        // 2. a single segment consists of two faces
        // 3. so we need to generate six (2*3) indices per segment

        for (var _iy = 0; _iy < gridY; _iy++) {
          for (var _ix = 0; _ix < gridX; _ix++) {
            var a = numberOfVertices + _ix + gridX1 * _iy;
            var b = numberOfVertices + _ix + gridX1 * (_iy + 1);
            var c = numberOfVertices + (_ix + 1) + gridX1 * (_iy + 1);
            var d = numberOfVertices + (_ix + 1) + gridX1 * _iy;

            // faces

            indices.push(a, b, d);
            indices.push(b, c, d);

            // increase counter

            groupCount += 6;
          }
        }

        // add a group to the geometry. this will ensure multi material support

        scope.addGroup(groupStart, groupCount, materialIndex);

        // calculate new start value for groups

        groupStart += groupCount;

        // update total number of vertices

        numberOfVertices += vertexCounter;
      }
      return _this14;
    }
    (0, _inherits2.default)(BoxGeometry, _BufferGeometry);
    return (0, _createClass2.default)(BoxGeometry, [{
      key: "copy",
      value: function copy(source) {
        _superPropGet(BoxGeometry, "copy", this, 3)([source]);
        this.parameters = Object.assign({}, source.parameters);
        return this;
      }
    }], [{
      key: "fromJSON",
      value: function fromJSON(data) {
        return new BoxGeometry(data.width, data.height, data.depth, data.widthSegments, data.heightSegments, data.depthSegments);
      }
    }]);
  }(BufferGeometry);
  /**
   * Uniform Utilities
   */
  function cloneUniforms(src) {
    var dst = {};
    for (var u in src) {
      dst[u] = {};
      for (var p in src[u]) {
        var property = src[u][p];
        if (property && (property.isColor || property.isMatrix3 || property.isMatrix4 || property.isVector2 || property.isVector3 || property.isVector4 || property.isTexture || property.isQuaternion)) {
          if (property.isRenderTargetTexture) {
            console.warn('UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms().');
            dst[u][p] = null;
          } else {
            dst[u][p] = property.clone();
          }
        } else if (Array.isArray(property)) {
          dst[u][p] = property.slice();
        } else {
          dst[u][p] = property;
        }
      }
    }
    return dst;
  }
  function mergeUniforms(uniforms) {
    var merged = {};
    for (var u = 0; u < uniforms.length; u++) {
      var _tmp = cloneUniforms(uniforms[u]);
      for (var p in _tmp) {
        merged[p] = _tmp[p];
      }
    }
    return merged;
  }
  function cloneUniformsGroups(src) {
    var dst = [];
    for (var u = 0; u < src.length; u++) {
      dst.push(src[u].clone());
    }
    return dst;
  }
  function getUnlitUniformColorSpace(renderer) {
    var currentRenderTarget = renderer.getRenderTarget();
    if (currentRenderTarget === null) {
      // https://github.com/mrdoob/three.js/pull/23937#issuecomment-1111067398
      return renderer.outputColorSpace;
    }

    // https://github.com/mrdoob/three.js/issues/27868
    if (currentRenderTarget.isXRRenderTarget === true) {
      return currentRenderTarget.texture.colorSpace;
    }
    return ColorManagement.workingColorSpace;
  }

  // Legacy

  var UniformsUtils = exports.UniformsUtils = {
    clone: cloneUniforms,
    merge: mergeUniforms
  };
  var default_vertex = "void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}";
  var default_fragment = "void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}";
  var ShaderMaterial = exports.ShaderMaterial = /*#__PURE__*/function (_Material2) {
    function ShaderMaterial(parameters) {
      var _this15;
      (0, _classCallCheck2.default)(this, ShaderMaterial);
      _this15 = _callSuper(this, ShaderMaterial);
      _this15.isShaderMaterial = true;
      _this15.type = 'ShaderMaterial';
      _this15.defines = {};
      _this15.uniforms = {};
      _this15.uniformsGroups = [];
      _this15.vertexShader = default_vertex;
      _this15.fragmentShader = default_fragment;
      _this15.linewidth = 1;
      _this15.wireframe = false;
      _this15.wireframeLinewidth = 1;
      _this15.fog = false; // set to use scene fog
      _this15.lights = false; // set to use scene lights
      _this15.clipping = false; // set to use user-defined clipping planes

      _this15.forceSinglePass = true;
      _this15.extensions = {
        clipCullDistance: false,
        // set to use vertex shader clipping
        multiDraw: false // set to use vertex shader multi_draw / enable gl_DrawID
      };

      // When rendered geometry doesn't include these attributes but the material does,
      // use these default values in WebGL. This avoids errors when buffer data is missing.
      _this15.defaultAttributeValues = {
        'color': [1, 1, 1],
        'uv': [0, 0],
        'uv1': [0, 0]
      };
      _this15.index0AttributeName = undefined;
      _this15.uniformsNeedUpdate = false;
      _this15.glslVersion = null;
      if (parameters !== undefined) {
        _this15.setValues(parameters);
      }
      return _this15;
    }
    (0, _inherits2.default)(ShaderMaterial, _Material2);
    return (0, _createClass2.default)(ShaderMaterial, [{
      key: "copy",
      value: function copy(source) {
        _superPropGet(ShaderMaterial, "copy", this, 3)([source]);
        this.fragmentShader = source.fragmentShader;
        this.vertexShader = source.vertexShader;
        this.uniforms = cloneUniforms(source.uniforms);
        this.uniformsGroups = cloneUniformsGroups(source.uniformsGroups);
        this.defines = Object.assign({}, source.defines);
        this.wireframe = source.wireframe;
        this.wireframeLinewidth = source.wireframeLinewidth;
        this.fog = source.fog;
        this.lights = source.lights;
        this.clipping = source.clipping;
        this.extensions = Object.assign({}, source.extensions);
        this.glslVersion = source.glslVersion;
        return this;
      }
    }, {
      key: "toJSON",
      value: function toJSON(meta) {
        var data = _superPropGet(ShaderMaterial, "toJSON", this, 3)([meta]);
        data.glslVersion = this.glslVersion;
        data.uniforms = {};
        for (var name in this.uniforms) {
          var uniform = this.uniforms[name];
          var value = uniform.value;
          if (value && value.isTexture) {
            data.uniforms[name] = {
              type: 't',
              value: value.toJSON(meta).uuid
            };
          } else if (value && value.isColor) {
            data.uniforms[name] = {
              type: 'c',
              value: value.getHex()
            };
          } else if (value && value.isVector2) {
            data.uniforms[name] = {
              type: 'v2',
              value: value.toArray()
            };
          } else if (value && value.isVector3) {
            data.uniforms[name] = {
              type: 'v3',
              value: value.toArray()
            };
          } else if (value && value.isVector4) {
            data.uniforms[name] = {
              type: 'v4',
              value: value.toArray()
            };
          } else if (value && value.isMatrix3) {
            data.uniforms[name] = {
              type: 'm3',
              value: value.toArray()
            };
          } else if (value && value.isMatrix4) {
            data.uniforms[name] = {
              type: 'm4',
              value: value.toArray()
            };
          } else {
            data.uniforms[name] = {
              value: value
            };

            // note: the array variants v2v, v3v, v4v, m4v and tv are not supported so far
          }
        }
        if (Object.keys(this.defines).length > 0) data.defines = this.defines;
        data.vertexShader = this.vertexShader;
        data.fragmentShader = this.fragmentShader;
        data.lights = this.lights;
        data.clipping = this.clipping;
        var extensions = {};
        for (var key in this.extensions) {
          if (this.extensions[key] === true) extensions[key] = true;
        }
        if (Object.keys(extensions).length > 0) data.extensions = extensions;
        return data;
      }
    }]);
  }(Material);
  var Camera = exports.Camera = /*#__PURE__*/function (_Object3D2) {
    function Camera() {
      var _this16;
      (0, _classCallCheck2.default)(this, Camera);
      _this16 = _callSuper(this, Camera);
      _this16.isCamera = true;
      _this16.type = 'Camera';
      _this16.matrixWorldInverse = new Matrix4();
      _this16.projectionMatrix = new Matrix4();
      _this16.projectionMatrixInverse = new Matrix4();
      _this16.coordinateSystem = WebGLCoordinateSystem;
      return _this16;
    }
    (0, _inherits2.default)(Camera, _Object3D2);
    return (0, _createClass2.default)(Camera, [{
      key: "copy",
      value: function copy(source, recursive) {
        _superPropGet(Camera, "copy", this, 3)([source, recursive]);
        this.matrixWorldInverse.copy(source.matrixWorldInverse);
        this.projectionMatrix.copy(source.projectionMatrix);
        this.projectionMatrixInverse.copy(source.projectionMatrixInverse);
        this.coordinateSystem = source.coordinateSystem;
        return this;
      }
    }, {
      key: "getWorldDirection",
      value: function getWorldDirection(target) {
        return _superPropGet(Camera, "getWorldDirection", this, 3)([target]).negate();
      }
    }, {
      key: "updateMatrixWorld",
      value: function updateMatrixWorld(force) {
        _superPropGet(Camera, "updateMatrixWorld", this, 3)([force]);
        this.matrixWorldInverse.copy(this.matrixWorld).invert();
      }
    }, {
      key: "updateWorldMatrix",
      value: function updateWorldMatrix(updateParents, updateChildren) {
        _superPropGet(Camera, "updateWorldMatrix", this, 3)([updateParents, updateChildren]);
        this.matrixWorldInverse.copy(this.matrixWorld).invert();
      }
    }, {
      key: "clone",
      value: function clone() {
        return new this.constructor().copy(this);
      }
    }]);
  }(Object3D);
  var _v3$1 = /*@__PURE__*/new Vector3();
  var _minTarget = /*@__PURE__*/new Vector2();
  var _maxTarget = /*@__PURE__*/new Vector2();
  var PerspectiveCamera = exports.PerspectiveCamera = /*#__PURE__*/function (_Camera) {
    function PerspectiveCamera() {
      var _this17;
      var fov = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 50;
      var aspect = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
      var near = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0.1;
      var far = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 2000;
      (0, _classCallCheck2.default)(this, PerspectiveCamera);
      _this17 = _callSuper(this, PerspectiveCamera);
      _this17.isPerspectiveCamera = true;
      _this17.type = 'PerspectiveCamera';
      _this17.fov = fov;
      _this17.zoom = 1;
      _this17.near = near;
      _this17.far = far;
      _this17.focus = 10;
      _this17.aspect = aspect;
      _this17.view = null;
      _this17.filmGauge = 35; // width of the film (default in millimeters)
      _this17.filmOffset = 0; // horizontal film offset (same unit as gauge)

      _this17.updateProjectionMatrix();
      return _this17;
    }
    (0, _inherits2.default)(PerspectiveCamera, _Camera);
    return (0, _createClass2.default)(PerspectiveCamera, [{
      key: "copy",
      value: function copy(source, recursive) {
        _superPropGet(PerspectiveCamera, "copy", this, 3)([source, recursive]);
        this.fov = source.fov;
        this.zoom = source.zoom;
        this.near = source.near;
        this.far = source.far;
        this.focus = source.focus;
        this.aspect = source.aspect;
        this.view = source.view === null ? null : Object.assign({}, source.view);
        this.filmGauge = source.filmGauge;
        this.filmOffset = source.filmOffset;
        return this;
      }

      /**
       * Sets the FOV by focal length in respect to the current .filmGauge.
       *
       * The default film gauge is 35, so that the focal length can be specified for
       * a 35mm (full frame) camera.
       *
       * @param {number} focalLength - Values for focal length and film gauge must have the same unit.
       */
    }, {
      key: "setFocalLength",
      value: function setFocalLength(focalLength) {
        /** see {@link http://www.bobatkins.com/photography/technical/field_of_view.html} */
        var vExtentSlope = 0.5 * this.getFilmHeight() / focalLength;
        this.fov = RAD2DEG * 2 * Math.atan(vExtentSlope);
        this.updateProjectionMatrix();
      }

      /**
       * Calculates the focal length from the current .fov and .filmGauge.
       *
       * @returns {number}
       */
    }, {
      key: "getFocalLength",
      value: function getFocalLength() {
        var vExtentSlope = Math.tan(DEG2RAD * 0.5 * this.fov);
        return 0.5 * this.getFilmHeight() / vExtentSlope;
      }
    }, {
      key: "getEffectiveFOV",
      value: function getEffectiveFOV() {
        return RAD2DEG * 2 * Math.atan(Math.tan(DEG2RAD * 0.5 * this.fov) / this.zoom);
      }
    }, {
      key: "getFilmWidth",
      value: function getFilmWidth() {
        // film not completely covered in portrait format (aspect < 1)
        return this.filmGauge * Math.min(this.aspect, 1);
      }
    }, {
      key: "getFilmHeight",
      value: function getFilmHeight() {
        // film not completely covered in landscape format (aspect > 1)
        return this.filmGauge / Math.max(this.aspect, 1);
      }

      /**
       * Computes the 2D bounds of the camera's viewable rectangle at a given distance along the viewing direction.
       * Sets minTarget and maxTarget to the coordinates of the lower-left and upper-right corners of the view rectangle.
       *
       * @param {number} distance
       * @param {Vector2} minTarget
       * @param {Vector2} maxTarget
       */
    }, {
      key: "getViewBounds",
      value: function getViewBounds(distance, minTarget, maxTarget) {
        _v3$1.set(-1, -1, 0.5).applyMatrix4(this.projectionMatrixInverse);
        minTarget.set(_v3$1.x, _v3$1.y).multiplyScalar(-distance / _v3$1.z);
        _v3$1.set(1, 1, 0.5).applyMatrix4(this.projectionMatrixInverse);
        maxTarget.set(_v3$1.x, _v3$1.y).multiplyScalar(-distance / _v3$1.z);
      }

      /**
       * Computes the width and height of the camera's viewable rectangle at a given distance along the viewing direction.
       *
       * @param {number} distance
       * @param {Vector2} target - Vector2 target used to store result where x is width and y is height.
       * @returns {Vector2}
       */
    }, {
      key: "getViewSize",
      value: function getViewSize(distance, target) {
        this.getViewBounds(distance, _minTarget, _maxTarget);
        return target.subVectors(_maxTarget, _minTarget);
      }

      /**
       * Sets an offset in a larger frustum. This is useful for multi-window or
       * multi-monitor/multi-machine setups.
       *
       * For example, if you have 3x2 monitors and each monitor is 1920x1080 and
       * the monitors are in grid like this
       *
       *   +---+---+---+
       *   | A | B | C |
       *   +---+---+---+
       *   | D | E | F |
       *   +---+---+---+
       *
       * then for each monitor you would call it like this
       *
       *   const w = 1920;
       *   const h = 1080;
       *   const fullWidth = w * 3;
       *   const fullHeight = h * 2;
       *
       *   --A--
       *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );
       *   --B--
       *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );
       *   --C--
       *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );
       *   --D--
       *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );
       *   --E--
       *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );
       *   --F--
       *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );
       *
       *   Note there is no reason monitors have to be the same size or in a grid.
       *
       * @param {number} fullWidth
       * @param {number} fullHeight
       * @param {number} x
       * @param {number} y
       * @param {number} width
       * @param {number} height
       */
    }, {
      key: "setViewOffset",
      value: function setViewOffset(fullWidth, fullHeight, x, y, width, height) {
        this.aspect = fullWidth / fullHeight;
        if (this.view === null) {
          this.view = {
            enabled: true,
            fullWidth: 1,
            fullHeight: 1,
            offsetX: 0,
            offsetY: 0,
            width: 1,
            height: 1
          };
        }
        this.view.enabled = true;
        this.view.fullWidth = fullWidth;
        this.view.fullHeight = fullHeight;
        this.view.offsetX = x;
        this.view.offsetY = y;
        this.view.width = width;
        this.view.height = height;
        this.updateProjectionMatrix();
      }
    }, {
      key: "clearViewOffset",
      value: function clearViewOffset() {
        if (this.view !== null) {
          this.view.enabled = false;
        }
        this.updateProjectionMatrix();
      }
    }, {
      key: "updateProjectionMatrix",
      value: function updateProjectionMatrix() {
        var near = this.near;
        var top = near * Math.tan(DEG2RAD * 0.5 * this.fov) / this.zoom;
        var height = 2 * top;
        var width = this.aspect * height;
        var left = -0.5 * width;
        var view = this.view;
        if (this.view !== null && this.view.enabled) {
          var fullWidth = view.fullWidth,
            fullHeight = view.fullHeight;
          left += view.offsetX * width / fullWidth;
          top -= view.offsetY * height / fullHeight;
          width *= view.width / fullWidth;
          height *= view.height / fullHeight;
        }
        var skew = this.filmOffset;
        if (skew !== 0) left += near * skew / this.getFilmWidth();
        this.projectionMatrix.makePerspective(left, left + width, top, top - height, near, this.far, this.coordinateSystem);
        this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
      }
    }, {
      key: "toJSON",
      value: function toJSON(meta) {
        var data = _superPropGet(PerspectiveCamera, "toJSON", this, 3)([meta]);
        data.object.fov = this.fov;
        data.object.zoom = this.zoom;
        data.object.near = this.near;
        data.object.far = this.far;
        data.object.focus = this.focus;
        data.object.aspect = this.aspect;
        if (this.view !== null) data.object.view = Object.assign({}, this.view);
        data.object.filmGauge = this.filmGauge;
        data.object.filmOffset = this.filmOffset;
        return data;
      }
    }]);
  }(Camera);
  var fov = -90; // negative fov is not an error
  var aspect = 1;
  var CubeCamera = exports.CubeCamera = /*#__PURE__*/function (_Object3D3) {
    function CubeCamera(near, far, renderTarget) {
      var _this18;
      (0, _classCallCheck2.default)(this, CubeCamera);
      _this18 = _callSuper(this, CubeCamera);
      _this18.type = 'CubeCamera';
      _this18.renderTarget = renderTarget;
      _this18.coordinateSystem = null;
      _this18.activeMipmapLevel = 0;
      var cameraPX = new PerspectiveCamera(fov, aspect, near, far);
      cameraPX.layers = _this18.layers;
      _this18.add(cameraPX);
      var cameraNX = new PerspectiveCamera(fov, aspect, near, far);
      cameraNX.layers = _this18.layers;
      _this18.add(cameraNX);
      var cameraPY = new PerspectiveCamera(fov, aspect, near, far);
      cameraPY.layers = _this18.layers;
      _this18.add(cameraPY);
      var cameraNY = new PerspectiveCamera(fov, aspect, near, far);
      cameraNY.layers = _this18.layers;
      _this18.add(cameraNY);
      var cameraPZ = new PerspectiveCamera(fov, aspect, near, far);
      cameraPZ.layers = _this18.layers;
      _this18.add(cameraPZ);
      var cameraNZ = new PerspectiveCamera(fov, aspect, near, far);
      cameraNZ.layers = _this18.layers;
      _this18.add(cameraNZ);
      return _this18;
    }
    (0, _inherits2.default)(CubeCamera, _Object3D3);
    return (0, _createClass2.default)(CubeCamera, [{
      key: "updateCoordinateSystem",
      value: function updateCoordinateSystem() {
        var coordinateSystem = this.coordinateSystem;
        var cameras = this.children.concat();
        var _cameras = (0, _slicedToArray2.default)(cameras, 6),
          cameraPX = _cameras[0],
          cameraNX = _cameras[1],
          cameraPY = _cameras[2],
          cameraNY = _cameras[3],
          cameraPZ = _cameras[4],
          cameraNZ = _cameras[5];
        for (var camera of cameras) this.remove(camera);
        if (coordinateSystem === WebGLCoordinateSystem) {
          cameraPX.up.set(0, 1, 0);
          cameraPX.lookAt(1, 0, 0);
          cameraNX.up.set(0, 1, 0);
          cameraNX.lookAt(-1, 0, 0);
          cameraPY.up.set(0, 0, -1);
          cameraPY.lookAt(0, 1, 0);
          cameraNY.up.set(0, 0, 1);
          cameraNY.lookAt(0, -1, 0);
          cameraPZ.up.set(0, 1, 0);
          cameraPZ.lookAt(0, 0, 1);
          cameraNZ.up.set(0, 1, 0);
          cameraNZ.lookAt(0, 0, -1);
        } else if (coordinateSystem === WebGPUCoordinateSystem) {
          cameraPX.up.set(0, -1, 0);
          cameraPX.lookAt(-1, 0, 0);
          cameraNX.up.set(0, -1, 0);
          cameraNX.lookAt(1, 0, 0);
          cameraPY.up.set(0, 0, 1);
          cameraPY.lookAt(0, 1, 0);
          cameraNY.up.set(0, 0, -1);
          cameraNY.lookAt(0, -1, 0);
          cameraPZ.up.set(0, -1, 0);
          cameraPZ.lookAt(0, 0, 1);
          cameraNZ.up.set(0, -1, 0);
          cameraNZ.lookAt(0, 0, -1);
        } else {
          throw new Error('THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: ' + coordinateSystem);
        }
        for (var _camera2 of cameras) {
          this.add(_camera2);
          _camera2.updateMatrixWorld();
        }
      }
    }, {
      key: "update",
      value: function update(renderer, scene) {
        if (this.parent === null) this.updateMatrixWorld();
        var renderTarget = this.renderTarget,
          activeMipmapLevel = this.activeMipmapLevel;
        if (this.coordinateSystem !== renderer.coordinateSystem) {
          this.coordinateSystem = renderer.coordinateSystem;
          this.updateCoordinateSystem();
        }
        var _this$children = (0, _slicedToArray2.default)(this.children, 6),
          cameraPX = _this$children[0],
          cameraNX = _this$children[1],
          cameraPY = _this$children[2],
          cameraNY = _this$children[3],
          cameraPZ = _this$children[4],
          cameraNZ = _this$children[5];
        var currentRenderTarget = renderer.getRenderTarget();
        var currentActiveCubeFace = renderer.getActiveCubeFace();
        var currentActiveMipmapLevel = renderer.getActiveMipmapLevel();
        var currentXrEnabled = renderer.xr.enabled;
        renderer.xr.enabled = false;
        var generateMipmaps = renderTarget.texture.generateMipmaps;
        renderTarget.texture.generateMipmaps = false;
        renderer.setRenderTarget(renderTarget, 0, activeMipmapLevel);
        renderer.render(scene, cameraPX);
        renderer.setRenderTarget(renderTarget, 1, activeMipmapLevel);
        renderer.render(scene, cameraNX);
        renderer.setRenderTarget(renderTarget, 2, activeMipmapLevel);
        renderer.render(scene, cameraPY);
        renderer.setRenderTarget(renderTarget, 3, activeMipmapLevel);
        renderer.render(scene, cameraNY);
        renderer.setRenderTarget(renderTarget, 4, activeMipmapLevel);
        renderer.render(scene, cameraPZ);

        // mipmaps are generated during the last call of render()
        // at this point, all sides of the cube render target are defined

        renderTarget.texture.generateMipmaps = generateMipmaps;
        renderer.setRenderTarget(renderTarget, 5, activeMipmapLevel);
        renderer.render(scene, cameraNZ);
        renderer.setRenderTarget(currentRenderTarget, currentActiveCubeFace, currentActiveMipmapLevel);
        renderer.xr.enabled = currentXrEnabled;
        renderTarget.texture.needsPMREMUpdate = true;
      }
    }]);
  }(Object3D);
  var CubeTexture = exports.CubeTexture = /*#__PURE__*/function (_Texture3) {
    function CubeTexture(images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, colorSpace) {
      var _this19;
      (0, _classCallCheck2.default)(this, CubeTexture);
      images = images !== undefined ? images : [];
      mapping = mapping !== undefined ? mapping : CubeReflectionMapping;
      _this19 = _callSuper(this, CubeTexture, [images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, colorSpace]);
      _this19.isCubeTexture = true;
      _this19.flipY = false;
      return _this19;
    }
    (0, _inherits2.default)(CubeTexture, _Texture3);
    return (0, _createClass2.default)(CubeTexture, [{
      key: "images",
      get: function get() {
        return this.image;
      },
      set: function set(value) {
        this.image = value;
      }
    }]);
  }(Texture);
  var WebGLCubeRenderTarget = exports.WebGLCubeRenderTarget = /*#__PURE__*/function (_WebGLRenderTarget3) {
    function WebGLCubeRenderTarget() {
      var _this20;
      var size = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      (0, _classCallCheck2.default)(this, WebGLCubeRenderTarget);
      _this20 = _callSuper(this, WebGLCubeRenderTarget, [size, size, options]);
      _this20.isWebGLCubeRenderTarget = true;
      var image = {
        width: size,
        height: size,
        depth: 1
      };
      var images = [image, image, image, image, image, image];
      _this20.texture = new CubeTexture(images, options.mapping, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.colorSpace);

      // By convention -- likely based on the RenderMan spec from the 1990's -- cube maps are specified by WebGL (and three.js)
      // in a coordinate system in which positive-x is to the right when looking up the positive-z axis -- in other words,
      // in a left-handed coordinate system. By continuing this convention, preexisting cube maps continued to render correctly.

      // three.js uses a right-handed coordinate system. So environment maps used in three.js appear to have px and nx swapped
      // and the flag isRenderTargetTexture controls this conversion. The flip is not required when using WebGLCubeRenderTarget.texture
      // as a cube texture (this is detected when isRenderTargetTexture is set to true for cube textures).

      _this20.texture.isRenderTargetTexture = true;
      _this20.texture.generateMipmaps = options.generateMipmaps !== undefined ? options.generateMipmaps : false;
      _this20.texture.minFilter = options.minFilter !== undefined ? options.minFilter : LinearFilter;
      return _this20;
    }
    (0, _inherits2.default)(WebGLCubeRenderTarget, _WebGLRenderTarget3);
    return (0, _createClass2.default)(WebGLCubeRenderTarget, [{
      key: "fromEquirectangularTexture",
      value: function fromEquirectangularTexture(renderer, texture) {
        this.texture.type = texture.type;
        this.texture.colorSpace = texture.colorSpace;
        this.texture.generateMipmaps = texture.generateMipmaps;
        this.texture.minFilter = texture.minFilter;
        this.texture.magFilter = texture.magFilter;
        var shader = {
          uniforms: {
            tEquirect: {
              value: null
            }
          },
          vertexShader: /* glsl */`

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,
          fragmentShader: /* glsl */`

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`
        };
        var geometry = new BoxGeometry(5, 5, 5);
        var material = new ShaderMaterial({
          name: 'CubemapFromEquirect',
          uniforms: cloneUniforms(shader.uniforms),
          vertexShader: shader.vertexShader,
          fragmentShader: shader.fragmentShader,
          side: BackSide,
          blending: NoBlending
        });
        material.uniforms.tEquirect.value = texture;
        var mesh = new Mesh(geometry, material);
        var currentMinFilter = texture.minFilter;

        // Avoid blurred poles
        if (texture.minFilter === LinearMipmapLinearFilter) texture.minFilter = LinearFilter;
        var camera = new CubeCamera(1, 10, this);
        camera.update(renderer, mesh);
        texture.minFilter = currentMinFilter;
        mesh.geometry.dispose();
        mesh.material.dispose();
        return this;
      }
    }, {
      key: "clear",
      value: function clear(renderer, color, depth, stencil) {
        var currentRenderTarget = renderer.getRenderTarget();
        for (var i = 0; i < 6; i++) {
          renderer.setRenderTarget(this, i);
          renderer.clear(color, depth, stencil);
        }
        renderer.setRenderTarget(currentRenderTarget);
      }
    }]);
  }(WebGLRenderTarget);
  var FogExp2 = exports.FogExp2 = /*#__PURE__*/function () {
    function FogExp2(color) {
      var density = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0.00025;
      (0, _classCallCheck2.default)(this, FogExp2);
      this.isFogExp2 = true;
      this.name = '';
      this.color = new Color(color);
      this.density = density;
    }
    return (0, _createClass2.default)(FogExp2, [{
      key: "clone",
      value: function clone() {
        return new FogExp2(this.color, this.density);
      }
    }, {
      key: "toJSON",
      value: function toJSON(/* meta */
      ) {
        return {
          type: 'FogExp2',
          name: this.name,
          color: this.color.getHex(),
          density: this.density
        };
      }
    }]);
  }();
  var Fog = exports.Fog = /*#__PURE__*/function () {
    function Fog(color) {
      var near = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
      var far = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1000;
      (0, _classCallCheck2.default)(this, Fog);
      this.isFog = true;
      this.name = '';
      this.color = new Color(color);
      this.near = near;
      this.far = far;
    }
    return (0, _createClass2.default)(Fog, [{
      key: "clone",
      value: function clone() {
        return new Fog(this.color, this.near, this.far);
      }
    }, {
      key: "toJSON",
      value: function toJSON(/* meta */
      ) {
        return {
          type: 'Fog',
          name: this.name,
          color: this.color.getHex(),
          near: this.near,
          far: this.far
        };
      }
    }]);
  }();
  var Scene = exports.Scene = /*#__PURE__*/function (_Object3D4) {
    function Scene() {
      var _this21;
      (0, _classCallCheck2.default)(this, Scene);
      _this21 = _callSuper(this, Scene);
      _this21.isScene = true;
      _this21.type = 'Scene';
      _this21.background = null;
      _this21.environment = null;
      _this21.fog = null;
      _this21.backgroundBlurriness = 0;
      _this21.backgroundIntensity = 1;
      _this21.backgroundRotation = new Euler();
      _this21.environmentIntensity = 1;
      _this21.environmentRotation = new Euler();
      _this21.overrideMaterial = null;
      if (typeof __THREE_DEVTOOLS__ !== 'undefined') {
        __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent('observe', {
          detail: _this21
        }));
      }
      return _this21;
    }
    (0, _inherits2.default)(Scene, _Object3D4);
    return (0, _createClass2.default)(Scene, [{
      key: "copy",
      value: function copy(source, recursive) {
        _superPropGet(Scene, "copy", this, 3)([source, recursive]);
        if (source.background !== null) this.background = source.background.clone();
        if (source.environment !== null) this.environment = source.environment.clone();
        if (source.fog !== null) this.fog = source.fog.clone();
        this.backgroundBlurriness = source.backgroundBlurriness;
        this.backgroundIntensity = source.backgroundIntensity;
        this.backgroundRotation.copy(source.backgroundRotation);
        this.environmentIntensity = source.environmentIntensity;
        this.environmentRotation.copy(source.environmentRotation);
        if (source.overrideMaterial !== null) this.overrideMaterial = source.overrideMaterial.clone();
        this.matrixAutoUpdate = source.matrixAutoUpdate;
        return this;
      }
    }, {
      key: "toJSON",
      value: function toJSON(meta) {
        var data = _superPropGet(Scene, "toJSON", this, 3)([meta]);
        if (this.fog !== null) data.object.fog = this.fog.toJSON();
        if (this.backgroundBlurriness > 0) data.object.backgroundBlurriness = this.backgroundBlurriness;
        if (this.backgroundIntensity !== 1) data.object.backgroundIntensity = this.backgroundIntensity;
        data.object.backgroundRotation = this.backgroundRotation.toArray();
        if (this.environmentIntensity !== 1) data.object.environmentIntensity = this.environmentIntensity;
        data.object.environmentRotation = this.environmentRotation.toArray();
        return data;
      }
    }]);
  }(Object3D);
  var InterleavedBuffer = exports.InterleavedBuffer = /*#__PURE__*/function () {
    function InterleavedBuffer(array, stride) {
      (0, _classCallCheck2.default)(this, InterleavedBuffer);
      this.isInterleavedBuffer = true;
      this.array = array;
      this.stride = stride;
      this.count = array !== undefined ? array.length / stride : 0;
      this.usage = StaticDrawUsage;
      this.updateRanges = [];
      this.version = 0;
      this.uuid = generateUUID();
    }
    return (0, _createClass2.default)(InterleavedBuffer, [{
      key: "onUploadCallback",
      value: function onUploadCallback() {}
    }, {
      key: "needsUpdate",
      set: function set(value) {
        if (value === true) this.version++;
      }
    }, {
      key: "setUsage",
      value: function setUsage(value) {
        this.usage = value;
        return this;
      }
    }, {
      key: "addUpdateRange",
      value: function addUpdateRange(start, count) {
        this.updateRanges.push({
          start: start,
          count: count
        });
      }
    }, {
      key: "clearUpdateRanges",
      value: function clearUpdateRanges() {
        this.updateRanges.length = 0;
      }
    }, {
      key: "copy",
      value: function copy(source) {
        this.array = new source.array.constructor(source.array);
        this.count = source.count;
        this.stride = source.stride;
        this.usage = source.usage;
        return this;
      }
    }, {
      key: "copyAt",
      value: function copyAt(index1, attribute, index2) {
        index1 *= this.stride;
        index2 *= attribute.stride;
        for (var i = 0, l = this.stride; i < l; i++) {
          this.array[index1 + i] = attribute.array[index2 + i];
        }
        return this;
      }
    }, {
      key: "set",
      value: function set(value) {
        var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        this.array.set(value, offset);
        return this;
      }
    }, {
      key: "clone",
      value: function clone(data) {
        if (data.arrayBuffers === undefined) {
          data.arrayBuffers = {};
        }
        if (this.array.buffer._uuid === undefined) {
          this.array.buffer._uuid = generateUUID();
        }
        if (data.arrayBuffers[this.array.buffer._uuid] === undefined) {
          data.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer;
        }
        var array = new this.array.constructor(data.arrayBuffers[this.array.buffer._uuid]);
        var ib = new this.constructor(array, this.stride);
        ib.setUsage(this.usage);
        return ib;
      }
    }, {
      key: "onUpload",
      value: function onUpload(callback) {
        this.onUploadCallback = callback;
        return this;
      }
    }, {
      key: "toJSON",
      value: function toJSON(data) {
        if (data.arrayBuffers === undefined) {
          data.arrayBuffers = {};
        }

        // generate UUID for array buffer if necessary

        if (this.array.buffer._uuid === undefined) {
          this.array.buffer._uuid = generateUUID();
        }
        if (data.arrayBuffers[this.array.buffer._uuid] === undefined) {
          data.arrayBuffers[this.array.buffer._uuid] = Array.from(new Uint32Array(this.array.buffer));
        }

        //

        return {
          uuid: this.uuid,
          buffer: this.array.buffer._uuid,
          type: this.array.constructor.name,
          stride: this.stride
        };
      }
    }]);
  }();
  var _vector$7 = /*@__PURE__*/new Vector3();
  var InterleavedBufferAttribute = exports.InterleavedBufferAttribute = /*#__PURE__*/function () {
    function InterleavedBufferAttribute(interleavedBuffer, itemSize, offset) {
      var normalized = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
      (0, _classCallCheck2.default)(this, InterleavedBufferAttribute);
      this.isInterleavedBufferAttribute = true;
      this.name = '';
      this.data = interleavedBuffer;
      this.itemSize = itemSize;
      this.offset = offset;
      this.normalized = normalized;
    }
    return (0, _createClass2.default)(InterleavedBufferAttribute, [{
      key: "count",
      get: function get() {
        return this.data.count;
      }
    }, {
      key: "array",
      get: function get() {
        return this.data.array;
      }
    }, {
      key: "needsUpdate",
      set: function set(value) {
        this.data.needsUpdate = value;
      }
    }, {
      key: "applyMatrix4",
      value: function applyMatrix4(m) {
        for (var i = 0, l = this.data.count; i < l; i++) {
          _vector$7.fromBufferAttribute(this, i);
          _vector$7.applyMatrix4(m);
          this.setXYZ(i, _vector$7.x, _vector$7.y, _vector$7.z);
        }
        return this;
      }
    }, {
      key: "applyNormalMatrix",
      value: function applyNormalMatrix(m) {
        for (var i = 0, l = this.count; i < l; i++) {
          _vector$7.fromBufferAttribute(this, i);
          _vector$7.applyNormalMatrix(m);
          this.setXYZ(i, _vector$7.x, _vector$7.y, _vector$7.z);
        }
        return this;
      }
    }, {
      key: "transformDirection",
      value: function transformDirection(m) {
        for (var i = 0, l = this.count; i < l; i++) {
          _vector$7.fromBufferAttribute(this, i);
          _vector$7.transformDirection(m);
          this.setXYZ(i, _vector$7.x, _vector$7.y, _vector$7.z);
        }
        return this;
      }
    }, {
      key: "getComponent",
      value: function getComponent(index, component) {
        var value = this.array[index * this.data.stride + this.offset + component];
        if (this.normalized) value = denormalize(value, this.array);
        return value;
      }
    }, {
      key: "setComponent",
      value: function setComponent(index, component, value) {
        if (this.normalized) value = normalize(value, this.array);
        this.data.array[index * this.data.stride + this.offset + component] = value;
        return this;
      }
    }, {
      key: "setX",
      value: function setX(index, x) {
        if (this.normalized) x = normalize(x, this.array);
        this.data.array[index * this.data.stride + this.offset] = x;
        return this;
      }
    }, {
      key: "setY",
      value: function setY(index, y) {
        if (this.normalized) y = normalize(y, this.array);
        this.data.array[index * this.data.stride + this.offset + 1] = y;
        return this;
      }
    }, {
      key: "setZ",
      value: function setZ(index, z) {
        if (this.normalized) z = normalize(z, this.array);
        this.data.array[index * this.data.stride + this.offset + 2] = z;
        return this;
      }
    }, {
      key: "setW",
      value: function setW(index, w) {
        if (this.normalized) w = normalize(w, this.array);
        this.data.array[index * this.data.stride + this.offset + 3] = w;
        return this;
      }
    }, {
      key: "getX",
      value: function getX(index) {
        var x = this.data.array[index * this.data.stride + this.offset];
        if (this.normalized) x = denormalize(x, this.array);
        return x;
      }
    }, {
      key: "getY",
      value: function getY(index) {
        var y = this.data.array[index * this.data.stride + this.offset + 1];
        if (this.normalized) y = denormalize(y, this.array);
        return y;
      }
    }, {
      key: "getZ",
      value: function getZ(index) {
        var z = this.data.array[index * this.data.stride + this.offset + 2];
        if (this.normalized) z = denormalize(z, this.array);
        return z;
      }
    }, {
      key: "getW",
      value: function getW(index) {
        var w = this.data.array[index * this.data.stride + this.offset + 3];
        if (this.normalized) w = denormalize(w, this.array);
        return w;
      }
    }, {
      key: "setXY",
      value: function setXY(index, x, y) {
        index = index * this.data.stride + this.offset;
        if (this.normalized) {
          x = normalize(x, this.array);
          y = normalize(y, this.array);
        }
        this.data.array[index + 0] = x;
        this.data.array[index + 1] = y;
        return this;
      }
    }, {
      key: "setXYZ",
      value: function setXYZ(index, x, y, z) {
        index = index * this.data.stride + this.offset;
        if (this.normalized) {
          x = normalize(x, this.array);
          y = normalize(y, this.array);
          z = normalize(z, this.array);
        }
        this.data.array[index + 0] = x;
        this.data.array[index + 1] = y;
        this.data.array[index + 2] = z;
        return this;
      }
    }, {
      key: "setXYZW",
      value: function setXYZW(index, x, y, z, w) {
        index = index * this.data.stride + this.offset;
        if (this.normalized) {
          x = normalize(x, this.array);
          y = normalize(y, this.array);
          z = normalize(z, this.array);
          w = normalize(w, this.array);
        }
        this.data.array[index + 0] = x;
        this.data.array[index + 1] = y;
        this.data.array[index + 2] = z;
        this.data.array[index + 3] = w;
        return this;
      }
    }, {
      key: "clone",
      value: function clone(data) {
        if (data === undefined) {
          console.log('THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data.');
          var array = [];
          for (var i = 0; i < this.count; i++) {
            var index = i * this.data.stride + this.offset;
            for (var j = 0; j < this.itemSize; j++) {
              array.push(this.data.array[index + j]);
            }
          }
          return new BufferAttribute(new this.array.constructor(array), this.itemSize, this.normalized);
        } else {
          if (data.interleavedBuffers === undefined) {
            data.interleavedBuffers = {};
          }
          if (data.interleavedBuffers[this.data.uuid] === undefined) {
            data.interleavedBuffers[this.data.uuid] = this.data.clone(data);
          }
          return new InterleavedBufferAttribute(data.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized);
        }
      }
    }, {
      key: "toJSON",
      value: function toJSON(data) {
        if (data === undefined) {
          console.log('THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data.');
          var array = [];
          for (var i = 0; i < this.count; i++) {
            var index = i * this.data.stride + this.offset;
            for (var j = 0; j < this.itemSize; j++) {
              array.push(this.data.array[index + j]);
            }
          }

          // de-interleave data and save it as an ordinary buffer attribute for now

          return {
            itemSize: this.itemSize,
            type: this.array.constructor.name,
            array: array,
            normalized: this.normalized
          };
        } else {
          // save as true interleaved attribute

          if (data.interleavedBuffers === undefined) {
            data.interleavedBuffers = {};
          }
          if (data.interleavedBuffers[this.data.uuid] === undefined) {
            data.interleavedBuffers[this.data.uuid] = this.data.toJSON(data);
          }
          return {
            isInterleavedBufferAttribute: true,
            itemSize: this.itemSize,
            data: this.data.uuid,
            offset: this.offset,
            normalized: this.normalized
          };
        }
      }
    }]);
  }();
  var SpriteMaterial = exports.SpriteMaterial = /*#__PURE__*/function (_Material3) {
    function SpriteMaterial(parameters) {
      var _this22;
      (0, _classCallCheck2.default)(this, SpriteMaterial);
      _this22 = _callSuper(this, SpriteMaterial);
      _this22.isSpriteMaterial = true;
      _this22.type = 'SpriteMaterial';
      _this22.color = new Color(0xffffff);
      _this22.map = null;
      _this22.alphaMap = null;
      _this22.rotation = 0;
      _this22.sizeAttenuation = true;
      _this22.transparent = true;
      _this22.fog = true;
      _this22.setValues(parameters);
      return _this22;
    }
    (0, _inherits2.default)(SpriteMaterial, _Material3);
    return (0, _createClass2.default)(SpriteMaterial, [{
      key: "copy",
      value: function copy(source) {
        _superPropGet(SpriteMaterial, "copy", this, 3)([source]);
        this.color.copy(source.color);
        this.map = source.map;
        this.alphaMap = source.alphaMap;
        this.rotation = source.rotation;
        this.sizeAttenuation = source.sizeAttenuation;
        this.fog = source.fog;
        return this;
      }
    }]);
  }(Material);
  var _geometry;
  var _intersectPoint = /*@__PURE__*/new Vector3();
  var _worldScale = /*@__PURE__*/new Vector3();
  var _mvPosition = /*@__PURE__*/new Vector3();
  var _alignedPosition = /*@__PURE__*/new Vector2();
  var _rotatedPosition = /*@__PURE__*/new Vector2();
  var _viewWorldMatrix = /*@__PURE__*/new Matrix4();
  var _vA = /*@__PURE__*/new Vector3();
  var _vB = /*@__PURE__*/new Vector3();
  var _vC = /*@__PURE__*/new Vector3();
  var _uvA = /*@__PURE__*/new Vector2();
  var _uvB = /*@__PURE__*/new Vector2();
  var _uvC = /*@__PURE__*/new Vector2();
  var Sprite = exports.Sprite = /*#__PURE__*/function (_Object3D5) {
    function Sprite() {
      var _this23;
      var material = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new SpriteMaterial();
      (0, _classCallCheck2.default)(this, Sprite);
      _this23 = _callSuper(this, Sprite);
      _this23.isSprite = true;
      _this23.type = 'Sprite';
      if (_geometry === undefined) {
        _geometry = new BufferGeometry();
        var float32Array = new Float32Array([-0.5, -0.5, 0, 0, 0, 0.5, -0.5, 0, 1, 0, 0.5, 0.5, 0, 1, 1, -0.5, 0.5, 0, 0, 1]);
        var interleavedBuffer = new InterleavedBuffer(float32Array, 5);
        _geometry.setIndex([0, 1, 2, 0, 2, 3]);
        _geometry.setAttribute('position', new InterleavedBufferAttribute(interleavedBuffer, 3, 0, false));
        _geometry.setAttribute('uv', new InterleavedBufferAttribute(interleavedBuffer, 2, 3, false));
      }
      _this23.geometry = _geometry;
      _this23.material = material;
      _this23.center = new Vector2(0.5, 0.5);
      return _this23;
    }
    (0, _inherits2.default)(Sprite, _Object3D5);
    return (0, _createClass2.default)(Sprite, [{
      key: "raycast",
      value: function raycast(raycaster, intersects) {
        if (raycaster.camera === null) {
          console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.');
        }
        _worldScale.setFromMatrixScale(this.matrixWorld);
        _viewWorldMatrix.copy(raycaster.camera.matrixWorld);
        this.modelViewMatrix.multiplyMatrices(raycaster.camera.matrixWorldInverse, this.matrixWorld);
        _mvPosition.setFromMatrixPosition(this.modelViewMatrix);
        if (raycaster.camera.isPerspectiveCamera && this.material.sizeAttenuation === false) {
          _worldScale.multiplyScalar(-_mvPosition.z);
        }
        var rotation = this.material.rotation;
        var sin, cos;
        if (rotation !== 0) {
          cos = Math.cos(rotation);
          sin = Math.sin(rotation);
        }
        var center = this.center;
        transformVertex(_vA.set(-0.5, -0.5, 0), _mvPosition, center, _worldScale, sin, cos);
        transformVertex(_vB.set(0.5, -0.5, 0), _mvPosition, center, _worldScale, sin, cos);
        transformVertex(_vC.set(0.5, 0.5, 0), _mvPosition, center, _worldScale, sin, cos);
        _uvA.set(0, 0);
        _uvB.set(1, 0);
        _uvC.set(1, 1);

        // check first triangle
        var intersect = raycaster.ray.intersectTriangle(_vA, _vB, _vC, false, _intersectPoint);
        if (intersect === null) {
          // check second triangle
          transformVertex(_vB.set(-0.5, 0.5, 0), _mvPosition, center, _worldScale, sin, cos);
          _uvB.set(0, 1);
          intersect = raycaster.ray.intersectTriangle(_vA, _vC, _vB, false, _intersectPoint);
          if (intersect === null) {
            return;
          }
        }
        var distance = raycaster.ray.origin.distanceTo(_intersectPoint);
        if (distance < raycaster.near || distance > raycaster.far) return;
        intersects.push({
          distance: distance,
          point: _intersectPoint.clone(),
          uv: Triangle.getInterpolation(_intersectPoint, _vA, _vB, _vC, _uvA, _uvB, _uvC, new Vector2()),
          face: null,
          object: this
        });
      }
    }, {
      key: "copy",
      value: function copy(source, recursive) {
        _superPropGet(Sprite, "copy", this, 3)([source, recursive]);
        if (source.center !== undefined) this.center.copy(source.center);
        this.material = source.material;
        return this;
      }
    }]);
  }(Object3D);
  function transformVertex(vertexPosition, mvPosition, center, scale, sin, cos) {
    // compute position in camera space
    _alignedPosition.subVectors(vertexPosition, center).addScalar(0.5).multiply(scale);

    // to check if rotation is not zero
    if (sin !== undefined) {
      _rotatedPosition.x = cos * _alignedPosition.x - sin * _alignedPosition.y;
      _rotatedPosition.y = sin * _alignedPosition.x + cos * _alignedPosition.y;
    } else {
      _rotatedPosition.copy(_alignedPosition);
    }
    vertexPosition.copy(mvPosition);
    vertexPosition.x += _rotatedPosition.x;
    vertexPosition.y += _rotatedPosition.y;

    // transform to world space
    vertexPosition.applyMatrix4(_viewWorldMatrix);
  }
  var _v1$2 = /*@__PURE__*/new Vector3();
  var _v2$1 = /*@__PURE__*/new Vector3();
  var LOD = exports.LOD = /*#__PURE__*/function (_Object3D6) {
    function LOD() {
      var _this24;
      (0, _classCallCheck2.default)(this, LOD);
      _this24 = _callSuper(this, LOD);
      _this24._currentLevel = 0;
      _this24.type = 'LOD';
      Object.defineProperties(_this24, {
        levels: {
          enumerable: true,
          value: []
        },
        isLOD: {
          value: true
        }
      });
      _this24.autoUpdate = true;
      return _this24;
    }
    (0, _inherits2.default)(LOD, _Object3D6);
    return (0, _createClass2.default)(LOD, [{
      key: "copy",
      value: function copy(source) {
        _superPropGet(LOD, "copy", this, 3)([source, false]);
        var levels = source.levels;
        for (var i = 0, l = levels.length; i < l; i++) {
          var level = levels[i];
          this.addLevel(level.object.clone(), level.distance, level.hysteresis);
        }
        this.autoUpdate = source.autoUpdate;
        return this;
      }
    }, {
      key: "addLevel",
      value: function addLevel(object) {
        var distance = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        var hysteresis = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
        distance = Math.abs(distance);
        var levels = this.levels;
        var l;
        for (l = 0; l < levels.length; l++) {
          if (distance < levels[l].distance) {
            break;
          }
        }
        levels.splice(l, 0, {
          distance: distance,
          hysteresis: hysteresis,
          object: object
        });
        this.add(object);
        return this;
      }
    }, {
      key: "removeLevel",
      value: function removeLevel(distance) {
        var levels = this.levels;
        for (var i = 0; i < levels.length; i++) {
          if (levels[i].distance === distance) {
            var removedElements = levels.splice(i, 1);
            this.remove(removedElements[0].object);
            return true;
          }
        }
        return false;
      }
    }, {
      key: "getCurrentLevel",
      value: function getCurrentLevel() {
        return this._currentLevel;
      }
    }, {
      key: "getObjectForDistance",
      value: function getObjectForDistance(distance) {
        var levels = this.levels;
        if (levels.length > 0) {
          var i, l;
          for (i = 1, l = levels.length; i < l; i++) {
            var levelDistance = levels[i].distance;
            if (levels[i].object.visible) {
              levelDistance -= levelDistance * levels[i].hysteresis;
            }
            if (distance < levelDistance) {
              break;
            }
          }
          return levels[i - 1].object;
        }
        return null;
      }
    }, {
      key: "raycast",
      value: function raycast(raycaster, intersects) {
        var levels = this.levels;
        if (levels.length > 0) {
          _v1$2.setFromMatrixPosition(this.matrixWorld);
          var distance = raycaster.ray.origin.distanceTo(_v1$2);
          this.getObjectForDistance(distance).raycast(raycaster, intersects);
        }
      }
    }, {
      key: "update",
      value: function update(camera) {
        var levels = this.levels;
        if (levels.length > 1) {
          _v1$2.setFromMatrixPosition(camera.matrixWorld);
          _v2$1.setFromMatrixPosition(this.matrixWorld);
          var distance = _v1$2.distanceTo(_v2$1) / camera.zoom;
          levels[0].object.visible = true;
          var i, l;
          for (i = 1, l = levels.length; i < l; i++) {
            var levelDistance = levels[i].distance;
            if (levels[i].object.visible) {
              levelDistance -= levelDistance * levels[i].hysteresis;
            }
            if (distance >= levelDistance) {
              levels[i - 1].object.visible = false;
              levels[i].object.visible = true;
            } else {
              break;
            }
          }
          this._currentLevel = i - 1;
          for (; i < l; i++) {
            levels[i].object.visible = false;
          }
        }
      }
    }, {
      key: "toJSON",
      value: function toJSON(meta) {
        var data = _superPropGet(LOD, "toJSON", this, 3)([meta]);
        if (this.autoUpdate === false) data.object.autoUpdate = false;
        data.object.levels = [];
        var levels = this.levels;
        for (var i = 0, l = levels.length; i < l; i++) {
          var level = levels[i];
          data.object.levels.push({
            object: level.object.uuid,
            distance: level.distance,
            hysteresis: level.hysteresis
          });
        }
        return data;
      }
    }]);
  }(Object3D);
  var _basePosition = /*@__PURE__*/new Vector3();
  var _skinIndex = /*@__PURE__*/new Vector4();
  var _skinWeight = /*@__PURE__*/new Vector4();
  var _vector3 = /*@__PURE__*/new Vector3();
  var _matrix4 = /*@__PURE__*/new Matrix4();
  var _vertex = /*@__PURE__*/new Vector3();
  var _sphere$5 = /*@__PURE__*/new Sphere();
  var _inverseMatrix$2 = /*@__PURE__*/new Matrix4();
  var _ray$2 = /*@__PURE__*/new Ray();
  var SkinnedMesh = exports.SkinnedMesh = /*#__PURE__*/function (_Mesh) {
    function SkinnedMesh(geometry, material) {
      var _this25;
      (0, _classCallCheck2.default)(this, SkinnedMesh);
      _this25 = _callSuper(this, SkinnedMesh, [geometry, material]);
      _this25.isSkinnedMesh = true;
      _this25.type = 'SkinnedMesh';
      _this25.bindMode = AttachedBindMode;
      _this25.bindMatrix = new Matrix4();
      _this25.bindMatrixInverse = new Matrix4();
      _this25.boundingBox = null;
      _this25.boundingSphere = null;
      return _this25;
    }
    (0, _inherits2.default)(SkinnedMesh, _Mesh);
    return (0, _createClass2.default)(SkinnedMesh, [{
      key: "computeBoundingBox",
      value: function computeBoundingBox() {
        var geometry = this.geometry;
        if (this.boundingBox === null) {
          this.boundingBox = new Box3();
        }
        this.boundingBox.makeEmpty();
        var positionAttribute = geometry.getAttribute('position');
        for (var i = 0; i < positionAttribute.count; i++) {
          this.getVertexPosition(i, _vertex);
          this.boundingBox.expandByPoint(_vertex);
        }
      }
    }, {
      key: "computeBoundingSphere",
      value: function computeBoundingSphere() {
        var geometry = this.geometry;
        if (this.boundingSphere === null) {
          this.boundingSphere = new Sphere();
        }
        this.boundingSphere.makeEmpty();
        var positionAttribute = geometry.getAttribute('position');
        for (var i = 0; i < positionAttribute.count; i++) {
          this.getVertexPosition(i, _vertex);
          this.boundingSphere.expandByPoint(_vertex);
        }
      }
    }, {
      key: "copy",
      value: function copy(source, recursive) {
        _superPropGet(SkinnedMesh, "copy", this, 3)([source, recursive]);
        this.bindMode = source.bindMode;
        this.bindMatrix.copy(source.bindMatrix);
        this.bindMatrixInverse.copy(source.bindMatrixInverse);
        this.skeleton = source.skeleton;
        if (source.boundingBox !== null) this.boundingBox = source.boundingBox.clone();
        if (source.boundingSphere !== null) this.boundingSphere = source.boundingSphere.clone();
        return this;
      }
    }, {
      key: "raycast",
      value: function raycast(raycaster, intersects) {
        var material = this.material;
        var matrixWorld = this.matrixWorld;
        if (material === undefined) return;

        // test with bounding sphere in world space

        if (this.boundingSphere === null) this.computeBoundingSphere();
        _sphere$5.copy(this.boundingSphere);
        _sphere$5.applyMatrix4(matrixWorld);
        if (raycaster.ray.intersectsSphere(_sphere$5) === false) return;

        // convert ray to local space of skinned mesh

        _inverseMatrix$2.copy(matrixWorld).invert();
        _ray$2.copy(raycaster.ray).applyMatrix4(_inverseMatrix$2);

        // test with bounding box in local space

        if (this.boundingBox !== null) {
          if (_ray$2.intersectsBox(this.boundingBox) === false) return;
        }

        // test for intersections with geometry

        this._computeIntersections(raycaster, intersects, _ray$2);
      }
    }, {
      key: "getVertexPosition",
      value: function getVertexPosition(index, target) {
        _superPropGet(SkinnedMesh, "getVertexPosition", this, 3)([index, target]);
        this.applyBoneTransform(index, target);
        return target;
      }
    }, {
      key: "bind",
      value: function bind(skeleton, bindMatrix) {
        this.skeleton = skeleton;
        if (bindMatrix === undefined) {
          this.updateMatrixWorld(true);
          this.skeleton.calculateInverses();
          bindMatrix = this.matrixWorld;
        }
        this.bindMatrix.copy(bindMatrix);
        this.bindMatrixInverse.copy(bindMatrix).invert();
      }
    }, {
      key: "pose",
      value: function pose() {
        this.skeleton.pose();
      }
    }, {
      key: "normalizeSkinWeights",
      value: function normalizeSkinWeights() {
        var vector = new Vector4();
        var skinWeight = this.geometry.attributes.skinWeight;
        for (var i = 0, l = skinWeight.count; i < l; i++) {
          vector.fromBufferAttribute(skinWeight, i);
          var scale = 1.0 / vector.manhattanLength();
          if (scale !== Infinity) {
            vector.multiplyScalar(scale);
          } else {
            vector.set(1, 0, 0, 0); // do something reasonable
          }
          skinWeight.setXYZW(i, vector.x, vector.y, vector.z, vector.w);
        }
      }
    }, {
      key: "updateMatrixWorld",
      value: function updateMatrixWorld(force) {
        _superPropGet(SkinnedMesh, "updateMatrixWorld", this, 3)([force]);
        if (this.bindMode === AttachedBindMode) {
          this.bindMatrixInverse.copy(this.matrixWorld).invert();
        } else if (this.bindMode === DetachedBindMode) {
          this.bindMatrixInverse.copy(this.bindMatrix).invert();
        } else {
          console.warn('THREE.SkinnedMesh: Unrecognized bindMode: ' + this.bindMode);
        }
      }
    }, {
      key: "applyBoneTransform",
      value: function applyBoneTransform(index, vector) {
        var skeleton = this.skeleton;
        var geometry = this.geometry;
        _skinIndex.fromBufferAttribute(geometry.attributes.skinIndex, index);
        _skinWeight.fromBufferAttribute(geometry.attributes.skinWeight, index);
        _basePosition.copy(vector).applyMatrix4(this.bindMatrix);
        vector.set(0, 0, 0);
        for (var i = 0; i < 4; i++) {
          var weight = _skinWeight.getComponent(i);
          if (weight !== 0) {
            var boneIndex = _skinIndex.getComponent(i);
            _matrix4.multiplyMatrices(skeleton.bones[boneIndex].matrixWorld, skeleton.boneInverses[boneIndex]);
            vector.addScaledVector(_vector3.copy(_basePosition).applyMatrix4(_matrix4), weight);
          }
        }
        return vector.applyMatrix4(this.bindMatrixInverse);
      }
    }]);
  }(Mesh);
  var Bone = exports.Bone = /*#__PURE__*/function (_Object3D7) {
    function Bone() {
      var _this26;
      (0, _classCallCheck2.default)(this, Bone);
      _this26 = _callSuper(this, Bone);
      _this26.isBone = true;
      _this26.type = 'Bone';
      return _this26;
    }
    (0, _inherits2.default)(Bone, _Object3D7);
    return (0, _createClass2.default)(Bone);
  }(Object3D);
  var DataTexture = exports.DataTexture = /*#__PURE__*/function (_Texture4) {
    function DataTexture() {
      var _this27;
      var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      var width = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
      var height = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
      var format = arguments.length > 3 ? arguments[3] : undefined;
      var type = arguments.length > 4 ? arguments[4] : undefined;
      var mapping = arguments.length > 5 ? arguments[5] : undefined;
      var wrapS = arguments.length > 6 ? arguments[6] : undefined;
      var wrapT = arguments.length > 7 ? arguments[7] : undefined;
      var magFilter = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : NearestFilter;
      var minFilter = arguments.length > 9 && arguments[9] !== undefined ? arguments[9] : NearestFilter;
      var anisotropy = arguments.length > 10 ? arguments[10] : undefined;
      var colorSpace = arguments.length > 11 ? arguments[11] : undefined;
      (0, _classCallCheck2.default)(this, DataTexture);
      _this27 = _callSuper(this, DataTexture, [null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, colorSpace]);
      _this27.isDataTexture = true;
      _this27.image = {
        data: data,
        width: width,
        height: height
      };
      _this27.generateMipmaps = false;
      _this27.flipY = false;
      _this27.unpackAlignment = 1;
      return _this27;
    }
    (0, _inherits2.default)(DataTexture, _Texture4);
    return (0, _createClass2.default)(DataTexture);
  }(Texture);
  var _offsetMatrix = /*@__PURE__*/new Matrix4();
  var _identityMatrix = /*@__PURE__*/new Matrix4();
  var Skeleton = exports.Skeleton = /*#__PURE__*/function () {
    function Skeleton() {
      var bones = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      var boneInverses = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
      (0, _classCallCheck2.default)(this, Skeleton);
      this.uuid = generateUUID();
      this.bones = bones.slice(0);
      this.boneInverses = boneInverses;
      this.boneMatrices = null;
      this.boneTexture = null;
      this.init();
    }
    return (0, _createClass2.default)(Skeleton, [{
      key: "init",
      value: function init() {
        var bones = this.bones;
        var boneInverses = this.boneInverses;
        this.boneMatrices = new Float32Array(bones.length * 16);

        // calculate inverse bone matrices if necessary

        if (boneInverses.length === 0) {
          this.calculateInverses();
        } else {
          // handle special case

          if (bones.length !== boneInverses.length) {
            console.warn('THREE.Skeleton: Number of inverse bone matrices does not match amount of bones.');
            this.boneInverses = [];
            for (var i = 0, il = this.bones.length; i < il; i++) {
              this.boneInverses.push(new Matrix4());
            }
          }
        }
      }
    }, {
      key: "calculateInverses",
      value: function calculateInverses() {
        this.boneInverses.length = 0;
        for (var i = 0, il = this.bones.length; i < il; i++) {
          var inverse = new Matrix4();
          if (this.bones[i]) {
            inverse.copy(this.bones[i].matrixWorld).invert();
          }
          this.boneInverses.push(inverse);
        }
      }
    }, {
      key: "pose",
      value: function pose() {
        // recover the bind-time world matrices

        for (var i = 0, il = this.bones.length; i < il; i++) {
          var bone = this.bones[i];
          if (bone) {
            bone.matrixWorld.copy(this.boneInverses[i]).invert();
          }
        }

        // compute the local matrices, positions, rotations and scales

        for (var _i24 = 0, _il9 = this.bones.length; _i24 < _il9; _i24++) {
          var _bone = this.bones[_i24];
          if (_bone) {
            if (_bone.parent && _bone.parent.isBone) {
              _bone.matrix.copy(_bone.parent.matrixWorld).invert();
              _bone.matrix.multiply(_bone.matrixWorld);
            } else {
              _bone.matrix.copy(_bone.matrixWorld);
            }
            _bone.matrix.decompose(_bone.position, _bone.quaternion, _bone.scale);
          }
        }
      }
    }, {
      key: "update",
      value: function update() {
        var bones = this.bones;
        var boneInverses = this.boneInverses;
        var boneMatrices = this.boneMatrices;
        var boneTexture = this.boneTexture;

        // flatten bone matrices to array

        for (var i = 0, il = bones.length; i < il; i++) {
          // compute the offset between the current and the original transform

          var matrix = bones[i] ? bones[i].matrixWorld : _identityMatrix;
          _offsetMatrix.multiplyMatrices(matrix, boneInverses[i]);
          _offsetMatrix.toArray(boneMatrices, i * 16);
        }
        if (boneTexture !== null) {
          boneTexture.needsUpdate = true;
        }
      }
    }, {
      key: "clone",
      value: function clone() {
        return new Skeleton(this.bones, this.boneInverses);
      }
    }, {
      key: "computeBoneTexture",
      value: function computeBoneTexture() {
        // layout (1 matrix = 4 pixels)
        //      RGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)
        //  with  8x8  pixel texture max   16 bones * 4 pixels =  (8 * 8)
        //       16x16 pixel texture max   64 bones * 4 pixels = (16 * 16)
        //       32x32 pixel texture max  256 bones * 4 pixels = (32 * 32)
        //       64x64 pixel texture max 1024 bones * 4 pixels = (64 * 64)

        var size = Math.sqrt(this.bones.length * 4); // 4 pixels needed for 1 matrix
        size = Math.ceil(size / 4) * 4;
        size = Math.max(size, 4);
        var boneMatrices = new Float32Array(size * size * 4); // 4 floats per RGBA pixel
        boneMatrices.set(this.boneMatrices); // copy current values

        var boneTexture = new DataTexture(boneMatrices, size, size, RGBAFormat, FloatType);
        boneTexture.needsUpdate = true;
        this.boneMatrices = boneMatrices;
        this.boneTexture = boneTexture;
        return this;
      }
    }, {
      key: "getBoneByName",
      value: function getBoneByName(name) {
        for (var i = 0, il = this.bones.length; i < il; i++) {
          var bone = this.bones[i];
          if (bone.name === name) {
            return bone;
          }
        }
        return undefined;
      }
    }, {
      key: "dispose",
      value: function dispose() {
        if (this.boneTexture !== null) {
          this.boneTexture.dispose();
          this.boneTexture = null;
        }
      }
    }, {
      key: "fromJSON",
      value: function fromJSON(json, bones) {
        this.uuid = json.uuid;
        for (var i = 0, l = json.bones.length; i < l; i++) {
          var uuid = json.bones[i];
          var bone = bones[uuid];
          if (bone === undefined) {
            console.warn('THREE.Skeleton: No bone found with UUID:', uuid);
            bone = new Bone();
          }
          this.bones.push(bone);
          this.boneInverses.push(new Matrix4().fromArray(json.boneInverses[i]));
        }
        this.init();
        return this;
      }
    }, {
      key: "toJSON",
      value: function toJSON() {
        var data = {
          metadata: {
            version: 4.6,
            type: 'Skeleton',
            generator: 'Skeleton.toJSON'
          },
          bones: [],
          boneInverses: []
        };
        data.uuid = this.uuid;
        var bones = this.bones;
        var boneInverses = this.boneInverses;
        for (var i = 0, l = bones.length; i < l; i++) {
          var bone = bones[i];
          data.bones.push(bone.uuid);
          var boneInverse = boneInverses[i];
          data.boneInverses.push(boneInverse.toArray());
        }
        return data;
      }
    }]);
  }();
  var InstancedBufferAttribute = exports.InstancedBufferAttribute = /*#__PURE__*/function (_BufferAttribute10) {
    function InstancedBufferAttribute(array, itemSize, normalized) {
      var _this28;
      var meshPerAttribute = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;
      (0, _classCallCheck2.default)(this, InstancedBufferAttribute);
      _this28 = _callSuper(this, InstancedBufferAttribute, [array, itemSize, normalized]);
      _this28.isInstancedBufferAttribute = true;
      _this28.meshPerAttribute = meshPerAttribute;
      return _this28;
    }
    (0, _inherits2.default)(InstancedBufferAttribute, _BufferAttribute10);
    return (0, _createClass2.default)(InstancedBufferAttribute, [{
      key: "copy",
      value: function copy(source) {
        _superPropGet(InstancedBufferAttribute, "copy", this, 3)([source]);
        this.meshPerAttribute = source.meshPerAttribute;
        return this;
      }
    }, {
      key: "toJSON",
      value: function toJSON() {
        var data = _superPropGet(InstancedBufferAttribute, "toJSON", this, 3)([]);
        data.meshPerAttribute = this.meshPerAttribute;
        data.isInstancedBufferAttribute = true;
        return data;
      }
    }]);
  }(BufferAttribute);
  var _instanceLocalMatrix = /*@__PURE__*/new Matrix4();
  var _instanceWorldMatrix = /*@__PURE__*/new Matrix4();
  var _instanceIntersects = [];
  var _box3 = /*@__PURE__*/new Box3();
  var _identity = /*@__PURE__*/new Matrix4();
  var _mesh$1 = /*@__PURE__*/new Mesh();
  var _sphere$4 = /*@__PURE__*/new Sphere();
  var InstancedMesh = exports.InstancedMesh = /*#__PURE__*/function (_Mesh2) {
    function InstancedMesh(geometry, material, count) {
      var _this29;
      (0, _classCallCheck2.default)(this, InstancedMesh);
      _this29 = _callSuper(this, InstancedMesh, [geometry, material]);
      _this29.isInstancedMesh = true;
      _this29.instanceMatrix = new InstancedBufferAttribute(new Float32Array(count * 16), 16);
      _this29.instanceColor = null;
      _this29.morphTexture = null;
      _this29.count = count;
      _this29.boundingBox = null;
      _this29.boundingSphere = null;
      for (var i = 0; i < count; i++) {
        _this29.setMatrixAt(i, _identity);
      }
      return _this29;
    }
    (0, _inherits2.default)(InstancedMesh, _Mesh2);
    return (0, _createClass2.default)(InstancedMesh, [{
      key: "computeBoundingBox",
      value: function computeBoundingBox() {
        var geometry = this.geometry;
        var count = this.count;
        if (this.boundingBox === null) {
          this.boundingBox = new Box3();
        }
        if (geometry.boundingBox === null) {
          geometry.computeBoundingBox();
        }
        this.boundingBox.makeEmpty();
        for (var i = 0; i < count; i++) {
          this.getMatrixAt(i, _instanceLocalMatrix);
          _box3.copy(geometry.boundingBox).applyMatrix4(_instanceLocalMatrix);
          this.boundingBox.union(_box3);
        }
      }
    }, {
      key: "computeBoundingSphere",
      value: function computeBoundingSphere() {
        var geometry = this.geometry;
        var count = this.count;
        if (this.boundingSphere === null) {
          this.boundingSphere = new Sphere();
        }
        if (geometry.boundingSphere === null) {
          geometry.computeBoundingSphere();
        }
        this.boundingSphere.makeEmpty();
        for (var i = 0; i < count; i++) {
          this.getMatrixAt(i, _instanceLocalMatrix);
          _sphere$4.copy(geometry.boundingSphere).applyMatrix4(_instanceLocalMatrix);
          this.boundingSphere.union(_sphere$4);
        }
      }
    }, {
      key: "copy",
      value: function copy(source, recursive) {
        _superPropGet(InstancedMesh, "copy", this, 3)([source, recursive]);
        this.instanceMatrix.copy(source.instanceMatrix);
        if (source.morphTexture !== null) this.morphTexture = source.morphTexture.clone();
        if (source.instanceColor !== null) this.instanceColor = source.instanceColor.clone();
        this.count = source.count;
        if (source.boundingBox !== null) this.boundingBox = source.boundingBox.clone();
        if (source.boundingSphere !== null) this.boundingSphere = source.boundingSphere.clone();
        return this;
      }
    }, {
      key: "getColorAt",
      value: function getColorAt(index, color) {
        color.fromArray(this.instanceColor.array, index * 3);
      }
    }, {
      key: "getMatrixAt",
      value: function getMatrixAt(index, matrix) {
        matrix.fromArray(this.instanceMatrix.array, index * 16);
      }
    }, {
      key: "getMorphAt",
      value: function getMorphAt(index, object) {
        var objectInfluences = object.morphTargetInfluences;
        var array = this.morphTexture.source.data.data;
        var len = objectInfluences.length + 1; // All influences + the baseInfluenceSum

        var dataIndex = index * len + 1; // Skip the baseInfluenceSum at the beginning

        for (var i = 0; i < objectInfluences.length; i++) {
          objectInfluences[i] = array[dataIndex + i];
        }
      }
    }, {
      key: "raycast",
      value: function raycast(raycaster, intersects) {
        var matrixWorld = this.matrixWorld;
        var raycastTimes = this.count;
        _mesh$1.geometry = this.geometry;
        _mesh$1.material = this.material;
        if (_mesh$1.material === undefined) return;

        // test with bounding sphere first

        if (this.boundingSphere === null) this.computeBoundingSphere();
        _sphere$4.copy(this.boundingSphere);
        _sphere$4.applyMatrix4(matrixWorld);
        if (raycaster.ray.intersectsSphere(_sphere$4) === false) return;

        // now test each instance

        for (var instanceId = 0; instanceId < raycastTimes; instanceId++) {
          // calculate the world matrix for each instance

          this.getMatrixAt(instanceId, _instanceLocalMatrix);
          _instanceWorldMatrix.multiplyMatrices(matrixWorld, _instanceLocalMatrix);

          // the mesh represents this single instance

          _mesh$1.matrixWorld = _instanceWorldMatrix;
          _mesh$1.raycast(raycaster, _instanceIntersects);

          // process the result of raycast

          for (var i = 0, l = _instanceIntersects.length; i < l; i++) {
            var _intersect = _instanceIntersects[i];
            _intersect.instanceId = instanceId;
            _intersect.object = this;
            intersects.push(_intersect);
          }
          _instanceIntersects.length = 0;
        }
      }
    }, {
      key: "setColorAt",
      value: function setColorAt(index, color) {
        if (this.instanceColor === null) {
          this.instanceColor = new InstancedBufferAttribute(new Float32Array(this.instanceMatrix.count * 3).fill(1), 3);
        }
        color.toArray(this.instanceColor.array, index * 3);
      }
    }, {
      key: "setMatrixAt",
      value: function setMatrixAt(index, matrix) {
        matrix.toArray(this.instanceMatrix.array, index * 16);
      }
    }, {
      key: "setMorphAt",
      value: function setMorphAt(index, object) {
        var objectInfluences = object.morphTargetInfluences;
        var len = objectInfluences.length + 1; // morphBaseInfluence + all influences

        if (this.morphTexture === null) {
          this.morphTexture = new DataTexture(new Float32Array(len * this.count), len, this.count, RedFormat, FloatType);
        }
        var array = this.morphTexture.source.data.data;
        var morphInfluencesSum = 0;
        for (var i = 0; i < objectInfluences.length; i++) {
          morphInfluencesSum += objectInfluences[i];
        }
        var morphBaseInfluence = this.geometry.morphTargetsRelative ? 1 : 1 - morphInfluencesSum;
        var dataIndex = len * index;
        array[dataIndex] = morphBaseInfluence;
        array.set(objectInfluences, dataIndex + 1);
      }
    }, {
      key: "updateMorphTargets",
      value: function updateMorphTargets() {}
    }, {
      key: "dispose",
      value: function dispose() {
        this.dispatchEvent({
          type: 'dispose'
        });
        if (this.morphTexture !== null) {
          this.morphTexture.dispose();
          this.morphTexture = null;
        }
        return this;
      }
    }]);
  }(Mesh);
  var _vector1 = /*@__PURE__*/new Vector3();
  var _vector2 = /*@__PURE__*/new Vector3();
  var _normalMatrix = /*@__PURE__*/new Matrix3();
  var Plane = exports.Plane = /*#__PURE__*/function () {
    function Plane() {
      var normal = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Vector3(1, 0, 0);
      var constant = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      (0, _classCallCheck2.default)(this, Plane);
      this.isPlane = true;

      // normal is assumed to be normalized

      this.normal = normal;
      this.constant = constant;
    }
    return (0, _createClass2.default)(Plane, [{
      key: "set",
      value: function set(normal, constant) {
        this.normal.copy(normal);
        this.constant = constant;
        return this;
      }
    }, {
      key: "setComponents",
      value: function setComponents(x, y, z, w) {
        this.normal.set(x, y, z);
        this.constant = w;
        return this;
      }
    }, {
      key: "setFromNormalAndCoplanarPoint",
      value: function setFromNormalAndCoplanarPoint(normal, point) {
        this.normal.copy(normal);
        this.constant = -point.dot(this.normal);
        return this;
      }
    }, {
      key: "setFromCoplanarPoints",
      value: function setFromCoplanarPoints(a, b, c) {
        var normal = _vector1.subVectors(c, b).cross(_vector2.subVectors(a, b)).normalize();

        // Q: should an error be thrown if normal is zero (e.g. degenerate plane)?

        this.setFromNormalAndCoplanarPoint(normal, a);
        return this;
      }
    }, {
      key: "copy",
      value: function copy(plane) {
        this.normal.copy(plane.normal);
        this.constant = plane.constant;
        return this;
      }
    }, {
      key: "normalize",
      value: function normalize() {
        // Note: will lead to a divide by zero if the plane is invalid.

        var inverseNormalLength = 1.0 / this.normal.length();
        this.normal.multiplyScalar(inverseNormalLength);
        this.constant *= inverseNormalLength;
        return this;
      }
    }, {
      key: "negate",
      value: function negate() {
        this.constant *= -1;
        this.normal.negate();
        return this;
      }
    }, {
      key: "distanceToPoint",
      value: function distanceToPoint(point) {
        return this.normal.dot(point) + this.constant;
      }
    }, {
      key: "distanceToSphere",
      value: function distanceToSphere(sphere) {
        return this.distanceToPoint(sphere.center) - sphere.radius;
      }
    }, {
      key: "projectPoint",
      value: function projectPoint(point, target) {
        return target.copy(point).addScaledVector(this.normal, -this.distanceToPoint(point));
      }
    }, {
      key: "intersectLine",
      value: function intersectLine(line, target) {
        var direction = line.delta(_vector1);
        var denominator = this.normal.dot(direction);
        if (denominator === 0) {
          // line is coplanar, return origin
          if (this.distanceToPoint(line.start) === 0) {
            return target.copy(line.start);
          }

          // Unsure if this is the correct method to handle this case.
          return null;
        }
        var t = -(line.start.dot(this.normal) + this.constant) / denominator;
        if (t < 0 || t > 1) {
          return null;
        }
        return target.copy(line.start).addScaledVector(direction, t);
      }
    }, {
      key: "intersectsLine",
      value: function intersectsLine(line) {
        // Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.

        var startSign = this.distanceToPoint(line.start);
        var endSign = this.distanceToPoint(line.end);
        return startSign < 0 && endSign > 0 || endSign < 0 && startSign > 0;
      }
    }, {
      key: "intersectsBox",
      value: function intersectsBox(box) {
        return box.intersectsPlane(this);
      }
    }, {
      key: "intersectsSphere",
      value: function intersectsSphere(sphere) {
        return sphere.intersectsPlane(this);
      }
    }, {
      key: "coplanarPoint",
      value: function coplanarPoint(target) {
        return target.copy(this.normal).multiplyScalar(-this.constant);
      }
    }, {
      key: "applyMatrix4",
      value: function applyMatrix4(matrix, optionalNormalMatrix) {
        var normalMatrix = optionalNormalMatrix || _normalMatrix.getNormalMatrix(matrix);
        var referencePoint = this.coplanarPoint(_vector1).applyMatrix4(matrix);
        var normal = this.normal.applyMatrix3(normalMatrix).normalize();
        this.constant = -referencePoint.dot(normal);
        return this;
      }
    }, {
      key: "translate",
      value: function translate(offset) {
        this.constant -= offset.dot(this.normal);
        return this;
      }
    }, {
      key: "equals",
      value: function equals(plane) {
        return plane.normal.equals(this.normal) && plane.constant === this.constant;
      }
    }, {
      key: "clone",
      value: function clone() {
        return new this.constructor().copy(this);
      }
    }]);
  }();
  var _sphere$3 = /*@__PURE__*/new Sphere();
  var _vector$6 = /*@__PURE__*/new Vector3();
  var Frustum = exports.Frustum = /*#__PURE__*/function () {
    function Frustum() {
      var p0 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Plane();
      var p1 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Plane();
      var p2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new Plane();
      var p3 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : new Plane();
      var p4 = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : new Plane();
      var p5 = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : new Plane();
      (0, _classCallCheck2.default)(this, Frustum);
      this.planes = [p0, p1, p2, p3, p4, p5];
    }
    return (0, _createClass2.default)(Frustum, [{
      key: "set",
      value: function set(p0, p1, p2, p3, p4, p5) {
        var planes = this.planes;
        planes[0].copy(p0);
        planes[1].copy(p1);
        planes[2].copy(p2);
        planes[3].copy(p3);
        planes[4].copy(p4);
        planes[5].copy(p5);
        return this;
      }
    }, {
      key: "copy",
      value: function copy(frustum) {
        var planes = this.planes;
        for (var i = 0; i < 6; i++) {
          planes[i].copy(frustum.planes[i]);
        }
        return this;
      }
    }, {
      key: "setFromProjectionMatrix",
      value: function setFromProjectionMatrix(m) {
        var coordinateSystem = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : WebGLCoordinateSystem;
        var planes = this.planes;
        var me = m.elements;
        var me0 = me[0],
          me1 = me[1],
          me2 = me[2],
          me3 = me[3];
        var me4 = me[4],
          me5 = me[5],
          me6 = me[6],
          me7 = me[7];
        var me8 = me[8],
          me9 = me[9],
          me10 = me[10],
          me11 = me[11];
        var me12 = me[12],
          me13 = me[13],
          me14 = me[14],
          me15 = me[15];
        planes[0].setComponents(me3 - me0, me7 - me4, me11 - me8, me15 - me12).normalize();
        planes[1].setComponents(me3 + me0, me7 + me4, me11 + me8, me15 + me12).normalize();
        planes[2].setComponents(me3 + me1, me7 + me5, me11 + me9, me15 + me13).normalize();
        planes[3].setComponents(me3 - me1, me7 - me5, me11 - me9, me15 - me13).normalize();
        planes[4].setComponents(me3 - me2, me7 - me6, me11 - me10, me15 - me14).normalize();
        if (coordinateSystem === WebGLCoordinateSystem) {
          planes[5].setComponents(me3 + me2, me7 + me6, me11 + me10, me15 + me14).normalize();
        } else if (coordinateSystem === WebGPUCoordinateSystem) {
          planes[5].setComponents(me2, me6, me10, me14).normalize();
        } else {
          throw new Error('THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: ' + coordinateSystem);
        }
        return this;
      }
    }, {
      key: "intersectsObject",
      value: function intersectsObject(object) {
        if (object.boundingSphere !== undefined) {
          if (object.boundingSphere === null) object.computeBoundingSphere();
          _sphere$3.copy(object.boundingSphere).applyMatrix4(object.matrixWorld);
        } else {
          var geometry = object.geometry;
          if (geometry.boundingSphere === null) geometry.computeBoundingSphere();
          _sphere$3.copy(geometry.boundingSphere).applyMatrix4(object.matrixWorld);
        }
        return this.intersectsSphere(_sphere$3);
      }
    }, {
      key: "intersectsSprite",
      value: function intersectsSprite(sprite) {
        _sphere$3.center.set(0, 0, 0);
        _sphere$3.radius = 0.7071067811865476;
        _sphere$3.applyMatrix4(sprite.matrixWorld);
        return this.intersectsSphere(_sphere$3);
      }
    }, {
      key: "intersectsSphere",
      value: function intersectsSphere(sphere) {
        var planes = this.planes;
        var center = sphere.center;
        var negRadius = -sphere.radius;
        for (var i = 0; i < 6; i++) {
          var distance = planes[i].distanceToPoint(center);
          if (distance < negRadius) {
            return false;
          }
        }
        return true;
      }
    }, {
      key: "intersectsBox",
      value: function intersectsBox(box) {
        var planes = this.planes;
        for (var i = 0; i < 6; i++) {
          var plane = planes[i];

          // corner at max distance

          _vector$6.x = plane.normal.x > 0 ? box.max.x : box.min.x;
          _vector$6.y = plane.normal.y > 0 ? box.max.y : box.min.y;
          _vector$6.z = plane.normal.z > 0 ? box.max.z : box.min.z;
          if (plane.distanceToPoint(_vector$6) < 0) {
            return false;
          }
        }
        return true;
      }
    }, {
      key: "containsPoint",
      value: function containsPoint(point) {
        var planes = this.planes;
        for (var i = 0; i < 6; i++) {
          if (planes[i].distanceToPoint(point) < 0) {
            return false;
          }
        }
        return true;
      }
    }, {
      key: "clone",
      value: function clone() {
        return new this.constructor().copy(this);
      }
    }]);
  }();
  function ascIdSort(a, b) {
    return a - b;
  }
  function sortOpaque(a, b) {
    return a.z - b.z;
  }
  function sortTransparent(a, b) {
    return b.z - a.z;
  }
  var MultiDrawRenderList = /*#__PURE__*/function () {
    function MultiDrawRenderList() {
      (0, _classCallCheck2.default)(this, MultiDrawRenderList);
      this.index = 0;
      this.pool = [];
      this.list = [];
    }
    return (0, _createClass2.default)(MultiDrawRenderList, [{
      key: "push",
      value: function push(start, count, z, index) {
        var pool = this.pool;
        var list = this.list;
        if (this.index >= pool.length) {
          pool.push({
            start: -1,
            count: -1,
            z: -1,
            index: -1
          });
        }
        var item = pool[this.index];
        list.push(item);
        this.index++;
        item.start = start;
        item.count = count;
        item.z = z;
        item.index = index;
      }
    }, {
      key: "reset",
      value: function reset() {
        this.list.length = 0;
        this.index = 0;
      }
    }]);
  }();
  var _matrix$1 = /*@__PURE__*/new Matrix4();
  var _whiteColor = /*@__PURE__*/new Color(1, 1, 1);
  var _frustum = /*@__PURE__*/new Frustum();
  var _box$1 = /*@__PURE__*/new Box3();
  var _sphere$2 = /*@__PURE__*/new Sphere();
  var _vector$5 = /*@__PURE__*/new Vector3();
  var _forward = /*@__PURE__*/new Vector3();
  var _temp = /*@__PURE__*/new Vector3();
  var _renderList = /*@__PURE__*/new MultiDrawRenderList();
  var _mesh = /*@__PURE__*/new Mesh();
  var _batchIntersects = [];

  // copies data from attribute "src" into "target" starting at "targetOffset"
  function copyAttributeData(src, target) {
    var targetOffset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
    var itemSize = target.itemSize;
    if (src.isInterleavedBufferAttribute || src.array.constructor !== target.array.constructor) {
      // use the component getters and setters if the array data cannot
      // be copied directly
      var vertexCount = src.count;
      for (var i = 0; i < vertexCount; i++) {
        for (var c = 0; c < itemSize; c++) {
          target.setComponent(i + targetOffset, c, src.getComponent(i, c));
        }
      }
    } else {
      // faster copy approach using typed array set function
      target.array.set(src.array, targetOffset * itemSize);
    }
    target.needsUpdate = true;
  }

  // safely copies array contents to a potentially smaller array
  function copyArrayContents(src, target) {
    if (src.constructor !== target.constructor) {
      // if arrays are of a different type (eg due to index size increasing) then data must be per-element copied
      var len = Math.min(src.length, target.length);
      for (var i = 0; i < len; i++) {
        target[i] = src[i];
      }
    } else {
      // if the arrays use the same data layout we can use a fast block copy
      var _len = Math.min(src.length, target.length);
      target.set(new src.constructor(src.buffer, 0, _len));
    }
  }
  var BatchedMesh = exports.BatchedMesh = /*#__PURE__*/function (_Mesh3) {
    function BatchedMesh(maxInstanceCount, maxVertexCount) {
      var _this30;
      var maxIndexCount = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : maxVertexCount * 2;
      var material = arguments.length > 3 ? arguments[3] : undefined;
      (0, _classCallCheck2.default)(this, BatchedMesh);
      _this30 = _callSuper(this, BatchedMesh, [new BufferGeometry(), material]);
      _this30.isBatchedMesh = true;
      _this30.perObjectFrustumCulled = true;
      _this30.sortObjects = true;
      _this30.boundingBox = null;
      _this30.boundingSphere = null;
      _this30.customSort = null;

      // stores visible, active, and geometry id per instance and reserved buffer ranges for geometries
      _this30._instanceInfo = [];
      _this30._geometryInfo = [];

      // instance, geometry ids that have been set as inactive, and are available to be overwritten
      _this30._availableInstanceIds = [];
      _this30._availableGeometryIds = [];

      // used to track where the next point is that geometry should be inserted
      _this30._nextIndexStart = 0;
      _this30._nextVertexStart = 0;
      _this30._geometryCount = 0;

      // flags
      _this30._visibilityChanged = true;
      _this30._geometryInitialized = false;

      // cached user options
      _this30._maxInstanceCount = maxInstanceCount;
      _this30._maxVertexCount = maxVertexCount;
      _this30._maxIndexCount = maxIndexCount;

      // buffers for multi draw
      _this30._multiDrawCounts = new Int32Array(maxInstanceCount);
      _this30._multiDrawStarts = new Int32Array(maxInstanceCount);
      _this30._multiDrawCount = 0;
      _this30._multiDrawInstances = null;

      // Local matrix per geometry by using data texture
      _this30._matricesTexture = null;
      _this30._indirectTexture = null;
      _this30._colorsTexture = null;
      _this30._initMatricesTexture();
      _this30._initIndirectTexture();
      return _this30;
    }
    (0, _inherits2.default)(BatchedMesh, _Mesh3);
    return (0, _createClass2.default)(BatchedMesh, [{
      key: "maxInstanceCount",
      get: function get() {
        return this._maxInstanceCount;
      }
    }, {
      key: "instanceCount",
      get: function get() {
        return this._instanceInfo.length - this._availableInstanceIds.length;
      }
    }, {
      key: "unusedVertexCount",
      get: function get() {
        return this._maxVertexCount - this._nextVertexStart;
      }
    }, {
      key: "unusedIndexCount",
      get: function get() {
        return this._maxIndexCount - this._nextIndexStart;
      }
    }, {
      key: "_initMatricesTexture",
      value: function _initMatricesTexture() {
        // layout (1 matrix = 4 pixels)
        //      RGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)
        //  with  8x8  pixel texture max   16 matrices * 4 pixels =  (8 * 8)
        //       16x16 pixel texture max   64 matrices * 4 pixels = (16 * 16)
        //       32x32 pixel texture max  256 matrices * 4 pixels = (32 * 32)
        //       64x64 pixel texture max 1024 matrices * 4 pixels = (64 * 64)

        var size = Math.sqrt(this._maxInstanceCount * 4); // 4 pixels needed for 1 matrix
        size = Math.ceil(size / 4) * 4;
        size = Math.max(size, 4);
        var matricesArray = new Float32Array(size * size * 4); // 4 floats per RGBA pixel
        var matricesTexture = new DataTexture(matricesArray, size, size, RGBAFormat, FloatType);
        this._matricesTexture = matricesTexture;
      }
    }, {
      key: "_initIndirectTexture",
      value: function _initIndirectTexture() {
        var size = Math.sqrt(this._maxInstanceCount);
        size = Math.ceil(size);
        var indirectArray = new Uint32Array(size * size);
        var indirectTexture = new DataTexture(indirectArray, size, size, RedIntegerFormat, UnsignedIntType);
        this._indirectTexture = indirectTexture;
      }
    }, {
      key: "_initColorsTexture",
      value: function _initColorsTexture() {
        var size = Math.sqrt(this._maxInstanceCount);
        size = Math.ceil(size);

        // 4 floats per RGBA pixel initialized to white
        var colorsArray = new Float32Array(size * size * 4).fill(1);
        var colorsTexture = new DataTexture(colorsArray, size, size, RGBAFormat, FloatType);
        colorsTexture.colorSpace = ColorManagement.workingColorSpace;
        this._colorsTexture = colorsTexture;
      }
    }, {
      key: "_initializeGeometry",
      value: function _initializeGeometry(reference) {
        var geometry = this.geometry;
        var maxVertexCount = this._maxVertexCount;
        var maxIndexCount = this._maxIndexCount;
        if (this._geometryInitialized === false) {
          for (var attributeName in reference.attributes) {
            var srcAttribute = reference.getAttribute(attributeName);
            var array = srcAttribute.array,
              itemSize = srcAttribute.itemSize,
              normalized = srcAttribute.normalized;
            var dstArray = new array.constructor(maxVertexCount * itemSize);
            var dstAttribute = new BufferAttribute(dstArray, itemSize, normalized);
            geometry.setAttribute(attributeName, dstAttribute);
          }
          if (reference.getIndex() !== null) {
            // Reserve last u16 index for primitive restart.
            var indexArray = maxVertexCount > 65535 ? new Uint32Array(maxIndexCount) : new Uint16Array(maxIndexCount);
            geometry.setIndex(new BufferAttribute(indexArray, 1));
          }
          this._geometryInitialized = true;
        }
      }

      // Make sure the geometry is compatible with the existing combined geometry attributes
    }, {
      key: "_validateGeometry",
      value: function _validateGeometry(geometry) {
        // check to ensure the geometries are using consistent attributes and indices
        var batchGeometry = this.geometry;
        if (Boolean(geometry.getIndex()) !== Boolean(batchGeometry.getIndex())) {
          throw new Error('THREE.BatchedMesh: All geometries must consistently have "index".');
        }
        for (var attributeName in batchGeometry.attributes) {
          if (!geometry.hasAttribute(attributeName)) {
            throw new Error(`THREE.BatchedMesh: Added geometry missing "${attributeName}". All geometries must have consistent attributes.`);
          }
          var srcAttribute = geometry.getAttribute(attributeName);
          var dstAttribute = batchGeometry.getAttribute(attributeName);
          if (srcAttribute.itemSize !== dstAttribute.itemSize || srcAttribute.normalized !== dstAttribute.normalized) {
            throw new Error('THREE.BatchedMesh: All attributes must have a consistent itemSize and normalized value.');
          }
        }
      }
    }, {
      key: "validateInstanceId",
      value: function validateInstanceId(instanceId) {
        var instanceInfo = this._instanceInfo;
        if (instanceId < 0 || instanceId >= instanceInfo.length || instanceInfo[instanceId].active === false) {
          throw new Error(`THREE.BatchedMesh: Invalid instanceId ${instanceId}. Instance is either out of range or has been deleted.`);
        }
      }
    }, {
      key: "validateGeometryId",
      value: function validateGeometryId(geometryId) {
        var geometryInfoList = this._geometryInfo;
        if (geometryId < 0 || geometryId >= geometryInfoList.length || geometryInfoList[geometryId].active === false) {
          throw new Error(`THREE.BatchedMesh: Invalid geometryId ${geometryId}. Geometry is either out of range or has been deleted.`);
        }
      }
    }, {
      key: "setCustomSort",
      value: function setCustomSort(func) {
        this.customSort = func;
        return this;
      }
    }, {
      key: "computeBoundingBox",
      value: function computeBoundingBox() {
        if (this.boundingBox === null) {
          this.boundingBox = new Box3();
        }
        var boundingBox = this.boundingBox;
        var instanceInfo = this._instanceInfo;
        boundingBox.makeEmpty();
        for (var i = 0, l = instanceInfo.length; i < l; i++) {
          if (instanceInfo[i].active === false) continue;
          var geometryId = instanceInfo[i].geometryIndex;
          this.getMatrixAt(i, _matrix$1);
          this.getBoundingBoxAt(geometryId, _box$1).applyMatrix4(_matrix$1);
          boundingBox.union(_box$1);
        }
      }
    }, {
      key: "computeBoundingSphere",
      value: function computeBoundingSphere() {
        if (this.boundingSphere === null) {
          this.boundingSphere = new Sphere();
        }
        var boundingSphere = this.boundingSphere;
        var instanceInfo = this._instanceInfo;
        boundingSphere.makeEmpty();
        for (var i = 0, l = instanceInfo.length; i < l; i++) {
          if (instanceInfo[i].active === false) continue;
          var geometryId = instanceInfo[i].geometryIndex;
          this.getMatrixAt(i, _matrix$1);
          this.getBoundingSphereAt(geometryId, _sphere$2).applyMatrix4(_matrix$1);
          boundingSphere.union(_sphere$2);
        }
      }
    }, {
      key: "addInstance",
      value: function addInstance(geometryId) {
        var atCapacity = this._instanceInfo.length >= this.maxInstanceCount;

        // ensure we're not over geometry
        if (atCapacity && this._availableInstanceIds.length === 0) {
          throw new Error('THREE.BatchedMesh: Maximum item count reached.');
        }
        var instanceInfo = {
          visible: true,
          active: true,
          geometryIndex: geometryId
        };
        var drawId = null;

        // Prioritize using previously freed instance ids
        if (this._availableInstanceIds.length > 0) {
          this._availableInstanceIds.sort(ascIdSort);
          drawId = this._availableInstanceIds.shift();
          this._instanceInfo[drawId] = instanceInfo;
        } else {
          drawId = this._instanceInfo.length;
          this._instanceInfo.push(instanceInfo);
        }
        var matricesTexture = this._matricesTexture;
        _matrix$1.identity().toArray(matricesTexture.image.data, drawId * 16);
        matricesTexture.needsUpdate = true;
        var colorsTexture = this._colorsTexture;
        if (colorsTexture) {
          _whiteColor.toArray(colorsTexture.image.data, drawId * 4);
          colorsTexture.needsUpdate = true;
        }
        this._visibilityChanged = true;
        return drawId;
      }
    }, {
      key: "addGeometry",
      value: function addGeometry(geometry) {
        var reservedVertexCount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : -1;
        var reservedIndexCount = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : -1;
        this._initializeGeometry(geometry);
        this._validateGeometry(geometry);
        var geometryInfo = {
          // geometry information
          vertexStart: -1,
          vertexCount: -1,
          reservedVertexCount: -1,
          indexStart: -1,
          indexCount: -1,
          reservedIndexCount: -1,
          // draw range information
          start: -1,
          count: -1,
          // state
          boundingBox: null,
          boundingSphere: null,
          active: true
        };
        var geometryInfoList = this._geometryInfo;
        geometryInfo.vertexStart = this._nextVertexStart;
        geometryInfo.reservedVertexCount = reservedVertexCount === -1 ? geometry.getAttribute('position').count : reservedVertexCount;
        var index = geometry.getIndex();
        var hasIndex = index !== null;
        if (hasIndex) {
          geometryInfo.indexStart = this._nextIndexStart;
          geometryInfo.reservedIndexCount = reservedIndexCount === -1 ? index.count : reservedIndexCount;
        }
        if (geometryInfo.indexStart !== -1 && geometryInfo.indexStart + geometryInfo.reservedIndexCount > this._maxIndexCount || geometryInfo.vertexStart + geometryInfo.reservedVertexCount > this._maxVertexCount) {
          throw new Error('THREE.BatchedMesh: Reserved space request exceeds the maximum buffer size.');
        }

        // update id
        var geometryId;
        if (this._availableGeometryIds.length > 0) {
          this._availableGeometryIds.sort(ascIdSort);
          geometryId = this._availableGeometryIds.shift();
          geometryInfoList[geometryId] = geometryInfo;
        } else {
          geometryId = this._geometryCount;
          this._geometryCount++;
          geometryInfoList.push(geometryInfo);
        }

        // update the geometry
        this.setGeometryAt(geometryId, geometry);

        // increment the next geometry position
        this._nextIndexStart = geometryInfo.indexStart + geometryInfo.reservedIndexCount;
        this._nextVertexStart = geometryInfo.vertexStart + geometryInfo.reservedVertexCount;
        return geometryId;
      }
    }, {
      key: "setGeometryAt",
      value: function setGeometryAt(geometryId, geometry) {
        if (geometryId >= this._geometryCount) {
          throw new Error('THREE.BatchedMesh: Maximum geometry count reached.');
        }
        this._validateGeometry(geometry);
        var batchGeometry = this.geometry;
        var hasIndex = batchGeometry.getIndex() !== null;
        var dstIndex = batchGeometry.getIndex();
        var srcIndex = geometry.getIndex();
        var geometryInfo = this._geometryInfo[geometryId];
        if (hasIndex && srcIndex.count > geometryInfo.reservedIndexCount || geometry.attributes.position.count > geometryInfo.reservedVertexCount) {
          throw new Error('THREE.BatchedMesh: Reserved space not large enough for provided geometry.');
        }

        // copy geometry buffer data over
        var vertexStart = geometryInfo.vertexStart;
        var reservedVertexCount = geometryInfo.reservedVertexCount;
        geometryInfo.vertexCount = geometry.getAttribute('position').count;
        for (var attributeName in batchGeometry.attributes) {
          // copy attribute data
          var srcAttribute = geometry.getAttribute(attributeName);
          var dstAttribute = batchGeometry.getAttribute(attributeName);
          copyAttributeData(srcAttribute, dstAttribute, vertexStart);

          // fill the rest in with zeroes
          var itemSize = srcAttribute.itemSize;
          for (var i = srcAttribute.count, l = reservedVertexCount; i < l; i++) {
            var index = vertexStart + i;
            for (var c = 0; c < itemSize; c++) {
              dstAttribute.setComponent(index, c, 0);
            }
          }
          dstAttribute.needsUpdate = true;
          dstAttribute.addUpdateRange(vertexStart * itemSize, reservedVertexCount * itemSize);
        }

        // copy index
        if (hasIndex) {
          var indexStart = geometryInfo.indexStart;
          var reservedIndexCount = geometryInfo.reservedIndexCount;
          geometryInfo.indexCount = geometry.getIndex().count;

          // copy index data over
          for (var _i25 = 0; _i25 < srcIndex.count; _i25++) {
            dstIndex.setX(indexStart + _i25, vertexStart + srcIndex.getX(_i25));
          }

          // fill the rest in with zeroes
          for (var _i26 = srcIndex.count, _l6 = reservedIndexCount; _i26 < _l6; _i26++) {
            dstIndex.setX(indexStart + _i26, vertexStart);
          }
          dstIndex.needsUpdate = true;
          dstIndex.addUpdateRange(indexStart, geometryInfo.reservedIndexCount);
        }

        // update the draw range
        geometryInfo.start = hasIndex ? geometryInfo.indexStart : geometryInfo.vertexStart;
        geometryInfo.count = hasIndex ? geometryInfo.indexCount : geometryInfo.vertexCount;

        // store the bounding boxes
        geometryInfo.boundingBox = null;
        if (geometry.boundingBox !== null) {
          geometryInfo.boundingBox = geometry.boundingBox.clone();
        }
        geometryInfo.boundingSphere = null;
        if (geometry.boundingSphere !== null) {
          geometryInfo.boundingSphere = geometry.boundingSphere.clone();
        }
        this._visibilityChanged = true;
        return geometryId;
      }
    }, {
      key: "deleteGeometry",
      value: function deleteGeometry(geometryId) {
        var geometryInfoList = this._geometryInfo;
        if (geometryId >= geometryInfoList.length || geometryInfoList[geometryId].active === false) {
          return this;
        }

        // delete any instances associated with this geometry
        var instanceInfo = this._instanceInfo;
        for (var i = 0, l = instanceInfo.length; i < l; i++) {
          if (instanceInfo[i].geometryIndex === geometryId) {
            this.deleteInstance(i);
          }
        }
        geometryInfoList[geometryId].active = false;
        this._availableGeometryIds.push(geometryId);
        this._visibilityChanged = true;
        return this;
      }
    }, {
      key: "deleteInstance",
      value: function deleteInstance(instanceId) {
        this.validateInstanceId(instanceId);
        this._instanceInfo[instanceId].active = false;
        this._availableInstanceIds.push(instanceId);
        this._visibilityChanged = true;
        return this;
      }
    }, {
      key: "optimize",
      value: function optimize() {
        // track the next indices to copy data to
        var nextVertexStart = 0;
        var nextIndexStart = 0;

        // Iterate over all geometry ranges in order sorted from earliest in the geometry buffer to latest
        // in the geometry buffer. Because draw range objects can be reused there is no guarantee of their order.
        var geometryInfoList = this._geometryInfo;
        var indices = geometryInfoList.map(function (e, i) {
          return i;
        }).sort(function (a, b) {
          return geometryInfoList[a].vertexStart - geometryInfoList[b].vertexStart;
        });
        var geometry = this.geometry;
        for (var i = 0, l = geometryInfoList.length; i < l; i++) {
          // if a geometry range is inactive then don't copy anything
          var index = indices[i];
          var geometryInfo = geometryInfoList[index];
          if (geometryInfo.active === false) {
            continue;
          }

          // if a geometry contains an index buffer then shift it, as well
          if (geometry.index !== null) {
            if (geometryInfo.indexStart !== nextIndexStart) {
              var indexStart = geometryInfo.indexStart,
                vertexStart = geometryInfo.vertexStart,
                reservedIndexCount = geometryInfo.reservedIndexCount;
              var _index = geometry.index;
              var array = _index.array;

              // shift the index pointers based on how the vertex data will shift
              // adjusting the index must happen first so the original vertex start value is available
              var elementDelta = nextVertexStart - vertexStart;
              for (var j = indexStart; j < indexStart + reservedIndexCount; j++) {
                array[j] = array[j] + elementDelta;
              }
              _index.array.copyWithin(nextIndexStart, indexStart, indexStart + reservedIndexCount);
              _index.addUpdateRange(nextIndexStart, reservedIndexCount);
              geometryInfo.indexStart = nextIndexStart;
            }
            nextIndexStart += geometryInfo.reservedIndexCount;
          }

          // if a geometry needs to be moved then copy attribute data to overwrite unused space
          if (geometryInfo.vertexStart !== nextVertexStart) {
            var _vertexStart = geometryInfo.vertexStart,
              reservedVertexCount = geometryInfo.reservedVertexCount;
            var attributes = geometry.attributes;
            for (var key in attributes) {
              var attribute = attributes[key];
              var _array = attribute.array,
                itemSize = attribute.itemSize;
              _array.copyWithin(nextVertexStart * itemSize, _vertexStart * itemSize, (_vertexStart + reservedVertexCount) * itemSize);
              attribute.addUpdateRange(nextVertexStart * itemSize, reservedVertexCount * itemSize);
            }
            geometryInfo.vertexStart = nextVertexStart;
          }
          nextVertexStart += geometryInfo.reservedVertexCount;
          geometryInfo.start = geometry.index ? geometryInfo.indexStart : geometryInfo.vertexStart;

          // step the next geometry points to the shifted position
          this._nextIndexStart = geometry.index ? geometryInfo.indexStart + geometryInfo.reservedIndexCount : 0;
          this._nextVertexStart = geometryInfo.vertexStart + geometryInfo.reservedVertexCount;
        }
        return this;
      }

      // get bounding box and compute it if it doesn't exist
    }, {
      key: "getBoundingBoxAt",
      value: function getBoundingBoxAt(geometryId, target) {
        if (geometryId >= this._geometryCount) {
          return null;
        }

        // compute bounding box
        var geometry = this.geometry;
        var geometryInfo = this._geometryInfo[geometryId];
        if (geometryInfo.boundingBox === null) {
          var box = new Box3();
          var index = geometry.index;
          var position = geometry.attributes.position;
          for (var i = geometryInfo.start, l = geometryInfo.start + geometryInfo.count; i < l; i++) {
            var iv = i;
            if (index) {
              iv = index.getX(iv);
            }
            box.expandByPoint(_vector$5.fromBufferAttribute(position, iv));
          }
          geometryInfo.boundingBox = box;
        }
        target.copy(geometryInfo.boundingBox);
        return target;
      }

      // get bounding sphere and compute it if it doesn't exist
    }, {
      key: "getBoundingSphereAt",
      value: function getBoundingSphereAt(geometryId, target) {
        if (geometryId >= this._geometryCount) {
          return null;
        }

        // compute bounding sphere
        var geometry = this.geometry;
        var geometryInfo = this._geometryInfo[geometryId];
        if (geometryInfo.boundingSphere === null) {
          var sphere = new Sphere();
          this.getBoundingBoxAt(geometryId, _box$1);
          _box$1.getCenter(sphere.center);
          var index = geometry.index;
          var position = geometry.attributes.position;
          var maxRadiusSq = 0;
          for (var i = geometryInfo.start, l = geometryInfo.start + geometryInfo.count; i < l; i++) {
            var iv = i;
            if (index) {
              iv = index.getX(iv);
            }
            _vector$5.fromBufferAttribute(position, iv);
            maxRadiusSq = Math.max(maxRadiusSq, sphere.center.distanceToSquared(_vector$5));
          }
          sphere.radius = Math.sqrt(maxRadiusSq);
          geometryInfo.boundingSphere = sphere;
        }
        target.copy(geometryInfo.boundingSphere);
        return target;
      }
    }, {
      key: "setMatrixAt",
      value: function setMatrixAt(instanceId, matrix) {
        this.validateInstanceId(instanceId);
        var matricesTexture = this._matricesTexture;
        var matricesArray = this._matricesTexture.image.data;
        matrix.toArray(matricesArray, instanceId * 16);
        matricesTexture.needsUpdate = true;
        return this;
      }
    }, {
      key: "getMatrixAt",
      value: function getMatrixAt(instanceId, matrix) {
        this.validateInstanceId(instanceId);
        return matrix.fromArray(this._matricesTexture.image.data, instanceId * 16);
      }
    }, {
      key: "setColorAt",
      value: function setColorAt(instanceId, color) {
        this.validateInstanceId(instanceId);
        if (this._colorsTexture === null) {
          this._initColorsTexture();
        }
        color.toArray(this._colorsTexture.image.data, instanceId * 4);
        this._colorsTexture.needsUpdate = true;
        return this;
      }
    }, {
      key: "getColorAt",
      value: function getColorAt(instanceId, color) {
        this.validateInstanceId(instanceId);
        return color.fromArray(this._colorsTexture.image.data, instanceId * 4);
      }
    }, {
      key: "setVisibleAt",
      value: function setVisibleAt(instanceId, value) {
        this.validateInstanceId(instanceId);
        if (this._instanceInfo[instanceId].visible === value) {
          return this;
        }
        this._instanceInfo[instanceId].visible = value;
        this._visibilityChanged = true;
        return this;
      }
    }, {
      key: "getVisibleAt",
      value: function getVisibleAt(instanceId) {
        this.validateInstanceId(instanceId);
        return this._instanceInfo[instanceId].visible;
      }
    }, {
      key: "setGeometryIdAt",
      value: function setGeometryIdAt(instanceId, geometryId) {
        this.validateInstanceId(instanceId);
        this.validateGeometryId(geometryId);
        this._instanceInfo[instanceId].geometryIndex = geometryId;
        return this;
      }
    }, {
      key: "getGeometryIdAt",
      value: function getGeometryIdAt(instanceId) {
        this.validateInstanceId(instanceId);
        return this._instanceInfo[instanceId].geometryIndex;
      }
    }, {
      key: "getGeometryRangeAt",
      value: function getGeometryRangeAt(geometryId) {
        var target = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        this.validateGeometryId(geometryId);
        var geometryInfo = this._geometryInfo[geometryId];
        target.vertexStart = geometryInfo.vertexStart;
        target.vertexCount = geometryInfo.vertexCount;
        target.reservedVertexCount = geometryInfo.reservedVertexCount;
        target.indexStart = geometryInfo.indexStart;
        target.indexCount = geometryInfo.indexCount;
        target.reservedIndexCount = geometryInfo.reservedIndexCount;
        target.start = geometryInfo.start;
        target.count = geometryInfo.count;
        return target;
      }
    }, {
      key: "setInstanceCount",
      value: function setInstanceCount(maxInstanceCount) {
        // shrink the available instances as much as possible
        var availableInstanceIds = this._availableInstanceIds;
        var instanceInfo = this._instanceInfo;
        availableInstanceIds.sort(ascIdSort);
        while (availableInstanceIds[availableInstanceIds.length - 1] === instanceInfo.length) {
          instanceInfo.pop();
          availableInstanceIds.pop();
        }

        // throw an error if it can't be shrunk to the desired size
        if (maxInstanceCount < instanceInfo.length) {
          throw new Error(`BatchedMesh: Instance ids outside the range ${maxInstanceCount} are being used. Cannot shrink instance count.`);
        }

        // copy the multi draw counts
        var multiDrawCounts = new Int32Array(maxInstanceCount);
        var multiDrawStarts = new Int32Array(maxInstanceCount);
        copyArrayContents(this._multiDrawCounts, multiDrawCounts);
        copyArrayContents(this._multiDrawStarts, multiDrawStarts);
        this._multiDrawCounts = multiDrawCounts;
        this._multiDrawStarts = multiDrawStarts;
        this._maxInstanceCount = maxInstanceCount;

        // update texture data for instance sampling
        var indirectTexture = this._indirectTexture;
        var matricesTexture = this._matricesTexture;
        var colorsTexture = this._colorsTexture;
        indirectTexture.dispose();
        this._initIndirectTexture();
        copyArrayContents(indirectTexture.image.data, this._indirectTexture.image.data);
        matricesTexture.dispose();
        this._initMatricesTexture();
        copyArrayContents(matricesTexture.image.data, this._matricesTexture.image.data);
        if (colorsTexture) {
          colorsTexture.dispose();
          this._initColorsTexture();
          copyArrayContents(colorsTexture.image.data, this._colorsTexture.image.data);
        }
      }
    }, {
      key: "setGeometrySize",
      value: function setGeometrySize(maxVertexCount, maxIndexCount) {
        // Check if we can shrink to the requested vertex attribute size
        var validRanges = (0, _toConsumableArray2.default)(this._geometryInfo).filter(function (info) {
          return info.active;
        });
        var requiredVertexLength = Math.max.apply(Math, (0, _toConsumableArray2.default)(validRanges.map(function (range) {
          return range.vertexStart + range.reservedVertexCount;
        })));
        if (requiredVertexLength > maxVertexCount) {
          throw new Error(`BatchedMesh: Geometry vertex values are being used outside the range ${maxIndexCount}. Cannot shrink further.`);
        }

        // Check if we can shrink to the requested index attribute size
        if (this.geometry.index) {
          var requiredIndexLength = Math.max.apply(Math, (0, _toConsumableArray2.default)(validRanges.map(function (range) {
            return range.indexStart + range.reservedIndexCount;
          })));
          if (requiredIndexLength > maxIndexCount) {
            throw new Error(`BatchedMesh: Geometry index values are being used outside the range ${maxIndexCount}. Cannot shrink further.`);
          }
        }

        //

        // dispose of the previous geometry
        var oldGeometry = this.geometry;
        oldGeometry.dispose();

        // recreate the geometry needed based on the previous variant
        this._maxVertexCount = maxVertexCount;
        this._maxIndexCount = maxIndexCount;
        if (this._geometryInitialized) {
          this._geometryInitialized = false;
          this.geometry = new BufferGeometry();
          this._initializeGeometry(oldGeometry);
        }

        // copy data from the previous geometry
        var geometry = this.geometry;
        if (oldGeometry.index) {
          copyArrayContents(oldGeometry.index.array, geometry.index.array);
        }
        for (var key in oldGeometry.attributes) {
          copyArrayContents(oldGeometry.attributes[key].array, geometry.attributes[key].array);
        }
      }
    }, {
      key: "raycast",
      value: function raycast(raycaster, intersects) {
        var instanceInfo = this._instanceInfo;
        var geometryInfoList = this._geometryInfo;
        var matrixWorld = this.matrixWorld;
        var batchGeometry = this.geometry;

        // iterate over each geometry
        _mesh.material = this.material;
        _mesh.geometry.index = batchGeometry.index;
        _mesh.geometry.attributes = batchGeometry.attributes;
        if (_mesh.geometry.boundingBox === null) {
          _mesh.geometry.boundingBox = new Box3();
        }
        if (_mesh.geometry.boundingSphere === null) {
          _mesh.geometry.boundingSphere = new Sphere();
        }
        for (var i = 0, l = instanceInfo.length; i < l; i++) {
          if (!instanceInfo[i].visible || !instanceInfo[i].active) {
            continue;
          }
          var geometryId = instanceInfo[i].geometryIndex;
          var geometryInfo = geometryInfoList[geometryId];
          _mesh.geometry.setDrawRange(geometryInfo.start, geometryInfo.count);

          // get the intersects
          this.getMatrixAt(i, _mesh.matrixWorld).premultiply(matrixWorld);
          this.getBoundingBoxAt(geometryId, _mesh.geometry.boundingBox);
          this.getBoundingSphereAt(geometryId, _mesh.geometry.boundingSphere);
          _mesh.raycast(raycaster, _batchIntersects);

          // add batch id to the intersects
          for (var j = 0, _l7 = _batchIntersects.length; j < _l7; j++) {
            var _intersect2 = _batchIntersects[j];
            _intersect2.object = this;
            _intersect2.batchId = i;
            intersects.push(_intersect2);
          }
          _batchIntersects.length = 0;
        }
        _mesh.material = null;
        _mesh.geometry.index = null;
        _mesh.geometry.attributes = {};
        _mesh.geometry.setDrawRange(0, Infinity);
      }
    }, {
      key: "copy",
      value: function copy(source) {
        _superPropGet(BatchedMesh, "copy", this, 3)([source]);
        this.geometry = source.geometry.clone();
        this.perObjectFrustumCulled = source.perObjectFrustumCulled;
        this.sortObjects = source.sortObjects;
        this.boundingBox = source.boundingBox !== null ? source.boundingBox.clone() : null;
        this.boundingSphere = source.boundingSphere !== null ? source.boundingSphere.clone() : null;
        this._geometryInfo = source._geometryInfo.map(function (info) {
          return Object.assign({}, info, {
            boundingBox: info.boundingBox !== null ? info.boundingBox.clone() : null,
            boundingSphere: info.boundingSphere !== null ? info.boundingSphere.clone() : null
          });
        });
        this._instanceInfo = source._instanceInfo.map(function (info) {
          return Object.assign({}, info);
        });
        this._maxInstanceCount = source._maxInstanceCount;
        this._maxVertexCount = source._maxVertexCount;
        this._maxIndexCount = source._maxIndexCount;
        this._geometryInitialized = source._geometryInitialized;
        this._geometryCount = source._geometryCount;
        this._multiDrawCounts = source._multiDrawCounts.slice();
        this._multiDrawStarts = source._multiDrawStarts.slice();
        this._matricesTexture = source._matricesTexture.clone();
        this._matricesTexture.image.data = this._matricesTexture.image.data.slice();
        if (this._colorsTexture !== null) {
          this._colorsTexture = source._colorsTexture.clone();
          this._colorsTexture.image.data = this._colorsTexture.image.data.slice();
        }
        return this;
      }
    }, {
      key: "dispose",
      value: function dispose() {
        // Assuming the geometry is not shared with other meshes
        this.geometry.dispose();
        this._matricesTexture.dispose();
        this._matricesTexture = null;
        this._indirectTexture.dispose();
        this._indirectTexture = null;
        if (this._colorsTexture !== null) {
          this._colorsTexture.dispose();
          this._colorsTexture = null;
        }
        return this;
      }
    }, {
      key: "onBeforeRender",
      value: function onBeforeRender(renderer, scene, camera, geometry, material /*, _group*/) {
        // if visibility has not changed and frustum culling and object sorting is not required
        // then skip iterating over all items
        if (!this._visibilityChanged && !this.perObjectFrustumCulled && !this.sortObjects) {
          return;
        }

        // the indexed version of the multi draw function requires specifying the start
        // offset in bytes.
        var index = geometry.getIndex();
        var bytesPerElement = index === null ? 1 : index.array.BYTES_PER_ELEMENT;
        var instanceInfo = this._instanceInfo;
        var multiDrawStarts = this._multiDrawStarts;
        var multiDrawCounts = this._multiDrawCounts;
        var geometryInfoList = this._geometryInfo;
        var perObjectFrustumCulled = this.perObjectFrustumCulled;
        var indirectTexture = this._indirectTexture;
        var indirectArray = indirectTexture.image.data;

        // prepare the frustum in the local frame
        if (perObjectFrustumCulled) {
          _matrix$1.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse).multiply(this.matrixWorld);
          _frustum.setFromProjectionMatrix(_matrix$1, renderer.coordinateSystem);
        }
        var multiDrawCount = 0;
        if (this.sortObjects) {
          // get the camera position in the local frame
          _matrix$1.copy(this.matrixWorld).invert();
          _vector$5.setFromMatrixPosition(camera.matrixWorld).applyMatrix4(_matrix$1);
          _forward.set(0, 0, -1).transformDirection(camera.matrixWorld).transformDirection(_matrix$1);
          for (var i = 0, l = instanceInfo.length; i < l; i++) {
            if (instanceInfo[i].visible && instanceInfo[i].active) {
              var geometryId = instanceInfo[i].geometryIndex;

              // get the bounds in world space
              this.getMatrixAt(i, _matrix$1);
              this.getBoundingSphereAt(geometryId, _sphere$2).applyMatrix4(_matrix$1);

              // determine whether the batched geometry is within the frustum
              var culled = false;
              if (perObjectFrustumCulled) {
                culled = !_frustum.intersectsSphere(_sphere$2);
              }
              if (!culled) {
                // get the distance from camera used for sorting
                var geometryInfo = geometryInfoList[geometryId];
                var z = _temp.subVectors(_sphere$2.center, _vector$5).dot(_forward);
                _renderList.push(geometryInfo.start, geometryInfo.count, z, i);
              }
            }
          }

          // Sort the draw ranges and prep for rendering
          var list = _renderList.list;
          var customSort = this.customSort;
          if (customSort === null) {
            list.sort(material.transparent ? sortTransparent : sortOpaque);
          } else {
            customSort.call(this, list, camera);
          }
          for (var _i27 = 0, _l8 = list.length; _i27 < _l8; _i27++) {
            var item = list[_i27];
            multiDrawStarts[multiDrawCount] = item.start * bytesPerElement;
            multiDrawCounts[multiDrawCount] = item.count;
            indirectArray[multiDrawCount] = item.index;
            multiDrawCount++;
          }
          _renderList.reset();
        } else {
          for (var _i28 = 0, _l9 = instanceInfo.length; _i28 < _l9; _i28++) {
            if (instanceInfo[_i28].visible && instanceInfo[_i28].active) {
              var _geometryId = instanceInfo[_i28].geometryIndex;

              // determine whether the batched geometry is within the frustum
              var _culled = false;
              if (perObjectFrustumCulled) {
                // get the bounds in world space
                this.getMatrixAt(_i28, _matrix$1);
                this.getBoundingSphereAt(_geometryId, _sphere$2).applyMatrix4(_matrix$1);
                _culled = !_frustum.intersectsSphere(_sphere$2);
              }
              if (!_culled) {
                var _geometryInfo = geometryInfoList[_geometryId];
                multiDrawStarts[multiDrawCount] = _geometryInfo.start * bytesPerElement;
                multiDrawCounts[multiDrawCount] = _geometryInfo.count;
                indirectArray[multiDrawCount] = _i28;
                multiDrawCount++;
              }
            }
          }
        }
        indirectTexture.needsUpdate = true;
        this._multiDrawCount = multiDrawCount;
        this._visibilityChanged = false;
      }
    }, {
      key: "onBeforeShadow",
      value: function onBeforeShadow(renderer, object, camera, shadowCamera, geometry, depthMaterial /* , group */) {
        this.onBeforeRender(renderer, null, shadowCamera, geometry, depthMaterial);
      }
    }]);
  }(Mesh);
  var LineBasicMaterial = exports.LineBasicMaterial = /*#__PURE__*/function (_Material4) {
    function LineBasicMaterial(parameters) {
      var _this31;
      (0, _classCallCheck2.default)(this, LineBasicMaterial);
      _this31 = _callSuper(this, LineBasicMaterial);
      _this31.isLineBasicMaterial = true;
      _this31.type = 'LineBasicMaterial';
      _this31.color = new Color(0xffffff);
      _this31.map = null;
      _this31.linewidth = 1;
      _this31.linecap = 'round';
      _this31.linejoin = 'round';
      _this31.fog = true;
      _this31.setValues(parameters);
      return _this31;
    }
    (0, _inherits2.default)(LineBasicMaterial, _Material4);
    return (0, _createClass2.default)(LineBasicMaterial, [{
      key: "copy",
      value: function copy(source) {
        _superPropGet(LineBasicMaterial, "copy", this, 3)([source]);
        this.color.copy(source.color);
        this.map = source.map;
        this.linewidth = source.linewidth;
        this.linecap = source.linecap;
        this.linejoin = source.linejoin;
        this.fog = source.fog;
        return this;
      }
    }]);
  }(Material);
  var _vStart = /*@__PURE__*/new Vector3();
  var _vEnd = /*@__PURE__*/new Vector3();
  var _inverseMatrix$1 = /*@__PURE__*/new Matrix4();
  var _ray$1 = /*@__PURE__*/new Ray();
  var _sphere$1 = /*@__PURE__*/new Sphere();
  var _intersectPointOnRay = /*@__PURE__*/new Vector3();
  var _intersectPointOnSegment = /*@__PURE__*/new Vector3();
  var Line = exports.Line = /*#__PURE__*/function (_Object3D8) {
    function Line() {
      var _this32;
      var geometry = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new BufferGeometry();
      var material = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new LineBasicMaterial();
      (0, _classCallCheck2.default)(this, Line);
      _this32 = _callSuper(this, Line);
      _this32.isLine = true;
      _this32.type = 'Line';
      _this32.geometry = geometry;
      _this32.material = material;
      _this32.updateMorphTargets();
      return _this32;
    }
    (0, _inherits2.default)(Line, _Object3D8);
    return (0, _createClass2.default)(Line, [{
      key: "copy",
      value: function copy(source, recursive) {
        _superPropGet(Line, "copy", this, 3)([source, recursive]);
        this.material = Array.isArray(source.material) ? source.material.slice() : source.material;
        this.geometry = source.geometry;
        return this;
      }
    }, {
      key: "computeLineDistances",
      value: function computeLineDistances() {
        var geometry = this.geometry;

        // we assume non-indexed geometry

        if (geometry.index === null) {
          var positionAttribute = geometry.attributes.position;
          var lineDistances = [0];
          for (var i = 1, l = positionAttribute.count; i < l; i++) {
            _vStart.fromBufferAttribute(positionAttribute, i - 1);
            _vEnd.fromBufferAttribute(positionAttribute, i);
            lineDistances[i] = lineDistances[i - 1];
            lineDistances[i] += _vStart.distanceTo(_vEnd);
          }
          geometry.setAttribute('lineDistance', new Float32BufferAttribute(lineDistances, 1));
        } else {
          console.warn('THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.');
        }
        return this;
      }
    }, {
      key: "raycast",
      value: function raycast(raycaster, intersects) {
        var geometry = this.geometry;
        var matrixWorld = this.matrixWorld;
        var threshold = raycaster.params.Line.threshold;
        var drawRange = geometry.drawRange;

        // Checking boundingSphere distance to ray

        if (geometry.boundingSphere === null) geometry.computeBoundingSphere();
        _sphere$1.copy(geometry.boundingSphere);
        _sphere$1.applyMatrix4(matrixWorld);
        _sphere$1.radius += threshold;
        if (raycaster.ray.intersectsSphere(_sphere$1) === false) return;

        //

        _inverseMatrix$1.copy(matrixWorld).invert();
        _ray$1.copy(raycaster.ray).applyMatrix4(_inverseMatrix$1);
        var localThreshold = threshold / ((this.scale.x + this.scale.y + this.scale.z) / 3);
        var localThresholdSq = localThreshold * localThreshold;
        var step = this.isLineSegments ? 2 : 1;
        var index = geometry.index;
        var attributes = geometry.attributes;
        var positionAttribute = attributes.position;
        if (index !== null) {
          var start = Math.max(0, drawRange.start);
          var end = Math.min(index.count, drawRange.start + drawRange.count);
          for (var i = start, l = end - 1; i < l; i += step) {
            var a = index.getX(i);
            var b = index.getX(i + 1);
            var _intersect3 = checkIntersection(this, raycaster, _ray$1, localThresholdSq, a, b);
            if (_intersect3) {
              intersects.push(_intersect3);
            }
          }
          if (this.isLineLoop) {
            var _a4 = index.getX(end - 1);
            var _b4 = index.getX(start);
            var _intersect4 = checkIntersection(this, raycaster, _ray$1, localThresholdSq, _a4, _b4);
            if (_intersect4) {
              intersects.push(_intersect4);
            }
          }
        } else {
          var _start6 = Math.max(0, drawRange.start);
          var _end5 = Math.min(positionAttribute.count, drawRange.start + drawRange.count);
          for (var _i29 = _start6, _l10 = _end5 - 1; _i29 < _l10; _i29 += step) {
            var _intersect5 = checkIntersection(this, raycaster, _ray$1, localThresholdSq, _i29, _i29 + 1);
            if (_intersect5) {
              intersects.push(_intersect5);
            }
          }
          if (this.isLineLoop) {
            var _intersect6 = checkIntersection(this, raycaster, _ray$1, localThresholdSq, _end5 - 1, _start6);
            if (_intersect6) {
              intersects.push(_intersect6);
            }
          }
        }
      }
    }, {
      key: "updateMorphTargets",
      value: function updateMorphTargets() {
        var geometry = this.geometry;
        var morphAttributes = geometry.morphAttributes;
        var keys = Object.keys(morphAttributes);
        if (keys.length > 0) {
          var morphAttribute = morphAttributes[keys[0]];
          if (morphAttribute !== undefined) {
            this.morphTargetInfluences = [];
            this.morphTargetDictionary = {};
            for (var m = 0, ml = morphAttribute.length; m < ml; m++) {
              var name = morphAttribute[m].name || String(m);
              this.morphTargetInfluences.push(0);
              this.morphTargetDictionary[name] = m;
            }
          }
        }
      }
    }]);
  }(Object3D);
  function checkIntersection(object, raycaster, ray, thresholdSq, a, b) {
    var positionAttribute = object.geometry.attributes.position;
    _vStart.fromBufferAttribute(positionAttribute, a);
    _vEnd.fromBufferAttribute(positionAttribute, b);
    var distSq = ray.distanceSqToSegment(_vStart, _vEnd, _intersectPointOnRay, _intersectPointOnSegment);
    if (distSq > thresholdSq) return;
    _intersectPointOnRay.applyMatrix4(object.matrixWorld); // Move back to world space for distance calculation

    var distance = raycaster.ray.origin.distanceTo(_intersectPointOnRay);
    if (distance < raycaster.near || distance > raycaster.far) return;
    return {
      distance: distance,
      // What do we want? intersection point on the ray or on the segment??
      // point: raycaster.ray.at( distance ),
      point: _intersectPointOnSegment.clone().applyMatrix4(object.matrixWorld),
      index: a,
      face: null,
      faceIndex: null,
      barycoord: null,
      object: object
    };
  }
  var _start = /*@__PURE__*/new Vector3();
  var _end = /*@__PURE__*/new Vector3();
  var LineSegments = exports.LineSegments = /*#__PURE__*/function (_Line) {
    function LineSegments(geometry, material) {
      var _this33;
      (0, _classCallCheck2.default)(this, LineSegments);
      _this33 = _callSuper(this, LineSegments, [geometry, material]);
      _this33.isLineSegments = true;
      _this33.type = 'LineSegments';
      return _this33;
    }
    (0, _inherits2.default)(LineSegments, _Line);
    return (0, _createClass2.default)(LineSegments, [{
      key: "computeLineDistances",
      value: function computeLineDistances() {
        var geometry = this.geometry;

        // we assume non-indexed geometry

        if (geometry.index === null) {
          var positionAttribute = geometry.attributes.position;
          var lineDistances = [];
          for (var i = 0, l = positionAttribute.count; i < l; i += 2) {
            _start.fromBufferAttribute(positionAttribute, i);
            _end.fromBufferAttribute(positionAttribute, i + 1);
            lineDistances[i] = i === 0 ? 0 : lineDistances[i - 1];
            lineDistances[i + 1] = lineDistances[i] + _start.distanceTo(_end);
          }
          geometry.setAttribute('lineDistance', new Float32BufferAttribute(lineDistances, 1));
        } else {
          console.warn('THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.');
        }
        return this;
      }
    }]);
  }(Line);
  var LineLoop = exports.LineLoop = /*#__PURE__*/function (_Line2) {
    function LineLoop(geometry, material) {
      var _this34;
      (0, _classCallCheck2.default)(this, LineLoop);
      _this34 = _callSuper(this, LineLoop, [geometry, material]);
      _this34.isLineLoop = true;
      _this34.type = 'LineLoop';
      return _this34;
    }
    (0, _inherits2.default)(LineLoop, _Line2);
    return (0, _createClass2.default)(LineLoop);
  }(Line);
  var PointsMaterial = exports.PointsMaterial = /*#__PURE__*/function (_Material5) {
    function PointsMaterial(parameters) {
      var _this35;
      (0, _classCallCheck2.default)(this, PointsMaterial);
      _this35 = _callSuper(this, PointsMaterial);
      _this35.isPointsMaterial = true;
      _this35.type = 'PointsMaterial';
      _this35.color = new Color(0xffffff);
      _this35.map = null;
      _this35.alphaMap = null;
      _this35.size = 1;
      _this35.sizeAttenuation = true;
      _this35.fog = true;
      _this35.setValues(parameters);
      return _this35;
    }
    (0, _inherits2.default)(PointsMaterial, _Material5);
    return (0, _createClass2.default)(PointsMaterial, [{
      key: "copy",
      value: function copy(source) {
        _superPropGet(PointsMaterial, "copy", this, 3)([source]);
        this.color.copy(source.color);
        this.map = source.map;
        this.alphaMap = source.alphaMap;
        this.size = source.size;
        this.sizeAttenuation = source.sizeAttenuation;
        this.fog = source.fog;
        return this;
      }
    }]);
  }(Material);
  var _inverseMatrix = /*@__PURE__*/new Matrix4();
  var _ray = /*@__PURE__*/new Ray();
  var _sphere = /*@__PURE__*/new Sphere();
  var _position$2 = /*@__PURE__*/new Vector3();
  var Points = exports.Points = /*#__PURE__*/function (_Object3D9) {
    function Points() {
      var _this36;
      var geometry = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new BufferGeometry();
      var material = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new PointsMaterial();
      (0, _classCallCheck2.default)(this, Points);
      _this36 = _callSuper(this, Points);
      _this36.isPoints = true;
      _this36.type = 'Points';
      _this36.geometry = geometry;
      _this36.material = material;
      _this36.updateMorphTargets();
      return _this36;
    }
    (0, _inherits2.default)(Points, _Object3D9);
    return (0, _createClass2.default)(Points, [{
      key: "copy",
      value: function copy(source, recursive) {
        _superPropGet(Points, "copy", this, 3)([source, recursive]);
        this.material = Array.isArray(source.material) ? source.material.slice() : source.material;
        this.geometry = source.geometry;
        return this;
      }
    }, {
      key: "raycast",
      value: function raycast(raycaster, intersects) {
        var geometry = this.geometry;
        var matrixWorld = this.matrixWorld;
        var threshold = raycaster.params.Points.threshold;
        var drawRange = geometry.drawRange;

        // Checking boundingSphere distance to ray

        if (geometry.boundingSphere === null) geometry.computeBoundingSphere();
        _sphere.copy(geometry.boundingSphere);
        _sphere.applyMatrix4(matrixWorld);
        _sphere.radius += threshold;
        if (raycaster.ray.intersectsSphere(_sphere) === false) return;

        //

        _inverseMatrix.copy(matrixWorld).invert();
        _ray.copy(raycaster.ray).applyMatrix4(_inverseMatrix);
        var localThreshold = threshold / ((this.scale.x + this.scale.y + this.scale.z) / 3);
        var localThresholdSq = localThreshold * localThreshold;
        var index = geometry.index;
        var attributes = geometry.attributes;
        var positionAttribute = attributes.position;
        if (index !== null) {
          var start = Math.max(0, drawRange.start);
          var end = Math.min(index.count, drawRange.start + drawRange.count);
          for (var i = start, il = end; i < il; i++) {
            var a = index.getX(i);
            _position$2.fromBufferAttribute(positionAttribute, a);
            testPoint(_position$2, a, localThresholdSq, matrixWorld, raycaster, intersects, this);
          }
        } else {
          var _start7 = Math.max(0, drawRange.start);
          var _end6 = Math.min(positionAttribute.count, drawRange.start + drawRange.count);
          for (var _i30 = _start7, l = _end6; _i30 < l; _i30++) {
            _position$2.fromBufferAttribute(positionAttribute, _i30);
            testPoint(_position$2, _i30, localThresholdSq, matrixWorld, raycaster, intersects, this);
          }
        }
      }
    }, {
      key: "updateMorphTargets",
      value: function updateMorphTargets() {
        var geometry = this.geometry;
        var morphAttributes = geometry.morphAttributes;
        var keys = Object.keys(morphAttributes);
        if (keys.length > 0) {
          var morphAttribute = morphAttributes[keys[0]];
          if (morphAttribute !== undefined) {
            this.morphTargetInfluences = [];
            this.morphTargetDictionary = {};
            for (var m = 0, ml = morphAttribute.length; m < ml; m++) {
              var name = morphAttribute[m].name || String(m);
              this.morphTargetInfluences.push(0);
              this.morphTargetDictionary[name] = m;
            }
          }
        }
      }
    }]);
  }(Object3D);
  function testPoint(point, index, localThresholdSq, matrixWorld, raycaster, intersects, object) {
    var rayPointDistanceSq = _ray.distanceSqToPoint(point);
    if (rayPointDistanceSq < localThresholdSq) {
      var intersectPoint = new Vector3();
      _ray.closestPointToPoint(point, intersectPoint);
      intersectPoint.applyMatrix4(matrixWorld);
      var distance = raycaster.ray.origin.distanceTo(intersectPoint);
      if (distance < raycaster.near || distance > raycaster.far) return;
      intersects.push({
        distance: distance,
        distanceToRay: Math.sqrt(rayPointDistanceSq),
        point: intersectPoint,
        index: index,
        face: null,
        faceIndex: null,
        barycoord: null,
        object: object
      });
    }
  }
  var Group = exports.Group = /*#__PURE__*/function (_Object3D10) {
    function Group() {
      var _this37;
      (0, _classCallCheck2.default)(this, Group);
      _this37 = _callSuper(this, Group);
      _this37.isGroup = true;
      _this37.type = 'Group';
      return _this37;
    }
    (0, _inherits2.default)(Group, _Object3D10);
    return (0, _createClass2.default)(Group);
  }(Object3D);
  var VideoTexture = exports.VideoTexture = /*#__PURE__*/function (_Texture5) {
    function VideoTexture(video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) {
      var _this38;
      (0, _classCallCheck2.default)(this, VideoTexture);
      _this38 = _callSuper(this, VideoTexture, [video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy]);
      _this38.isVideoTexture = true;
      _this38.minFilter = minFilter !== undefined ? minFilter : LinearFilter;
      _this38.magFilter = magFilter !== undefined ? magFilter : LinearFilter;
      _this38.generateMipmaps = false;
      var scope = _this38;
      function updateVideo() {
        scope.needsUpdate = true;
        video.requestVideoFrameCallback(updateVideo);
      }
      if ('requestVideoFrameCallback' in video) {
        video.requestVideoFrameCallback(updateVideo);
      }
      return _this38;
    }
    (0, _inherits2.default)(VideoTexture, _Texture5);
    return (0, _createClass2.default)(VideoTexture, [{
      key: "clone",
      value: function clone() {
        return new this.constructor(this.image).copy(this);
      }
    }, {
      key: "update",
      value: function update() {
        var video = this.image;
        var hasVideoFrameCallback = 'requestVideoFrameCallback' in video;
        if (hasVideoFrameCallback === false && video.readyState >= video.HAVE_CURRENT_DATA) {
          this.needsUpdate = true;
        }
      }
    }]);
  }(Texture);
  var FramebufferTexture = exports.FramebufferTexture = /*#__PURE__*/function (_Texture6) {
    function FramebufferTexture(width, height) {
      var _this39;
      (0, _classCallCheck2.default)(this, FramebufferTexture);
      _this39 = _callSuper(this, FramebufferTexture, [{
        width: width,
        height: height
      }]);
      _this39.isFramebufferTexture = true;
      _this39.magFilter = NearestFilter;
      _this39.minFilter = NearestFilter;
      _this39.generateMipmaps = false;
      _this39.needsUpdate = true;
      return _this39;
    }
    (0, _inherits2.default)(FramebufferTexture, _Texture6);
    return (0, _createClass2.default)(FramebufferTexture);
  }(Texture);
  var CompressedTexture = exports.CompressedTexture = /*#__PURE__*/function (_Texture7) {
    function CompressedTexture(mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, colorSpace) {
      var _this40;
      (0, _classCallCheck2.default)(this, CompressedTexture);
      _this40 = _callSuper(this, CompressedTexture, [null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, colorSpace]);
      _this40.isCompressedTexture = true;
      _this40.image = {
        width: width,
        height: height
      };
      _this40.mipmaps = mipmaps;

      // no flipping for cube textures
      // (also flipping doesn't work for compressed textures )

      _this40.flipY = false;

      // can't generate mipmaps for compressed textures
      // mips must be embedded in DDS files

      _this40.generateMipmaps = false;
      return _this40;
    }
    (0, _inherits2.default)(CompressedTexture, _Texture7);
    return (0, _createClass2.default)(CompressedTexture);
  }(Texture);
  var CompressedArrayTexture = exports.CompressedArrayTexture = /*#__PURE__*/function (_CompressedTexture) {
    function CompressedArrayTexture(mipmaps, width, height, depth, format, type) {
      var _this41;
      (0, _classCallCheck2.default)(this, CompressedArrayTexture);
      _this41 = _callSuper(this, CompressedArrayTexture, [mipmaps, width, height, format, type]);
      _this41.isCompressedArrayTexture = true;
      _this41.image.depth = depth;
      _this41.wrapR = ClampToEdgeWrapping;
      _this41.layerUpdates = new Set();
      return _this41;
    }
    (0, _inherits2.default)(CompressedArrayTexture, _CompressedTexture);
    return (0, _createClass2.default)(CompressedArrayTexture, [{
      key: "addLayerUpdate",
      value: function addLayerUpdate(layerIndex) {
        this.layerUpdates.add(layerIndex);
      }
    }, {
      key: "clearLayerUpdates",
      value: function clearLayerUpdates() {
        this.layerUpdates.clear();
      }
    }]);
  }(CompressedTexture);
  var CompressedCubeTexture = exports.CompressedCubeTexture = /*#__PURE__*/function (_CompressedTexture2) {
    function CompressedCubeTexture(images, format, type) {
      var _this42;
      (0, _classCallCheck2.default)(this, CompressedCubeTexture);
      _this42 = _callSuper(this, CompressedCubeTexture, [undefined, images[0].width, images[0].height, format, type, CubeReflectionMapping]);
      _this42.isCompressedCubeTexture = true;
      _this42.isCubeTexture = true;
      _this42.image = images;
      return _this42;
    }
    (0, _inherits2.default)(CompressedCubeTexture, _CompressedTexture2);
    return (0, _createClass2.default)(CompressedCubeTexture);
  }(CompressedTexture);
  var CanvasTexture = exports.CanvasTexture = /*#__PURE__*/function (_Texture8) {
    function CanvasTexture(canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy) {
      var _this43;
      (0, _classCallCheck2.default)(this, CanvasTexture);
      _this43 = _callSuper(this, CanvasTexture, [canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy]);
      _this43.isCanvasTexture = true;
      _this43.needsUpdate = true;
      return _this43;
    }
    (0, _inherits2.default)(CanvasTexture, _Texture8);
    return (0, _createClass2.default)(CanvasTexture);
  }(Texture);
  var DepthTexture = exports.DepthTexture = /*#__PURE__*/function (_Texture9) {
    function DepthTexture(width, height, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy) {
      var _this44;
      var format = arguments.length > 9 && arguments[9] !== undefined ? arguments[9] : DepthFormat;
      (0, _classCallCheck2.default)(this, DepthTexture);
      if (format !== DepthFormat && format !== DepthStencilFormat) {
        throw new Error('DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat');
      }
      if (type === undefined && format === DepthFormat) type = UnsignedIntType;
      if (type === undefined && format === DepthStencilFormat) type = UnsignedInt248Type;
      _this44 = _callSuper(this, DepthTexture, [null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy]);
      _this44.isDepthTexture = true;
      _this44.image = {
        width: width,
        height: height
      };
      _this44.magFilter = magFilter !== undefined ? magFilter : NearestFilter;
      _this44.minFilter = minFilter !== undefined ? minFilter : NearestFilter;
      _this44.flipY = false;
      _this44.generateMipmaps = false;
      _this44.compareFunction = null;
      return _this44;
    }
    (0, _inherits2.default)(DepthTexture, _Texture9);
    return (0, _createClass2.default)(DepthTexture, [{
      key: "copy",
      value: function copy(source) {
        _superPropGet(DepthTexture, "copy", this, 3)([source]);
        this.compareFunction = source.compareFunction;
        return this;
      }
    }, {
      key: "toJSON",
      value: function toJSON(meta) {
        var data = _superPropGet(DepthTexture, "toJSON", this, 3)([meta]);
        if (this.compareFunction !== null) data.compareFunction = this.compareFunction;
        return data;
      }
    }]);
  }(Texture);
  /**
   * Extensible curve object.
   *
   * Some common of curve methods:
   * .getPoint( t, optionalTarget ), .getTangent( t, optionalTarget )
   * .getPointAt( u, optionalTarget ), .getTangentAt( u, optionalTarget )
   * .getPoints(), .getSpacedPoints()
   * .getLength()
   * .updateArcLengths()
   *
   * This following curves inherit from THREE.Curve:
   *
   * -- 2D curves --
   * THREE.ArcCurve
   * THREE.CubicBezierCurve
   * THREE.EllipseCurve
   * THREE.LineCurve
   * THREE.QuadraticBezierCurve
   * THREE.SplineCurve
   *
   * -- 3D curves --
   * THREE.CatmullRomCurve3
   * THREE.CubicBezierCurve3
   * THREE.LineCurve3
   * THREE.QuadraticBezierCurve3
   *
   * A series of curves can be represented as a THREE.CurvePath.
   *
   **/
  var Curve = exports.Curve = /*#__PURE__*/function () {
    function Curve() {
      (0, _classCallCheck2.default)(this, Curve);
      this.type = 'Curve';
      this.arcLengthDivisions = 200;
    }

    // Virtual base class method to overwrite and implement in subclasses
    //	- t [0 .. 1]
    return (0, _createClass2.default)(Curve, [{
      key: "getPoint",
      value: function getPoint(/* t, optionalTarget */
      ) {
        console.warn('THREE.Curve: .getPoint() not implemented.');
        return null;
      }

      // Get point at relative position in curve according to arc length
      // - u [0 .. 1]
    }, {
      key: "getPointAt",
      value: function getPointAt(u, optionalTarget) {
        var t = this.getUtoTmapping(u);
        return this.getPoint(t, optionalTarget);
      }

      // Get sequence of points using getPoint( t )
    }, {
      key: "getPoints",
      value: function getPoints() {
        var divisions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 5;
        var points = [];
        for (var d = 0; d <= divisions; d++) {
          points.push(this.getPoint(d / divisions));
        }
        return points;
      }

      // Get sequence of points using getPointAt( u )
    }, {
      key: "getSpacedPoints",
      value: function getSpacedPoints() {
        var divisions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 5;
        var points = [];
        for (var d = 0; d <= divisions; d++) {
          points.push(this.getPointAt(d / divisions));
        }
        return points;
      }

      // Get total curve arc length
    }, {
      key: "getLength",
      value: function getLength() {
        var lengths = this.getLengths();
        return lengths[lengths.length - 1];
      }

      // Get list of cumulative segment lengths
    }, {
      key: "getLengths",
      value: function getLengths() {
        var divisions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.arcLengthDivisions;
        if (this.cacheArcLengths && this.cacheArcLengths.length === divisions + 1 && !this.needsUpdate) {
          return this.cacheArcLengths;
        }
        this.needsUpdate = false;
        var cache = [];
        var current,
          last = this.getPoint(0);
        var sum = 0;
        cache.push(0);
        for (var p = 1; p <= divisions; p++) {
          current = this.getPoint(p / divisions);
          sum += current.distanceTo(last);
          cache.push(sum);
          last = current;
        }
        this.cacheArcLengths = cache;
        return cache; // { sums: cache, sum: sum }; Sum is in the last element.
      }
    }, {
      key: "updateArcLengths",
      value: function updateArcLengths() {
        this.needsUpdate = true;
        this.getLengths();
      }

      // Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant
    }, {
      key: "getUtoTmapping",
      value: function getUtoTmapping(u, distance) {
        var arcLengths = this.getLengths();
        var i = 0;
        var il = arcLengths.length;
        var targetArcLength; // The targeted u distance value to get

        if (distance) {
          targetArcLength = distance;
        } else {
          targetArcLength = u * arcLengths[il - 1];
        }

        // binary search for the index with largest value smaller than target u distance

        var low = 0,
          high = il - 1,
          comparison;
        while (low <= high) {
          i = Math.floor(low + (high - low) / 2); // less likely to overflow, though probably not issue here, JS doesn't really have integers, all numbers are floats

          comparison = arcLengths[i] - targetArcLength;
          if (comparison < 0) {
            low = i + 1;
          } else if (comparison > 0) {
            high = i - 1;
          } else {
            high = i;
            break;

            // DONE
          }
        }
        i = high;
        if (arcLengths[i] === targetArcLength) {
          return i / (il - 1);
        }

        // we could get finer grain at lengths, or use simple interpolation between two points

        var lengthBefore = arcLengths[i];
        var lengthAfter = arcLengths[i + 1];
        var segmentLength = lengthAfter - lengthBefore;

        // determine where we are between the 'before' and 'after' points

        var segmentFraction = (targetArcLength - lengthBefore) / segmentLength;

        // add that fractional amount to t

        var t = (i + segmentFraction) / (il - 1);
        return t;
      }

      // Returns a unit vector tangent at t
      // In case any sub curve does not implement its tangent derivation,
      // 2 points a small delta apart will be used to find its gradient
      // which seems to give a reasonable approximation
    }, {
      key: "getTangent",
      value: function getTangent(t, optionalTarget) {
        var delta = 0.0001;
        var t1 = t - delta;
        var t2 = t + delta;

        // Capping in case of danger

        if (t1 < 0) t1 = 0;
        if (t2 > 1) t2 = 1;
        var pt1 = this.getPoint(t1);
        var pt2 = this.getPoint(t2);
        var tangent = optionalTarget || (pt1.isVector2 ? new Vector2() : new Vector3());
        tangent.copy(pt2).sub(pt1).normalize();
        return tangent;
      }
    }, {
      key: "getTangentAt",
      value: function getTangentAt(u, optionalTarget) {
        var t = this.getUtoTmapping(u);
        return this.getTangent(t, optionalTarget);
      }
    }, {
      key: "computeFrenetFrames",
      value: function computeFrenetFrames(segments, closed) {
        // see http://www.cs.indiana.edu/pub/techreports/TR425.pdf

        var normal = new Vector3();
        var tangents = [];
        var normals = [];
        var binormals = [];
        var vec = new Vector3();
        var mat = new Matrix4();

        // compute the tangent vectors for each segment on the curve

        for (var i = 0; i <= segments; i++) {
          var u = i / segments;
          tangents[i] = this.getTangentAt(u, new Vector3());
        }

        // select an initial normal vector perpendicular to the first tangent vector,
        // and in the direction of the minimum tangent xyz component

        normals[0] = new Vector3();
        binormals[0] = new Vector3();
        var min = Number.MAX_VALUE;
        var tx = Math.abs(tangents[0].x);
        var ty = Math.abs(tangents[0].y);
        var tz = Math.abs(tangents[0].z);
        if (tx <= min) {
          min = tx;
          normal.set(1, 0, 0);
        }
        if (ty <= min) {
          min = ty;
          normal.set(0, 1, 0);
        }
        if (tz <= min) {
          normal.set(0, 0, 1);
        }
        vec.crossVectors(tangents[0], normal).normalize();
        normals[0].crossVectors(tangents[0], vec);
        binormals[0].crossVectors(tangents[0], normals[0]);

        // compute the slowly-varying normal and binormal vectors for each segment on the curve

        for (var _i31 = 1; _i31 <= segments; _i31++) {
          normals[_i31] = normals[_i31 - 1].clone();
          binormals[_i31] = binormals[_i31 - 1].clone();
          vec.crossVectors(tangents[_i31 - 1], tangents[_i31]);
          if (vec.length() > Number.EPSILON) {
            vec.normalize();
            var theta = Math.acos(_clamp(tangents[_i31 - 1].dot(tangents[_i31]), -1, 1)); // clamp for floating pt errors

            normals[_i31].applyMatrix4(mat.makeRotationAxis(vec, theta));
          }
          binormals[_i31].crossVectors(tangents[_i31], normals[_i31]);
        }

        // if the curve is closed, postprocess the vectors so the first and last normal vectors are the same

        if (closed === true) {
          var _theta = Math.acos(_clamp(normals[0].dot(normals[segments]), -1, 1));
          _theta /= segments;
          if (tangents[0].dot(vec.crossVectors(normals[0], normals[segments])) > 0) {
            _theta = -_theta;
          }
          for (var _i32 = 1; _i32 <= segments; _i32++) {
            // twist a little...
            normals[_i32].applyMatrix4(mat.makeRotationAxis(tangents[_i32], _theta * _i32));
            binormals[_i32].crossVectors(tangents[_i32], normals[_i32]);
          }
        }
        return {
          tangents: tangents,
          normals: normals,
          binormals: binormals
        };
      }
    }, {
      key: "clone",
      value: function clone() {
        return new this.constructor().copy(this);
      }
    }, {
      key: "copy",
      value: function copy(source) {
        this.arcLengthDivisions = source.arcLengthDivisions;
        return this;
      }
    }, {
      key: "toJSON",
      value: function toJSON() {
        var data = {
          metadata: {
            version: 4.6,
            type: 'Curve',
            generator: 'Curve.toJSON'
          }
        };
        data.arcLengthDivisions = this.arcLengthDivisions;
        data.type = this.type;
        return data;
      }
    }, {
      key: "fromJSON",
      value: function fromJSON(json) {
        this.arcLengthDivisions = json.arcLengthDivisions;
        return this;
      }
    }]);
  }();
  var EllipseCurve = exports.EllipseCurve = /*#__PURE__*/function (_Curve) {
    function EllipseCurve() {
      var _this45;
      var aX = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      var aY = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var xRadius = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
      var yRadius = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;
      var aStartAngle = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
      var aEndAngle = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : Math.PI * 2;
      var aClockwise = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : false;
      var aRotation = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : 0;
      (0, _classCallCheck2.default)(this, EllipseCurve);
      _this45 = _callSuper(this, EllipseCurve);
      _this45.isEllipseCurve = true;
      _this45.type = 'EllipseCurve';
      _this45.aX = aX;
      _this45.aY = aY;
      _this45.xRadius = xRadius;
      _this45.yRadius = yRadius;
      _this45.aStartAngle = aStartAngle;
      _this45.aEndAngle = aEndAngle;
      _this45.aClockwise = aClockwise;
      _this45.aRotation = aRotation;
      return _this45;
    }
    (0, _inherits2.default)(EllipseCurve, _Curve);
    return (0, _createClass2.default)(EllipseCurve, [{
      key: "getPoint",
      value: function getPoint(t) {
        var optionalTarget = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Vector2();
        var point = optionalTarget;
        var twoPi = Math.PI * 2;
        var deltaAngle = this.aEndAngle - this.aStartAngle;
        var samePoints = Math.abs(deltaAngle) < Number.EPSILON;

        // ensures that deltaAngle is 0 .. 2 PI
        while (deltaAngle < 0) deltaAngle += twoPi;
        while (deltaAngle > twoPi) deltaAngle -= twoPi;
        if (deltaAngle < Number.EPSILON) {
          if (samePoints) {
            deltaAngle = 0;
          } else {
            deltaAngle = twoPi;
          }
        }
        if (this.aClockwise === true && !samePoints) {
          if (deltaAngle === twoPi) {
            deltaAngle = -twoPi;
          } else {
            deltaAngle = deltaAngle - twoPi;
          }
        }
        var angle = this.aStartAngle + t * deltaAngle;
        var x = this.aX + this.xRadius * Math.cos(angle);
        var y = this.aY + this.yRadius * Math.sin(angle);
        if (this.aRotation !== 0) {
          var cos = Math.cos(this.aRotation);
          var sin = Math.sin(this.aRotation);
          var tx = x - this.aX;
          var ty = y - this.aY;

          // Rotate the point about the center of the ellipse.
          x = tx * cos - ty * sin + this.aX;
          y = tx * sin + ty * cos + this.aY;
        }
        return point.set(x, y);
      }
    }, {
      key: "copy",
      value: function copy(source) {
        _superPropGet(EllipseCurve, "copy", this, 3)([source]);
        this.aX = source.aX;
        this.aY = source.aY;
        this.xRadius = source.xRadius;
        this.yRadius = source.yRadius;
        this.aStartAngle = source.aStartAngle;
        this.aEndAngle = source.aEndAngle;
        this.aClockwise = source.aClockwise;
        this.aRotation = source.aRotation;
        return this;
      }
    }, {
      key: "toJSON",
      value: function toJSON() {
        var data = _superPropGet(EllipseCurve, "toJSON", this, 3)([]);
        data.aX = this.aX;
        data.aY = this.aY;
        data.xRadius = this.xRadius;
        data.yRadius = this.yRadius;
        data.aStartAngle = this.aStartAngle;
        data.aEndAngle = this.aEndAngle;
        data.aClockwise = this.aClockwise;
        data.aRotation = this.aRotation;
        return data;
      }
    }, {
      key: "fromJSON",
      value: function fromJSON(json) {
        _superPropGet(EllipseCurve, "fromJSON", this, 3)([json]);
        this.aX = json.aX;
        this.aY = json.aY;
        this.xRadius = json.xRadius;
        this.yRadius = json.yRadius;
        this.aStartAngle = json.aStartAngle;
        this.aEndAngle = json.aEndAngle;
        this.aClockwise = json.aClockwise;
        this.aRotation = json.aRotation;
        return this;
      }
    }]);
  }(Curve);
  var ArcCurve = exports.ArcCurve = /*#__PURE__*/function (_EllipseCurve) {
    function ArcCurve(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
      var _this46;
      (0, _classCallCheck2.default)(this, ArcCurve);
      _this46 = _callSuper(this, ArcCurve, [aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise]);
      _this46.isArcCurve = true;
      _this46.type = 'ArcCurve';
      return _this46;
    }
    (0, _inherits2.default)(ArcCurve, _EllipseCurve);
    return (0, _createClass2.default)(ArcCurve);
  }(EllipseCurve);
  /**
   * Centripetal CatmullRom Curve - which is useful for avoiding
   * cusps and self-intersections in non-uniform catmull rom curves.
   * http://www.cemyuksel.com/research/catmullrom_param/catmullrom.pdf
   *
   * curve.type accepts centripetal(default), chordal and catmullrom
   * curve.tension is used for catmullrom which defaults to 0.5
   */
  /*
  Based on an optimized c++ solution in
   - http://stackoverflow.com/questions/9489736/catmull-rom-curve-with-no-cusps-and-no-self-intersections/
   - http://ideone.com/NoEbVM
  
  This CubicPoly class could be used for reusing some variables and calculations,
  but for three.js curve use, it could be possible inlined and flatten into a single function call
  which can be placed in CurveUtils.
  */
  function CubicPoly() {
    var c0 = 0,
      c1 = 0,
      c2 = 0,
      c3 = 0;

    /*
     * Compute coefficients for a cubic polynomial
     *   p(s) = c0 + c1*s + c2*s^2 + c3*s^3
     * such that
     *   p(0) = x0, p(1) = x1
     *  and
     *   p'(0) = t0, p'(1) = t1.
     */
    function init(x0, x1, t0, t1) {
      c0 = x0;
      c1 = t0;
      c2 = -3 * x0 + 3 * x1 - 2 * t0 - t1;
      c3 = 2 * x0 - 2 * x1 + t0 + t1;
    }
    return {
      initCatmullRom: function initCatmullRom(x0, x1, x2, x3, tension) {
        init(x1, x2, tension * (x2 - x0), tension * (x3 - x1));
      },
      initNonuniformCatmullRom: function initNonuniformCatmullRom(x0, x1, x2, x3, dt0, dt1, dt2) {
        // compute tangents when parameterized in [t1,t2]
        var t1 = (x1 - x0) / dt0 - (x2 - x0) / (dt0 + dt1) + (x2 - x1) / dt1;
        var t2 = (x2 - x1) / dt1 - (x3 - x1) / (dt1 + dt2) + (x3 - x2) / dt2;

        // rescale tangents for parametrization in [0,1]
        t1 *= dt1;
        t2 *= dt1;
        init(x1, x2, t1, t2);
      },
      calc: function calc(t) {
        var t2 = t * t;
        var t3 = t2 * t;
        return c0 + c1 * t + c2 * t2 + c3 * t3;
      }
    };
  }

  //

  var tmp = /*@__PURE__*/new Vector3();
  var px = /*@__PURE__*/new CubicPoly();
  var py = /*@__PURE__*/new CubicPoly();
  var pz = /*@__PURE__*/new CubicPoly();
  var CatmullRomCurve3 = exports.CatmullRomCurve3 = /*#__PURE__*/function (_Curve2) {
    function CatmullRomCurve3() {
      var _this47;
      var points = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      var closed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      var curveType = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'centripetal';
      var tension = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0.5;
      (0, _classCallCheck2.default)(this, CatmullRomCurve3);
      _this47 = _callSuper(this, CatmullRomCurve3);
      _this47.isCatmullRomCurve3 = true;
      _this47.type = 'CatmullRomCurve3';
      _this47.points = points;
      _this47.closed = closed;
      _this47.curveType = curveType;
      _this47.tension = tension;
      return _this47;
    }
    (0, _inherits2.default)(CatmullRomCurve3, _Curve2);
    return (0, _createClass2.default)(CatmullRomCurve3, [{
      key: "getPoint",
      value: function getPoint(t) {
        var optionalTarget = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Vector3();
        var point = optionalTarget;
        var points = this.points;
        var l = points.length;
        var p = (l - (this.closed ? 0 : 1)) * t;
        var intPoint = Math.floor(p);
        var weight = p - intPoint;
        if (this.closed) {
          intPoint += intPoint > 0 ? 0 : (Math.floor(Math.abs(intPoint) / l) + 1) * l;
        } else if (weight === 0 && intPoint === l - 1) {
          intPoint = l - 2;
          weight = 1;
        }
        var p0, p3; // 4 points (p1 & p2 defined below)

        if (this.closed || intPoint > 0) {
          p0 = points[(intPoint - 1) % l];
        } else {
          // extrapolate first point
          tmp.subVectors(points[0], points[1]).add(points[0]);
          p0 = tmp;
        }
        var p1 = points[intPoint % l];
        var p2 = points[(intPoint + 1) % l];
        if (this.closed || intPoint + 2 < l) {
          p3 = points[(intPoint + 2) % l];
        } else {
          // extrapolate last point
          tmp.subVectors(points[l - 1], points[l - 2]).add(points[l - 1]);
          p3 = tmp;
        }
        if (this.curveType === 'centripetal' || this.curveType === 'chordal') {
          // init Centripetal / Chordal Catmull-Rom
          var pow = this.curveType === 'chordal' ? 0.5 : 0.25;
          var dt0 = Math.pow(p0.distanceToSquared(p1), pow);
          var dt1 = Math.pow(p1.distanceToSquared(p2), pow);
          var dt2 = Math.pow(p2.distanceToSquared(p3), pow);

          // safety check for repeated points
          if (dt1 < 1e-4) dt1 = 1.0;
          if (dt0 < 1e-4) dt0 = dt1;
          if (dt2 < 1e-4) dt2 = dt1;
          px.initNonuniformCatmullRom(p0.x, p1.x, p2.x, p3.x, dt0, dt1, dt2);
          py.initNonuniformCatmullRom(p0.y, p1.y, p2.y, p3.y, dt0, dt1, dt2);
          pz.initNonuniformCatmullRom(p0.z, p1.z, p2.z, p3.z, dt0, dt1, dt2);
        } else if (this.curveType === 'catmullrom') {
          px.initCatmullRom(p0.x, p1.x, p2.x, p3.x, this.tension);
          py.initCatmullRom(p0.y, p1.y, p2.y, p3.y, this.tension);
          pz.initCatmullRom(p0.z, p1.z, p2.z, p3.z, this.tension);
        }
        point.set(px.calc(weight), py.calc(weight), pz.calc(weight));
        return point;
      }
    }, {
      key: "copy",
      value: function copy(source) {
        _superPropGet(CatmullRomCurve3, "copy", this, 3)([source]);
        this.points = [];
        for (var i = 0, l = source.points.length; i < l; i++) {
          var point = source.points[i];
          this.points.push(point.clone());
        }
        this.closed = source.closed;
        this.curveType = source.curveType;
        this.tension = source.tension;
        return this;
      }
    }, {
      key: "toJSON",
      value: function toJSON() {
        var data = _superPropGet(CatmullRomCurve3, "toJSON", this, 3)([]);
        data.points = [];
        for (var i = 0, l = this.points.length; i < l; i++) {
          var point = this.points[i];
          data.points.push(point.toArray());
        }
        data.closed = this.closed;
        data.curveType = this.curveType;
        data.tension = this.tension;
        return data;
      }
    }, {
      key: "fromJSON",
      value: function fromJSON(json) {
        _superPropGet(CatmullRomCurve3, "fromJSON", this, 3)([json]);
        this.points = [];
        for (var i = 0, l = json.points.length; i < l; i++) {
          var point = json.points[i];
          this.points.push(new Vector3().fromArray(point));
        }
        this.closed = json.closed;
        this.curveType = json.curveType;
        this.tension = json.tension;
        return this;
      }
    }]);
  }(Curve);
  /**
   * Bezier Curves formulas obtained from
   * https://en.wikipedia.org/wiki/B%C3%A9zier_curve
   */
  function CatmullRom(t, p0, p1, p2, p3) {
    var v0 = (p2 - p0) * 0.5;
    var v1 = (p3 - p1) * 0.5;
    var t2 = t * t;
    var t3 = t * t2;
    return (2 * p1 - 2 * p2 + v0 + v1) * t3 + (-3 * p1 + 3 * p2 - 2 * v0 - v1) * t2 + v0 * t + p1;
  }

  //

  function QuadraticBezierP0(t, p) {
    var k = 1 - t;
    return k * k * p;
  }
  function QuadraticBezierP1(t, p) {
    return 2 * (1 - t) * t * p;
  }
  function QuadraticBezierP2(t, p) {
    return t * t * p;
  }
  function QuadraticBezier(t, p0, p1, p2) {
    return QuadraticBezierP0(t, p0) + QuadraticBezierP1(t, p1) + QuadraticBezierP2(t, p2);
  }

  //

  function CubicBezierP0(t, p) {
    var k = 1 - t;
    return k * k * k * p;
  }
  function CubicBezierP1(t, p) {
    var k = 1 - t;
    return 3 * k * k * t * p;
  }
  function CubicBezierP2(t, p) {
    return 3 * (1 - t) * t * t * p;
  }
  function CubicBezierP3(t, p) {
    return t * t * t * p;
  }
  function CubicBezier(t, p0, p1, p2, p3) {
    return CubicBezierP0(t, p0) + CubicBezierP1(t, p1) + CubicBezierP2(t, p2) + CubicBezierP3(t, p3);
  }
  var CubicBezierCurve = exports.CubicBezierCurve = /*#__PURE__*/function (_Curve3) {
    function CubicBezierCurve() {
      var _this48;
      var v0 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Vector2();
      var v1 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Vector2();
      var v2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new Vector2();
      var v3 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : new Vector2();
      (0, _classCallCheck2.default)(this, CubicBezierCurve);
      _this48 = _callSuper(this, CubicBezierCurve);
      _this48.isCubicBezierCurve = true;
      _this48.type = 'CubicBezierCurve';
      _this48.v0 = v0;
      _this48.v1 = v1;
      _this48.v2 = v2;
      _this48.v3 = v3;
      return _this48;
    }
    (0, _inherits2.default)(CubicBezierCurve, _Curve3);
    return (0, _createClass2.default)(CubicBezierCurve, [{
      key: "getPoint",
      value: function getPoint(t) {
        var optionalTarget = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Vector2();
        var point = optionalTarget;
        var v0 = this.v0,
          v1 = this.v1,
          v2 = this.v2,
          v3 = this.v3;
        point.set(CubicBezier(t, v0.x, v1.x, v2.x, v3.x), CubicBezier(t, v0.y, v1.y, v2.y, v3.y));
        return point;
      }
    }, {
      key: "copy",
      value: function copy(source) {
        _superPropGet(CubicBezierCurve, "copy", this, 3)([source]);
        this.v0.copy(source.v0);
        this.v1.copy(source.v1);
        this.v2.copy(source.v2);
        this.v3.copy(source.v3);
        return this;
      }
    }, {
      key: "toJSON",
      value: function toJSON() {
        var data = _superPropGet(CubicBezierCurve, "toJSON", this, 3)([]);
        data.v0 = this.v0.toArray();
        data.v1 = this.v1.toArray();
        data.v2 = this.v2.toArray();
        data.v3 = this.v3.toArray();
        return data;
      }
    }, {
      key: "fromJSON",
      value: function fromJSON(json) {
        _superPropGet(CubicBezierCurve, "fromJSON", this, 3)([json]);
        this.v0.fromArray(json.v0);
        this.v1.fromArray(json.v1);
        this.v2.fromArray(json.v2);
        this.v3.fromArray(json.v3);
        return this;
      }
    }]);
  }(Curve);
  var CubicBezierCurve3 = exports.CubicBezierCurve3 = /*#__PURE__*/function (_Curve4) {
    function CubicBezierCurve3() {
      var _this49;
      var v0 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Vector3();
      var v1 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Vector3();
      var v2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new Vector3();
      var v3 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : new Vector3();
      (0, _classCallCheck2.default)(this, CubicBezierCurve3);
      _this49 = _callSuper(this, CubicBezierCurve3);
      _this49.isCubicBezierCurve3 = true;
      _this49.type = 'CubicBezierCurve3';
      _this49.v0 = v0;
      _this49.v1 = v1;
      _this49.v2 = v2;
      _this49.v3 = v3;
      return _this49;
    }
    (0, _inherits2.default)(CubicBezierCurve3, _Curve4);
    return (0, _createClass2.default)(CubicBezierCurve3, [{
      key: "getPoint",
      value: function getPoint(t) {
        var optionalTarget = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Vector3();
        var point = optionalTarget;
        var v0 = this.v0,
          v1 = this.v1,
          v2 = this.v2,
          v3 = this.v3;
        point.set(CubicBezier(t, v0.x, v1.x, v2.x, v3.x), CubicBezier(t, v0.y, v1.y, v2.y, v3.y), CubicBezier(t, v0.z, v1.z, v2.z, v3.z));
        return point;
      }
    }, {
      key: "copy",
      value: function copy(source) {
        _superPropGet(CubicBezierCurve3, "copy", this, 3)([source]);
        this.v0.copy(source.v0);
        this.v1.copy(source.v1);
        this.v2.copy(source.v2);
        this.v3.copy(source.v3);
        return this;
      }
    }, {
      key: "toJSON",
      value: function toJSON() {
        var data = _superPropGet(CubicBezierCurve3, "toJSON", this, 3)([]);
        data.v0 = this.v0.toArray();
        data.v1 = this.v1.toArray();
        data.v2 = this.v2.toArray();
        data.v3 = this.v3.toArray();
        return data;
      }
    }, {
      key: "fromJSON",
      value: function fromJSON(json) {
        _superPropGet(CubicBezierCurve3, "fromJSON", this, 3)([json]);
        this.v0.fromArray(json.v0);
        this.v1.fromArray(json.v1);
        this.v2.fromArray(json.v2);
        this.v3.fromArray(json.v3);
        return this;
      }
    }]);
  }(Curve);
  var LineCurve = exports.LineCurve = /*#__PURE__*/function (_Curve5) {
    function LineCurve() {
      var _this50;
      var v1 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Vector2();
      var v2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Vector2();
      (0, _classCallCheck2.default)(this, LineCurve);
      _this50 = _callSuper(this, LineCurve);
      _this50.isLineCurve = true;
      _this50.type = 'LineCurve';
      _this50.v1 = v1;
      _this50.v2 = v2;
      return _this50;
    }
    (0, _inherits2.default)(LineCurve, _Curve5);
    return (0, _createClass2.default)(LineCurve, [{
      key: "getPoint",
      value: function getPoint(t) {
        var optionalTarget = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Vector2();
        var point = optionalTarget;
        if (t === 1) {
          point.copy(this.v2);
        } else {
          point.copy(this.v2).sub(this.v1);
          point.multiplyScalar(t).add(this.v1);
        }
        return point;
      }

      // Line curve is linear, so we can overwrite default getPointAt
    }, {
      key: "getPointAt",
      value: function getPointAt(u, optionalTarget) {
        return this.getPoint(u, optionalTarget);
      }
    }, {
      key: "getTangent",
      value: function getTangent(t) {
        var optionalTarget = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Vector2();
        return optionalTarget.subVectors(this.v2, this.v1).normalize();
      }
    }, {
      key: "getTangentAt",
      value: function getTangentAt(u, optionalTarget) {
        return this.getTangent(u, optionalTarget);
      }
    }, {
      key: "copy",
      value: function copy(source) {
        _superPropGet(LineCurve, "copy", this, 3)([source]);
        this.v1.copy(source.v1);
        this.v2.copy(source.v2);
        return this;
      }
    }, {
      key: "toJSON",
      value: function toJSON() {
        var data = _superPropGet(LineCurve, "toJSON", this, 3)([]);
        data.v1 = this.v1.toArray();
        data.v2 = this.v2.toArray();
        return data;
      }
    }, {
      key: "fromJSON",
      value: function fromJSON(json) {
        _superPropGet(LineCurve, "fromJSON", this, 3)([json]);
        this.v1.fromArray(json.v1);
        this.v2.fromArray(json.v2);
        return this;
      }
    }]);
  }(Curve);
  var LineCurve3 = exports.LineCurve3 = /*#__PURE__*/function (_Curve6) {
    function LineCurve3() {
      var _this51;
      var v1 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Vector3();
      var v2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Vector3();
      (0, _classCallCheck2.default)(this, LineCurve3);
      _this51 = _callSuper(this, LineCurve3);
      _this51.isLineCurve3 = true;
      _this51.type = 'LineCurve3';
      _this51.v1 = v1;
      _this51.v2 = v2;
      return _this51;
    }
    (0, _inherits2.default)(LineCurve3, _Curve6);
    return (0, _createClass2.default)(LineCurve3, [{
      key: "getPoint",
      value: function getPoint(t) {
        var optionalTarget = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Vector3();
        var point = optionalTarget;
        if (t === 1) {
          point.copy(this.v2);
        } else {
          point.copy(this.v2).sub(this.v1);
          point.multiplyScalar(t).add(this.v1);
        }
        return point;
      }

      // Line curve is linear, so we can overwrite default getPointAt
    }, {
      key: "getPointAt",
      value: function getPointAt(u, optionalTarget) {
        return this.getPoint(u, optionalTarget);
      }
    }, {
      key: "getTangent",
      value: function getTangent(t) {
        var optionalTarget = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Vector3();
        return optionalTarget.subVectors(this.v2, this.v1).normalize();
      }
    }, {
      key: "getTangentAt",
      value: function getTangentAt(u, optionalTarget) {
        return this.getTangent(u, optionalTarget);
      }
    }, {
      key: "copy",
      value: function copy(source) {
        _superPropGet(LineCurve3, "copy", this, 3)([source]);
        this.v1.copy(source.v1);
        this.v2.copy(source.v2);
        return this;
      }
    }, {
      key: "toJSON",
      value: function toJSON() {
        var data = _superPropGet(LineCurve3, "toJSON", this, 3)([]);
        data.v1 = this.v1.toArray();
        data.v2 = this.v2.toArray();
        return data;
      }
    }, {
      key: "fromJSON",
      value: function fromJSON(json) {
        _superPropGet(LineCurve3, "fromJSON", this, 3)([json]);
        this.v1.fromArray(json.v1);
        this.v2.fromArray(json.v2);
        return this;
      }
    }]);
  }(Curve);
  var QuadraticBezierCurve = exports.QuadraticBezierCurve = /*#__PURE__*/function (_Curve7) {
    function QuadraticBezierCurve() {
      var _this52;
      var v0 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Vector2();
      var v1 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Vector2();
      var v2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new Vector2();
      (0, _classCallCheck2.default)(this, QuadraticBezierCurve);
      _this52 = _callSuper(this, QuadraticBezierCurve);
      _this52.isQuadraticBezierCurve = true;
      _this52.type = 'QuadraticBezierCurve';
      _this52.v0 = v0;
      _this52.v1 = v1;
      _this52.v2 = v2;
      return _this52;
    }
    (0, _inherits2.default)(QuadraticBezierCurve, _Curve7);
    return (0, _createClass2.default)(QuadraticBezierCurve, [{
      key: "getPoint",
      value: function getPoint(t) {
        var optionalTarget = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Vector2();
        var point = optionalTarget;
        var v0 = this.v0,
          v1 = this.v1,
          v2 = this.v2;
        point.set(QuadraticBezier(t, v0.x, v1.x, v2.x), QuadraticBezier(t, v0.y, v1.y, v2.y));
        return point;
      }
    }, {
      key: "copy",
      value: function copy(source) {
        _superPropGet(QuadraticBezierCurve, "copy", this, 3)([source]);
        this.v0.copy(source.v0);
        this.v1.copy(source.v1);
        this.v2.copy(source.v2);
        return this;
      }
    }, {
      key: "toJSON",
      value: function toJSON() {
        var data = _superPropGet(QuadraticBezierCurve, "toJSON", this, 3)([]);
        data.v0 = this.v0.toArray();
        data.v1 = this.v1.toArray();
        data.v2 = this.v2.toArray();
        return data;
      }
    }, {
      key: "fromJSON",
      value: function fromJSON(json) {
        _superPropGet(QuadraticBezierCurve, "fromJSON", this, 3)([json]);
        this.v0.fromArray(json.v0);
        this.v1.fromArray(json.v1);
        this.v2.fromArray(json.v2);
        return this;
      }
    }]);
  }(Curve);
  var QuadraticBezierCurve3 = exports.QuadraticBezierCurve3 = /*#__PURE__*/function (_Curve8) {
    function QuadraticBezierCurve3() {
      var _this53;
      var v0 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Vector3();
      var v1 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Vector3();
      var v2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new Vector3();
      (0, _classCallCheck2.default)(this, QuadraticBezierCurve3);
      _this53 = _callSuper(this, QuadraticBezierCurve3);
      _this53.isQuadraticBezierCurve3 = true;
      _this53.type = 'QuadraticBezierCurve3';
      _this53.v0 = v0;
      _this53.v1 = v1;
      _this53.v2 = v2;
      return _this53;
    }
    (0, _inherits2.default)(QuadraticBezierCurve3, _Curve8);
    return (0, _createClass2.default)(QuadraticBezierCurve3, [{
      key: "getPoint",
      value: function getPoint(t) {
        var optionalTarget = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Vector3();
        var point = optionalTarget;
        var v0 = this.v0,
          v1 = this.v1,
          v2 = this.v2;
        point.set(QuadraticBezier(t, v0.x, v1.x, v2.x), QuadraticBezier(t, v0.y, v1.y, v2.y), QuadraticBezier(t, v0.z, v1.z, v2.z));
        return point;
      }
    }, {
      key: "copy",
      value: function copy(source) {
        _superPropGet(QuadraticBezierCurve3, "copy", this, 3)([source]);
        this.v0.copy(source.v0);
        this.v1.copy(source.v1);
        this.v2.copy(source.v2);
        return this;
      }
    }, {
      key: "toJSON",
      value: function toJSON() {
        var data = _superPropGet(QuadraticBezierCurve3, "toJSON", this, 3)([]);
        data.v0 = this.v0.toArray();
        data.v1 = this.v1.toArray();
        data.v2 = this.v2.toArray();
        return data;
      }
    }, {
      key: "fromJSON",
      value: function fromJSON(json) {
        _superPropGet(QuadraticBezierCurve3, "fromJSON", this, 3)([json]);
        this.v0.fromArray(json.v0);
        this.v1.fromArray(json.v1);
        this.v2.fromArray(json.v2);
        return this;
      }
    }]);
  }(Curve);
  var SplineCurve = exports.SplineCurve = /*#__PURE__*/function (_Curve9) {
    function SplineCurve() {
      var _this54;
      var points = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      (0, _classCallCheck2.default)(this, SplineCurve);
      _this54 = _callSuper(this, SplineCurve);
      _this54.isSplineCurve = true;
      _this54.type = 'SplineCurve';
      _this54.points = points;
      return _this54;
    }
    (0, _inherits2.default)(SplineCurve, _Curve9);
    return (0, _createClass2.default)(SplineCurve, [{
      key: "getPoint",
      value: function getPoint(t) {
        var optionalTarget = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Vector2();
        var point = optionalTarget;
        var points = this.points;
        var p = (points.length - 1) * t;
        var intPoint = Math.floor(p);
        var weight = p - intPoint;
        var p0 = points[intPoint === 0 ? intPoint : intPoint - 1];
        var p1 = points[intPoint];
        var p2 = points[intPoint > points.length - 2 ? points.length - 1 : intPoint + 1];
        var p3 = points[intPoint > points.length - 3 ? points.length - 1 : intPoint + 2];
        point.set(CatmullRom(weight, p0.x, p1.x, p2.x, p3.x), CatmullRom(weight, p0.y, p1.y, p2.y, p3.y));
        return point;
      }
    }, {
      key: "copy",
      value: function copy(source) {
        _superPropGet(SplineCurve, "copy", this, 3)([source]);
        this.points = [];
        for (var i = 0, l = source.points.length; i < l; i++) {
          var point = source.points[i];
          this.points.push(point.clone());
        }
        return this;
      }
    }, {
      key: "toJSON",
      value: function toJSON() {
        var data = _superPropGet(SplineCurve, "toJSON", this, 3)([]);
        data.points = [];
        for (var i = 0, l = this.points.length; i < l; i++) {
          var point = this.points[i];
          data.points.push(point.toArray());
        }
        return data;
      }
    }, {
      key: "fromJSON",
      value: function fromJSON(json) {
        _superPropGet(SplineCurve, "fromJSON", this, 3)([json]);
        this.points = [];
        for (var i = 0, l = json.points.length; i < l; i++) {
          var point = json.points[i];
          this.points.push(new Vector2().fromArray(point));
        }
        return this;
      }
    }]);
  }(Curve);
  var Curves = /*#__PURE__*/Object.freeze({
    __proto__: null,
    ArcCurve: ArcCurve,
    CatmullRomCurve3: CatmullRomCurve3,
    CubicBezierCurve: CubicBezierCurve,
    CubicBezierCurve3: CubicBezierCurve3,
    EllipseCurve: EllipseCurve,
    LineCurve: LineCurve,
    LineCurve3: LineCurve3,
    QuadraticBezierCurve: QuadraticBezierCurve,
    QuadraticBezierCurve3: QuadraticBezierCurve3,
    SplineCurve: SplineCurve
  });

  /**************************************************************
   *	Curved Path - a curve path is simply a array of connected
   *  curves, but retains the api of a curve
   **************************************************************/
  var CurvePath = exports.CurvePath = /*#__PURE__*/function (_Curve10) {
    function CurvePath() {
      var _this55;
      (0, _classCallCheck2.default)(this, CurvePath);
      _this55 = _callSuper(this, CurvePath);
      _this55.type = 'CurvePath';
      _this55.curves = [];
      _this55.autoClose = false; // Automatically closes the path
      return _this55;
    }
    (0, _inherits2.default)(CurvePath, _Curve10);
    return (0, _createClass2.default)(CurvePath, [{
      key: "add",
      value: function add(curve) {
        this.curves.push(curve);
      }
    }, {
      key: "closePath",
      value: function closePath() {
        // Add a line curve if start and end of lines are not connected
        var startPoint = this.curves[0].getPoint(0);
        var endPoint = this.curves[this.curves.length - 1].getPoint(1);
        if (!startPoint.equals(endPoint)) {
          var lineType = startPoint.isVector2 === true ? 'LineCurve' : 'LineCurve3';
          this.curves.push(new Curves[lineType](endPoint, startPoint));
        }
        return this;
      }

      // To get accurate point with reference to
      // entire path distance at time t,
      // following has to be done:

      // 1. Length of each sub path have to be known
      // 2. Locate and identify type of curve
      // 3. Get t for the curve
      // 4. Return curve.getPointAt(t')
    }, {
      key: "getPoint",
      value: function getPoint(t, optionalTarget) {
        var d = t * this.getLength();
        var curveLengths = this.getCurveLengths();
        var i = 0;

        // To think about boundaries points.

        while (i < curveLengths.length) {
          if (curveLengths[i] >= d) {
            var diff = curveLengths[i] - d;
            var curve = this.curves[i];
            var segmentLength = curve.getLength();
            var u = segmentLength === 0 ? 0 : 1 - diff / segmentLength;
            return curve.getPointAt(u, optionalTarget);
          }
          i++;
        }
        return null;

        // loop where sum != 0, sum > d , sum+1 <d
      }

      // We cannot use the default THREE.Curve getPoint() with getLength() because in
      // THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath
      // getPoint() depends on getLength
    }, {
      key: "getLength",
      value: function getLength() {
        var lens = this.getCurveLengths();
        return lens[lens.length - 1];
      }

      // cacheLengths must be recalculated.
    }, {
      key: "updateArcLengths",
      value: function updateArcLengths() {
        this.needsUpdate = true;
        this.cacheLengths = null;
        this.getCurveLengths();
      }

      // Compute lengths and cache them
      // We cannot overwrite getLengths() because UtoT mapping uses it.
    }, {
      key: "getCurveLengths",
      value: function getCurveLengths() {
        // We use cache values if curves and cache array are same length

        if (this.cacheLengths && this.cacheLengths.length === this.curves.length) {
          return this.cacheLengths;
        }

        // Get length of sub-curve
        // Push sums into cached array

        var lengths = [];
        var sums = 0;
        for (var i = 0, l = this.curves.length; i < l; i++) {
          sums += this.curves[i].getLength();
          lengths.push(sums);
        }
        this.cacheLengths = lengths;
        return lengths;
      }
    }, {
      key: "getSpacedPoints",
      value: function getSpacedPoints() {
        var divisions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 40;
        var points = [];
        for (var i = 0; i <= divisions; i++) {
          points.push(this.getPoint(i / divisions));
        }
        if (this.autoClose) {
          points.push(points[0]);
        }
        return points;
      }
    }, {
      key: "getPoints",
      value: function getPoints() {
        var divisions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 12;
        var points = [];
        var last;
        for (var i = 0, curves = this.curves; i < curves.length; i++) {
          var curve = curves[i];
          var resolution = curve.isEllipseCurve ? divisions * 2 : curve.isLineCurve || curve.isLineCurve3 ? 1 : curve.isSplineCurve ? divisions * curve.points.length : divisions;
          var pts = curve.getPoints(resolution);
          for (var j = 0; j < pts.length; j++) {
            var point = pts[j];
            if (last && last.equals(point)) continue; // ensures no consecutive points are duplicates

            points.push(point);
            last = point;
          }
        }
        if (this.autoClose && points.length > 1 && !points[points.length - 1].equals(points[0])) {
          points.push(points[0]);
        }
        return points;
      }
    }, {
      key: "copy",
      value: function copy(source) {
        _superPropGet(CurvePath, "copy", this, 3)([source]);
        this.curves = [];
        for (var i = 0, l = source.curves.length; i < l; i++) {
          var curve = source.curves[i];
          this.curves.push(curve.clone());
        }
        this.autoClose = source.autoClose;
        return this;
      }
    }, {
      key: "toJSON",
      value: function toJSON() {
        var data = _superPropGet(CurvePath, "toJSON", this, 3)([]);
        data.autoClose = this.autoClose;
        data.curves = [];
        for (var i = 0, l = this.curves.length; i < l; i++) {
          var curve = this.curves[i];
          data.curves.push(curve.toJSON());
        }
        return data;
      }
    }, {
      key: "fromJSON",
      value: function fromJSON(json) {
        _superPropGet(CurvePath, "fromJSON", this, 3)([json]);
        this.autoClose = json.autoClose;
        this.curves = [];
        for (var i = 0, l = json.curves.length; i < l; i++) {
          var curve = json.curves[i];
          this.curves.push(new Curves[curve.type]().fromJSON(curve));
        }
        return this;
      }
    }]);
  }(Curve);
  var Path = exports.Path = /*#__PURE__*/function (_CurvePath) {
    function Path(points) {
      var _this56;
      (0, _classCallCheck2.default)(this, Path);
      _this56 = _callSuper(this, Path);
      _this56.type = 'Path';
      _this56.currentPoint = new Vector2();
      if (points) {
        _this56.setFromPoints(points);
      }
      return _this56;
    }
    (0, _inherits2.default)(Path, _CurvePath);
    return (0, _createClass2.default)(Path, [{
      key: "setFromPoints",
      value: function setFromPoints(points) {
        this.moveTo(points[0].x, points[0].y);
        for (var i = 1, l = points.length; i < l; i++) {
          this.lineTo(points[i].x, points[i].y);
        }
        return this;
      }
    }, {
      key: "moveTo",
      value: function moveTo(x, y) {
        this.currentPoint.set(x, y); // TODO consider referencing vectors instead of copying?

        return this;
      }
    }, {
      key: "lineTo",
      value: function lineTo(x, y) {
        var curve = new LineCurve(this.currentPoint.clone(), new Vector2(x, y));
        this.curves.push(curve);
        this.currentPoint.set(x, y);
        return this;
      }
    }, {
      key: "quadraticCurveTo",
      value: function quadraticCurveTo(aCPx, aCPy, aX, aY) {
        var curve = new QuadraticBezierCurve(this.currentPoint.clone(), new Vector2(aCPx, aCPy), new Vector2(aX, aY));
        this.curves.push(curve);
        this.currentPoint.set(aX, aY);
        return this;
      }
    }, {
      key: "bezierCurveTo",
      value: function bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) {
        var curve = new CubicBezierCurve(this.currentPoint.clone(), new Vector2(aCP1x, aCP1y), new Vector2(aCP2x, aCP2y), new Vector2(aX, aY));
        this.curves.push(curve);
        this.currentPoint.set(aX, aY);
        return this;
      }
    }, {
      key: "splineThru",
      value: function splineThru(pts /*Array of Vector*/) {
        var npts = [this.currentPoint.clone()].concat(pts);
        var curve = new SplineCurve(npts);
        this.curves.push(curve);
        this.currentPoint.copy(pts[pts.length - 1]);
        return this;
      }
    }, {
      key: "arc",
      value: function arc(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
        var x0 = this.currentPoint.x;
        var y0 = this.currentPoint.y;
        this.absarc(aX + x0, aY + y0, aRadius, aStartAngle, aEndAngle, aClockwise);
        return this;
      }
    }, {
      key: "absarc",
      value: function absarc(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
        this.absellipse(aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise);
        return this;
      }
    }, {
      key: "ellipse",
      value: function ellipse(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
        var x0 = this.currentPoint.x;
        var y0 = this.currentPoint.y;
        this.absellipse(aX + x0, aY + y0, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation);
        return this;
      }
    }, {
      key: "absellipse",
      value: function absellipse(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation) {
        var curve = new EllipseCurve(aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation);
        if (this.curves.length > 0) {
          // if a previous curve is present, attempt to join
          var firstPoint = curve.getPoint(0);
          if (!firstPoint.equals(this.currentPoint)) {
            this.lineTo(firstPoint.x, firstPoint.y);
          }
        }
        this.curves.push(curve);
        var lastPoint = curve.getPoint(1);
        this.currentPoint.copy(lastPoint);
        return this;
      }
    }, {
      key: "copy",
      value: function copy(source) {
        _superPropGet(Path, "copy", this, 3)([source]);
        this.currentPoint.copy(source.currentPoint);
        return this;
      }
    }, {
      key: "toJSON",
      value: function toJSON() {
        var data = _superPropGet(Path, "toJSON", this, 3)([]);
        data.currentPoint = this.currentPoint.toArray();
        return data;
      }
    }, {
      key: "fromJSON",
      value: function fromJSON(json) {
        _superPropGet(Path, "fromJSON", this, 3)([json]);
        this.currentPoint.fromArray(json.currentPoint);
        return this;
      }
    }]);
  }(CurvePath);
  var LatheGeometry = exports.LatheGeometry = /*#__PURE__*/function (_BufferGeometry2) {
    function LatheGeometry() {
      var _this57;
      var points = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [new Vector2(0, -0.5), new Vector2(0.5, 0), new Vector2(0, 0.5)];
      var segments = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 12;
      var phiStart = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      var phiLength = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : Math.PI * 2;
      (0, _classCallCheck2.default)(this, LatheGeometry);
      _this57 = _callSuper(this, LatheGeometry);
      _this57.type = 'LatheGeometry';
      _this57.parameters = {
        points: points,
        segments: segments,
        phiStart: phiStart,
        phiLength: phiLength
      };
      segments = Math.floor(segments);

      // clamp phiLength so it's in range of [ 0, 2PI ]

      phiLength = _clamp(phiLength, 0, Math.PI * 2);

      // buffers

      var indices = [];
      var vertices = [];
      var uvs = [];
      var initNormals = [];
      var normals = [];

      // helper variables

      var inverseSegments = 1.0 / segments;
      var vertex = new Vector3();
      var uv = new Vector2();
      var normal = new Vector3();
      var curNormal = new Vector3();
      var prevNormal = new Vector3();
      var dx = 0;
      var dy = 0;

      // pre-compute normals for initial "meridian"

      for (var j = 0; j <= points.length - 1; j++) {
        switch (j) {
          case 0:
            // special handling for 1st vertex on path

            dx = points[j + 1].x - points[j].x;
            dy = points[j + 1].y - points[j].y;
            normal.x = dy * 1.0;
            normal.y = -dx;
            normal.z = dy * 0.0;
            prevNormal.copy(normal);
            normal.normalize();
            initNormals.push(normal.x, normal.y, normal.z);
            break;
          case points.length - 1:
            // special handling for last Vertex on path

            initNormals.push(prevNormal.x, prevNormal.y, prevNormal.z);
            break;
          default:
            // default handling for all vertices in between

            dx = points[j + 1].x - points[j].x;
            dy = points[j + 1].y - points[j].y;
            normal.x = dy * 1.0;
            normal.y = -dx;
            normal.z = dy * 0.0;
            curNormal.copy(normal);
            normal.x += prevNormal.x;
            normal.y += prevNormal.y;
            normal.z += prevNormal.z;
            normal.normalize();
            initNormals.push(normal.x, normal.y, normal.z);
            prevNormal.copy(curNormal);
        }
      }

      // generate vertices, uvs and normals

      for (var i = 0; i <= segments; i++) {
        var phi = phiStart + i * inverseSegments * phiLength;
        var sin = Math.sin(phi);
        var cos = Math.cos(phi);
        for (var _j3 = 0; _j3 <= points.length - 1; _j3++) {
          // vertex

          vertex.x = points[_j3].x * sin;
          vertex.y = points[_j3].y;
          vertex.z = points[_j3].x * cos;
          vertices.push(vertex.x, vertex.y, vertex.z);

          // uv

          uv.x = i / segments;
          uv.y = _j3 / (points.length - 1);
          uvs.push(uv.x, uv.y);

          // normal

          var x = initNormals[3 * _j3 + 0] * sin;
          var y = initNormals[3 * _j3 + 1];
          var z = initNormals[3 * _j3 + 0] * cos;
          normals.push(x, y, z);
        }
      }

      // indices

      for (var _i33 = 0; _i33 < segments; _i33++) {
        for (var _j4 = 0; _j4 < points.length - 1; _j4++) {
          var base = _j4 + _i33 * points.length;
          var a = base;
          var b = base + points.length;
          var c = base + points.length + 1;
          var d = base + 1;

          // faces

          indices.push(a, b, d);
          indices.push(c, d, b);
        }
      }

      // build geometry

      _this57.setIndex(indices);
      _this57.setAttribute('position', new Float32BufferAttribute(vertices, 3));
      _this57.setAttribute('uv', new Float32BufferAttribute(uvs, 2));
      _this57.setAttribute('normal', new Float32BufferAttribute(normals, 3));
      return _this57;
    }
    (0, _inherits2.default)(LatheGeometry, _BufferGeometry2);
    return (0, _createClass2.default)(LatheGeometry, [{
      key: "copy",
      value: function copy(source) {
        _superPropGet(LatheGeometry, "copy", this, 3)([source]);
        this.parameters = Object.assign({}, source.parameters);
        return this;
      }
    }], [{
      key: "fromJSON",
      value: function fromJSON(data) {
        return new LatheGeometry(data.points, data.segments, data.phiStart, data.phiLength);
      }
    }]);
  }(BufferGeometry);
  var CapsuleGeometry = exports.CapsuleGeometry = /*#__PURE__*/function (_LatheGeometry) {
    function CapsuleGeometry() {
      var _this58;
      var radius = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
      var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
      var capSegments = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 4;
      var radialSegments = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 8;
      (0, _classCallCheck2.default)(this, CapsuleGeometry);
      var path = new Path();
      path.absarc(0, -length / 2, radius, Math.PI * 1.5, 0);
      path.absarc(0, length / 2, radius, 0, Math.PI * 0.5);
      _this58 = _callSuper(this, CapsuleGeometry, [path.getPoints(capSegments), radialSegments]);
      _this58.type = 'CapsuleGeometry';
      _this58.parameters = {
        radius: radius,
        length: length,
        capSegments: capSegments,
        radialSegments: radialSegments
      };
      return _this58;
    }
    (0, _inherits2.default)(CapsuleGeometry, _LatheGeometry);
    return (0, _createClass2.default)(CapsuleGeometry, null, [{
      key: "fromJSON",
      value: function fromJSON(data) {
        return new CapsuleGeometry(data.radius, data.length, data.capSegments, data.radialSegments);
      }
    }]);
  }(LatheGeometry);
  var CircleGeometry = exports.CircleGeometry = /*#__PURE__*/function (_BufferGeometry3) {
    function CircleGeometry() {
      var _this59;
      var radius = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
      var segments = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 32;
      var thetaStart = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      var thetaLength = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : Math.PI * 2;
      (0, _classCallCheck2.default)(this, CircleGeometry);
      _this59 = _callSuper(this, CircleGeometry);
      _this59.type = 'CircleGeometry';
      _this59.parameters = {
        radius: radius,
        segments: segments,
        thetaStart: thetaStart,
        thetaLength: thetaLength
      };
      segments = Math.max(3, segments);

      // buffers

      var indices = [];
      var vertices = [];
      var normals = [];
      var uvs = [];

      // helper variables

      var vertex = new Vector3();
      var uv = new Vector2();

      // center point

      vertices.push(0, 0, 0);
      normals.push(0, 0, 1);
      uvs.push(0.5, 0.5);
      for (var s = 0, i = 3; s <= segments; s++, i += 3) {
        var segment = thetaStart + s / segments * thetaLength;

        // vertex

        vertex.x = radius * Math.cos(segment);
        vertex.y = radius * Math.sin(segment);
        vertices.push(vertex.x, vertex.y, vertex.z);

        // normal

        normals.push(0, 0, 1);

        // uvs

        uv.x = (vertices[i] / radius + 1) / 2;
        uv.y = (vertices[i + 1] / radius + 1) / 2;
        uvs.push(uv.x, uv.y);
      }

      // indices

      for (var _i34 = 1; _i34 <= segments; _i34++) {
        indices.push(_i34, _i34 + 1, 0);
      }

      // build geometry

      _this59.setIndex(indices);
      _this59.setAttribute('position', new Float32BufferAttribute(vertices, 3));
      _this59.setAttribute('normal', new Float32BufferAttribute(normals, 3));
      _this59.setAttribute('uv', new Float32BufferAttribute(uvs, 2));
      return _this59;
    }
    (0, _inherits2.default)(CircleGeometry, _BufferGeometry3);
    return (0, _createClass2.default)(CircleGeometry, [{
      key: "copy",
      value: function copy(source) {
        _superPropGet(CircleGeometry, "copy", this, 3)([source]);
        this.parameters = Object.assign({}, source.parameters);
        return this;
      }
    }], [{
      key: "fromJSON",
      value: function fromJSON(data) {
        return new CircleGeometry(data.radius, data.segments, data.thetaStart, data.thetaLength);
      }
    }]);
  }(BufferGeometry);
  var CylinderGeometry = exports.CylinderGeometry = /*#__PURE__*/function (_BufferGeometry4) {
    function CylinderGeometry() {
      var _this60;
      var radiusTop = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
      var radiusBottom = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
      var height = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
      var radialSegments = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 32;
      var heightSegments = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 1;
      var openEnded = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;
      var thetaStart = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 0;
      var thetaLength = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : Math.PI * 2;
      (0, _classCallCheck2.default)(this, CylinderGeometry);
      _this60 = _callSuper(this, CylinderGeometry);
      _this60.type = 'CylinderGeometry';
      _this60.parameters = {
        radiusTop: radiusTop,
        radiusBottom: radiusBottom,
        height: height,
        radialSegments: radialSegments,
        heightSegments: heightSegments,
        openEnded: openEnded,
        thetaStart: thetaStart,
        thetaLength: thetaLength
      };
      var scope = _this60;
      radialSegments = Math.floor(radialSegments);
      heightSegments = Math.floor(heightSegments);

      // buffers

      var indices = [];
      var vertices = [];
      var normals = [];
      var uvs = [];

      // helper variables

      var index = 0;
      var indexArray = [];
      var halfHeight = height / 2;
      var groupStart = 0;

      // generate geometry

      generateTorso();
      if (openEnded === false) {
        if (radiusTop > 0) generateCap(true);
        if (radiusBottom > 0) generateCap(false);
      }

      // build geometry

      _this60.setIndex(indices);
      _this60.setAttribute('position', new Float32BufferAttribute(vertices, 3));
      _this60.setAttribute('normal', new Float32BufferAttribute(normals, 3));
      _this60.setAttribute('uv', new Float32BufferAttribute(uvs, 2));
      function generateTorso() {
        var normal = new Vector3();
        var vertex = new Vector3();
        var groupCount = 0;

        // this will be used to calculate the normal
        var slope = (radiusBottom - radiusTop) / height;

        // generate vertices, normals and uvs

        for (var y = 0; y <= heightSegments; y++) {
          var indexRow = [];
          var v = y / heightSegments;

          // calculate the radius of the current row

          var radius = v * (radiusBottom - radiusTop) + radiusTop;
          for (var x = 0; x <= radialSegments; x++) {
            var u = x / radialSegments;
            var theta = u * thetaLength + thetaStart;
            var sinTheta = Math.sin(theta);
            var cosTheta = Math.cos(theta);

            // vertex

            vertex.x = radius * sinTheta;
            vertex.y = -v * height + halfHeight;
            vertex.z = radius * cosTheta;
            vertices.push(vertex.x, vertex.y, vertex.z);

            // normal

            normal.set(sinTheta, slope, cosTheta).normalize();
            normals.push(normal.x, normal.y, normal.z);

            // uv

            uvs.push(u, 1 - v);

            // save index of vertex in respective row

            indexRow.push(index++);
          }

          // now save vertices of the row in our index array

          indexArray.push(indexRow);
        }

        // generate indices

        for (var _x2 = 0; _x2 < radialSegments; _x2++) {
          for (var _y2 = 0; _y2 < heightSegments; _y2++) {
            // we use the index array to access the correct indices

            var a = indexArray[_y2][_x2];
            var b = indexArray[_y2 + 1][_x2];
            var c = indexArray[_y2 + 1][_x2 + 1];
            var d = indexArray[_y2][_x2 + 1];

            // faces

            if (radiusTop > 0 || _y2 !== 0) {
              indices.push(a, b, d);
              groupCount += 3;
            }
            if (radiusBottom > 0 || _y2 !== heightSegments - 1) {
              indices.push(b, c, d);
              groupCount += 3;
            }
          }
        }

        // add a group to the geometry. this will ensure multi material support

        scope.addGroup(groupStart, groupCount, 0);

        // calculate new start value for groups

        groupStart += groupCount;
      }
      function generateCap(top) {
        // save the index of the first center vertex
        var centerIndexStart = index;
        var uv = new Vector2();
        var vertex = new Vector3();
        var groupCount = 0;
        var radius = top === true ? radiusTop : radiusBottom;
        var sign = top === true ? 1 : -1;

        // first we generate the center vertex data of the cap.
        // because the geometry needs one set of uvs per face,
        // we must generate a center vertex per face/segment

        for (var x = 1; x <= radialSegments; x++) {
          // vertex

          vertices.push(0, halfHeight * sign, 0);

          // normal

          normals.push(0, sign, 0);

          // uv

          uvs.push(0.5, 0.5);

          // increase index

          index++;
        }

        // save the index of the last center vertex
        var centerIndexEnd = index;

        // now we generate the surrounding vertices, normals and uvs

        for (var _x3 = 0; _x3 <= radialSegments; _x3++) {
          var u = _x3 / radialSegments;
          var theta = u * thetaLength + thetaStart;
          var cosTheta = Math.cos(theta);
          var sinTheta = Math.sin(theta);

          // vertex

          vertex.x = radius * sinTheta;
          vertex.y = halfHeight * sign;
          vertex.z = radius * cosTheta;
          vertices.push(vertex.x, vertex.y, vertex.z);

          // normal

          normals.push(0, sign, 0);

          // uv

          uv.x = cosTheta * 0.5 + 0.5;
          uv.y = sinTheta * 0.5 * sign + 0.5;
          uvs.push(uv.x, uv.y);

          // increase index

          index++;
        }

        // generate indices

        for (var _x4 = 0; _x4 < radialSegments; _x4++) {
          var c = centerIndexStart + _x4;
          var i = centerIndexEnd + _x4;
          if (top === true) {
            // face top

            indices.push(i, i + 1, c);
          } else {
            // face bottom

            indices.push(i + 1, i, c);
          }
          groupCount += 3;
        }

        // add a group to the geometry. this will ensure multi material support

        scope.addGroup(groupStart, groupCount, top === true ? 1 : 2);

        // calculate new start value for groups

        groupStart += groupCount;
      }
      return _this60;
    }
    (0, _inherits2.default)(CylinderGeometry, _BufferGeometry4);
    return (0, _createClass2.default)(CylinderGeometry, [{
      key: "copy",
      value: function copy(source) {
        _superPropGet(CylinderGeometry, "copy", this, 3)([source]);
        this.parameters = Object.assign({}, source.parameters);
        return this;
      }
    }], [{
      key: "fromJSON",
      value: function fromJSON(data) {
        return new CylinderGeometry(data.radiusTop, data.radiusBottom, data.height, data.radialSegments, data.heightSegments, data.openEnded, data.thetaStart, data.thetaLength);
      }
    }]);
  }(BufferGeometry);
  var ConeGeometry = exports.ConeGeometry = /*#__PURE__*/function (_CylinderGeometry) {
    function ConeGeometry() {
      var _this61;
      var radius = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
      var height = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
      var radialSegments = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 32;
      var heightSegments = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;
      var openEnded = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
      var thetaStart = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;
      var thetaLength = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : Math.PI * 2;
      (0, _classCallCheck2.default)(this, ConeGeometry);
      _this61 = _callSuper(this, ConeGeometry, [0, radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength]);
      _this61.type = 'ConeGeometry';
      _this61.parameters = {
        radius: radius,
        height: height,
        radialSegments: radialSegments,
        heightSegments: heightSegments,
        openEnded: openEnded,
        thetaStart: thetaStart,
        thetaLength: thetaLength
      };
      return _this61;
    }
    (0, _inherits2.default)(ConeGeometry, _CylinderGeometry);
    return (0, _createClass2.default)(ConeGeometry, null, [{
      key: "fromJSON",
      value: function fromJSON(data) {
        return new ConeGeometry(data.radius, data.height, data.radialSegments, data.heightSegments, data.openEnded, data.thetaStart, data.thetaLength);
      }
    }]);
  }(CylinderGeometry);
  var PolyhedronGeometry = exports.PolyhedronGeometry = /*#__PURE__*/function (_BufferGeometry5) {
    function PolyhedronGeometry() {
      var _this62;
      var vertices = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      var indices = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
      var radius = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
      var detail = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
      (0, _classCallCheck2.default)(this, PolyhedronGeometry);
      _this62 = _callSuper(this, PolyhedronGeometry);
      _this62.type = 'PolyhedronGeometry';
      _this62.parameters = {
        vertices: vertices,
        indices: indices,
        radius: radius,
        detail: detail
      };

      // default buffer data

      var vertexBuffer = [];
      var uvBuffer = [];

      // the subdivision creates the vertex buffer data

      subdivide(detail);

      // all vertices should lie on a conceptual sphere with a given radius

      applyRadius(radius);

      // finally, create the uv data

      generateUVs();

      // build non-indexed geometry

      _this62.setAttribute('position', new Float32BufferAttribute(vertexBuffer, 3));
      _this62.setAttribute('normal', new Float32BufferAttribute(vertexBuffer.slice(), 3));
      _this62.setAttribute('uv', new Float32BufferAttribute(uvBuffer, 2));
      if (detail === 0) {
        _this62.computeVertexNormals(); // flat normals
      } else {
        _this62.normalizeNormals(); // smooth normals
      }

      // helper functions

      function subdivide(detail) {
        var a = new Vector3();
        var b = new Vector3();
        var c = new Vector3();

        // iterate over all faces and apply a subdivision with the given detail value

        for (var i = 0; i < indices.length; i += 3) {
          // get the vertices of the face

          getVertexByIndex(indices[i + 0], a);
          getVertexByIndex(indices[i + 1], b);
          getVertexByIndex(indices[i + 2], c);

          // perform subdivision

          subdivideFace(a, b, c, detail);
        }
      }
      function subdivideFace(a, b, c, detail) {
        var cols = detail + 1;

        // we use this multidimensional array as a data structure for creating the subdivision

        var v = [];

        // construct all of the vertices for this subdivision

        for (var i = 0; i <= cols; i++) {
          v[i] = [];
          var aj = a.clone().lerp(c, i / cols);
          var bj = b.clone().lerp(c, i / cols);
          var rows = cols - i;
          for (var j = 0; j <= rows; j++) {
            if (j === 0 && i === cols) {
              v[i][j] = aj;
            } else {
              v[i][j] = aj.clone().lerp(bj, j / rows);
            }
          }
        }

        // construct all of the faces

        for (var _i35 = 0; _i35 < cols; _i35++) {
          for (var _j5 = 0; _j5 < 2 * (cols - _i35) - 1; _j5++) {
            var k = Math.floor(_j5 / 2);
            if (_j5 % 2 === 0) {
              pushVertex(v[_i35][k + 1]);
              pushVertex(v[_i35 + 1][k]);
              pushVertex(v[_i35][k]);
            } else {
              pushVertex(v[_i35][k + 1]);
              pushVertex(v[_i35 + 1][k + 1]);
              pushVertex(v[_i35 + 1][k]);
            }
          }
        }
      }
      function applyRadius(radius) {
        var vertex = new Vector3();

        // iterate over the entire buffer and apply the radius to each vertex

        for (var i = 0; i < vertexBuffer.length; i += 3) {
          vertex.x = vertexBuffer[i + 0];
          vertex.y = vertexBuffer[i + 1];
          vertex.z = vertexBuffer[i + 2];
          vertex.normalize().multiplyScalar(radius);
          vertexBuffer[i + 0] = vertex.x;
          vertexBuffer[i + 1] = vertex.y;
          vertexBuffer[i + 2] = vertex.z;
        }
      }
      function generateUVs() {
        var vertex = new Vector3();
        for (var i = 0; i < vertexBuffer.length; i += 3) {
          vertex.x = vertexBuffer[i + 0];
          vertex.y = vertexBuffer[i + 1];
          vertex.z = vertexBuffer[i + 2];
          var u = azimuth(vertex) / 2 / Math.PI + 0.5;
          var v = inclination(vertex) / Math.PI + 0.5;
          uvBuffer.push(u, 1 - v);
        }
        correctUVs();
        correctSeam();
      }
      function correctSeam() {
        // handle case when face straddles the seam, see #3269

        for (var i = 0; i < uvBuffer.length; i += 6) {
          // uv data of a single face

          var x0 = uvBuffer[i + 0];
          var x1 = uvBuffer[i + 2];
          var x2 = uvBuffer[i + 4];
          var max = Math.max(x0, x1, x2);
          var min = Math.min(x0, x1, x2);

          // 0.9 is somewhat arbitrary

          if (max > 0.9 && min < 0.1) {
            if (x0 < 0.2) uvBuffer[i + 0] += 1;
            if (x1 < 0.2) uvBuffer[i + 2] += 1;
            if (x2 < 0.2) uvBuffer[i + 4] += 1;
          }
        }
      }
      function pushVertex(vertex) {
        vertexBuffer.push(vertex.x, vertex.y, vertex.z);
      }
      function getVertexByIndex(index, vertex) {
        var stride = index * 3;
        vertex.x = vertices[stride + 0];
        vertex.y = vertices[stride + 1];
        vertex.z = vertices[stride + 2];
      }
      function correctUVs() {
        var a = new Vector3();
        var b = new Vector3();
        var c = new Vector3();
        var centroid = new Vector3();
        var uvA = new Vector2();
        var uvB = new Vector2();
        var uvC = new Vector2();
        for (var i = 0, j = 0; i < vertexBuffer.length; i += 9, j += 6) {
          a.set(vertexBuffer[i + 0], vertexBuffer[i + 1], vertexBuffer[i + 2]);
          b.set(vertexBuffer[i + 3], vertexBuffer[i + 4], vertexBuffer[i + 5]);
          c.set(vertexBuffer[i + 6], vertexBuffer[i + 7], vertexBuffer[i + 8]);
          uvA.set(uvBuffer[j + 0], uvBuffer[j + 1]);
          uvB.set(uvBuffer[j + 2], uvBuffer[j + 3]);
          uvC.set(uvBuffer[j + 4], uvBuffer[j + 5]);
          centroid.copy(a).add(b).add(c).divideScalar(3);
          var azi = azimuth(centroid);
          correctUV(uvA, j + 0, a, azi);
          correctUV(uvB, j + 2, b, azi);
          correctUV(uvC, j + 4, c, azi);
        }
      }
      function correctUV(uv, stride, vector, azimuth) {
        if (azimuth < 0 && uv.x === 1) {
          uvBuffer[stride] = uv.x - 1;
        }
        if (vector.x === 0 && vector.z === 0) {
          uvBuffer[stride] = azimuth / 2 / Math.PI + 0.5;
        }
      }

      // Angle around the Y axis, counter-clockwise when looking from above.

      function azimuth(vector) {
        return Math.atan2(vector.z, -vector.x);
      }

      // Angle above the XZ plane.

      function inclination(vector) {
        return Math.atan2(-vector.y, Math.sqrt(vector.x * vector.x + vector.z * vector.z));
      }
      return _this62;
    }
    (0, _inherits2.default)(PolyhedronGeometry, _BufferGeometry5);
    return (0, _createClass2.default)(PolyhedronGeometry, [{
      key: "copy",
      value: function copy(source) {
        _superPropGet(PolyhedronGeometry, "copy", this, 3)([source]);
        this.parameters = Object.assign({}, source.parameters);
        return this;
      }
    }], [{
      key: "fromJSON",
      value: function fromJSON(data) {
        return new PolyhedronGeometry(data.vertices, data.indices, data.radius, data.details);
      }
    }]);
  }(BufferGeometry);
  var DodecahedronGeometry = exports.DodecahedronGeometry = /*#__PURE__*/function (_PolyhedronGeometry) {
    function DodecahedronGeometry() {
      var _this63;
      var radius = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
      var detail = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      (0, _classCallCheck2.default)(this, DodecahedronGeometry);
      var t = (1 + Math.sqrt(5)) / 2;
      var r = 1 / t;
      var vertices = [
      // (1, 1, 1)
      -1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1,
      // (0, 1/, )
      0, -r, -t, 0, -r, t, 0, r, -t, 0, r, t,
      // (1/, , 0)
      -r, -t, 0, -r, t, 0, r, -t, 0, r, t, 0,
      // (, 0, 1/)
      -t, 0, -r, t, 0, -r, -t, 0, r, t, 0, r];
      var indices = [3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9];
      _this63 = _callSuper(this, DodecahedronGeometry, [vertices, indices, radius, detail]);
      _this63.type = 'DodecahedronGeometry';
      _this63.parameters = {
        radius: radius,
        detail: detail
      };
      return _this63;
    }
    (0, _inherits2.default)(DodecahedronGeometry, _PolyhedronGeometry);
    return (0, _createClass2.default)(DodecahedronGeometry, null, [{
      key: "fromJSON",
      value: function fromJSON(data) {
        return new DodecahedronGeometry(data.radius, data.detail);
      }
    }]);
  }(PolyhedronGeometry);
  var _v0 = /*@__PURE__*/new Vector3();
  var _v1$1 = /*@__PURE__*/new Vector3();
  var _normal = /*@__PURE__*/new Vector3();
  var _triangle = /*@__PURE__*/new Triangle();
  var EdgesGeometry = exports.EdgesGeometry = /*#__PURE__*/function (_BufferGeometry6) {
    function EdgesGeometry() {
      var _this64;
      var geometry = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      var thresholdAngle = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
      (0, _classCallCheck2.default)(this, EdgesGeometry);
      _this64 = _callSuper(this, EdgesGeometry);
      _this64.type = 'EdgesGeometry';
      _this64.parameters = {
        geometry: geometry,
        thresholdAngle: thresholdAngle
      };
      if (geometry !== null) {
        var precisionPoints = 4;
        var precision = Math.pow(10, precisionPoints);
        var thresholdDot = Math.cos(DEG2RAD * thresholdAngle);
        var indexAttr = geometry.getIndex();
        var positionAttr = geometry.getAttribute('position');
        var indexCount = indexAttr ? indexAttr.count : positionAttr.count;
        var indexArr = [0, 0, 0];
        var vertKeys = ['a', 'b', 'c'];
        var hashes = new Array(3);
        var edgeData = {};
        var vertices = [];
        for (var i = 0; i < indexCount; i += 3) {
          if (indexAttr) {
            indexArr[0] = indexAttr.getX(i);
            indexArr[1] = indexAttr.getX(i + 1);
            indexArr[2] = indexAttr.getX(i + 2);
          } else {
            indexArr[0] = i;
            indexArr[1] = i + 1;
            indexArr[2] = i + 2;
          }
          var a = _triangle.a,
            b = _triangle.b,
            c = _triangle.c;
          a.fromBufferAttribute(positionAttr, indexArr[0]);
          b.fromBufferAttribute(positionAttr, indexArr[1]);
          c.fromBufferAttribute(positionAttr, indexArr[2]);
          _triangle.getNormal(_normal);

          // create hashes for the edge from the vertices
          hashes[0] = `${Math.round(a.x * precision)},${Math.round(a.y * precision)},${Math.round(a.z * precision)}`;
          hashes[1] = `${Math.round(b.x * precision)},${Math.round(b.y * precision)},${Math.round(b.z * precision)}`;
          hashes[2] = `${Math.round(c.x * precision)},${Math.round(c.y * precision)},${Math.round(c.z * precision)}`;

          // skip degenerate triangles
          if (hashes[0] === hashes[1] || hashes[1] === hashes[2] || hashes[2] === hashes[0]) {
            continue;
          }

          // iterate over every edge
          for (var j = 0; j < 3; j++) {
            // get the first and next vertex making up the edge
            var jNext = (j + 1) % 3;
            var vecHash0 = hashes[j];
            var vecHash1 = hashes[jNext];
            var v0 = _triangle[vertKeys[j]];
            var v1 = _triangle[vertKeys[jNext]];
            var hash = `${vecHash0}_${vecHash1}`;
            var reverseHash = `${vecHash1}_${vecHash0}`;
            if (reverseHash in edgeData && edgeData[reverseHash]) {
              // if we found a sibling edge add it into the vertex array if
              // it meets the angle threshold and delete the edge from the map.
              if (_normal.dot(edgeData[reverseHash].normal) <= thresholdDot) {
                vertices.push(v0.x, v0.y, v0.z);
                vertices.push(v1.x, v1.y, v1.z);
              }
              edgeData[reverseHash] = null;
            } else if (!(hash in edgeData)) {
              // if we've already got an edge here then skip adding a new one
              edgeData[hash] = {
                index0: indexArr[j],
                index1: indexArr[jNext],
                normal: _normal.clone()
              };
            }
          }
        }

        // iterate over all remaining, unmatched edges and add them to the vertex array
        for (var key in edgeData) {
          if (edgeData[key]) {
            var _edgeData$key = edgeData[key],
              index0 = _edgeData$key.index0,
              index1 = _edgeData$key.index1;
            _v0.fromBufferAttribute(positionAttr, index0);
            _v1$1.fromBufferAttribute(positionAttr, index1);
            vertices.push(_v0.x, _v0.y, _v0.z);
            vertices.push(_v1$1.x, _v1$1.y, _v1$1.z);
          }
        }
        _this64.setAttribute('position', new Float32BufferAttribute(vertices, 3));
      }
      return _this64;
    }
    (0, _inherits2.default)(EdgesGeometry, _BufferGeometry6);
    return (0, _createClass2.default)(EdgesGeometry, [{
      key: "copy",
      value: function copy(source) {
        _superPropGet(EdgesGeometry, "copy", this, 3)([source]);
        this.parameters = Object.assign({}, source.parameters);
        return this;
      }
    }]);
  }(BufferGeometry);
  var Shape = exports.Shape = /*#__PURE__*/function (_Path) {
    function Shape(points) {
      var _this65;
      (0, _classCallCheck2.default)(this, Shape);
      _this65 = _callSuper(this, Shape, [points]);
      _this65.uuid = generateUUID();
      _this65.type = 'Shape';
      _this65.holes = [];
      return _this65;
    }
    (0, _inherits2.default)(Shape, _Path);
    return (0, _createClass2.default)(Shape, [{
      key: "getPointsHoles",
      value: function getPointsHoles(divisions) {
        var holesPts = [];
        for (var i = 0, l = this.holes.length; i < l; i++) {
          holesPts[i] = this.holes[i].getPoints(divisions);
        }
        return holesPts;
      }

      // get points of shape and holes (keypoints based on segments parameter)
    }, {
      key: "extractPoints",
      value: function extractPoints(divisions) {
        return {
          shape: this.getPoints(divisions),
          holes: this.getPointsHoles(divisions)
        };
      }
    }, {
      key: "copy",
      value: function copy(source) {
        _superPropGet(Shape, "copy", this, 3)([source]);
        this.holes = [];
        for (var i = 0, l = source.holes.length; i < l; i++) {
          var hole = source.holes[i];
          this.holes.push(hole.clone());
        }
        return this;
      }
    }, {
      key: "toJSON",
      value: function toJSON() {
        var data = _superPropGet(Shape, "toJSON", this, 3)([]);
        data.uuid = this.uuid;
        data.holes = [];
        for (var i = 0, l = this.holes.length; i < l; i++) {
          var hole = this.holes[i];
          data.holes.push(hole.toJSON());
        }
        return data;
      }
    }, {
      key: "fromJSON",
      value: function fromJSON(json) {
        _superPropGet(Shape, "fromJSON", this, 3)([json]);
        this.uuid = json.uuid;
        this.holes = [];
        for (var i = 0, l = json.holes.length; i < l; i++) {
          var hole = json.holes[i];
          this.holes.push(new Path().fromJSON(hole));
        }
        return this;
      }
    }]);
  }(Path);
  /**
   * Port from https://github.com/mapbox/earcut (v2.2.4)
   */
  var Earcut = {
    triangulate: function triangulate(data, holeIndices) {
      var dim = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 2;
      var hasHoles = holeIndices && holeIndices.length;
      var outerLen = hasHoles ? holeIndices[0] * dim : data.length;
      var outerNode = linkedList(data, 0, outerLen, dim, true);
      var triangles = [];
      if (!outerNode || outerNode.next === outerNode.prev) return triangles;
      var minX, minY, maxX, maxY, x, y, invSize;
      if (hasHoles) outerNode = eliminateHoles(data, holeIndices, outerNode, dim);

      // if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox
      if (data.length > 80 * dim) {
        minX = maxX = data[0];
        minY = maxY = data[1];
        for (var i = dim; i < outerLen; i += dim) {
          x = data[i];
          y = data[i + 1];
          if (x < minX) minX = x;
          if (y < minY) minY = y;
          if (x > maxX) maxX = x;
          if (y > maxY) maxY = y;
        }

        // minX, minY and invSize are later used to transform coords into integers for z-order calculation
        invSize = Math.max(maxX - minX, maxY - minY);
        invSize = invSize !== 0 ? 32767 / invSize : 0;
      }
      earcutLinked(outerNode, triangles, dim, minX, minY, invSize, 0);
      return triangles;
    }
  };

  // create a circular doubly linked list from polygon points in the specified winding order
  function linkedList(data, start, end, dim, clockwise) {
    var i, last;
    if (clockwise === signedArea(data, start, end, dim) > 0) {
      for (i = start; i < end; i += dim) last = insertNode(i, data[i], data[i + 1], last);
    } else {
      for (i = end - dim; i >= start; i -= dim) last = insertNode(i, data[i], data[i + 1], last);
    }
    if (last && equals(last, last.next)) {
      removeNode(last);
      last = last.next;
    }
    return last;
  }

  // eliminate colinear or duplicate points
  function filterPoints(start, end) {
    if (!start) return start;
    if (!end) end = start;
    var p = start,
      again;
    do {
      again = false;
      if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {
        removeNode(p);
        p = end = p.prev;
        if (p === p.next) break;
        again = true;
      } else {
        p = p.next;
      }
    } while (again || p !== end);
    return end;
  }

  // main ear slicing loop which triangulates a polygon (given as a linked list)
  function earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {
    if (!ear) return;

    // interlink polygon nodes in z-order
    if (!pass && invSize) indexCurve(ear, minX, minY, invSize);
    var stop = ear,
      prev,
      next;

    // iterate through ears, slicing them one by one
    while (ear.prev !== ear.next) {
      prev = ear.prev;
      next = ear.next;
      if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {
        // cut off the triangle
        triangles.push(prev.i / dim | 0);
        triangles.push(ear.i / dim | 0);
        triangles.push(next.i / dim | 0);
        removeNode(ear);

        // skipping the next vertex leads to less sliver triangles
        ear = next.next;
        stop = next.next;
        continue;
      }
      ear = next;

      // if we looped through the whole remaining polygon and can't find any more ears
      if (ear === stop) {
        // try filtering points and slicing again
        if (!pass) {
          earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);

          // if this didn't work, try curing all small self-intersections locally
        } else if (pass === 1) {
          ear = cureLocalIntersections(filterPoints(ear), triangles, dim);
          earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);

          // as a last resort, try splitting the remaining polygon into two
        } else if (pass === 2) {
          splitEarcut(ear, triangles, dim, minX, minY, invSize);
        }
        break;
      }
    }
  }

  // check whether a polygon node forms a valid ear with adjacent nodes
  function isEar(ear) {
    var a = ear.prev,
      b = ear,
      c = ear.next;
    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear

    // now make sure we don't have other points inside the potential ear
    var ax = a.x,
      bx = b.x,
      cx = c.x,
      ay = a.y,
      by = b.y,
      cy = c.y;

    // triangle bbox; min & max are calculated like this for speed
    var x0 = ax < bx ? ax < cx ? ax : cx : bx < cx ? bx : cx,
      y0 = ay < by ? ay < cy ? ay : cy : by < cy ? by : cy,
      x1 = ax > bx ? ax > cx ? ax : cx : bx > cx ? bx : cx,
      y1 = ay > by ? ay > cy ? ay : cy : by > cy ? by : cy;
    var p = c.next;
    while (p !== a) {
      if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
      p = p.next;
    }
    return true;
  }
  function isEarHashed(ear, minX, minY, invSize) {
    var a = ear.prev,
      b = ear,
      c = ear.next;
    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear

    var ax = a.x,
      bx = b.x,
      cx = c.x,
      ay = a.y,
      by = b.y,
      cy = c.y;

    // triangle bbox; min & max are calculated like this for speed
    var x0 = ax < bx ? ax < cx ? ax : cx : bx < cx ? bx : cx,
      y0 = ay < by ? ay < cy ? ay : cy : by < cy ? by : cy,
      x1 = ax > bx ? ax > cx ? ax : cx : bx > cx ? bx : cx,
      y1 = ay > by ? ay > cy ? ay : cy : by > cy ? by : cy;

    // z-order range for the current triangle bbox;
    var minZ = zOrder(x0, y0, minX, minY, invSize),
      maxZ = zOrder(x1, y1, minX, minY, invSize);
    var p = ear.prevZ,
      n = ear.nextZ;

    // look for points inside the triangle in both directions
    while (p && p.z >= minZ && n && n.z <= maxZ) {
      if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c && pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
      p = p.prevZ;
      if (n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c && pointInTriangle(ax, ay, bx, by, cx, cy, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;
      n = n.nextZ;
    }

    // look for remaining points in decreasing z-order
    while (p && p.z >= minZ) {
      if (p.x >= x0 && p.x <= x1 && p.y >= y0 && p.y <= y1 && p !== a && p !== c && pointInTriangle(ax, ay, bx, by, cx, cy, p.x, p.y) && area(p.prev, p, p.next) >= 0) return false;
      p = p.prevZ;
    }

    // look for remaining points in increasing z-order
    while (n && n.z <= maxZ) {
      if (n.x >= x0 && n.x <= x1 && n.y >= y0 && n.y <= y1 && n !== a && n !== c && pointInTriangle(ax, ay, bx, by, cx, cy, n.x, n.y) && area(n.prev, n, n.next) >= 0) return false;
      n = n.nextZ;
    }
    return true;
  }

  // go through all polygon nodes and cure small local self-intersections
  function cureLocalIntersections(start, triangles, dim) {
    var p = start;
    do {
      var a = p.prev,
        b = p.next.next;
      if (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {
        triangles.push(a.i / dim | 0);
        triangles.push(p.i / dim | 0);
        triangles.push(b.i / dim | 0);

        // remove two nodes involved
        removeNode(p);
        removeNode(p.next);
        p = start = b;
      }
      p = p.next;
    } while (p !== start);
    return filterPoints(p);
  }

  // try splitting polygon into two and triangulate them independently
  function splitEarcut(start, triangles, dim, minX, minY, invSize) {
    // look for a valid diagonal that divides the polygon into two
    var a = start;
    do {
      var b = a.next.next;
      while (b !== a.prev) {
        if (a.i !== b.i && isValidDiagonal(a, b)) {
          // split the polygon in two by the diagonal
          var c = splitPolygon(a, b);

          // filter colinear points around the cuts
          a = filterPoints(a, a.next);
          c = filterPoints(c, c.next);

          // run earcut on each half
          earcutLinked(a, triangles, dim, minX, minY, invSize, 0);
          earcutLinked(c, triangles, dim, minX, minY, invSize, 0);
          return;
        }
        b = b.next;
      }
      a = a.next;
    } while (a !== start);
  }

  // link every hole into the outer loop, producing a single-ring polygon without holes
  function eliminateHoles(data, holeIndices, outerNode, dim) {
    var queue = [];
    var i, len, start, end, list;
    for (i = 0, len = holeIndices.length; i < len; i++) {
      start = holeIndices[i] * dim;
      end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
      list = linkedList(data, start, end, dim, false);
      if (list === list.next) list.steiner = true;
      queue.push(getLeftmost(list));
    }
    queue.sort(compareX);

    // process holes from left to right
    for (i = 0; i < queue.length; i++) {
      outerNode = eliminateHole(queue[i], outerNode);
    }
    return outerNode;
  }
  function compareX(a, b) {
    return a.x - b.x;
  }

  // find a bridge between vertices that connects hole with an outer ring and link it
  function eliminateHole(hole, outerNode) {
    var bridge = findHoleBridge(hole, outerNode);
    if (!bridge) {
      return outerNode;
    }
    var bridgeReverse = splitPolygon(bridge, hole);

    // filter collinear points around the cuts
    filterPoints(bridgeReverse, bridgeReverse.next);
    return filterPoints(bridge, bridge.next);
  }

  // David Eberly's algorithm for finding a bridge between hole and outer polygon
  function findHoleBridge(hole, outerNode) {
    var p = outerNode,
      qx = -Infinity,
      m;
    var hx = hole.x,
      hy = hole.y;

    // find a segment intersected by a ray from the hole's leftmost point to the left;
    // segment's endpoint with lesser x will be potential connection point
    do {
      if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {
        var x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);
        if (x <= hx && x > qx) {
          qx = x;
          m = p.x < p.next.x ? p : p.next;
          if (x === hx) return m; // hole touches outer segment; pick leftmost endpoint
        }
      }
      p = p.next;
    } while (p !== outerNode);
    if (!m) return null;

    // look for points inside the triangle of hole point, segment intersection and endpoint;
    // if there are no points found, we have a valid connection;
    // otherwise choose the point of the minimum angle with the ray as connection point

    var stop = m,
      mx = m.x,
      my = m.y;
    var tanMin = Infinity,
      tan;
    p = m;
    do {
      if (hx >= p.x && p.x >= mx && hx !== p.x && pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {
        tan = Math.abs(hy - p.y) / (hx - p.x); // tangential

        if (locallyInside(p, hole) && (tan < tanMin || tan === tanMin && (p.x > m.x || p.x === m.x && sectorContainsSector(m, p)))) {
          m = p;
          tanMin = tan;
        }
      }
      p = p.next;
    } while (p !== stop);
    return m;
  }

  // whether sector in vertex m contains sector in vertex p in the same coordinates
  function sectorContainsSector(m, p) {
    return area(m.prev, m, p.prev) < 0 && area(p.next, m, m.next) < 0;
  }

  // interlink polygon nodes in z-order
  function indexCurve(start, minX, minY, invSize) {
    var p = start;
    do {
      if (p.z === 0) p.z = zOrder(p.x, p.y, minX, minY, invSize);
      p.prevZ = p.prev;
      p.nextZ = p.next;
      p = p.next;
    } while (p !== start);
    p.prevZ.nextZ = null;
    p.prevZ = null;
    sortLinked(p);
  }

  // Simon Tatham's linked list merge sort algorithm
  // http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html
  function sortLinked(list) {
    var i,
      p,
      q,
      e,
      tail,
      numMerges,
      pSize,
      qSize,
      inSize = 1;
    do {
      p = list;
      list = null;
      tail = null;
      numMerges = 0;
      while (p) {
        numMerges++;
        q = p;
        pSize = 0;
        for (i = 0; i < inSize; i++) {
          pSize++;
          q = q.nextZ;
          if (!q) break;
        }
        qSize = inSize;
        while (pSize > 0 || qSize > 0 && q) {
          if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {
            e = p;
            p = p.nextZ;
            pSize--;
          } else {
            e = q;
            q = q.nextZ;
            qSize--;
          }
          if (tail) tail.nextZ = e;else list = e;
          e.prevZ = tail;
          tail = e;
        }
        p = q;
      }
      tail.nextZ = null;
      inSize *= 2;
    } while (numMerges > 1);
    return list;
  }

  // z-order of a point given coords and inverse of the longer side of data bbox
  function zOrder(x, y, minX, minY, invSize) {
    // coords are transformed into non-negative 15-bit integer range
    x = (x - minX) * invSize | 0;
    y = (y - minY) * invSize | 0;
    x = (x | x << 8) & 0x00FF00FF;
    x = (x | x << 4) & 0x0F0F0F0F;
    x = (x | x << 2) & 0x33333333;
    x = (x | x << 1) & 0x55555555;
    y = (y | y << 8) & 0x00FF00FF;
    y = (y | y << 4) & 0x0F0F0F0F;
    y = (y | y << 2) & 0x33333333;
    y = (y | y << 1) & 0x55555555;
    return x | y << 1;
  }

  // find the leftmost node of a polygon ring
  function getLeftmost(start) {
    var p = start,
      leftmost = start;
    do {
      if (p.x < leftmost.x || p.x === leftmost.x && p.y < leftmost.y) leftmost = p;
      p = p.next;
    } while (p !== start);
    return leftmost;
  }

  // check if a point lies within a convex triangle
  function pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {
    return (cx - px) * (ay - py) >= (ax - px) * (cy - py) && (ax - px) * (by - py) >= (bx - px) * (ay - py) && (bx - px) * (cy - py) >= (cx - px) * (by - py);
  }

  // check if a diagonal between two polygon nodes is valid (lies in polygon interior)
  function isValidDiagonal(a, b) {
    return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) && (
    // doesn't intersect other edges
    locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b) && (
    // locally visible
    area(a.prev, a, b.prev) || area(a, b.prev, b)) ||
    // does not create opposite-facing sectors
    equals(a, b) && area(a.prev, a, a.next) > 0 && area(b.prev, b, b.next) > 0); // special zero-length case
  }

  // signed area of a triangle
  function area(p, q, r) {
    return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
  }

  // check if two points are equal
  function equals(p1, p2) {
    return p1.x === p2.x && p1.y === p2.y;
  }

  // check if two segments intersect
  function intersects(p1, q1, p2, q2) {
    var o1 = sign(area(p1, q1, p2));
    var o2 = sign(area(p1, q1, q2));
    var o3 = sign(area(p2, q2, p1));
    var o4 = sign(area(p2, q2, q1));
    if (o1 !== o2 && o3 !== o4) return true; // general case

    if (o1 === 0 && onSegment(p1, p2, q1)) return true; // p1, q1 and p2 are collinear and p2 lies on p1q1
    if (o2 === 0 && onSegment(p1, q2, q1)) return true; // p1, q1 and q2 are collinear and q2 lies on p1q1
    if (o3 === 0 && onSegment(p2, p1, q2)) return true; // p2, q2 and p1 are collinear and p1 lies on p2q2
    if (o4 === 0 && onSegment(p2, q1, q2)) return true; // p2, q2 and q1 are collinear and q1 lies on p2q2

    return false;
  }

  // for collinear points p, q, r, check if point q lies on segment pr
  function onSegment(p, q, r) {
    return q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) && q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y);
  }
  function sign(num) {
    return num > 0 ? 1 : num < 0 ? -1 : 0;
  }

  // check if a polygon diagonal intersects any polygon segments
  function intersectsPolygon(a, b) {
    var p = a;
    do {
      if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i && intersects(p, p.next, a, b)) return true;
      p = p.next;
    } while (p !== a);
    return false;
  }

  // check if a polygon diagonal is locally inside the polygon
  function locallyInside(a, b) {
    return area(a.prev, a, a.next) < 0 ? area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 : area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;
  }

  // check if the middle point of a polygon diagonal is inside the polygon
  function middleInside(a, b) {
    var p = a,
      inside = false;
    var px = (a.x + b.x) / 2,
      py = (a.y + b.y) / 2;
    do {
      if (p.y > py !== p.next.y > py && p.next.y !== p.y && px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x) inside = !inside;
      p = p.next;
    } while (p !== a);
    return inside;
  }

  // link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;
  // if one belongs to the outer ring and another to a hole, it merges it into a single ring
  function splitPolygon(a, b) {
    var a2 = new Node(a.i, a.x, a.y),
      b2 = new Node(b.i, b.x, b.y),
      an = a.next,
      bp = b.prev;
    a.next = b;
    b.prev = a;
    a2.next = an;
    an.prev = a2;
    b2.next = a2;
    a2.prev = b2;
    bp.next = b2;
    b2.prev = bp;
    return b2;
  }

  // create a node and optionally link it with previous one (in a circular doubly linked list)
  function insertNode(i, x, y, last) {
    var p = new Node(i, x, y);
    if (!last) {
      p.prev = p;
      p.next = p;
    } else {
      p.next = last.next;
      p.prev = last;
      last.next.prev = p;
      last.next = p;
    }
    return p;
  }
  function removeNode(p) {
    p.next.prev = p.prev;
    p.prev.next = p.next;
    if (p.prevZ) p.prevZ.nextZ = p.nextZ;
    if (p.nextZ) p.nextZ.prevZ = p.prevZ;
  }
  function Node(i, x, y) {
    // vertex index in coordinates array
    this.i = i;

    // vertex coordinates
    this.x = x;
    this.y = y;

    // previous and next vertex nodes in a polygon ring
    this.prev = null;
    this.next = null;

    // z-order curve value
    this.z = 0;

    // previous and next nodes in z-order
    this.prevZ = null;
    this.nextZ = null;

    // indicates whether this is a steiner point
    this.steiner = false;
  }
  function signedArea(data, start, end, dim) {
    var sum = 0;
    for (var i = start, j = end - dim; i < end; i += dim) {
      sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);
      j = i;
    }
    return sum;
  }
  var ShapeUtils = exports.ShapeUtils = /*#__PURE__*/function () {
    function ShapeUtils() {
      (0, _classCallCheck2.default)(this, ShapeUtils);
    }
    return (0, _createClass2.default)(ShapeUtils, null, [{
      key: "area",
      value:
      // calculate area of the contour polygon

      function area(contour) {
        var n = contour.length;
        var a = 0.0;
        for (var p = n - 1, q = 0; q < n; p = q++) {
          a += contour[p].x * contour[q].y - contour[q].x * contour[p].y;
        }
        return a * 0.5;
      }
    }, {
      key: "isClockWise",
      value: function isClockWise(pts) {
        return ShapeUtils.area(pts) < 0;
      }
    }, {
      key: "triangulateShape",
      value: function triangulateShape(contour, holes) {
        var vertices = []; // flat array of vertices like [ x0,y0, x1,y1, x2,y2, ... ]
        var holeIndices = []; // array of hole indices
        var faces = []; // final array of vertex indices like [ [ a,b,d ], [ b,c,d ] ]

        removeDupEndPts(contour);
        addContour(vertices, contour);

        //

        var holeIndex = contour.length;
        holes.forEach(removeDupEndPts);
        for (var i = 0; i < holes.length; i++) {
          holeIndices.push(holeIndex);
          holeIndex += holes[i].length;
          addContour(vertices, holes[i]);
        }

        //

        var triangles = Earcut.triangulate(vertices, holeIndices);

        //

        for (var _i36 = 0; _i36 < triangles.length; _i36 += 3) {
          faces.push(triangles.slice(_i36, _i36 + 3));
        }
        return faces;
      }
    }]);
  }();
  function removeDupEndPts(points) {
    var l = points.length;
    if (l > 2 && points[l - 1].equals(points[0])) {
      points.pop();
    }
  }
  function addContour(vertices, contour) {
    for (var i = 0; i < contour.length; i++) {
      vertices.push(contour[i].x);
      vertices.push(contour[i].y);
    }
  }

  /**
   * Creates extruded geometry from a path shape.
   *
   * parameters = {
   *
   *  curveSegments: <int>, // number of points on the curves
   *  steps: <int>, // number of points for z-side extrusions / used for subdividing segments of extrude spline too
   *  depth: <float>, // Depth to extrude the shape
   *
   *  bevelEnabled: <bool>, // turn on bevel
   *  bevelThickness: <float>, // how deep into the original shape bevel goes
   *  bevelSize: <float>, // how far from shape outline (including bevelOffset) is bevel
   *  bevelOffset: <float>, // how far from shape outline does bevel start
   *  bevelSegments: <int>, // number of bevel layers
   *
   *  extrudePath: <THREE.Curve> // curve to extrude shape along
   *
   *  UVGenerator: <Object> // object that provides UV generator functions
   *
   * }
   */
  var ExtrudeGeometry = exports.ExtrudeGeometry = /*#__PURE__*/function (_BufferGeometry7) {
    function ExtrudeGeometry() {
      var _this66;
      var shapes = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Shape([new Vector2(0.5, 0.5), new Vector2(-0.5, 0.5), new Vector2(-0.5, -0.5), new Vector2(0.5, -0.5)]);
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      (0, _classCallCheck2.default)(this, ExtrudeGeometry);
      _this66 = _callSuper(this, ExtrudeGeometry);
      _this66.type = 'ExtrudeGeometry';
      _this66.parameters = {
        shapes: shapes,
        options: options
      };
      shapes = Array.isArray(shapes) ? shapes : [shapes];
      var scope = _this66;
      var verticesArray = [];
      var uvArray = [];
      for (var i = 0, l = shapes.length; i < l; i++) {
        var shape = shapes[i];
        addShape(shape);
      }

      // build geometry

      _this66.setAttribute('position', new Float32BufferAttribute(verticesArray, 3));
      _this66.setAttribute('uv', new Float32BufferAttribute(uvArray, 2));
      _this66.computeVertexNormals();

      // functions

      function addShape(shape) {
        var placeholder = [];

        // options

        var curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;
        var steps = options.steps !== undefined ? options.steps : 1;
        var depth = options.depth !== undefined ? options.depth : 1;
        var bevelEnabled = options.bevelEnabled !== undefined ? options.bevelEnabled : true;
        var bevelThickness = options.bevelThickness !== undefined ? options.bevelThickness : 0.2;
        var bevelSize = options.bevelSize !== undefined ? options.bevelSize : bevelThickness - 0.1;
        var bevelOffset = options.bevelOffset !== undefined ? options.bevelOffset : 0;
        var bevelSegments = options.bevelSegments !== undefined ? options.bevelSegments : 3;
        var extrudePath = options.extrudePath;
        var uvgen = options.UVGenerator !== undefined ? options.UVGenerator : WorldUVGenerator;

        //

        var extrudePts,
          extrudeByPath = false;
        var splineTube, binormal, normal, position2;
        if (extrudePath) {
          extrudePts = extrudePath.getSpacedPoints(steps);
          extrudeByPath = true;
          bevelEnabled = false; // bevels not supported for path extrusion

          // SETUP TNB variables

          // TODO1 - have a .isClosed in spline?

          splineTube = extrudePath.computeFrenetFrames(steps, false);

          // console.log(splineTube, 'splineTube', splineTube.normals.length, 'steps', steps, 'extrudePts', extrudePts.length);

          binormal = new Vector3();
          normal = new Vector3();
          position2 = new Vector3();
        }

        // Safeguards if bevels are not enabled

        if (!bevelEnabled) {
          bevelSegments = 0;
          bevelThickness = 0;
          bevelSize = 0;
          bevelOffset = 0;
        }

        // Variables initialization

        var shapePoints = shape.extractPoints(curveSegments);
        var vertices = shapePoints.shape;
        var holes = shapePoints.holes;
        var reverse = !ShapeUtils.isClockWise(vertices);
        if (reverse) {
          vertices = vertices.reverse();

          // Maybe we should also check if holes are in the opposite direction, just to be safe ...

          for (var h = 0, hl = holes.length; h < hl; h++) {
            var ahole = holes[h];
            if (ShapeUtils.isClockWise(ahole)) {
              holes[h] = ahole.reverse();
            }
          }
        }
        var faces = ShapeUtils.triangulateShape(vertices, holes);

        /* Vertices */

        var contour = vertices; // vertices has all points but contour has only points of circumference

        for (var _h = 0, _hl = holes.length; _h < _hl; _h++) {
          var _ahole = holes[_h];
          vertices = vertices.concat(_ahole);
        }
        function scalePt2(pt, vec, size) {
          if (!vec) console.error('THREE.ExtrudeGeometry: vec does not exist');
          return pt.clone().addScaledVector(vec, size);
        }
        var vlen = vertices.length,
          flen = faces.length;

        // Find directions for point movement

        function getBevelVec(inPt, inPrev, inNext) {
          // computes for inPt the corresponding point inPt' on a new contour
          //   shifted by 1 unit (length of normalized vector) to the left
          // if we walk along contour clockwise, this new contour is outside the old one
          //
          // inPt' is the intersection of the two lines parallel to the two
          //  adjacent edges of inPt at a distance of 1 unit on the left side.

          var v_trans_x, v_trans_y, shrink_by; // resulting translation vector for inPt

          // good reading for geometry algorithms (here: line-line intersection)
          // http://geomalgorithms.com/a05-_intersect-1.html

          var v_prev_x = inPt.x - inPrev.x,
            v_prev_y = inPt.y - inPrev.y;
          var v_next_x = inNext.x - inPt.x,
            v_next_y = inNext.y - inPt.y;
          var v_prev_lensq = v_prev_x * v_prev_x + v_prev_y * v_prev_y;

          // check for collinear edges
          var collinear0 = v_prev_x * v_next_y - v_prev_y * v_next_x;
          if (Math.abs(collinear0) > Number.EPSILON) {
            // not collinear

            // length of vectors for normalizing

            var v_prev_len = Math.sqrt(v_prev_lensq);
            var v_next_len = Math.sqrt(v_next_x * v_next_x + v_next_y * v_next_y);

            // shift adjacent points by unit vectors to the left

            var ptPrevShift_x = inPrev.x - v_prev_y / v_prev_len;
            var ptPrevShift_y = inPrev.y + v_prev_x / v_prev_len;
            var ptNextShift_x = inNext.x - v_next_y / v_next_len;
            var ptNextShift_y = inNext.y + v_next_x / v_next_len;

            // scaling factor for v_prev to intersection point

            var sf = ((ptNextShift_x - ptPrevShift_x) * v_next_y - (ptNextShift_y - ptPrevShift_y) * v_next_x) / (v_prev_x * v_next_y - v_prev_y * v_next_x);

            // vector from inPt to intersection point

            v_trans_x = ptPrevShift_x + v_prev_x * sf - inPt.x;
            v_trans_y = ptPrevShift_y + v_prev_y * sf - inPt.y;

            // Don't normalize!, otherwise sharp corners become ugly
            //  but prevent crazy spikes
            var v_trans_lensq = v_trans_x * v_trans_x + v_trans_y * v_trans_y;
            if (v_trans_lensq <= 2) {
              return new Vector2(v_trans_x, v_trans_y);
            } else {
              shrink_by = Math.sqrt(v_trans_lensq / 2);
            }
          } else {
            // handle special case of collinear edges

            var direction_eq = false; // assumes: opposite

            if (v_prev_x > Number.EPSILON) {
              if (v_next_x > Number.EPSILON) {
                direction_eq = true;
              }
            } else {
              if (v_prev_x < -Number.EPSILON) {
                if (v_next_x < -Number.EPSILON) {
                  direction_eq = true;
                }
              } else {
                if (Math.sign(v_prev_y) === Math.sign(v_next_y)) {
                  direction_eq = true;
                }
              }
            }
            if (direction_eq) {
              // console.log("Warning: lines are a straight sequence");
              v_trans_x = -v_prev_y;
              v_trans_y = v_prev_x;
              shrink_by = Math.sqrt(v_prev_lensq);
            } else {
              // console.log("Warning: lines are a straight spike");
              v_trans_x = v_prev_x;
              v_trans_y = v_prev_y;
              shrink_by = Math.sqrt(v_prev_lensq / 2);
            }
          }
          return new Vector2(v_trans_x / shrink_by, v_trans_y / shrink_by);
        }
        var contourMovements = [];
        for (var _i37 = 0, il = contour.length, j = il - 1, k = _i37 + 1; _i37 < il; _i37++, j++, k++) {
          if (j === il) j = 0;
          if (k === il) k = 0;

          //  (j)---(i)---(k)
          // console.log('i,j,k', i, j , k)

          contourMovements[_i37] = getBevelVec(contour[_i37], contour[j], contour[k]);
        }
        var holesMovements = [];
        var oneHoleMovements,
          verticesMovements = contourMovements.concat();
        for (var _h2 = 0, _hl2 = holes.length; _h2 < _hl2; _h2++) {
          var _ahole2 = holes[_h2];
          oneHoleMovements = [];
          for (var _i38 = 0, _il10 = _ahole2.length, _j6 = _il10 - 1, _k = _i38 + 1; _i38 < _il10; _i38++, _j6++, _k++) {
            if (_j6 === _il10) _j6 = 0;
            if (_k === _il10) _k = 0;

            //  (j)---(i)---(k)
            oneHoleMovements[_i38] = getBevelVec(_ahole2[_i38], _ahole2[_j6], _ahole2[_k]);
          }
          holesMovements.push(oneHoleMovements);
          verticesMovements = verticesMovements.concat(oneHoleMovements);
        }

        // Loop bevelSegments, 1 for the front, 1 for the back

        for (var b = 0; b < bevelSegments; b++) {
          //for ( b = bevelSegments; b > 0; b -- ) {

          var t = b / bevelSegments;
          var z = bevelThickness * Math.cos(t * Math.PI / 2);
          var _bs = bevelSize * Math.sin(t * Math.PI / 2) + bevelOffset;

          // contract shape

          for (var _i39 = 0, _il11 = contour.length; _i39 < _il11; _i39++) {
            var vert = scalePt2(contour[_i39], contourMovements[_i39], _bs);
            v(vert.x, vert.y, -z);
          }

          // expand holes

          for (var _h3 = 0, _hl3 = holes.length; _h3 < _hl3; _h3++) {
            var _ahole3 = holes[_h3];
            oneHoleMovements = holesMovements[_h3];
            for (var _i40 = 0, _il12 = _ahole3.length; _i40 < _il12; _i40++) {
              var _vert = scalePt2(_ahole3[_i40], oneHoleMovements[_i40], _bs);
              v(_vert.x, _vert.y, -z);
            }
          }
        }
        var bs = bevelSize + bevelOffset;

        // Back facing vertices

        for (var _i41 = 0; _i41 < vlen; _i41++) {
          var _vert2 = bevelEnabled ? scalePt2(vertices[_i41], verticesMovements[_i41], bs) : vertices[_i41];
          if (!extrudeByPath) {
            v(_vert2.x, _vert2.y, 0);
          } else {
            // v( vert.x, vert.y + extrudePts[ 0 ].y, extrudePts[ 0 ].x );

            normal.copy(splineTube.normals[0]).multiplyScalar(_vert2.x);
            binormal.copy(splineTube.binormals[0]).multiplyScalar(_vert2.y);
            position2.copy(extrudePts[0]).add(normal).add(binormal);
            v(position2.x, position2.y, position2.z);
          }
        }

        // Add stepped vertices...
        // Including front facing vertices

        for (var s = 1; s <= steps; s++) {
          for (var _i42 = 0; _i42 < vlen; _i42++) {
            var _vert3 = bevelEnabled ? scalePt2(vertices[_i42], verticesMovements[_i42], bs) : vertices[_i42];
            if (!extrudeByPath) {
              v(_vert3.x, _vert3.y, depth / steps * s);
            } else {
              // v( vert.x, vert.y + extrudePts[ s - 1 ].y, extrudePts[ s - 1 ].x );

              normal.copy(splineTube.normals[s]).multiplyScalar(_vert3.x);
              binormal.copy(splineTube.binormals[s]).multiplyScalar(_vert3.y);
              position2.copy(extrudePts[s]).add(normal).add(binormal);
              v(position2.x, position2.y, position2.z);
            }
          }
        }

        // Add bevel segments planes

        //for ( b = 1; b <= bevelSegments; b ++ ) {
        for (var _b5 = bevelSegments - 1; _b5 >= 0; _b5--) {
          var _t = _b5 / bevelSegments;
          var _z2 = bevelThickness * Math.cos(_t * Math.PI / 2);
          var _bs2 = bevelSize * Math.sin(_t * Math.PI / 2) + bevelOffset;

          // contract shape

          for (var _i43 = 0, _il13 = contour.length; _i43 < _il13; _i43++) {
            var _vert4 = scalePt2(contour[_i43], contourMovements[_i43], _bs2);
            v(_vert4.x, _vert4.y, depth + _z2);
          }

          // expand holes

          for (var _h4 = 0, _hl4 = holes.length; _h4 < _hl4; _h4++) {
            var _ahole4 = holes[_h4];
            oneHoleMovements = holesMovements[_h4];
            for (var _i44 = 0, _il14 = _ahole4.length; _i44 < _il14; _i44++) {
              var _vert5 = scalePt2(_ahole4[_i44], oneHoleMovements[_i44], _bs2);
              if (!extrudeByPath) {
                v(_vert5.x, _vert5.y, depth + _z2);
              } else {
                v(_vert5.x, _vert5.y + extrudePts[steps - 1].y, extrudePts[steps - 1].x + _z2);
              }
            }
          }
        }

        /* Faces */

        // Top and bottom faces

        buildLidFaces();

        // Sides faces

        buildSideFaces();

        /////  Internal functions

        function buildLidFaces() {
          var start = verticesArray.length / 3;
          if (bevelEnabled) {
            var layer = 0; // steps + 1
            var offset = vlen * layer;

            // Bottom faces

            for (var _i45 = 0; _i45 < flen; _i45++) {
              var face = faces[_i45];
              f3(face[2] + offset, face[1] + offset, face[0] + offset);
            }
            layer = steps + bevelSegments * 2;
            offset = vlen * layer;

            // Top faces

            for (var _i46 = 0; _i46 < flen; _i46++) {
              var _face = faces[_i46];
              f3(_face[0] + offset, _face[1] + offset, _face[2] + offset);
            }
          } else {
            // Bottom faces

            for (var _i47 = 0; _i47 < flen; _i47++) {
              var _face2 = faces[_i47];
              f3(_face2[2], _face2[1], _face2[0]);
            }

            // Top faces

            for (var _i48 = 0; _i48 < flen; _i48++) {
              var _face3 = faces[_i48];
              f3(_face3[0] + vlen * steps, _face3[1] + vlen * steps, _face3[2] + vlen * steps);
            }
          }
          scope.addGroup(start, verticesArray.length / 3 - start, 0);
        }

        // Create faces for the z-sides of the shape

        function buildSideFaces() {
          var start = verticesArray.length / 3;
          var layeroffset = 0;
          sidewalls(contour, layeroffset);
          layeroffset += contour.length;
          for (var _h5 = 0, _hl5 = holes.length; _h5 < _hl5; _h5++) {
            var _ahole5 = holes[_h5];
            sidewalls(_ahole5, layeroffset);

            //, true
            layeroffset += _ahole5.length;
          }
          scope.addGroup(start, verticesArray.length / 3 - start, 1);
        }
        function sidewalls(contour, layeroffset) {
          var i = contour.length;
          while (--i >= 0) {
            var _j7 = i;
            var _k2 = i - 1;
            if (_k2 < 0) _k2 = contour.length - 1;

            //console.log('b', i,j, i-1, k,vertices.length);

            for (var _s4 = 0, sl = steps + bevelSegments * 2; _s4 < sl; _s4++) {
              var slen1 = vlen * _s4;
              var slen2 = vlen * (_s4 + 1);
              var a = layeroffset + _j7 + slen1,
                _b6 = layeroffset + _k2 + slen1,
                c = layeroffset + _k2 + slen2,
                d = layeroffset + _j7 + slen2;
              f4(a, _b6, c, d);
            }
          }
        }
        function v(x, y, z) {
          placeholder.push(x);
          placeholder.push(y);
          placeholder.push(z);
        }
        function f3(a, b, c) {
          addVertex(a);
          addVertex(b);
          addVertex(c);
          var nextIndex = verticesArray.length / 3;
          var uvs = uvgen.generateTopUV(scope, verticesArray, nextIndex - 3, nextIndex - 2, nextIndex - 1);
          addUV(uvs[0]);
          addUV(uvs[1]);
          addUV(uvs[2]);
        }
        function f4(a, b, c, d) {
          addVertex(a);
          addVertex(b);
          addVertex(d);
          addVertex(b);
          addVertex(c);
          addVertex(d);
          var nextIndex = verticesArray.length / 3;
          var uvs = uvgen.generateSideWallUV(scope, verticesArray, nextIndex - 6, nextIndex - 3, nextIndex - 2, nextIndex - 1);
          addUV(uvs[0]);
          addUV(uvs[1]);
          addUV(uvs[3]);
          addUV(uvs[1]);
          addUV(uvs[2]);
          addUV(uvs[3]);
        }
        function addVertex(index) {
          verticesArray.push(placeholder[index * 3 + 0]);
          verticesArray.push(placeholder[index * 3 + 1]);
          verticesArray.push(placeholder[index * 3 + 2]);
        }
        function addUV(vector2) {
          uvArray.push(vector2.x);
          uvArray.push(vector2.y);
        }
      }
      return _this66;
    }
    (0, _inherits2.default)(ExtrudeGeometry, _BufferGeometry7);
    return (0, _createClass2.default)(ExtrudeGeometry, [{
      key: "copy",
      value: function copy(source) {
        _superPropGet(ExtrudeGeometry, "copy", this, 3)([source]);
        this.parameters = Object.assign({}, source.parameters);
        return this;
      }
    }, {
      key: "toJSON",
      value: function toJSON() {
        var data = _superPropGet(ExtrudeGeometry, "toJSON", this, 3)([]);
        var shapes = this.parameters.shapes;
        var options = this.parameters.options;
        return toJSON$1(shapes, options, data);
      }
    }], [{
      key: "fromJSON",
      value: function fromJSON(data, shapes) {
        var geometryShapes = [];
        for (var j = 0, jl = data.shapes.length; j < jl; j++) {
          var shape = shapes[data.shapes[j]];
          geometryShapes.push(shape);
        }
        var extrudePath = data.options.extrudePath;
        if (extrudePath !== undefined) {
          data.options.extrudePath = new Curves[extrudePath.type]().fromJSON(extrudePath);
        }
        return new ExtrudeGeometry(geometryShapes, data.options);
      }
    }]);
  }(BufferGeometry);
  var WorldUVGenerator = {
    generateTopUV: function generateTopUV(geometry, vertices, indexA, indexB, indexC) {
      var a_x = vertices[indexA * 3];
      var a_y = vertices[indexA * 3 + 1];
      var b_x = vertices[indexB * 3];
      var b_y = vertices[indexB * 3 + 1];
      var c_x = vertices[indexC * 3];
      var c_y = vertices[indexC * 3 + 1];
      return [new Vector2(a_x, a_y), new Vector2(b_x, b_y), new Vector2(c_x, c_y)];
    },
    generateSideWallUV: function generateSideWallUV(geometry, vertices, indexA, indexB, indexC, indexD) {
      var a_x = vertices[indexA * 3];
      var a_y = vertices[indexA * 3 + 1];
      var a_z = vertices[indexA * 3 + 2];
      var b_x = vertices[indexB * 3];
      var b_y = vertices[indexB * 3 + 1];
      var b_z = vertices[indexB * 3 + 2];
      var c_x = vertices[indexC * 3];
      var c_y = vertices[indexC * 3 + 1];
      var c_z = vertices[indexC * 3 + 2];
      var d_x = vertices[indexD * 3];
      var d_y = vertices[indexD * 3 + 1];
      var d_z = vertices[indexD * 3 + 2];
      if (Math.abs(a_y - b_y) < Math.abs(a_x - b_x)) {
        return [new Vector2(a_x, 1 - a_z), new Vector2(b_x, 1 - b_z), new Vector2(c_x, 1 - c_z), new Vector2(d_x, 1 - d_z)];
      } else {
        return [new Vector2(a_y, 1 - a_z), new Vector2(b_y, 1 - b_z), new Vector2(c_y, 1 - c_z), new Vector2(d_y, 1 - d_z)];
      }
    }
  };
  function toJSON$1(shapes, options, data) {
    data.shapes = [];
    if (Array.isArray(shapes)) {
      for (var i = 0, l = shapes.length; i < l; i++) {
        var shape = shapes[i];
        data.shapes.push(shape.uuid);
      }
    } else {
      data.shapes.push(shapes.uuid);
    }
    data.options = Object.assign({}, options);
    if (options.extrudePath !== undefined) data.options.extrudePath = options.extrudePath.toJSON();
    return data;
  }
  var IcosahedronGeometry = exports.IcosahedronGeometry = /*#__PURE__*/function (_PolyhedronGeometry2) {
    function IcosahedronGeometry() {
      var _this67;
      var radius = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
      var detail = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      (0, _classCallCheck2.default)(this, IcosahedronGeometry);
      var t = (1 + Math.sqrt(5)) / 2;
      var vertices = [-1, t, 0, 1, t, 0, -1, -t, 0, 1, -t, 0, 0, -1, t, 0, 1, t, 0, -1, -t, 0, 1, -t, t, 0, -1, t, 0, 1, -t, 0, -1, -t, 0, 1];
      var indices = [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1];
      _this67 = _callSuper(this, IcosahedronGeometry, [vertices, indices, radius, detail]);
      _this67.type = 'IcosahedronGeometry';
      _this67.parameters = {
        radius: radius,
        detail: detail
      };
      return _this67;
    }
    (0, _inherits2.default)(IcosahedronGeometry, _PolyhedronGeometry2);
    return (0, _createClass2.default)(IcosahedronGeometry, null, [{
      key: "fromJSON",
      value: function fromJSON(data) {
        return new IcosahedronGeometry(data.radius, data.detail);
      }
    }]);
  }(PolyhedronGeometry);
  var OctahedronGeometry = exports.OctahedronGeometry = /*#__PURE__*/function (_PolyhedronGeometry3) {
    function OctahedronGeometry() {
      var _this68;
      var radius = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
      var detail = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      (0, _classCallCheck2.default)(this, OctahedronGeometry);
      var vertices = [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1];
      var indices = [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2];
      _this68 = _callSuper(this, OctahedronGeometry, [vertices, indices, radius, detail]);
      _this68.type = 'OctahedronGeometry';
      _this68.parameters = {
        radius: radius,
        detail: detail
      };
      return _this68;
    }
    (0, _inherits2.default)(OctahedronGeometry, _PolyhedronGeometry3);
    return (0, _createClass2.default)(OctahedronGeometry, null, [{
      key: "fromJSON",
      value: function fromJSON(data) {
        return new OctahedronGeometry(data.radius, data.detail);
      }
    }]);
  }(PolyhedronGeometry);
  var PlaneGeometry = exports.PlaneGeometry = /*#__PURE__*/function (_BufferGeometry8) {
    function PlaneGeometry() {
      var _this69;
      var width = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
      var height = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
      var widthSegments = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
      var heightSegments = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;
      (0, _classCallCheck2.default)(this, PlaneGeometry);
      _this69 = _callSuper(this, PlaneGeometry);
      _this69.type = 'PlaneGeometry';
      _this69.parameters = {
        width: width,
        height: height,
        widthSegments: widthSegments,
        heightSegments: heightSegments
      };
      var width_half = width / 2;
      var height_half = height / 2;
      var gridX = Math.floor(widthSegments);
      var gridY = Math.floor(heightSegments);
      var gridX1 = gridX + 1;
      var gridY1 = gridY + 1;
      var segment_width = width / gridX;
      var segment_height = height / gridY;

      //

      var indices = [];
      var vertices = [];
      var normals = [];
      var uvs = [];
      for (var iy = 0; iy < gridY1; iy++) {
        var y = iy * segment_height - height_half;
        for (var ix = 0; ix < gridX1; ix++) {
          var x = ix * segment_width - width_half;
          vertices.push(x, -y, 0);
          normals.push(0, 0, 1);
          uvs.push(ix / gridX);
          uvs.push(1 - iy / gridY);
        }
      }
      for (var _iy2 = 0; _iy2 < gridY; _iy2++) {
        for (var _ix2 = 0; _ix2 < gridX; _ix2++) {
          var a = _ix2 + gridX1 * _iy2;
          var b = _ix2 + gridX1 * (_iy2 + 1);
          var c = _ix2 + 1 + gridX1 * (_iy2 + 1);
          var d = _ix2 + 1 + gridX1 * _iy2;
          indices.push(a, b, d);
          indices.push(b, c, d);
        }
      }
      _this69.setIndex(indices);
      _this69.setAttribute('position', new Float32BufferAttribute(vertices, 3));
      _this69.setAttribute('normal', new Float32BufferAttribute(normals, 3));
      _this69.setAttribute('uv', new Float32BufferAttribute(uvs, 2));
      return _this69;
    }
    (0, _inherits2.default)(PlaneGeometry, _BufferGeometry8);
    return (0, _createClass2.default)(PlaneGeometry, [{
      key: "copy",
      value: function copy(source) {
        _superPropGet(PlaneGeometry, "copy", this, 3)([source]);
        this.parameters = Object.assign({}, source.parameters);
        return this;
      }
    }], [{
      key: "fromJSON",
      value: function fromJSON(data) {
        return new PlaneGeometry(data.width, data.height, data.widthSegments, data.heightSegments);
      }
    }]);
  }(BufferGeometry);
  var RingGeometry = exports.RingGeometry = /*#__PURE__*/function (_BufferGeometry9) {
    function RingGeometry() {
      var _this70;
      var innerRadius = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0.5;
      var outerRadius = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
      var thetaSegments = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 32;
      var phiSegments = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;
      var thetaStart = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
      var thetaLength = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : Math.PI * 2;
      (0, _classCallCheck2.default)(this, RingGeometry);
      _this70 = _callSuper(this, RingGeometry);
      _this70.type = 'RingGeometry';
      _this70.parameters = {
        innerRadius: innerRadius,
        outerRadius: outerRadius,
        thetaSegments: thetaSegments,
        phiSegments: phiSegments,
        thetaStart: thetaStart,
        thetaLength: thetaLength
      };
      thetaSegments = Math.max(3, thetaSegments);
      phiSegments = Math.max(1, phiSegments);

      // buffers

      var indices = [];
      var vertices = [];
      var normals = [];
      var uvs = [];

      // some helper variables

      var radius = innerRadius;
      var radiusStep = (outerRadius - innerRadius) / phiSegments;
      var vertex = new Vector3();
      var uv = new Vector2();

      // generate vertices, normals and uvs

      for (var j = 0; j <= phiSegments; j++) {
        for (var i = 0; i <= thetaSegments; i++) {
          // values are generate from the inside of the ring to the outside

          var segment = thetaStart + i / thetaSegments * thetaLength;

          // vertex

          vertex.x = radius * Math.cos(segment);
          vertex.y = radius * Math.sin(segment);
          vertices.push(vertex.x, vertex.y, vertex.z);

          // normal

          normals.push(0, 0, 1);

          // uv

          uv.x = (vertex.x / outerRadius + 1) / 2;
          uv.y = (vertex.y / outerRadius + 1) / 2;
          uvs.push(uv.x, uv.y);
        }

        // increase the radius for next row of vertices

        radius += radiusStep;
      }

      // indices

      for (var _j8 = 0; _j8 < phiSegments; _j8++) {
        var thetaSegmentLevel = _j8 * (thetaSegments + 1);
        for (var _i49 = 0; _i49 < thetaSegments; _i49++) {
          var _segment = _i49 + thetaSegmentLevel;
          var a = _segment;
          var b = _segment + thetaSegments + 1;
          var c = _segment + thetaSegments + 2;
          var d = _segment + 1;

          // faces

          indices.push(a, b, d);
          indices.push(b, c, d);
        }
      }

      // build geometry

      _this70.setIndex(indices);
      _this70.setAttribute('position', new Float32BufferAttribute(vertices, 3));
      _this70.setAttribute('normal', new Float32BufferAttribute(normals, 3));
      _this70.setAttribute('uv', new Float32BufferAttribute(uvs, 2));
      return _this70;
    }
    (0, _inherits2.default)(RingGeometry, _BufferGeometry9);
    return (0, _createClass2.default)(RingGeometry, [{
      key: "copy",
      value: function copy(source) {
        _superPropGet(RingGeometry, "copy", this, 3)([source]);
        this.parameters = Object.assign({}, source.parameters);
        return this;
      }
    }], [{
      key: "fromJSON",
      value: function fromJSON(data) {
        return new RingGeometry(data.innerRadius, data.outerRadius, data.thetaSegments, data.phiSegments, data.thetaStart, data.thetaLength);
      }
    }]);
  }(BufferGeometry);
  var ShapeGeometry = exports.ShapeGeometry = /*#__PURE__*/function (_BufferGeometry10) {
    function ShapeGeometry() {
      var _this71;
      var shapes = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Shape([new Vector2(0, 0.5), new Vector2(-0.5, -0.5), new Vector2(0.5, -0.5)]);
      var curveSegments = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 12;
      (0, _classCallCheck2.default)(this, ShapeGeometry);
      _this71 = _callSuper(this, ShapeGeometry);
      _this71.type = 'ShapeGeometry';
      _this71.parameters = {
        shapes: shapes,
        curveSegments: curveSegments
      };

      // buffers

      var indices = [];
      var vertices = [];
      var normals = [];
      var uvs = [];

      // helper variables

      var groupStart = 0;
      var groupCount = 0;

      // allow single and array values for "shapes" parameter

      if (Array.isArray(shapes) === false) {
        addShape(shapes);
      } else {
        for (var i = 0; i < shapes.length; i++) {
          addShape(shapes[i]);
          _this71.addGroup(groupStart, groupCount, i); // enables MultiMaterial support

          groupStart += groupCount;
          groupCount = 0;
        }
      }

      // build geometry

      _this71.setIndex(indices);
      _this71.setAttribute('position', new Float32BufferAttribute(vertices, 3));
      _this71.setAttribute('normal', new Float32BufferAttribute(normals, 3));
      _this71.setAttribute('uv', new Float32BufferAttribute(uvs, 2));

      // helper functions

      function addShape(shape) {
        var indexOffset = vertices.length / 3;
        var points = shape.extractPoints(curveSegments);
        var shapeVertices = points.shape;
        var shapeHoles = points.holes;

        // check direction of vertices

        if (ShapeUtils.isClockWise(shapeVertices) === false) {
          shapeVertices = shapeVertices.reverse();
        }
        for (var _i50 = 0, l = shapeHoles.length; _i50 < l; _i50++) {
          var shapeHole = shapeHoles[_i50];
          if (ShapeUtils.isClockWise(shapeHole) === true) {
            shapeHoles[_i50] = shapeHole.reverse();
          }
        }
        var faces = ShapeUtils.triangulateShape(shapeVertices, shapeHoles);

        // join vertices of inner and outer paths to a single array

        for (var _i51 = 0, _l11 = shapeHoles.length; _i51 < _l11; _i51++) {
          var _shapeHole = shapeHoles[_i51];
          shapeVertices = shapeVertices.concat(_shapeHole);
        }

        // vertices, normals, uvs

        for (var _i52 = 0, _l12 = shapeVertices.length; _i52 < _l12; _i52++) {
          var vertex = shapeVertices[_i52];
          vertices.push(vertex.x, vertex.y, 0);
          normals.push(0, 0, 1);
          uvs.push(vertex.x, vertex.y); // world uvs
        }

        // indices

        for (var _i53 = 0, _l13 = faces.length; _i53 < _l13; _i53++) {
          var face = faces[_i53];
          var a = face[0] + indexOffset;
          var b = face[1] + indexOffset;
          var c = face[2] + indexOffset;
          indices.push(a, b, c);
          groupCount += 3;
        }
      }
      return _this71;
    }
    (0, _inherits2.default)(ShapeGeometry, _BufferGeometry10);
    return (0, _createClass2.default)(ShapeGeometry, [{
      key: "copy",
      value: function copy(source) {
        _superPropGet(ShapeGeometry, "copy", this, 3)([source]);
        this.parameters = Object.assign({}, source.parameters);
        return this;
      }
    }, {
      key: "toJSON",
      value: function toJSON() {
        var data = _superPropGet(ShapeGeometry, "toJSON", this, 3)([]);
        var shapes = this.parameters.shapes;
        return _toJSON(shapes, data);
      }
    }], [{
      key: "fromJSON",
      value: function fromJSON(data, shapes) {
        var geometryShapes = [];
        for (var j = 0, jl = data.shapes.length; j < jl; j++) {
          var shape = shapes[data.shapes[j]];
          geometryShapes.push(shape);
        }
        return new ShapeGeometry(geometryShapes, data.curveSegments);
      }
    }]);
  }(BufferGeometry);
  function _toJSON(shapes, data) {
    data.shapes = [];
    if (Array.isArray(shapes)) {
      for (var i = 0, l = shapes.length; i < l; i++) {
        var shape = shapes[i];
        data.shapes.push(shape.uuid);
      }
    } else {
      data.shapes.push(shapes.uuid);
    }
    return data;
  }
  var SphereGeometry = exports.SphereGeometry = /*#__PURE__*/function (_BufferGeometry11) {
    function SphereGeometry() {
      var _this72;
      var radius = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
      var widthSegments = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 32;
      var heightSegments = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 16;
      var phiStart = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
      var phiLength = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : Math.PI * 2;
      var thetaStart = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;
      var thetaLength = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : Math.PI;
      (0, _classCallCheck2.default)(this, SphereGeometry);
      _this72 = _callSuper(this, SphereGeometry);
      _this72.type = 'SphereGeometry';
      _this72.parameters = {
        radius: radius,
        widthSegments: widthSegments,
        heightSegments: heightSegments,
        phiStart: phiStart,
        phiLength: phiLength,
        thetaStart: thetaStart,
        thetaLength: thetaLength
      };
      widthSegments = Math.max(3, Math.floor(widthSegments));
      heightSegments = Math.max(2, Math.floor(heightSegments));
      var thetaEnd = Math.min(thetaStart + thetaLength, Math.PI);
      var index = 0;
      var grid = [];
      var vertex = new Vector3();
      var normal = new Vector3();

      // buffers

      var indices = [];
      var vertices = [];
      var normals = [];
      var uvs = [];

      // generate vertices, normals and uvs

      for (var iy = 0; iy <= heightSegments; iy++) {
        var verticesRow = [];
        var v = iy / heightSegments;

        // special case for the poles

        var uOffset = 0;
        if (iy === 0 && thetaStart === 0) {
          uOffset = 0.5 / widthSegments;
        } else if (iy === heightSegments && thetaEnd === Math.PI) {
          uOffset = -0.5 / widthSegments;
        }
        for (var ix = 0; ix <= widthSegments; ix++) {
          var u = ix / widthSegments;

          // vertex

          vertex.x = -radius * Math.cos(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);
          vertex.y = radius * Math.cos(thetaStart + v * thetaLength);
          vertex.z = radius * Math.sin(phiStart + u * phiLength) * Math.sin(thetaStart + v * thetaLength);
          vertices.push(vertex.x, vertex.y, vertex.z);

          // normal

          normal.copy(vertex).normalize();
          normals.push(normal.x, normal.y, normal.z);

          // uv

          uvs.push(u + uOffset, 1 - v);
          verticesRow.push(index++);
        }
        grid.push(verticesRow);
      }

      // indices

      for (var _iy3 = 0; _iy3 < heightSegments; _iy3++) {
        for (var _ix3 = 0; _ix3 < widthSegments; _ix3++) {
          var a = grid[_iy3][_ix3 + 1];
          var b = grid[_iy3][_ix3];
          var c = grid[_iy3 + 1][_ix3];
          var d = grid[_iy3 + 1][_ix3 + 1];
          if (_iy3 !== 0 || thetaStart > 0) indices.push(a, b, d);
          if (_iy3 !== heightSegments - 1 || thetaEnd < Math.PI) indices.push(b, c, d);
        }
      }

      // build geometry

      _this72.setIndex(indices);
      _this72.setAttribute('position', new Float32BufferAttribute(vertices, 3));
      _this72.setAttribute('normal', new Float32BufferAttribute(normals, 3));
      _this72.setAttribute('uv', new Float32BufferAttribute(uvs, 2));
      return _this72;
    }
    (0, _inherits2.default)(SphereGeometry, _BufferGeometry11);
    return (0, _createClass2.default)(SphereGeometry, [{
      key: "copy",
      value: function copy(source) {
        _superPropGet(SphereGeometry, "copy", this, 3)([source]);
        this.parameters = Object.assign({}, source.parameters);
        return this;
      }
    }], [{
      key: "fromJSON",
      value: function fromJSON(data) {
        return new SphereGeometry(data.radius, data.widthSegments, data.heightSegments, data.phiStart, data.phiLength, data.thetaStart, data.thetaLength);
      }
    }]);
  }(BufferGeometry);
  var TetrahedronGeometry = exports.TetrahedronGeometry = /*#__PURE__*/function (_PolyhedronGeometry4) {
    function TetrahedronGeometry() {
      var _this73;
      var radius = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
      var detail = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      (0, _classCallCheck2.default)(this, TetrahedronGeometry);
      var vertices = [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1];
      var indices = [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1];
      _this73 = _callSuper(this, TetrahedronGeometry, [vertices, indices, radius, detail]);
      _this73.type = 'TetrahedronGeometry';
      _this73.parameters = {
        radius: radius,
        detail: detail
      };
      return _this73;
    }
    (0, _inherits2.default)(TetrahedronGeometry, _PolyhedronGeometry4);
    return (0, _createClass2.default)(TetrahedronGeometry, null, [{
      key: "fromJSON",
      value: function fromJSON(data) {
        return new TetrahedronGeometry(data.radius, data.detail);
      }
    }]);
  }(PolyhedronGeometry);
  var TorusGeometry = exports.TorusGeometry = /*#__PURE__*/function (_BufferGeometry12) {
    function TorusGeometry() {
      var _this74;
      var radius = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
      var tube = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0.4;
      var radialSegments = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 12;
      var tubularSegments = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 48;
      var arc = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : Math.PI * 2;
      (0, _classCallCheck2.default)(this, TorusGeometry);
      _this74 = _callSuper(this, TorusGeometry);
      _this74.type = 'TorusGeometry';
      _this74.parameters = {
        radius: radius,
        tube: tube,
        radialSegments: radialSegments,
        tubularSegments: tubularSegments,
        arc: arc
      };
      radialSegments = Math.floor(radialSegments);
      tubularSegments = Math.floor(tubularSegments);

      // buffers

      var indices = [];
      var vertices = [];
      var normals = [];
      var uvs = [];

      // helper variables

      var center = new Vector3();
      var vertex = new Vector3();
      var normal = new Vector3();

      // generate vertices, normals and uvs

      for (var j = 0; j <= radialSegments; j++) {
        for (var i = 0; i <= tubularSegments; i++) {
          var u = i / tubularSegments * arc;
          var v = j / radialSegments * Math.PI * 2;

          // vertex

          vertex.x = (radius + tube * Math.cos(v)) * Math.cos(u);
          vertex.y = (radius + tube * Math.cos(v)) * Math.sin(u);
          vertex.z = tube * Math.sin(v);
          vertices.push(vertex.x, vertex.y, vertex.z);

          // normal

          center.x = radius * Math.cos(u);
          center.y = radius * Math.sin(u);
          normal.subVectors(vertex, center).normalize();
          normals.push(normal.x, normal.y, normal.z);

          // uv

          uvs.push(i / tubularSegments);
          uvs.push(j / radialSegments);
        }
      }

      // generate indices

      for (var _j9 = 1; _j9 <= radialSegments; _j9++) {
        for (var _i54 = 1; _i54 <= tubularSegments; _i54++) {
          // indices

          var a = (tubularSegments + 1) * _j9 + _i54 - 1;
          var b = (tubularSegments + 1) * (_j9 - 1) + _i54 - 1;
          var c = (tubularSegments + 1) * (_j9 - 1) + _i54;
          var d = (tubularSegments + 1) * _j9 + _i54;

          // faces

          indices.push(a, b, d);
          indices.push(b, c, d);
        }
      }

      // build geometry

      _this74.setIndex(indices);
      _this74.setAttribute('position', new Float32BufferAttribute(vertices, 3));
      _this74.setAttribute('normal', new Float32BufferAttribute(normals, 3));
      _this74.setAttribute('uv', new Float32BufferAttribute(uvs, 2));
      return _this74;
    }
    (0, _inherits2.default)(TorusGeometry, _BufferGeometry12);
    return (0, _createClass2.default)(TorusGeometry, [{
      key: "copy",
      value: function copy(source) {
        _superPropGet(TorusGeometry, "copy", this, 3)([source]);
        this.parameters = Object.assign({}, source.parameters);
        return this;
      }
    }], [{
      key: "fromJSON",
      value: function fromJSON(data) {
        return new TorusGeometry(data.radius, data.tube, data.radialSegments, data.tubularSegments, data.arc);
      }
    }]);
  }(BufferGeometry);
  var TorusKnotGeometry = exports.TorusKnotGeometry = /*#__PURE__*/function (_BufferGeometry13) {
    function TorusKnotGeometry() {
      var _this75;
      var radius = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
      var tube = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0.4;
      var tubularSegments = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 64;
      var radialSegments = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 8;
      var p = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 2;
      var q = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 3;
      (0, _classCallCheck2.default)(this, TorusKnotGeometry);
      _this75 = _callSuper(this, TorusKnotGeometry);
      _this75.type = 'TorusKnotGeometry';
      _this75.parameters = {
        radius: radius,
        tube: tube,
        tubularSegments: tubularSegments,
        radialSegments: radialSegments,
        p: p,
        q: q
      };
      tubularSegments = Math.floor(tubularSegments);
      radialSegments = Math.floor(radialSegments);

      // buffers

      var indices = [];
      var vertices = [];
      var normals = [];
      var uvs = [];

      // helper variables

      var vertex = new Vector3();
      var normal = new Vector3();
      var P1 = new Vector3();
      var P2 = new Vector3();
      var B = new Vector3();
      var T = new Vector3();
      var N = new Vector3();

      // generate vertices, normals and uvs

      for (var i = 0; i <= tubularSegments; ++i) {
        // the radian "u" is used to calculate the position on the torus curve of the current tubular segment

        var u = i / tubularSegments * p * Math.PI * 2;

        // now we calculate two points. P1 is our current position on the curve, P2 is a little farther ahead.
        // these points are used to create a special "coordinate space", which is necessary to calculate the correct vertex positions

        calculatePositionOnCurve(u, p, q, radius, P1);
        calculatePositionOnCurve(u + 0.01, p, q, radius, P2);

        // calculate orthonormal basis

        T.subVectors(P2, P1);
        N.addVectors(P2, P1);
        B.crossVectors(T, N);
        N.crossVectors(B, T);

        // normalize B, N. T can be ignored, we don't use it

        B.normalize();
        N.normalize();
        for (var j = 0; j <= radialSegments; ++j) {
          // now calculate the vertices. they are nothing more than an extrusion of the torus curve.
          // because we extrude a shape in the xy-plane, there is no need to calculate a z-value.

          var v = j / radialSegments * Math.PI * 2;
          var cx = -tube * Math.cos(v);
          var cy = tube * Math.sin(v);

          // now calculate the final vertex position.
          // first we orient the extrusion with our basis vectors, then we add it to the current position on the curve

          vertex.x = P1.x + (cx * N.x + cy * B.x);
          vertex.y = P1.y + (cx * N.y + cy * B.y);
          vertex.z = P1.z + (cx * N.z + cy * B.z);
          vertices.push(vertex.x, vertex.y, vertex.z);

          // normal (P1 is always the center/origin of the extrusion, thus we can use it to calculate the normal)

          normal.subVectors(vertex, P1).normalize();
          normals.push(normal.x, normal.y, normal.z);

          // uv

          uvs.push(i / tubularSegments);
          uvs.push(j / radialSegments);
        }
      }

      // generate indices

      for (var _j10 = 1; _j10 <= tubularSegments; _j10++) {
        for (var _i55 = 1; _i55 <= radialSegments; _i55++) {
          // indices

          var a = (radialSegments + 1) * (_j10 - 1) + (_i55 - 1);
          var b = (radialSegments + 1) * _j10 + (_i55 - 1);
          var c = (radialSegments + 1) * _j10 + _i55;
          var d = (radialSegments + 1) * (_j10 - 1) + _i55;

          // faces

          indices.push(a, b, d);
          indices.push(b, c, d);
        }
      }

      // build geometry

      _this75.setIndex(indices);
      _this75.setAttribute('position', new Float32BufferAttribute(vertices, 3));
      _this75.setAttribute('normal', new Float32BufferAttribute(normals, 3));
      _this75.setAttribute('uv', new Float32BufferAttribute(uvs, 2));

      // this function calculates the current position on the torus curve

      function calculatePositionOnCurve(u, p, q, radius, position) {
        var cu = Math.cos(u);
        var su = Math.sin(u);
        var quOverP = q / p * u;
        var cs = Math.cos(quOverP);
        position.x = radius * (2 + cs) * 0.5 * cu;
        position.y = radius * (2 + cs) * su * 0.5;
        position.z = radius * Math.sin(quOverP) * 0.5;
      }
      return _this75;
    }
    (0, _inherits2.default)(TorusKnotGeometry, _BufferGeometry13);
    return (0, _createClass2.default)(TorusKnotGeometry, [{
      key: "copy",
      value: function copy(source) {
        _superPropGet(TorusKnotGeometry, "copy", this, 3)([source]);
        this.parameters = Object.assign({}, source.parameters);
        return this;
      }
    }], [{
      key: "fromJSON",
      value: function fromJSON(data) {
        return new TorusKnotGeometry(data.radius, data.tube, data.tubularSegments, data.radialSegments, data.p, data.q);
      }
    }]);
  }(BufferGeometry);
  var TubeGeometry = exports.TubeGeometry = /*#__PURE__*/function (_BufferGeometry14) {
    function TubeGeometry() {
      var _this76;
      var path = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new QuadraticBezierCurve3(new Vector3(-1, -1, 0), new Vector3(-1, 1, 0), new Vector3(1, 1, 0));
      var tubularSegments = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 64;
      var radius = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
      var radialSegments = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 8;
      var closed = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
      (0, _classCallCheck2.default)(this, TubeGeometry);
      _this76 = _callSuper(this, TubeGeometry);
      _this76.type = 'TubeGeometry';
      _this76.parameters = {
        path: path,
        tubularSegments: tubularSegments,
        radius: radius,
        radialSegments: radialSegments,
        closed: closed
      };
      var frames = path.computeFrenetFrames(tubularSegments, closed);

      // expose internals

      _this76.tangents = frames.tangents;
      _this76.normals = frames.normals;
      _this76.binormals = frames.binormals;

      // helper variables

      var vertex = new Vector3();
      var normal = new Vector3();
      var uv = new Vector2();
      var P = new Vector3();

      // buffer

      var vertices = [];
      var normals = [];
      var uvs = [];
      var indices = [];

      // create buffer data

      generateBufferData();

      // build geometry

      _this76.setIndex(indices);
      _this76.setAttribute('position', new Float32BufferAttribute(vertices, 3));
      _this76.setAttribute('normal', new Float32BufferAttribute(normals, 3));
      _this76.setAttribute('uv', new Float32BufferAttribute(uvs, 2));

      // functions

      function generateBufferData() {
        for (var i = 0; i < tubularSegments; i++) {
          generateSegment(i);
        }

        // if the geometry is not closed, generate the last row of vertices and normals
        // at the regular position on the given path
        //
        // if the geometry is closed, duplicate the first row of vertices and normals (uvs will differ)

        generateSegment(closed === false ? tubularSegments : 0);

        // uvs are generated in a separate function.
        // this makes it easy compute correct values for closed geometries

        generateUVs();

        // finally create faces

        generateIndices();
      }
      function generateSegment(i) {
        // we use getPointAt to sample evenly distributed points from the given path

        P = path.getPointAt(i / tubularSegments, P);

        // retrieve corresponding normal and binormal

        var N = frames.normals[i];
        var B = frames.binormals[i];

        // generate normals and vertices for the current segment

        for (var j = 0; j <= radialSegments; j++) {
          var v = j / radialSegments * Math.PI * 2;
          var sin = Math.sin(v);
          var cos = -Math.cos(v);

          // normal

          normal.x = cos * N.x + sin * B.x;
          normal.y = cos * N.y + sin * B.y;
          normal.z = cos * N.z + sin * B.z;
          normal.normalize();
          normals.push(normal.x, normal.y, normal.z);

          // vertex

          vertex.x = P.x + radius * normal.x;
          vertex.y = P.y + radius * normal.y;
          vertex.z = P.z + radius * normal.z;
          vertices.push(vertex.x, vertex.y, vertex.z);
        }
      }
      function generateIndices() {
        for (var j = 1; j <= tubularSegments; j++) {
          for (var i = 1; i <= radialSegments; i++) {
            var a = (radialSegments + 1) * (j - 1) + (i - 1);
            var b = (radialSegments + 1) * j + (i - 1);
            var c = (radialSegments + 1) * j + i;
            var d = (radialSegments + 1) * (j - 1) + i;

            // faces

            indices.push(a, b, d);
            indices.push(b, c, d);
          }
        }
      }
      function generateUVs() {
        for (var i = 0; i <= tubularSegments; i++) {
          for (var j = 0; j <= radialSegments; j++) {
            uv.x = i / tubularSegments;
            uv.y = j / radialSegments;
            uvs.push(uv.x, uv.y);
          }
        }
      }
      return _this76;
    }
    (0, _inherits2.default)(TubeGeometry, _BufferGeometry14);
    return (0, _createClass2.default)(TubeGeometry, [{
      key: "copy",
      value: function copy(source) {
        _superPropGet(TubeGeometry, "copy", this, 3)([source]);
        this.parameters = Object.assign({}, source.parameters);
        return this;
      }
    }, {
      key: "toJSON",
      value: function toJSON() {
        var data = _superPropGet(TubeGeometry, "toJSON", this, 3)([]);
        data.path = this.parameters.path.toJSON();
        return data;
      }
    }], [{
      key: "fromJSON",
      value: function fromJSON(data) {
        // This only works for built-in curves (e.g. CatmullRomCurve3).
        // User defined curves or instances of CurvePath will not be deserialized.
        return new TubeGeometry(new Curves[data.path.type]().fromJSON(data.path), data.tubularSegments, data.radius, data.radialSegments, data.closed);
      }
    }]);
  }(BufferGeometry);
  var WireframeGeometry = exports.WireframeGeometry = /*#__PURE__*/function (_BufferGeometry15) {
    function WireframeGeometry() {
      var _this77;
      var geometry = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      (0, _classCallCheck2.default)(this, WireframeGeometry);
      _this77 = _callSuper(this, WireframeGeometry);
      _this77.type = 'WireframeGeometry';
      _this77.parameters = {
        geometry: geometry
      };
      if (geometry !== null) {
        // buffer

        var vertices = [];
        var edges = new Set();

        // helper variables

        var start = new Vector3();
        var end = new Vector3();
        if (geometry.index !== null) {
          // indexed BufferGeometry

          var position = geometry.attributes.position;
          var indices = geometry.index;
          var groups = geometry.groups;
          if (groups.length === 0) {
            groups = [{
              start: 0,
              count: indices.count,
              materialIndex: 0
            }];
          }

          // create a data structure that contains all edges without duplicates

          for (var o = 0, ol = groups.length; o < ol; ++o) {
            var group = groups[o];
            var groupStart = group.start;
            var groupCount = group.count;
            for (var i = groupStart, l = groupStart + groupCount; i < l; i += 3) {
              for (var j = 0; j < 3; j++) {
                var index1 = indices.getX(i + j);
                var index2 = indices.getX(i + (j + 1) % 3);
                start.fromBufferAttribute(position, index1);
                end.fromBufferAttribute(position, index2);
                if (isUniqueEdge(start, end, edges) === true) {
                  vertices.push(start.x, start.y, start.z);
                  vertices.push(end.x, end.y, end.z);
                }
              }
            }
          }
        } else {
          // non-indexed BufferGeometry

          var _position2 = geometry.attributes.position;
          for (var _i56 = 0, _l14 = _position2.count / 3; _i56 < _l14; _i56++) {
            for (var _j11 = 0; _j11 < 3; _j11++) {
              // three edges per triangle, an edge is represented as (index1, index2)
              // e.g. the first triangle has the following edges: (0,1),(1,2),(2,0)

              var _index2 = 3 * _i56 + _j11;
              var _index3 = 3 * _i56 + (_j11 + 1) % 3;
              start.fromBufferAttribute(_position2, _index2);
              end.fromBufferAttribute(_position2, _index3);
              if (isUniqueEdge(start, end, edges) === true) {
                vertices.push(start.x, start.y, start.z);
                vertices.push(end.x, end.y, end.z);
              }
            }
          }
        }

        // build geometry

        _this77.setAttribute('position', new Float32BufferAttribute(vertices, 3));
      }
      return _this77;
    }
    (0, _inherits2.default)(WireframeGeometry, _BufferGeometry15);
    return (0, _createClass2.default)(WireframeGeometry, [{
      key: "copy",
      value: function copy(source) {
        _superPropGet(WireframeGeometry, "copy", this, 3)([source]);
        this.parameters = Object.assign({}, source.parameters);
        return this;
      }
    }]);
  }(BufferGeometry);
  function isUniqueEdge(start, end, edges) {
    var hash1 = `${start.x},${start.y},${start.z}-${end.x},${end.y},${end.z}`;
    var hash2 = `${end.x},${end.y},${end.z}-${start.x},${start.y},${start.z}`; // coincident edge

    if (edges.has(hash1) === true || edges.has(hash2) === true) {
      return false;
    } else {
      edges.add(hash1);
      edges.add(hash2);
      return true;
    }
  }
  var Geometries = /*#__PURE__*/Object.freeze({
    __proto__: null,
    BoxGeometry: BoxGeometry,
    CapsuleGeometry: CapsuleGeometry,
    CircleGeometry: CircleGeometry,
    ConeGeometry: ConeGeometry,
    CylinderGeometry: CylinderGeometry,
    DodecahedronGeometry: DodecahedronGeometry,
    EdgesGeometry: EdgesGeometry,
    ExtrudeGeometry: ExtrudeGeometry,
    IcosahedronGeometry: IcosahedronGeometry,
    LatheGeometry: LatheGeometry,
    OctahedronGeometry: OctahedronGeometry,
    PlaneGeometry: PlaneGeometry,
    PolyhedronGeometry: PolyhedronGeometry,
    RingGeometry: RingGeometry,
    ShapeGeometry: ShapeGeometry,
    SphereGeometry: SphereGeometry,
    TetrahedronGeometry: TetrahedronGeometry,
    TorusGeometry: TorusGeometry,
    TorusKnotGeometry: TorusKnotGeometry,
    TubeGeometry: TubeGeometry,
    WireframeGeometry: WireframeGeometry
  });
  var ShadowMaterial = exports.ShadowMaterial = /*#__PURE__*/function (_Material6) {
    function ShadowMaterial(parameters) {
      var _this78;
      (0, _classCallCheck2.default)(this, ShadowMaterial);
      _this78 = _callSuper(this, ShadowMaterial);
      _this78.isShadowMaterial = true;
      _this78.type = 'ShadowMaterial';
      _this78.color = new Color(0x000000);
      _this78.transparent = true;
      _this78.fog = true;
      _this78.setValues(parameters);
      return _this78;
    }
    (0, _inherits2.default)(ShadowMaterial, _Material6);
    return (0, _createClass2.default)(ShadowMaterial, [{
      key: "copy",
      value: function copy(source) {
        _superPropGet(ShadowMaterial, "copy", this, 3)([source]);
        this.color.copy(source.color);
        this.fog = source.fog;
        return this;
      }
    }]);
  }(Material);
  var RawShaderMaterial = exports.RawShaderMaterial = /*#__PURE__*/function (_ShaderMaterial) {
    function RawShaderMaterial(parameters) {
      var _this79;
      (0, _classCallCheck2.default)(this, RawShaderMaterial);
      _this79 = _callSuper(this, RawShaderMaterial, [parameters]);
      _this79.isRawShaderMaterial = true;
      _this79.type = 'RawShaderMaterial';
      return _this79;
    }
    (0, _inherits2.default)(RawShaderMaterial, _ShaderMaterial);
    return (0, _createClass2.default)(RawShaderMaterial);
  }(ShaderMaterial);
  var MeshStandardMaterial = exports.MeshStandardMaterial = /*#__PURE__*/function (_Material7) {
    function MeshStandardMaterial(parameters) {
      var _this80;
      (0, _classCallCheck2.default)(this, MeshStandardMaterial);
      _this80 = _callSuper(this, MeshStandardMaterial);
      _this80.isMeshStandardMaterial = true;
      _this80.type = 'MeshStandardMaterial';
      _this80.defines = {
        'STANDARD': ''
      };
      _this80.color = new Color(0xffffff); // diffuse
      _this80.roughness = 1.0;
      _this80.metalness = 0.0;
      _this80.map = null;
      _this80.lightMap = null;
      _this80.lightMapIntensity = 1.0;
      _this80.aoMap = null;
      _this80.aoMapIntensity = 1.0;
      _this80.emissive = new Color(0x000000);
      _this80.emissiveIntensity = 1.0;
      _this80.emissiveMap = null;
      _this80.bumpMap = null;
      _this80.bumpScale = 1;
      _this80.normalMap = null;
      _this80.normalMapType = TangentSpaceNormalMap;
      _this80.normalScale = new Vector2(1, 1);
      _this80.displacementMap = null;
      _this80.displacementScale = 1;
      _this80.displacementBias = 0;
      _this80.roughnessMap = null;
      _this80.metalnessMap = null;
      _this80.alphaMap = null;
      _this80.envMap = null;
      _this80.envMapRotation = new Euler();
      _this80.envMapIntensity = 1.0;
      _this80.wireframe = false;
      _this80.wireframeLinewidth = 1;
      _this80.wireframeLinecap = 'round';
      _this80.wireframeLinejoin = 'round';
      _this80.flatShading = false;
      _this80.fog = true;
      _this80.setValues(parameters);
      return _this80;
    }
    (0, _inherits2.default)(MeshStandardMaterial, _Material7);
    return (0, _createClass2.default)(MeshStandardMaterial, [{
      key: "copy",
      value: function copy(source) {
        _superPropGet(MeshStandardMaterial, "copy", this, 3)([source]);
        this.defines = {
          'STANDARD': ''
        };
        this.color.copy(source.color);
        this.roughness = source.roughness;
        this.metalness = source.metalness;
        this.map = source.map;
        this.lightMap = source.lightMap;
        this.lightMapIntensity = source.lightMapIntensity;
        this.aoMap = source.aoMap;
        this.aoMapIntensity = source.aoMapIntensity;
        this.emissive.copy(source.emissive);
        this.emissiveMap = source.emissiveMap;
        this.emissiveIntensity = source.emissiveIntensity;
        this.bumpMap = source.bumpMap;
        this.bumpScale = source.bumpScale;
        this.normalMap = source.normalMap;
        this.normalMapType = source.normalMapType;
        this.normalScale.copy(source.normalScale);
        this.displacementMap = source.displacementMap;
        this.displacementScale = source.displacementScale;
        this.displacementBias = source.displacementBias;
        this.roughnessMap = source.roughnessMap;
        this.metalnessMap = source.metalnessMap;
        this.alphaMap = source.alphaMap;
        this.envMap = source.envMap;
        this.envMapRotation.copy(source.envMapRotation);
        this.envMapIntensity = source.envMapIntensity;
        this.wireframe = source.wireframe;
        this.wireframeLinewidth = source.wireframeLinewidth;
        this.wireframeLinecap = source.wireframeLinecap;
        this.wireframeLinejoin = source.wireframeLinejoin;
        this.flatShading = source.flatShading;
        this.fog = source.fog;
        return this;
      }
    }]);
  }(Material);
  var MeshPhysicalMaterial = exports.MeshPhysicalMaterial = /*#__PURE__*/function (_MeshStandardMaterial) {
    function MeshPhysicalMaterial(parameters) {
      var _this81;
      (0, _classCallCheck2.default)(this, MeshPhysicalMaterial);
      _this81 = _callSuper(this, MeshPhysicalMaterial);
      _this81.isMeshPhysicalMaterial = true;
      _this81.defines = {
        'STANDARD': '',
        'PHYSICAL': ''
      };
      _this81.type = 'MeshPhysicalMaterial';
      _this81.anisotropyRotation = 0;
      _this81.anisotropyMap = null;
      _this81.clearcoatMap = null;
      _this81.clearcoatRoughness = 0.0;
      _this81.clearcoatRoughnessMap = null;
      _this81.clearcoatNormalScale = new Vector2(1, 1);
      _this81.clearcoatNormalMap = null;
      _this81.ior = 1.5;
      Object.defineProperty(_this81, 'reflectivity', {
        get: function get() {
          return _clamp(2.5 * (this.ior - 1) / (this.ior + 1), 0, 1);
        },
        set: function set(reflectivity) {
          this.ior = (1 + 0.4 * reflectivity) / (1 - 0.4 * reflectivity);
        }
      });
      _this81.iridescenceMap = null;
      _this81.iridescenceIOR = 1.3;
      _this81.iridescenceThicknessRange = [100, 400];
      _this81.iridescenceThicknessMap = null;
      _this81.sheenColor = new Color(0x000000);
      _this81.sheenColorMap = null;
      _this81.sheenRoughness = 1.0;
      _this81.sheenRoughnessMap = null;
      _this81.transmissionMap = null;
      _this81.thickness = 0;
      _this81.thicknessMap = null;
      _this81.attenuationDistance = Infinity;
      _this81.attenuationColor = new Color(1, 1, 1);
      _this81.specularIntensity = 1.0;
      _this81.specularIntensityMap = null;
      _this81.specularColor = new Color(1, 1, 1);
      _this81.specularColorMap = null;
      _this81._anisotropy = 0;
      _this81._clearcoat = 0;
      _this81._dispersion = 0;
      _this81._iridescence = 0;
      _this81._sheen = 0.0;
      _this81._transmission = 0;
      _this81.setValues(parameters);
      return _this81;
    }
    (0, _inherits2.default)(MeshPhysicalMaterial, _MeshStandardMaterial);
    return (0, _createClass2.default)(MeshPhysicalMaterial, [{
      key: "anisotropy",
      get: function get() {
        return this._anisotropy;
      },
      set: function set(value) {
        if (this._anisotropy > 0 !== value > 0) {
          this.version++;
        }
        this._anisotropy = value;
      }
    }, {
      key: "clearcoat",
      get: function get() {
        return this._clearcoat;
      },
      set: function set(value) {
        if (this._clearcoat > 0 !== value > 0) {
          this.version++;
        }
        this._clearcoat = value;
      }
    }, {
      key: "iridescence",
      get: function get() {
        return this._iridescence;
      },
      set: function set(value) {
        if (this._iridescence > 0 !== value > 0) {
          this.version++;
        }
        this._iridescence = value;
      }
    }, {
      key: "dispersion",
      get: function get() {
        return this._dispersion;
      },
      set: function set(value) {
        if (this._dispersion > 0 !== value > 0) {
          this.version++;
        }
        this._dispersion = value;
      }
    }, {
      key: "sheen",
      get: function get() {
        return this._sheen;
      },
      set: function set(value) {
        if (this._sheen > 0 !== value > 0) {
          this.version++;
        }
        this._sheen = value;
      }
    }, {
      key: "transmission",
      get: function get() {
        return this._transmission;
      },
      set: function set(value) {
        if (this._transmission > 0 !== value > 0) {
          this.version++;
        }
        this._transmission = value;
      }
    }, {
      key: "copy",
      value: function copy(source) {
        _superPropGet(MeshPhysicalMaterial, "copy", this, 3)([source]);
        this.defines = {
          'STANDARD': '',
          'PHYSICAL': ''
        };
        this.anisotropy = source.anisotropy;
        this.anisotropyRotation = source.anisotropyRotation;
        this.anisotropyMap = source.anisotropyMap;
        this.clearcoat = source.clearcoat;
        this.clearcoatMap = source.clearcoatMap;
        this.clearcoatRoughness = source.clearcoatRoughness;
        this.clearcoatRoughnessMap = source.clearcoatRoughnessMap;
        this.clearcoatNormalMap = source.clearcoatNormalMap;
        this.clearcoatNormalScale.copy(source.clearcoatNormalScale);
        this.dispersion = source.dispersion;
        this.ior = source.ior;
        this.iridescence = source.iridescence;
        this.iridescenceMap = source.iridescenceMap;
        this.iridescenceIOR = source.iridescenceIOR;
        this.iridescenceThicknessRange = (0, _toConsumableArray2.default)(source.iridescenceThicknessRange);
        this.iridescenceThicknessMap = source.iridescenceThicknessMap;
        this.sheen = source.sheen;
        this.sheenColor.copy(source.sheenColor);
        this.sheenColorMap = source.sheenColorMap;
        this.sheenRoughness = source.sheenRoughness;
        this.sheenRoughnessMap = source.sheenRoughnessMap;
        this.transmission = source.transmission;
        this.transmissionMap = source.transmissionMap;
        this.thickness = source.thickness;
        this.thicknessMap = source.thicknessMap;
        this.attenuationDistance = source.attenuationDistance;
        this.attenuationColor.copy(source.attenuationColor);
        this.specularIntensity = source.specularIntensity;
        this.specularIntensityMap = source.specularIntensityMap;
        this.specularColor.copy(source.specularColor);
        this.specularColorMap = source.specularColorMap;
        return this;
      }
    }]);
  }(MeshStandardMaterial);
  var MeshPhongMaterial = exports.MeshPhongMaterial = /*#__PURE__*/function (_Material8) {
    function MeshPhongMaterial(parameters) {
      var _this82;
      (0, _classCallCheck2.default)(this, MeshPhongMaterial);
      _this82 = _callSuper(this, MeshPhongMaterial);
      _this82.isMeshPhongMaterial = true;
      _this82.type = 'MeshPhongMaterial';
      _this82.color = new Color(0xffffff); // diffuse
      _this82.specular = new Color(0x111111);
      _this82.shininess = 30;
      _this82.map = null;
      _this82.lightMap = null;
      _this82.lightMapIntensity = 1.0;
      _this82.aoMap = null;
      _this82.aoMapIntensity = 1.0;
      _this82.emissive = new Color(0x000000);
      _this82.emissiveIntensity = 1.0;
      _this82.emissiveMap = null;
      _this82.bumpMap = null;
      _this82.bumpScale = 1;
      _this82.normalMap = null;
      _this82.normalMapType = TangentSpaceNormalMap;
      _this82.normalScale = new Vector2(1, 1);
      _this82.displacementMap = null;
      _this82.displacementScale = 1;
      _this82.displacementBias = 0;
      _this82.specularMap = null;
      _this82.alphaMap = null;
      _this82.envMap = null;
      _this82.envMapRotation = new Euler();
      _this82.combine = MultiplyOperation;
      _this82.reflectivity = 1;
      _this82.refractionRatio = 0.98;
      _this82.wireframe = false;
      _this82.wireframeLinewidth = 1;
      _this82.wireframeLinecap = 'round';
      _this82.wireframeLinejoin = 'round';
      _this82.flatShading = false;
      _this82.fog = true;
      _this82.setValues(parameters);
      return _this82;
    }
    (0, _inherits2.default)(MeshPhongMaterial, _Material8);
    return (0, _createClass2.default)(MeshPhongMaterial, [{
      key: "copy",
      value: function copy(source) {
        _superPropGet(MeshPhongMaterial, "copy", this, 3)([source]);
        this.color.copy(source.color);
        this.specular.copy(source.specular);
        this.shininess = source.shininess;
        this.map = source.map;
        this.lightMap = source.lightMap;
        this.lightMapIntensity = source.lightMapIntensity;
        this.aoMap = source.aoMap;
        this.aoMapIntensity = source.aoMapIntensity;
        this.emissive.copy(source.emissive);
        this.emissiveMap = source.emissiveMap;
        this.emissiveIntensity = source.emissiveIntensity;
        this.bumpMap = source.bumpMap;
        this.bumpScale = source.bumpScale;
        this.normalMap = source.normalMap;
        this.normalMapType = source.normalMapType;
        this.normalScale.copy(source.normalScale);
        this.displacementMap = source.displacementMap;
        this.displacementScale = source.displacementScale;
        this.displacementBias = source.displacementBias;
        this.specularMap = source.specularMap;
        this.alphaMap = source.alphaMap;
        this.envMap = source.envMap;
        this.envMapRotation.copy(source.envMapRotation);
        this.combine = source.combine;
        this.reflectivity = source.reflectivity;
        this.refractionRatio = source.refractionRatio;
        this.wireframe = source.wireframe;
        this.wireframeLinewidth = source.wireframeLinewidth;
        this.wireframeLinecap = source.wireframeLinecap;
        this.wireframeLinejoin = source.wireframeLinejoin;
        this.flatShading = source.flatShading;
        this.fog = source.fog;
        return this;
      }
    }]);
  }(Material);
  var MeshToonMaterial = exports.MeshToonMaterial = /*#__PURE__*/function (_Material9) {
    function MeshToonMaterial(parameters) {
      var _this83;
      (0, _classCallCheck2.default)(this, MeshToonMaterial);
      _this83 = _callSuper(this, MeshToonMaterial);
      _this83.isMeshToonMaterial = true;
      _this83.defines = {
        'TOON': ''
      };
      _this83.type = 'MeshToonMaterial';
      _this83.color = new Color(0xffffff);
      _this83.map = null;
      _this83.gradientMap = null;
      _this83.lightMap = null;
      _this83.lightMapIntensity = 1.0;
      _this83.aoMap = null;
      _this83.aoMapIntensity = 1.0;
      _this83.emissive = new Color(0x000000);
      _this83.emissiveIntensity = 1.0;
      _this83.emissiveMap = null;
      _this83.bumpMap = null;
      _this83.bumpScale = 1;
      _this83.normalMap = null;
      _this83.normalMapType = TangentSpaceNormalMap;
      _this83.normalScale = new Vector2(1, 1);
      _this83.displacementMap = null;
      _this83.displacementScale = 1;
      _this83.displacementBias = 0;
      _this83.alphaMap = null;
      _this83.wireframe = false;
      _this83.wireframeLinewidth = 1;
      _this83.wireframeLinecap = 'round';
      _this83.wireframeLinejoin = 'round';
      _this83.fog = true;
      _this83.setValues(parameters);
      return _this83;
    }
    (0, _inherits2.default)(MeshToonMaterial, _Material9);
    return (0, _createClass2.default)(MeshToonMaterial, [{
      key: "copy",
      value: function copy(source) {
        _superPropGet(MeshToonMaterial, "copy", this, 3)([source]);
        this.color.copy(source.color);
        this.map = source.map;
        this.gradientMap = source.gradientMap;
        this.lightMap = source.lightMap;
        this.lightMapIntensity = source.lightMapIntensity;
        this.aoMap = source.aoMap;
        this.aoMapIntensity = source.aoMapIntensity;
        this.emissive.copy(source.emissive);
        this.emissiveMap = source.emissiveMap;
        this.emissiveIntensity = source.emissiveIntensity;
        this.bumpMap = source.bumpMap;
        this.bumpScale = source.bumpScale;
        this.normalMap = source.normalMap;
        this.normalMapType = source.normalMapType;
        this.normalScale.copy(source.normalScale);
        this.displacementMap = source.displacementMap;
        this.displacementScale = source.displacementScale;
        this.displacementBias = source.displacementBias;
        this.alphaMap = source.alphaMap;
        this.wireframe = source.wireframe;
        this.wireframeLinewidth = source.wireframeLinewidth;
        this.wireframeLinecap = source.wireframeLinecap;
        this.wireframeLinejoin = source.wireframeLinejoin;
        this.fog = source.fog;
        return this;
      }
    }]);
  }(Material);
  var MeshNormalMaterial = exports.MeshNormalMaterial = /*#__PURE__*/function (_Material10) {
    function MeshNormalMaterial(parameters) {
      var _this84;
      (0, _classCallCheck2.default)(this, MeshNormalMaterial);
      _this84 = _callSuper(this, MeshNormalMaterial);
      _this84.isMeshNormalMaterial = true;
      _this84.type = 'MeshNormalMaterial';
      _this84.bumpMap = null;
      _this84.bumpScale = 1;
      _this84.normalMap = null;
      _this84.normalMapType = TangentSpaceNormalMap;
      _this84.normalScale = new Vector2(1, 1);
      _this84.displacementMap = null;
      _this84.displacementScale = 1;
      _this84.displacementBias = 0;
      _this84.wireframe = false;
      _this84.wireframeLinewidth = 1;
      _this84.flatShading = false;
      _this84.setValues(parameters);
      return _this84;
    }
    (0, _inherits2.default)(MeshNormalMaterial, _Material10);
    return (0, _createClass2.default)(MeshNormalMaterial, [{
      key: "copy",
      value: function copy(source) {
        _superPropGet(MeshNormalMaterial, "copy", this, 3)([source]);
        this.bumpMap = source.bumpMap;
        this.bumpScale = source.bumpScale;
        this.normalMap = source.normalMap;
        this.normalMapType = source.normalMapType;
        this.normalScale.copy(source.normalScale);
        this.displacementMap = source.displacementMap;
        this.displacementScale = source.displacementScale;
        this.displacementBias = source.displacementBias;
        this.wireframe = source.wireframe;
        this.wireframeLinewidth = source.wireframeLinewidth;
        this.flatShading = source.flatShading;
        return this;
      }
    }]);
  }(Material);
  var MeshLambertMaterial = exports.MeshLambertMaterial = /*#__PURE__*/function (_Material11) {
    function MeshLambertMaterial(parameters) {
      var _this85;
      (0, _classCallCheck2.default)(this, MeshLambertMaterial);
      _this85 = _callSuper(this, MeshLambertMaterial);
      _this85.isMeshLambertMaterial = true;
      _this85.type = 'MeshLambertMaterial';
      _this85.color = new Color(0xffffff); // diffuse

      _this85.map = null;
      _this85.lightMap = null;
      _this85.lightMapIntensity = 1.0;
      _this85.aoMap = null;
      _this85.aoMapIntensity = 1.0;
      _this85.emissive = new Color(0x000000);
      _this85.emissiveIntensity = 1.0;
      _this85.emissiveMap = null;
      _this85.bumpMap = null;
      _this85.bumpScale = 1;
      _this85.normalMap = null;
      _this85.normalMapType = TangentSpaceNormalMap;
      _this85.normalScale = new Vector2(1, 1);
      _this85.displacementMap = null;
      _this85.displacementScale = 1;
      _this85.displacementBias = 0;
      _this85.specularMap = null;
      _this85.alphaMap = null;
      _this85.envMap = null;
      _this85.envMapRotation = new Euler();
      _this85.combine = MultiplyOperation;
      _this85.reflectivity = 1;
      _this85.refractionRatio = 0.98;
      _this85.wireframe = false;
      _this85.wireframeLinewidth = 1;
      _this85.wireframeLinecap = 'round';
      _this85.wireframeLinejoin = 'round';
      _this85.flatShading = false;
      _this85.fog = true;
      _this85.setValues(parameters);
      return _this85;
    }
    (0, _inherits2.default)(MeshLambertMaterial, _Material11);
    return (0, _createClass2.default)(MeshLambertMaterial, [{
      key: "copy",
      value: function copy(source) {
        _superPropGet(MeshLambertMaterial, "copy", this, 3)([source]);
        this.color.copy(source.color);
        this.map = source.map;
        this.lightMap = source.lightMap;
        this.lightMapIntensity = source.lightMapIntensity;
        this.aoMap = source.aoMap;
        this.aoMapIntensity = source.aoMapIntensity;
        this.emissive.copy(source.emissive);
        this.emissiveMap = source.emissiveMap;
        this.emissiveIntensity = source.emissiveIntensity;
        this.bumpMap = source.bumpMap;
        this.bumpScale = source.bumpScale;
        this.normalMap = source.normalMap;
        this.normalMapType = source.normalMapType;
        this.normalScale.copy(source.normalScale);
        this.displacementMap = source.displacementMap;
        this.displacementScale = source.displacementScale;
        this.displacementBias = source.displacementBias;
        this.specularMap = source.specularMap;
        this.alphaMap = source.alphaMap;
        this.envMap = source.envMap;
        this.envMapRotation.copy(source.envMapRotation);
        this.combine = source.combine;
        this.reflectivity = source.reflectivity;
        this.refractionRatio = source.refractionRatio;
        this.wireframe = source.wireframe;
        this.wireframeLinewidth = source.wireframeLinewidth;
        this.wireframeLinecap = source.wireframeLinecap;
        this.wireframeLinejoin = source.wireframeLinejoin;
        this.flatShading = source.flatShading;
        this.fog = source.fog;
        return this;
      }
    }]);
  }(Material);
  var MeshDepthMaterial = exports.MeshDepthMaterial = /*#__PURE__*/function (_Material12) {
    function MeshDepthMaterial(parameters) {
      var _this86;
      (0, _classCallCheck2.default)(this, MeshDepthMaterial);
      _this86 = _callSuper(this, MeshDepthMaterial);
      _this86.isMeshDepthMaterial = true;
      _this86.type = 'MeshDepthMaterial';
      _this86.depthPacking = BasicDepthPacking;
      _this86.map = null;
      _this86.alphaMap = null;
      _this86.displacementMap = null;
      _this86.displacementScale = 1;
      _this86.displacementBias = 0;
      _this86.wireframe = false;
      _this86.wireframeLinewidth = 1;
      _this86.setValues(parameters);
      return _this86;
    }
    (0, _inherits2.default)(MeshDepthMaterial, _Material12);
    return (0, _createClass2.default)(MeshDepthMaterial, [{
      key: "copy",
      value: function copy(source) {
        _superPropGet(MeshDepthMaterial, "copy", this, 3)([source]);
        this.depthPacking = source.depthPacking;
        this.map = source.map;
        this.alphaMap = source.alphaMap;
        this.displacementMap = source.displacementMap;
        this.displacementScale = source.displacementScale;
        this.displacementBias = source.displacementBias;
        this.wireframe = source.wireframe;
        this.wireframeLinewidth = source.wireframeLinewidth;
        return this;
      }
    }]);
  }(Material);
  var MeshDistanceMaterial = exports.MeshDistanceMaterial = /*#__PURE__*/function (_Material13) {
    function MeshDistanceMaterial(parameters) {
      var _this87;
      (0, _classCallCheck2.default)(this, MeshDistanceMaterial);
      _this87 = _callSuper(this, MeshDistanceMaterial);
      _this87.isMeshDistanceMaterial = true;
      _this87.type = 'MeshDistanceMaterial';
      _this87.map = null;
      _this87.alphaMap = null;
      _this87.displacementMap = null;
      _this87.displacementScale = 1;
      _this87.displacementBias = 0;
      _this87.setValues(parameters);
      return _this87;
    }
    (0, _inherits2.default)(MeshDistanceMaterial, _Material13);
    return (0, _createClass2.default)(MeshDistanceMaterial, [{
      key: "copy",
      value: function copy(source) {
        _superPropGet(MeshDistanceMaterial, "copy", this, 3)([source]);
        this.map = source.map;
        this.alphaMap = source.alphaMap;
        this.displacementMap = source.displacementMap;
        this.displacementScale = source.displacementScale;
        this.displacementBias = source.displacementBias;
        return this;
      }
    }]);
  }(Material);
  var MeshMatcapMaterial = exports.MeshMatcapMaterial = /*#__PURE__*/function (_Material14) {
    function MeshMatcapMaterial(parameters) {
      var _this88;
      (0, _classCallCheck2.default)(this, MeshMatcapMaterial);
      _this88 = _callSuper(this, MeshMatcapMaterial);
      _this88.isMeshMatcapMaterial = true;
      _this88.defines = {
        'MATCAP': ''
      };
      _this88.type = 'MeshMatcapMaterial';
      _this88.color = new Color(0xffffff); // diffuse

      _this88.matcap = null;
      _this88.map = null;
      _this88.bumpMap = null;
      _this88.bumpScale = 1;
      _this88.normalMap = null;
      _this88.normalMapType = TangentSpaceNormalMap;
      _this88.normalScale = new Vector2(1, 1);
      _this88.displacementMap = null;
      _this88.displacementScale = 1;
      _this88.displacementBias = 0;
      _this88.alphaMap = null;
      _this88.flatShading = false;
      _this88.fog = true;
      _this88.setValues(parameters);
      return _this88;
    }
    (0, _inherits2.default)(MeshMatcapMaterial, _Material14);
    return (0, _createClass2.default)(MeshMatcapMaterial, [{
      key: "copy",
      value: function copy(source) {
        _superPropGet(MeshMatcapMaterial, "copy", this, 3)([source]);
        this.defines = {
          'MATCAP': ''
        };
        this.color.copy(source.color);
        this.matcap = source.matcap;
        this.map = source.map;
        this.bumpMap = source.bumpMap;
        this.bumpScale = source.bumpScale;
        this.normalMap = source.normalMap;
        this.normalMapType = source.normalMapType;
        this.normalScale.copy(source.normalScale);
        this.displacementMap = source.displacementMap;
        this.displacementScale = source.displacementScale;
        this.displacementBias = source.displacementBias;
        this.alphaMap = source.alphaMap;
        this.flatShading = source.flatShading;
        this.fog = source.fog;
        return this;
      }
    }]);
  }(Material);
  var LineDashedMaterial = exports.LineDashedMaterial = /*#__PURE__*/function (_LineBasicMaterial) {
    function LineDashedMaterial(parameters) {
      var _this89;
      (0, _classCallCheck2.default)(this, LineDashedMaterial);
      _this89 = _callSuper(this, LineDashedMaterial);
      _this89.isLineDashedMaterial = true;
      _this89.type = 'LineDashedMaterial';
      _this89.scale = 1;
      _this89.dashSize = 3;
      _this89.gapSize = 1;
      _this89.setValues(parameters);
      return _this89;
    }
    (0, _inherits2.default)(LineDashedMaterial, _LineBasicMaterial);
    return (0, _createClass2.default)(LineDashedMaterial, [{
      key: "copy",
      value: function copy(source) {
        _superPropGet(LineDashedMaterial, "copy", this, 3)([source]);
        this.scale = source.scale;
        this.dashSize = source.dashSize;
        this.gapSize = source.gapSize;
        return this;
      }
    }]);
  }(LineBasicMaterial); // converts an array to a specific type
  function convertArray(array, type, forceClone) {
    if (!array ||
    // let 'undefined' and 'null' pass
    !forceClone && array.constructor === type) return array;
    if (typeof type.BYTES_PER_ELEMENT === 'number') {
      return new type(array); // create typed array
    }
    return Array.prototype.slice.call(array); // create Array
  }
  function isTypedArray(object) {
    return ArrayBuffer.isView(object) && !(object instanceof DataView);
  }

  // returns an array by which times and values can be sorted
  function getKeyframeOrder(times) {
    function compareTime(i, j) {
      return times[i] - times[j];
    }
    var n = times.length;
    var result = new Array(n);
    for (var i = 0; i !== n; ++i) result[i] = i;
    result.sort(compareTime);
    return result;
  }

  // uses the array previously returned by 'getKeyframeOrder' to sort data
  function sortedArray(values, stride, order) {
    var nValues = values.length;
    var result = new values.constructor(nValues);
    for (var i = 0, dstOffset = 0; dstOffset !== nValues; ++i) {
      var srcOffset = order[i] * stride;
      for (var j = 0; j !== stride; ++j) {
        result[dstOffset++] = values[srcOffset + j];
      }
    }
    return result;
  }

  // function for parsing AOS keyframe formats
  function flattenJSON(jsonKeys, times, values, valuePropertyName) {
    var i = 1,
      key = jsonKeys[0];
    while (key !== undefined && key[valuePropertyName] === undefined) {
      key = jsonKeys[i++];
    }
    if (key === undefined) return; // no data

    var value = key[valuePropertyName];
    if (value === undefined) return; // no data

    if (Array.isArray(value)) {
      do {
        value = key[valuePropertyName];
        if (value !== undefined) {
          times.push(key.time);
          values.push.apply(values, value); // push all elements
        }
        key = jsonKeys[i++];
      } while (key !== undefined);
    } else if (value.toArray !== undefined) {
      // ...assume THREE.Math-ish

      do {
        value = key[valuePropertyName];
        if (value !== undefined) {
          times.push(key.time);
          value.toArray(values, values.length);
        }
        key = jsonKeys[i++];
      } while (key !== undefined);
    } else {
      // otherwise push as-is

      do {
        value = key[valuePropertyName];
        if (value !== undefined) {
          times.push(key.time);
          values.push(value);
        }
        key = jsonKeys[i++];
      } while (key !== undefined);
    }
  }
  function subclip(sourceClip, name, startFrame, endFrame) {
    var fps = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 30;
    var clip = sourceClip.clone();
    clip.name = name;
    var tracks = [];
    for (var i = 0; i < clip.tracks.length; ++i) {
      var track = clip.tracks[i];
      var valueSize = track.getValueSize();
      var times = [];
      var values = [];
      for (var j = 0; j < track.times.length; ++j) {
        var frame = track.times[j] * fps;
        if (frame < startFrame || frame >= endFrame) continue;
        times.push(track.times[j]);
        for (var k = 0; k < valueSize; ++k) {
          values.push(track.values[j * valueSize + k]);
        }
      }
      if (times.length === 0) continue;
      track.times = convertArray(times, track.times.constructor);
      track.values = convertArray(values, track.values.constructor);
      tracks.push(track);
    }
    clip.tracks = tracks;

    // find minimum .times value across all tracks in the trimmed clip

    var minStartTime = Infinity;
    for (var _i57 = 0; _i57 < clip.tracks.length; ++_i57) {
      if (minStartTime > clip.tracks[_i57].times[0]) {
        minStartTime = clip.tracks[_i57].times[0];
      }
    }

    // shift all tracks such that clip begins at t=0

    for (var _i58 = 0; _i58 < clip.tracks.length; ++_i58) {
      clip.tracks[_i58].shift(-1 * minStartTime);
    }
    clip.resetDuration();
    return clip;
  }
  function makeClipAdditive(targetClip) {
    var referenceFrame = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    var referenceClip = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : targetClip;
    var fps = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 30;
    if (fps <= 0) fps = 30;
    var numTracks = referenceClip.tracks.length;
    var referenceTime = referenceFrame / fps;

    // Make each track's values relative to the values at the reference frame
    var _loop = function _loop() {
        var referenceTrack = referenceClip.tracks[i];
        var referenceTrackType = referenceTrack.ValueTypeName;

        // Skip this track if it's non-numeric
        if (referenceTrackType === 'bool' || referenceTrackType === 'string') return 0; // continue

        // Find the track in the target clip whose name and type matches the reference track
        var targetTrack = targetClip.tracks.find(function (track) {
          return track.name === referenceTrack.name && track.ValueTypeName === referenceTrackType;
        });
        if (targetTrack === undefined) return 0; // continue
        var referenceOffset = 0;
        var referenceValueSize = referenceTrack.getValueSize();
        if (referenceTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline) {
          referenceOffset = referenceValueSize / 3;
        }
        var targetOffset = 0;
        var targetValueSize = targetTrack.getValueSize();
        if (targetTrack.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline) {
          targetOffset = targetValueSize / 3;
        }
        var lastIndex = referenceTrack.times.length - 1;
        var referenceValue;

        // Find the value to subtract out of the track
        if (referenceTime <= referenceTrack.times[0]) {
          // Reference frame is earlier than the first keyframe, so just use the first keyframe
          var startIndex = referenceOffset;
          var endIndex = referenceValueSize - referenceOffset;
          referenceValue = referenceTrack.values.slice(startIndex, endIndex);
        } else if (referenceTime >= referenceTrack.times[lastIndex]) {
          // Reference frame is after the last keyframe, so just use the last keyframe
          var _startIndex = lastIndex * referenceValueSize + referenceOffset;
          var _endIndex = _startIndex + referenceValueSize - referenceOffset;
          referenceValue = referenceTrack.values.slice(_startIndex, _endIndex);
        } else {
          // Interpolate to the reference value
          var interpolant = referenceTrack.createInterpolant();
          var _startIndex2 = referenceOffset;
          var _endIndex2 = referenceValueSize - referenceOffset;
          interpolant.evaluate(referenceTime);
          referenceValue = interpolant.resultBuffer.slice(_startIndex2, _endIndex2);
        }

        // Conjugate the quaternion
        if (referenceTrackType === 'quaternion') {
          var referenceQuat = new Quaternion().fromArray(referenceValue).normalize().conjugate();
          referenceQuat.toArray(referenceValue);
        }

        // Subtract the reference value from all of the track values

        var numTimes = targetTrack.times.length;
        for (var j = 0; j < numTimes; ++j) {
          var valueStart = j * targetValueSize + targetOffset;
          if (referenceTrackType === 'quaternion') {
            // Multiply the conjugate for quaternion track types
            Quaternion.multiplyQuaternionsFlat(targetTrack.values, valueStart, referenceValue, 0, targetTrack.values, valueStart);
          } else {
            var valueEnd = targetValueSize - targetOffset * 2;

            // Subtract each value for all other numeric track types
            for (var k = 0; k < valueEnd; ++k) {
              targetTrack.values[valueStart + k] -= referenceValue[k];
            }
          }
        }
      },
      _ret;
    for (var i = 0; i < numTracks; ++i) {
      _ret = _loop();
      if (_ret === 0) continue;
    }
    targetClip.blendMode = AdditiveAnimationBlendMode;
    return targetClip;
  }
  var AnimationUtils = exports.AnimationUtils = {
    convertArray: convertArray,
    isTypedArray: isTypedArray,
    getKeyframeOrder: getKeyframeOrder,
    sortedArray: sortedArray,
    flattenJSON: flattenJSON,
    subclip: subclip,
    makeClipAdditive: makeClipAdditive
  };

  /**
   * Abstract base class of interpolants over parametric samples.
   *
   * The parameter domain is one dimensional, typically the time or a path
   * along a curve defined by the data.
   *
   * The sample values can have any dimensionality and derived classes may
   * apply special interpretations to the data.
   *
   * This class provides the interval seek in a Template Method, deferring
   * the actual interpolation to derived classes.
   *
   * Time complexity is O(1) for linear access crossing at most two points
   * and O(log N) for random access, where N is the number of positions.
   *
   * References:
   *
   * 		http://www.oodesign.com/template-method-pattern.html
   *
   */
  var Interpolant = exports.Interpolant = /*#__PURE__*/function () {
    function Interpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
      (0, _classCallCheck2.default)(this, Interpolant);
      this.parameterPositions = parameterPositions;
      this._cachedIndex = 0;
      this.resultBuffer = resultBuffer !== undefined ? resultBuffer : new sampleValues.constructor(sampleSize);
      this.sampleValues = sampleValues;
      this.valueSize = sampleSize;
      this.settings = null;
      this.DefaultSettings_ = {};
    }
    return (0, _createClass2.default)(Interpolant, [{
      key: "evaluate",
      value: function evaluate(t) {
        var pp = this.parameterPositions;
        var i1 = this._cachedIndex,
          t1 = pp[i1],
          t0 = pp[i1 - 1];
        validate_interval: {
          seek: {
            var right;
            linear_scan: {
              //- See http://jsperf.com/comparison-to-undefined/3
              //- slower code:
              //-
              //- 				if ( t >= t1 || t1 === undefined ) {
              forward_scan: if (!(t < t1)) {
                for (var giveUpAt = i1 + 2;;) {
                  if (t1 === undefined) {
                    if (t < t0) break forward_scan;

                    // after end

                    i1 = pp.length;
                    this._cachedIndex = i1;
                    return this.copySampleValue_(i1 - 1);
                  }
                  if (i1 === giveUpAt) break; // this loop

                  t0 = t1;
                  t1 = pp[++i1];
                  if (t < t1) {
                    // we have arrived at the sought interval
                    break seek;
                  }
                }

                // prepare binary search on the right side of the index
                right = pp.length;
                break linear_scan;
              }

              //- slower code:
              //-					if ( t < t0 || t0 === undefined ) {
              if (!(t >= t0)) {
                // looping?

                var t1global = pp[1];
                if (t < t1global) {
                  i1 = 2; // + 1, using the scan for the details
                  t0 = t1global;
                }

                // linear reverse scan

                for (var _giveUpAt = i1 - 2;;) {
                  if (t0 === undefined) {
                    // before start

                    this._cachedIndex = 0;
                    return this.copySampleValue_(0);
                  }
                  if (i1 === _giveUpAt) break; // this loop

                  t1 = t0;
                  t0 = pp[--i1 - 1];
                  if (t >= t0) {
                    // we have arrived at the sought interval
                    break seek;
                  }
                }

                // prepare binary search on the left side of the index
                right = i1;
                i1 = 0;
                break linear_scan;
              }

              // the interval is valid

              break validate_interval;
            } // linear scan

            // binary search

            while (i1 < right) {
              var mid = i1 + right >>> 1;
              if (t < pp[mid]) {
                right = mid;
              } else {
                i1 = mid + 1;
              }
            }
            t1 = pp[i1];
            t0 = pp[i1 - 1];

            // check boundary cases, again

            if (t0 === undefined) {
              this._cachedIndex = 0;
              return this.copySampleValue_(0);
            }
            if (t1 === undefined) {
              i1 = pp.length;
              this._cachedIndex = i1;
              return this.copySampleValue_(i1 - 1);
            }
          } // seek

          this._cachedIndex = i1;
          this.intervalChanged_(i1, t0, t1);
        } // validate_interval

        return this.interpolate_(i1, t0, t, t1);
      }
    }, {
      key: "getSettings_",
      value: function getSettings_() {
        return this.settings || this.DefaultSettings_;
      }
    }, {
      key: "copySampleValue_",
      value: function copySampleValue_(index) {
        // copies a sample value to the result buffer

        var result = this.resultBuffer,
          values = this.sampleValues,
          stride = this.valueSize,
          offset = index * stride;
        for (var i = 0; i !== stride; ++i) {
          result[i] = values[offset + i];
        }
        return result;
      }

      // Template methods for derived classes:
    }, {
      key: "interpolate_",
      value: function interpolate_(/* i1, t0, t, t1 */
      ) {
        throw new Error('call to abstract method');
        // implementations shall return this.resultBuffer
      }
    }, {
      key: "intervalChanged_",
      value: function intervalChanged_(/* i1, t0, t1 */
      ) {

        // empty
      }
    }]);
  }();
  /**
   * Fast and simple cubic spline interpolant.
   *
   * It was derived from a Hermitian construction setting the first derivative
   * at each sample position to the linear slope between neighboring positions
   * over their parameter interval.
   */
  var CubicInterpolant = exports.CubicInterpolant = /*#__PURE__*/function (_Interpolant) {
    function CubicInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
      var _this90;
      (0, _classCallCheck2.default)(this, CubicInterpolant);
      _this90 = _callSuper(this, CubicInterpolant, [parameterPositions, sampleValues, sampleSize, resultBuffer]);
      _this90._weightPrev = -0;
      _this90._offsetPrev = -0;
      _this90._weightNext = -0;
      _this90._offsetNext = -0;
      _this90.DefaultSettings_ = {
        endingStart: ZeroCurvatureEnding,
        endingEnd: ZeroCurvatureEnding
      };
      return _this90;
    }
    (0, _inherits2.default)(CubicInterpolant, _Interpolant);
    return (0, _createClass2.default)(CubicInterpolant, [{
      key: "intervalChanged_",
      value: function intervalChanged_(i1, t0, t1) {
        var pp = this.parameterPositions;
        var iPrev = i1 - 2,
          iNext = i1 + 1,
          tPrev = pp[iPrev],
          tNext = pp[iNext];
        if (tPrev === undefined) {
          switch (this.getSettings_().endingStart) {
            case ZeroSlopeEnding:
              // f'(t0) = 0
              iPrev = i1;
              tPrev = 2 * t0 - t1;
              break;
            case WrapAroundEnding:
              // use the other end of the curve
              iPrev = pp.length - 2;
              tPrev = t0 + pp[iPrev] - pp[iPrev + 1];
              break;
            default:
              // ZeroCurvatureEnding

              // f''(t0) = 0 a.k.a. Natural Spline
              iPrev = i1;
              tPrev = t1;
          }
        }
        if (tNext === undefined) {
          switch (this.getSettings_().endingEnd) {
            case ZeroSlopeEnding:
              // f'(tN) = 0
              iNext = i1;
              tNext = 2 * t1 - t0;
              break;
            case WrapAroundEnding:
              // use the other end of the curve
              iNext = 1;
              tNext = t1 + pp[1] - pp[0];
              break;
            default:
              // ZeroCurvatureEnding

              // f''(tN) = 0, a.k.a. Natural Spline
              iNext = i1 - 1;
              tNext = t0;
          }
        }
        var halfDt = (t1 - t0) * 0.5,
          stride = this.valueSize;
        this._weightPrev = halfDt / (t0 - tPrev);
        this._weightNext = halfDt / (tNext - t1);
        this._offsetPrev = iPrev * stride;
        this._offsetNext = iNext * stride;
      }
    }, {
      key: "interpolate_",
      value: function interpolate_(i1, t0, t, t1) {
        var result = this.resultBuffer,
          values = this.sampleValues,
          stride = this.valueSize,
          o1 = i1 * stride,
          o0 = o1 - stride,
          oP = this._offsetPrev,
          oN = this._offsetNext,
          wP = this._weightPrev,
          wN = this._weightNext,
          p = (t - t0) / (t1 - t0),
          pp = p * p,
          ppp = pp * p;

        // evaluate polynomials

        var sP = -wP * ppp + 2 * wP * pp - wP * p;
        var s0 = (1 + wP) * ppp + (-1.5 - 2 * wP) * pp + (-0.5 + wP) * p + 1;
        var s1 = (-1 - wN) * ppp + (1.5 + wN) * pp + 0.5 * p;
        var sN = wN * ppp - wN * pp;

        // combine data linearly

        for (var i = 0; i !== stride; ++i) {
          result[i] = sP * values[oP + i] + s0 * values[o0 + i] + s1 * values[o1 + i] + sN * values[oN + i];
        }
        return result;
      }
    }]);
  }(Interpolant);
  var LinearInterpolant = exports.LinearInterpolant = /*#__PURE__*/function (_Interpolant2) {
    function LinearInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
      (0, _classCallCheck2.default)(this, LinearInterpolant);
      return _callSuper(this, LinearInterpolant, [parameterPositions, sampleValues, sampleSize, resultBuffer]);
    }
    (0, _inherits2.default)(LinearInterpolant, _Interpolant2);
    return (0, _createClass2.default)(LinearInterpolant, [{
      key: "interpolate_",
      value: function interpolate_(i1, t0, t, t1) {
        var result = this.resultBuffer,
          values = this.sampleValues,
          stride = this.valueSize,
          offset1 = i1 * stride,
          offset0 = offset1 - stride,
          weight1 = (t - t0) / (t1 - t0),
          weight0 = 1 - weight1;
        for (var i = 0; i !== stride; ++i) {
          result[i] = values[offset0 + i] * weight0 + values[offset1 + i] * weight1;
        }
        return result;
      }
    }]);
  }(Interpolant);
  /**
   *
   * Interpolant that evaluates to the sample value at the position preceding
   * the parameter.
   */
  var DiscreteInterpolant = exports.DiscreteInterpolant = /*#__PURE__*/function (_Interpolant3) {
    function DiscreteInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
      (0, _classCallCheck2.default)(this, DiscreteInterpolant);
      return _callSuper(this, DiscreteInterpolant, [parameterPositions, sampleValues, sampleSize, resultBuffer]);
    }
    (0, _inherits2.default)(DiscreteInterpolant, _Interpolant3);
    return (0, _createClass2.default)(DiscreteInterpolant, [{
      key: "interpolate_",
      value: function interpolate_(i1 /*, t0, t, t1 */) {
        return this.copySampleValue_(i1 - 1);
      }
    }]);
  }(Interpolant);
  var KeyframeTrack = exports.KeyframeTrack = /*#__PURE__*/function () {
    function KeyframeTrack(name, times, values, interpolation) {
      (0, _classCallCheck2.default)(this, KeyframeTrack);
      if (name === undefined) throw new Error('THREE.KeyframeTrack: track name is undefined');
      if (times === undefined || times.length === 0) throw new Error('THREE.KeyframeTrack: no keyframes in track named ' + name);
      this.name = name;
      this.times = convertArray(times, this.TimeBufferType);
      this.values = convertArray(values, this.ValueBufferType);
      this.setInterpolation(interpolation || this.DefaultInterpolation);
    }

    // Serialization (in static context, because of constructor invocation
    // and automatic invocation of .toJSON):
    return (0, _createClass2.default)(KeyframeTrack, [{
      key: "InterpolantFactoryMethodDiscrete",
      value: function InterpolantFactoryMethodDiscrete(result) {
        return new DiscreteInterpolant(this.times, this.values, this.getValueSize(), result);
      }
    }, {
      key: "InterpolantFactoryMethodLinear",
      value: function InterpolantFactoryMethodLinear(result) {
        return new LinearInterpolant(this.times, this.values, this.getValueSize(), result);
      }
    }, {
      key: "InterpolantFactoryMethodSmooth",
      value: function InterpolantFactoryMethodSmooth(result) {
        return new CubicInterpolant(this.times, this.values, this.getValueSize(), result);
      }
    }, {
      key: "setInterpolation",
      value: function setInterpolation(interpolation) {
        var factoryMethod;
        switch (interpolation) {
          case InterpolateDiscrete:
            factoryMethod = this.InterpolantFactoryMethodDiscrete;
            break;
          case InterpolateLinear:
            factoryMethod = this.InterpolantFactoryMethodLinear;
            break;
          case InterpolateSmooth:
            factoryMethod = this.InterpolantFactoryMethodSmooth;
            break;
        }
        if (factoryMethod === undefined) {
          var message = 'unsupported interpolation for ' + this.ValueTypeName + ' keyframe track named ' + this.name;
          if (this.createInterpolant === undefined) {
            // fall back to default, unless the default itself is messed up
            if (interpolation !== this.DefaultInterpolation) {
              this.setInterpolation(this.DefaultInterpolation);
            } else {
              throw new Error(message); // fatal, in this case
            }
          }
          console.warn('THREE.KeyframeTrack:', message);
          return this;
        }
        this.createInterpolant = factoryMethod;
        return this;
      }
    }, {
      key: "getInterpolation",
      value: function getInterpolation() {
        switch (this.createInterpolant) {
          case this.InterpolantFactoryMethodDiscrete:
            return InterpolateDiscrete;
          case this.InterpolantFactoryMethodLinear:
            return InterpolateLinear;
          case this.InterpolantFactoryMethodSmooth:
            return InterpolateSmooth;
        }
      }
    }, {
      key: "getValueSize",
      value: function getValueSize() {
        return this.values.length / this.times.length;
      }

      // move all keyframes either forwards or backwards in time
    }, {
      key: "shift",
      value: function shift(timeOffset) {
        if (timeOffset !== 0.0) {
          var times = this.times;
          for (var i = 0, n = times.length; i !== n; ++i) {
            times[i] += timeOffset;
          }
        }
        return this;
      }

      // scale all keyframe times by a factor (useful for frame <-> seconds conversions)
    }, {
      key: "scale",
      value: function scale(timeScale) {
        if (timeScale !== 1.0) {
          var times = this.times;
          for (var i = 0, n = times.length; i !== n; ++i) {
            times[i] *= timeScale;
          }
        }
        return this;
      }

      // removes keyframes before and after animation without changing any values within the range [startTime, endTime].
      // IMPORTANT: We do not shift around keys to the start of the track time, because for interpolated keys this will change their values
    }, {
      key: "trim",
      value: function trim(startTime, endTime) {
        var times = this.times,
          nKeys = times.length;
        var from = 0,
          to = nKeys - 1;
        while (from !== nKeys && times[from] < startTime) {
          ++from;
        }
        while (to !== -1 && times[to] > endTime) {
          --to;
        }
        ++to; // inclusive -> exclusive bound

        if (from !== 0 || to !== nKeys) {
          // empty tracks are forbidden, so keep at least one keyframe
          if (from >= to) {
            to = Math.max(to, 1);
            from = to - 1;
          }
          var stride = this.getValueSize();
          this.times = times.slice(from, to);
          this.values = this.values.slice(from * stride, to * stride);
        }
        return this;
      }

      // ensure we do not get a GarbageInGarbageOut situation, make sure tracks are at least minimally viable
    }, {
      key: "validate",
      value: function validate() {
        var valid = true;
        var valueSize = this.getValueSize();
        if (valueSize - Math.floor(valueSize) !== 0) {
          console.error('THREE.KeyframeTrack: Invalid value size in track.', this);
          valid = false;
        }
        var times = this.times,
          values = this.values,
          nKeys = times.length;
        if (nKeys === 0) {
          console.error('THREE.KeyframeTrack: Track is empty.', this);
          valid = false;
        }
        var prevTime = null;
        for (var i = 0; i !== nKeys; i++) {
          var currTime = times[i];
          if (typeof currTime === 'number' && isNaN(currTime)) {
            console.error('THREE.KeyframeTrack: Time is not a valid number.', this, i, currTime);
            valid = false;
            break;
          }
          if (prevTime !== null && prevTime > currTime) {
            console.error('THREE.KeyframeTrack: Out of order keys.', this, i, currTime, prevTime);
            valid = false;
            break;
          }
          prevTime = currTime;
        }
        if (values !== undefined) {
          if (isTypedArray(values)) {
            for (var _i59 = 0, n = values.length; _i59 !== n; ++_i59) {
              var value = values[_i59];
              if (isNaN(value)) {
                console.error('THREE.KeyframeTrack: Value is not a valid number.', this, _i59, value);
                valid = false;
                break;
              }
            }
          }
        }
        return valid;
      }

      // removes equivalent sequential keys as common in morph target sequences
      // (0,0,0,0,1,1,1,0,0,0,0,0,0,0) --> (0,0,1,1,0,0)
    }, {
      key: "optimize",
      value: function optimize() {
        // times or values may be shared with other tracks, so overwriting is unsafe
        var times = this.times.slice(),
          values = this.values.slice(),
          stride = this.getValueSize(),
          smoothInterpolation = this.getInterpolation() === InterpolateSmooth,
          lastIndex = times.length - 1;
        var writeIndex = 1;
        for (var i = 1; i < lastIndex; ++i) {
          var keep = false;
          var time = times[i];
          var timeNext = times[i + 1];

          // remove adjacent keyframes scheduled at the same time

          if (time !== timeNext && (i !== 1 || time !== times[0])) {
            if (!smoothInterpolation) {
              // remove unnecessary keyframes same as their neighbors

              var offset = i * stride,
                offsetP = offset - stride,
                offsetN = offset + stride;
              for (var j = 0; j !== stride; ++j) {
                var value = values[offset + j];
                if (value !== values[offsetP + j] || value !== values[offsetN + j]) {
                  keep = true;
                  break;
                }
              }
            } else {
              keep = true;
            }
          }

          // in-place compaction

          if (keep) {
            if (i !== writeIndex) {
              times[writeIndex] = times[i];
              var readOffset = i * stride,
                writeOffset = writeIndex * stride;
              for (var _j12 = 0; _j12 !== stride; ++_j12) {
                values[writeOffset + _j12] = values[readOffset + _j12];
              }
            }
            ++writeIndex;
          }
        }

        // flush last keyframe (compaction looks ahead)

        if (lastIndex > 0) {
          times[writeIndex] = times[lastIndex];
          for (var _readOffset = lastIndex * stride, _writeOffset = writeIndex * stride, _j13 = 0; _j13 !== stride; ++_j13) {
            values[_writeOffset + _j13] = values[_readOffset + _j13];
          }
          ++writeIndex;
        }
        if (writeIndex !== times.length) {
          this.times = times.slice(0, writeIndex);
          this.values = values.slice(0, writeIndex * stride);
        } else {
          this.times = times;
          this.values = values;
        }
        return this;
      }
    }, {
      key: "clone",
      value: function clone() {
        var times = this.times.slice();
        var values = this.values.slice();
        var TypedKeyframeTrack = this.constructor;
        var track = new TypedKeyframeTrack(this.name, times, values);

        // Interpolant argument to constructor is not saved, so copy the factory method directly.
        track.createInterpolant = this.createInterpolant;
        return track;
      }
    }], [{
      key: "toJSON",
      value: function toJSON(track) {
        var trackType = track.constructor;
        var json;

        // derived classes can define a static toJSON method
        if (trackType.toJSON !== this.toJSON) {
          json = trackType.toJSON(track);
        } else {
          // by default, we assume the data can be serialized as-is
          json = {
            'name': track.name,
            'times': convertArray(track.times, Array),
            'values': convertArray(track.values, Array)
          };
          var interpolation = track.getInterpolation();
          if (interpolation !== track.DefaultInterpolation) {
            json.interpolation = interpolation;
          }
        }
        json.type = track.ValueTypeName; // mandatory

        return json;
      }
    }]);
  }();
  KeyframeTrack.prototype.TimeBufferType = Float32Array;
  KeyframeTrack.prototype.ValueBufferType = Float32Array;
  KeyframeTrack.prototype.DefaultInterpolation = InterpolateLinear;

  /**
   * A Track of Boolean keyframe values.
   */
  var BooleanKeyframeTrack = exports.BooleanKeyframeTrack = /*#__PURE__*/function (_KeyframeTrack) {
    // No interpolation parameter because only InterpolateDiscrete is valid.
    function BooleanKeyframeTrack(name, times, values) {
      (0, _classCallCheck2.default)(this, BooleanKeyframeTrack);
      return _callSuper(this, BooleanKeyframeTrack, [name, times, values]);
    }
    (0, _inherits2.default)(BooleanKeyframeTrack, _KeyframeTrack);
    return (0, _createClass2.default)(BooleanKeyframeTrack);
  }(KeyframeTrack);
  BooleanKeyframeTrack.prototype.ValueTypeName = 'bool';
  BooleanKeyframeTrack.prototype.ValueBufferType = Array;
  BooleanKeyframeTrack.prototype.DefaultInterpolation = InterpolateDiscrete;
  BooleanKeyframeTrack.prototype.InterpolantFactoryMethodLinear = undefined;
  BooleanKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = undefined;

  /**
   * A Track of keyframe values that represent color.
   */
  var ColorKeyframeTrack = exports.ColorKeyframeTrack = /*#__PURE__*/function (_KeyframeTrack2) {
    function ColorKeyframeTrack() {
      (0, _classCallCheck2.default)(this, ColorKeyframeTrack);
      return _callSuper(this, ColorKeyframeTrack, arguments);
    }
    (0, _inherits2.default)(ColorKeyframeTrack, _KeyframeTrack2);
    return (0, _createClass2.default)(ColorKeyframeTrack);
  }(KeyframeTrack);
  ColorKeyframeTrack.prototype.ValueTypeName = 'color';

  /**
   * A Track of numeric keyframe values.
   */
  var NumberKeyframeTrack = exports.NumberKeyframeTrack = /*#__PURE__*/function (_KeyframeTrack3) {
    function NumberKeyframeTrack() {
      (0, _classCallCheck2.default)(this, NumberKeyframeTrack);
      return _callSuper(this, NumberKeyframeTrack, arguments);
    }
    (0, _inherits2.default)(NumberKeyframeTrack, _KeyframeTrack3);
    return (0, _createClass2.default)(NumberKeyframeTrack);
  }(KeyframeTrack);
  NumberKeyframeTrack.prototype.ValueTypeName = 'number';

  /**
   * Spherical linear unit quaternion interpolant.
   */
  var QuaternionLinearInterpolant = exports.QuaternionLinearInterpolant = /*#__PURE__*/function (_Interpolant4) {
    function QuaternionLinearInterpolant(parameterPositions, sampleValues, sampleSize, resultBuffer) {
      (0, _classCallCheck2.default)(this, QuaternionLinearInterpolant);
      return _callSuper(this, QuaternionLinearInterpolant, [parameterPositions, sampleValues, sampleSize, resultBuffer]);
    }
    (0, _inherits2.default)(QuaternionLinearInterpolant, _Interpolant4);
    return (0, _createClass2.default)(QuaternionLinearInterpolant, [{
      key: "interpolate_",
      value: function interpolate_(i1, t0, t, t1) {
        var result = this.resultBuffer,
          values = this.sampleValues,
          stride = this.valueSize,
          alpha = (t - t0) / (t1 - t0);
        var offset = i1 * stride;
        for (var end = offset + stride; offset !== end; offset += 4) {
          Quaternion.slerpFlat(result, 0, values, offset - stride, values, offset, alpha);
        }
        return result;
      }
    }]);
  }(Interpolant);
  /**
   * A Track of quaternion keyframe values.
   */
  var QuaternionKeyframeTrack = exports.QuaternionKeyframeTrack = /*#__PURE__*/function (_KeyframeTrack4) {
    function QuaternionKeyframeTrack() {
      (0, _classCallCheck2.default)(this, QuaternionKeyframeTrack);
      return _callSuper(this, QuaternionKeyframeTrack, arguments);
    }
    (0, _inherits2.default)(QuaternionKeyframeTrack, _KeyframeTrack4);
    return (0, _createClass2.default)(QuaternionKeyframeTrack, [{
      key: "InterpolantFactoryMethodLinear",
      value: function InterpolantFactoryMethodLinear(result) {
        return new QuaternionLinearInterpolant(this.times, this.values, this.getValueSize(), result);
      }
    }]);
  }(KeyframeTrack);
  QuaternionKeyframeTrack.prototype.ValueTypeName = 'quaternion';
  // ValueBufferType is inherited
  // DefaultInterpolation is inherited;
  QuaternionKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = undefined;

  /**
   * A Track that interpolates Strings
   */
  var StringKeyframeTrack = exports.StringKeyframeTrack = /*#__PURE__*/function (_KeyframeTrack5) {
    // No interpolation parameter because only InterpolateDiscrete is valid.
    function StringKeyframeTrack(name, times, values) {
      (0, _classCallCheck2.default)(this, StringKeyframeTrack);
      return _callSuper(this, StringKeyframeTrack, [name, times, values]);
    }
    (0, _inherits2.default)(StringKeyframeTrack, _KeyframeTrack5);
    return (0, _createClass2.default)(StringKeyframeTrack);
  }(KeyframeTrack);
  StringKeyframeTrack.prototype.ValueTypeName = 'string';
  StringKeyframeTrack.prototype.ValueBufferType = Array;
  StringKeyframeTrack.prototype.DefaultInterpolation = InterpolateDiscrete;
  StringKeyframeTrack.prototype.InterpolantFactoryMethodLinear = undefined;
  StringKeyframeTrack.prototype.InterpolantFactoryMethodSmooth = undefined;

  /**
   * A Track of vectored keyframe values.
   */
  var VectorKeyframeTrack = exports.VectorKeyframeTrack = /*#__PURE__*/function (_KeyframeTrack6) {
    function VectorKeyframeTrack() {
      (0, _classCallCheck2.default)(this, VectorKeyframeTrack);
      return _callSuper(this, VectorKeyframeTrack, arguments);
    }
    (0, _inherits2.default)(VectorKeyframeTrack, _KeyframeTrack6);
    return (0, _createClass2.default)(VectorKeyframeTrack);
  }(KeyframeTrack);
  VectorKeyframeTrack.prototype.ValueTypeName = 'vector';
  var AnimationClip = exports.AnimationClip = /*#__PURE__*/function () {
    function AnimationClip() {
      var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
      var duration = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : -1;
      var tracks = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
      var blendMode = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : NormalAnimationBlendMode;
      (0, _classCallCheck2.default)(this, AnimationClip);
      this.name = name;
      this.tracks = tracks;
      this.duration = duration;
      this.blendMode = blendMode;
      this.uuid = generateUUID();

      // this means it should figure out its duration by scanning the tracks
      if (this.duration < 0) {
        this.resetDuration();
      }
    }
    return (0, _createClass2.default)(AnimationClip, [{
      key: "resetDuration",
      value: function resetDuration() {
        var tracks = this.tracks;
        var duration = 0;
        for (var i = 0, n = tracks.length; i !== n; ++i) {
          var track = this.tracks[i];
          duration = Math.max(duration, track.times[track.times.length - 1]);
        }
        this.duration = duration;
        return this;
      }
    }, {
      key: "trim",
      value: function trim() {
        for (var i = 0; i < this.tracks.length; i++) {
          this.tracks[i].trim(0, this.duration);
        }
        return this;
      }
    }, {
      key: "validate",
      value: function validate() {
        var valid = true;
        for (var i = 0; i < this.tracks.length; i++) {
          valid = valid && this.tracks[i].validate();
        }
        return valid;
      }
    }, {
      key: "optimize",
      value: function optimize() {
        for (var i = 0; i < this.tracks.length; i++) {
          this.tracks[i].optimize();
        }
        return this;
      }
    }, {
      key: "clone",
      value: function clone() {
        var tracks = [];
        for (var i = 0; i < this.tracks.length; i++) {
          tracks.push(this.tracks[i].clone());
        }
        return new this.constructor(this.name, this.duration, tracks, this.blendMode);
      }
    }, {
      key: "toJSON",
      value: function toJSON() {
        return this.constructor.toJSON(this);
      }
    }], [{
      key: "parse",
      value: function parse(json) {
        var tracks = [],
          jsonTracks = json.tracks,
          frameTime = 1.0 / (json.fps || 1.0);
        for (var i = 0, n = jsonTracks.length; i !== n; ++i) {
          tracks.push(parseKeyframeTrack(jsonTracks[i]).scale(frameTime));
        }
        var clip = new this(json.name, json.duration, tracks, json.blendMode);
        clip.uuid = json.uuid;
        return clip;
      }
    }, {
      key: "toJSON",
      value: function toJSON(clip) {
        var tracks = [],
          clipTracks = clip.tracks;
        var json = {
          'name': clip.name,
          'duration': clip.duration,
          'tracks': tracks,
          'uuid': clip.uuid,
          'blendMode': clip.blendMode
        };
        for (var i = 0, n = clipTracks.length; i !== n; ++i) {
          tracks.push(KeyframeTrack.toJSON(clipTracks[i]));
        }
        return json;
      }
    }, {
      key: "CreateFromMorphTargetSequence",
      value: function CreateFromMorphTargetSequence(name, morphTargetSequence, fps, noLoop) {
        var numMorphTargets = morphTargetSequence.length;
        var tracks = [];
        for (var i = 0; i < numMorphTargets; i++) {
          var times = [];
          var values = [];
          times.push((i + numMorphTargets - 1) % numMorphTargets, i, (i + 1) % numMorphTargets);
          values.push(0, 1, 0);
          var order = getKeyframeOrder(times);
          times = sortedArray(times, 1, order);
          values = sortedArray(values, 1, order);

          // if there is a key at the first frame, duplicate it as the
          // last frame as well for perfect loop.
          if (!noLoop && times[0] === 0) {
            times.push(numMorphTargets);
            values.push(values[0]);
          }
          tracks.push(new NumberKeyframeTrack('.morphTargetInfluences[' + morphTargetSequence[i].name + ']', times, values).scale(1.0 / fps));
        }
        return new this(name, -1, tracks);
      }
    }, {
      key: "findByName",
      value: function findByName(objectOrClipArray, name) {
        var clipArray = objectOrClipArray;
        if (!Array.isArray(objectOrClipArray)) {
          var o = objectOrClipArray;
          clipArray = o.geometry && o.geometry.animations || o.animations;
        }
        for (var i = 0; i < clipArray.length; i++) {
          if (clipArray[i].name === name) {
            return clipArray[i];
          }
        }
        return null;
      }
    }, {
      key: "CreateClipsFromMorphTargetSequences",
      value: function CreateClipsFromMorphTargetSequences(morphTargets, fps, noLoop) {
        var animationToMorphTargets = {};

        // tested with https://regex101.com/ on trick sequences
        // such flamingo_flyA_003, flamingo_run1_003, crdeath0059
        var pattern = /^([\w-]*?)([\d]+)$/;

        // sort morph target names into animation groups based
        // patterns like Walk_001, Walk_002, Run_001, Run_002
        for (var i = 0, il = morphTargets.length; i < il; i++) {
          var morphTarget = morphTargets[i];
          var parts = morphTarget.name.match(pattern);
          if (parts && parts.length > 1) {
            var name = parts[1];
            var animationMorphTargets = animationToMorphTargets[name];
            if (!animationMorphTargets) {
              animationToMorphTargets[name] = animationMorphTargets = [];
            }
            animationMorphTargets.push(morphTarget);
          }
        }
        var clips = [];
        for (var _name3 in animationToMorphTargets) {
          clips.push(this.CreateFromMorphTargetSequence(_name3, animationToMorphTargets[_name3], fps, noLoop));
        }
        return clips;
      }

      // parse the animation.hierarchy format
    }, {
      key: "parseAnimation",
      value: function parseAnimation(animation, bones) {
        if (!animation) {
          console.error('THREE.AnimationClip: No animation in JSONLoader data.');
          return null;
        }
        var addNonemptyTrack = function addNonemptyTrack(trackType, trackName, animationKeys, propertyName, destTracks) {
          // only return track if there are actually keys.
          if (animationKeys.length !== 0) {
            var times = [];
            var values = [];
            flattenJSON(animationKeys, times, values, propertyName);

            // empty keys are filtered out, so check again
            if (times.length !== 0) {
              destTracks.push(new trackType(trackName, times, values));
            }
          }
        };
        var tracks = [];
        var clipName = animation.name || 'default';
        var fps = animation.fps || 30;
        var blendMode = animation.blendMode;

        // automatic length determination in AnimationClip.
        var duration = animation.length || -1;
        var hierarchyTracks = animation.hierarchy || [];
        for (var h = 0; h < hierarchyTracks.length; h++) {
          var animationKeys = hierarchyTracks[h].keys;

          // skip empty tracks
          if (!animationKeys || animationKeys.length === 0) continue;

          // process morph targets
          if (animationKeys[0].morphTargets) {
            // figure out all morph targets used in this track
            var morphTargetNames = {};
            var k = void 0;
            for (k = 0; k < animationKeys.length; k++) {
              if (animationKeys[k].morphTargets) {
                for (var m = 0; m < animationKeys[k].morphTargets.length; m++) {
                  morphTargetNames[animationKeys[k].morphTargets[m]] = -1;
                }
              }
            }

            // create a track for each morph target with all zero
            // morphTargetInfluences except for the keys in which
            // the morphTarget is named.
            for (var morphTargetName in morphTargetNames) {
              var times = [];
              var values = [];
              for (var _m = 0; _m !== animationKeys[k].morphTargets.length; ++_m) {
                var animationKey = animationKeys[k];
                times.push(animationKey.time);
                values.push(animationKey.morphTarget === morphTargetName ? 1 : 0);
              }
              tracks.push(new NumberKeyframeTrack('.morphTargetInfluence[' + morphTargetName + ']', times, values));
            }
            duration = morphTargetNames.length * fps;
          } else {
            // ...assume skeletal animation

            var boneName = '.bones[' + bones[h].name + ']';
            addNonemptyTrack(VectorKeyframeTrack, boneName + '.position', animationKeys, 'pos', tracks);
            addNonemptyTrack(QuaternionKeyframeTrack, boneName + '.quaternion', animationKeys, 'rot', tracks);
            addNonemptyTrack(VectorKeyframeTrack, boneName + '.scale', animationKeys, 'scl', tracks);
          }
        }
        if (tracks.length === 0) {
          return null;
        }
        var clip = new this(clipName, duration, tracks, blendMode);
        return clip;
      }
    }]);
  }();
  function getTrackTypeForValueTypeName(typeName) {
    switch (typeName.toLowerCase()) {
      case 'scalar':
      case 'double':
      case 'float':
      case 'number':
      case 'integer':
        return NumberKeyframeTrack;
      case 'vector':
      case 'vector2':
      case 'vector3':
      case 'vector4':
        return VectorKeyframeTrack;
      case 'color':
        return ColorKeyframeTrack;
      case 'quaternion':
        return QuaternionKeyframeTrack;
      case 'bool':
      case 'boolean':
        return BooleanKeyframeTrack;
      case 'string':
        return StringKeyframeTrack;
    }
    throw new Error('THREE.KeyframeTrack: Unsupported typeName: ' + typeName);
  }
  function parseKeyframeTrack(json) {
    if (json.type === undefined) {
      throw new Error('THREE.KeyframeTrack: track type undefined, can not parse');
    }
    var trackType = getTrackTypeForValueTypeName(json.type);
    if (json.times === undefined) {
      var times = [],
        values = [];
      flattenJSON(json.keys, times, values, 'value');
      json.times = times;
      json.values = values;
    }

    // derived classes can define a static parse method
    if (trackType.parse !== undefined) {
      return trackType.parse(json);
    } else {
      // by default, we assume a constructor compatible with the base
      return new trackType(json.name, json.times, json.values, json.interpolation);
    }
  }
  var Cache = exports.Cache = {
    enabled: false,
    files: {},
    add: function add(key, file) {
      if (this.enabled === false) return;

      // console.log( 'THREE.Cache', 'Adding key:', key );

      this.files[key] = file;
    },
    get: function get(key) {
      if (this.enabled === false) return;

      // console.log( 'THREE.Cache', 'Checking key:', key );

      return this.files[key];
    },
    remove: function remove(key) {
      delete this.files[key];
    },
    clear: function clear() {
      this.files = {};
    }
  };
  var LoadingManager = exports.LoadingManager = /*#__PURE__*/(0, _createClass2.default)(function LoadingManager(onLoad, onProgress, onError) {
    (0, _classCallCheck2.default)(this, LoadingManager);
    var scope = this;
    var isLoading = false;
    var itemsLoaded = 0;
    var itemsTotal = 0;
    var urlModifier = undefined;
    var handlers = [];

    // Refer to #5689 for the reason why we don't set .onStart
    // in the constructor

    this.onStart = undefined;
    this.onLoad = onLoad;
    this.onProgress = onProgress;
    this.onError = onError;
    this.itemStart = function (url) {
      itemsTotal++;
      if (isLoading === false) {
        if (scope.onStart !== undefined) {
          scope.onStart(url, itemsLoaded, itemsTotal);
        }
      }
      isLoading = true;
    };
    this.itemEnd = function (url) {
      itemsLoaded++;
      if (scope.onProgress !== undefined) {
        scope.onProgress(url, itemsLoaded, itemsTotal);
      }
      if (itemsLoaded === itemsTotal) {
        isLoading = false;
        if (scope.onLoad !== undefined) {
          scope.onLoad();
        }
      }
    };
    this.itemError = function (url) {
      if (scope.onError !== undefined) {
        scope.onError(url);
      }
    };
    this.resolveURL = function (url) {
      if (urlModifier) {
        return urlModifier(url);
      }
      return url;
    };
    this.setURLModifier = function (transform) {
      urlModifier = transform;
      return this;
    };
    this.addHandler = function (regex, loader) {
      handlers.push(regex, loader);
      return this;
    };
    this.removeHandler = function (regex) {
      var index = handlers.indexOf(regex);
      if (index !== -1) {
        handlers.splice(index, 2);
      }
      return this;
    };
    this.getHandler = function (file) {
      for (var i = 0, l = handlers.length; i < l; i += 2) {
        var regex = handlers[i];
        var loader = handlers[i + 1];
        if (regex.global) regex.lastIndex = 0; // see #17920

        if (regex.test(file)) {
          return loader;
        }
      }
      return null;
    };
  });
  var DefaultLoadingManager = exports.DefaultLoadingManager = /*@__PURE__*/new LoadingManager();
  var Loader = exports.Loader = /*#__PURE__*/function () {
    function Loader(manager) {
      (0, _classCallCheck2.default)(this, Loader);
      this.manager = manager !== undefined ? manager : DefaultLoadingManager;
      this.crossOrigin = 'anonymous';
      this.withCredentials = false;
      this.path = '';
      this.resourcePath = '';
      this.requestHeader = {};
    }
    return (0, _createClass2.default)(Loader, [{
      key: "load",
      value: function load(/* url, onLoad, onProgress, onError */) {}
    }, {
      key: "loadAsync",
      value: function loadAsync(url, onProgress) {
        var scope = this;
        return new Promise(function (resolve, reject) {
          scope.load(url, resolve, onProgress, reject);
        });
      }
    }, {
      key: "parse",
      value: function parse(/* data */) {}
    }, {
      key: "setCrossOrigin",
      value: function setCrossOrigin(crossOrigin) {
        this.crossOrigin = crossOrigin;
        return this;
      }
    }, {
      key: "setWithCredentials",
      value: function setWithCredentials(value) {
        this.withCredentials = value;
        return this;
      }
    }, {
      key: "setPath",
      value: function setPath(path) {
        this.path = path;
        return this;
      }
    }, {
      key: "setResourcePath",
      value: function setResourcePath(resourcePath) {
        this.resourcePath = resourcePath;
        return this;
      }
    }, {
      key: "setRequestHeader",
      value: function setRequestHeader(requestHeader) {
        this.requestHeader = requestHeader;
        return this;
      }
    }]);
  }();
  Loader.DEFAULT_MATERIAL_NAME = '__DEFAULT';
  var loading = {};
  var HttpError = /*#__PURE__*/function (_Error) {
    function HttpError(message, response) {
      var _this91;
      (0, _classCallCheck2.default)(this, HttpError);
      _this91 = _callSuper(this, HttpError, [message]);
      _this91.response = response;
      return _this91;
    }
    (0, _inherits2.default)(HttpError, _Error);
    return (0, _createClass2.default)(HttpError);
  }(/*#__PURE__*/(0, _wrapNativeSuper2.default)(Error));
  var FileLoader = exports.FileLoader = /*#__PURE__*/function (_Loader) {
    function FileLoader(manager) {
      (0, _classCallCheck2.default)(this, FileLoader);
      return _callSuper(this, FileLoader, [manager]);
    }
    (0, _inherits2.default)(FileLoader, _Loader);
    return (0, _createClass2.default)(FileLoader, [{
      key: "load",
      value: function load(url, onLoad, onProgress, onError) {
        var _this92 = this;
        if (url === undefined) url = '';
        if (this.path !== undefined) url = this.path + url;
        url = this.manager.resolveURL(url);
        var cached = Cache.get(url);
        if (cached !== undefined) {
          this.manager.itemStart(url);
          setTimeout(function () {
            if (onLoad) onLoad(cached);
            _this92.manager.itemEnd(url);
          }, 0);
          return cached;
        }

        // Check if request is duplicate

        if (loading[url] !== undefined) {
          loading[url].push({
            onLoad: onLoad,
            onProgress: onProgress,
            onError: onError
          });
          return;
        }

        // Initialise array for duplicate requests
        loading[url] = [];
        loading[url].push({
          onLoad: onLoad,
          onProgress: onProgress,
          onError: onError
        });

        // create request
        var req = new Request(url, {
          headers: new Headers(this.requestHeader),
          credentials: this.withCredentials ? 'include' : 'same-origin'
          // An abort controller could be added within a future PR
        });

        // record states ( avoid data race )
        var mimeType = this.mimeType;
        var responseType = this.responseType;

        // start the fetch
        fetch(req).then(function (response) {
          if (response.status === 200 || response.status === 0) {
            // Some browsers return HTTP Status 0 when using non-http protocol
            // e.g. 'file://' or 'data://'. Handle as success.

            if (response.status === 0) {
              console.warn('THREE.FileLoader: HTTP Status 0 received.');
            }

            // Workaround: Checking if response.body === undefined for Alipay browser #23548

            if (typeof ReadableStream === 'undefined' || response.body === undefined || response.body.getReader === undefined) {
              return response;
            }
            var callbacks = loading[url];
            var reader = response.body.getReader();

            // Nginx needs X-File-Size check
            // https://serverfault.com/questions/482875/why-does-nginx-remove-content-length-header-for-chunked-content
            var contentLength = response.headers.get('X-File-Size') || response.headers.get('Content-Length');
            var total = contentLength ? parseInt(contentLength) : 0;
            var lengthComputable = total !== 0;
            var loaded = 0;

            // periodically read data into the new stream tracking while download progress
            var stream = new ReadableStream({
              start: function start(controller) {
                readData();
                function readData() {
                  reader.read().then(function (_ref) {
                    var done = _ref.done,
                      value = _ref.value;
                    if (done) {
                      controller.close();
                    } else {
                      loaded += value.byteLength;
                      var event = new ProgressEvent('progress', {
                        lengthComputable: lengthComputable,
                        loaded: loaded,
                        total: total
                      });
                      for (var i = 0, il = callbacks.length; i < il; i++) {
                        var callback = callbacks[i];
                        if (callback.onProgress) callback.onProgress(event);
                      }
                      controller.enqueue(value);
                      readData();
                    }
                  }, function (e) {
                    controller.error(e);
                  });
                }
              }
            });
            return new Response(stream);
          } else {
            throw new HttpError(`fetch for "${response.url}" responded with ${response.status}: ${response.statusText}`, response);
          }
        }).then(function (response) {
          switch (responseType) {
            case 'arraybuffer':
              return response.arrayBuffer();
            case 'blob':
              return response.blob();
            case 'document':
              return response.text().then(function (text) {
                var parser = new DOMParser();
                return parser.parseFromString(text, mimeType);
              });
            case 'json':
              return response.json();
            default:
              if (mimeType === undefined) {
                return response.text();
              } else {
                // sniff encoding
                var re = /charset="?([^;"\s]*)"?/i;
                var exec = re.exec(mimeType);
                var label = exec && exec[1] ? exec[1].toLowerCase() : undefined;
                var decoder = new TextDecoder(label);
                return response.arrayBuffer().then(function (ab) {
                  return decoder.decode(ab);
                });
              }
          }
        }).then(function (data) {
          // Add to cache only on HTTP success, so that we do not cache
          // error response bodies as proper responses to requests.
          Cache.add(url, data);
          var callbacks = loading[url];
          delete loading[url];
          for (var i = 0, il = callbacks.length; i < il; i++) {
            var callback = callbacks[i];
            if (callback.onLoad) callback.onLoad(data);
          }
        }).catch(function (err) {
          // Abort errors and other errors are handled the same

          var callbacks = loading[url];
          if (callbacks === undefined) {
            // When onLoad was called and url was deleted in `loading`
            _this92.manager.itemError(url);
            throw err;
          }
          delete loading[url];
          for (var i = 0, il = callbacks.length; i < il; i++) {
            var callback = callbacks[i];
            if (callback.onError) callback.onError(err);
          }
          _this92.manager.itemError(url);
        }).finally(function () {
          _this92.manager.itemEnd(url);
        });
        this.manager.itemStart(url);
      }
    }, {
      key: "setResponseType",
      value: function setResponseType(value) {
        this.responseType = value;
        return this;
      }
    }, {
      key: "setMimeType",
      value: function setMimeType(value) {
        this.mimeType = value;
        return this;
      }
    }]);
  }(Loader);
  var AnimationLoader = exports.AnimationLoader = /*#__PURE__*/function (_Loader2) {
    function AnimationLoader(manager) {
      (0, _classCallCheck2.default)(this, AnimationLoader);
      return _callSuper(this, AnimationLoader, [manager]);
    }
    (0, _inherits2.default)(AnimationLoader, _Loader2);
    return (0, _createClass2.default)(AnimationLoader, [{
      key: "load",
      value: function load(url, onLoad, onProgress, onError) {
        var scope = this;
        var loader = new FileLoader(this.manager);
        loader.setPath(this.path);
        loader.setRequestHeader(this.requestHeader);
        loader.setWithCredentials(this.withCredentials);
        loader.load(url, function (text) {
          try {
            onLoad(scope.parse(JSON.parse(text)));
          } catch (e) {
            if (onError) {
              onError(e);
            } else {
              console.error(e);
            }
            scope.manager.itemError(url);
          }
        }, onProgress, onError);
      }
    }, {
      key: "parse",
      value: function parse(json) {
        var animations = [];
        for (var i = 0; i < json.length; i++) {
          var clip = AnimationClip.parse(json[i]);
          animations.push(clip);
        }
        return animations;
      }
    }]);
  }(Loader);
  /**
   * Abstract Base class to block based textures loader (dds, pvr, ...)
   *
   * Sub classes have to implement the parse() method which will be used in load().
   */
  var CompressedTextureLoader = exports.CompressedTextureLoader = /*#__PURE__*/function (_Loader3) {
    function CompressedTextureLoader(manager) {
      (0, _classCallCheck2.default)(this, CompressedTextureLoader);
      return _callSuper(this, CompressedTextureLoader, [manager]);
    }
    (0, _inherits2.default)(CompressedTextureLoader, _Loader3);
    return (0, _createClass2.default)(CompressedTextureLoader, [{
      key: "load",
      value: function load(url, onLoad, onProgress, onError) {
        var scope = this;
        var images = [];
        var texture = new CompressedTexture();
        var loader = new FileLoader(this.manager);
        loader.setPath(this.path);
        loader.setResponseType('arraybuffer');
        loader.setRequestHeader(this.requestHeader);
        loader.setWithCredentials(scope.withCredentials);
        var loaded = 0;
        function loadTexture(i) {
          loader.load(url[i], function (buffer) {
            var texDatas = scope.parse(buffer, true);
            images[i] = {
              width: texDatas.width,
              height: texDatas.height,
              format: texDatas.format,
              mipmaps: texDatas.mipmaps
            };
            loaded += 1;
            if (loaded === 6) {
              if (texDatas.mipmapCount === 1) texture.minFilter = LinearFilter;
              texture.image = images;
              texture.format = texDatas.format;
              texture.needsUpdate = true;
              if (onLoad) onLoad(texture);
            }
          }, onProgress, onError);
        }
        if (Array.isArray(url)) {
          for (var i = 0, il = url.length; i < il; ++i) {
            loadTexture(i);
          }
        } else {
          // compressed cubemap texture stored in a single DDS file

          loader.load(url, function (buffer) {
            var texDatas = scope.parse(buffer, true);
            if (texDatas.isCubemap) {
              var faces = texDatas.mipmaps.length / texDatas.mipmapCount;
              for (var f = 0; f < faces; f++) {
                images[f] = {
                  mipmaps: []
                };
                for (var _i60 = 0; _i60 < texDatas.mipmapCount; _i60++) {
                  images[f].mipmaps.push(texDatas.mipmaps[f * texDatas.mipmapCount + _i60]);
                  images[f].format = texDatas.format;
                  images[f].width = texDatas.width;
                  images[f].height = texDatas.height;
                }
              }
              texture.image = images;
            } else {
              texture.image.width = texDatas.width;
              texture.image.height = texDatas.height;
              texture.mipmaps = texDatas.mipmaps;
            }
            if (texDatas.mipmapCount === 1) {
              texture.minFilter = LinearFilter;
            }
            texture.format = texDatas.format;
            texture.needsUpdate = true;
            if (onLoad) onLoad(texture);
          }, onProgress, onError);
        }
        return texture;
      }
    }]);
  }(Loader);
  var ImageLoader = exports.ImageLoader = /*#__PURE__*/function (_Loader4) {
    function ImageLoader(manager) {
      (0, _classCallCheck2.default)(this, ImageLoader);
      return _callSuper(this, ImageLoader, [manager]);
    }
    (0, _inherits2.default)(ImageLoader, _Loader4);
    return (0, _createClass2.default)(ImageLoader, [{
      key: "load",
      value: function load(url, onLoad, onProgress, onError) {
        if (this.path !== undefined) url = this.path + url;
        url = this.manager.resolveURL(url);
        var scope = this;
        var cached = Cache.get(url);
        if (cached !== undefined) {
          scope.manager.itemStart(url);
          setTimeout(function () {
            if (onLoad) onLoad(cached);
            scope.manager.itemEnd(url);
          }, 0);
          return cached;
        }
        var image = createElementNS('img');
        function onImageLoad() {
          removeEventListeners();
          Cache.add(url, this);
          if (onLoad) onLoad(this);
          scope.manager.itemEnd(url);
        }
        function onImageError(event) {
          removeEventListeners();
          if (onError) onError(event);
          scope.manager.itemError(url);
          scope.manager.itemEnd(url);
        }
        function removeEventListeners() {
          image.removeEventListener('load', onImageLoad, false);
          image.removeEventListener('error', onImageError, false);
        }
        image.addEventListener('load', onImageLoad, false);
        image.addEventListener('error', onImageError, false);
        if (url.slice(0, 5) !== 'data:') {
          if (this.crossOrigin !== undefined) image.crossOrigin = this.crossOrigin;
        }
        scope.manager.itemStart(url);
        image.src = url;
        return image;
      }
    }]);
  }(Loader);
  var CubeTextureLoader = exports.CubeTextureLoader = /*#__PURE__*/function (_Loader5) {
    function CubeTextureLoader(manager) {
      (0, _classCallCheck2.default)(this, CubeTextureLoader);
      return _callSuper(this, CubeTextureLoader, [manager]);
    }
    (0, _inherits2.default)(CubeTextureLoader, _Loader5);
    return (0, _createClass2.default)(CubeTextureLoader, [{
      key: "load",
      value: function load(urls, onLoad, onProgress, onError) {
        var texture = new CubeTexture();
        texture.colorSpace = SRGBColorSpace;
        var loader = new ImageLoader(this.manager);
        loader.setCrossOrigin(this.crossOrigin);
        loader.setPath(this.path);
        var loaded = 0;
        function loadTexture(i) {
          loader.load(urls[i], function (image) {
            texture.images[i] = image;
            loaded++;
            if (loaded === 6) {
              texture.needsUpdate = true;
              if (onLoad) onLoad(texture);
            }
          }, undefined, onError);
        }
        for (var i = 0; i < urls.length; ++i) {
          loadTexture(i);
        }
        return texture;
      }
    }]);
  }(Loader);
  /**
   * Abstract Base class to load generic binary textures formats (rgbe, hdr, ...)
   *
   * Sub classes have to implement the parse() method which will be used in load().
   */
  var DataTextureLoader = exports.DataTextureLoader = /*#__PURE__*/function (_Loader6) {
    function DataTextureLoader(manager) {
      (0, _classCallCheck2.default)(this, DataTextureLoader);
      return _callSuper(this, DataTextureLoader, [manager]);
    }
    (0, _inherits2.default)(DataTextureLoader, _Loader6);
    return (0, _createClass2.default)(DataTextureLoader, [{
      key: "load",
      value: function load(url, onLoad, onProgress, onError) {
        var scope = this;
        var texture = new DataTexture();
        var loader = new FileLoader(this.manager);
        loader.setResponseType('arraybuffer');
        loader.setRequestHeader(this.requestHeader);
        loader.setPath(this.path);
        loader.setWithCredentials(scope.withCredentials);
        loader.load(url, function (buffer) {
          var texData;
          try {
            texData = scope.parse(buffer);
          } catch (error) {
            if (onError !== undefined) {
              onError(error);
            } else {
              console.error(error);
              return;
            }
          }
          if (texData.image !== undefined) {
            texture.image = texData.image;
          } else if (texData.data !== undefined) {
            texture.image.width = texData.width;
            texture.image.height = texData.height;
            texture.image.data = texData.data;
          }
          texture.wrapS = texData.wrapS !== undefined ? texData.wrapS : ClampToEdgeWrapping;
          texture.wrapT = texData.wrapT !== undefined ? texData.wrapT : ClampToEdgeWrapping;
          texture.magFilter = texData.magFilter !== undefined ? texData.magFilter : LinearFilter;
          texture.minFilter = texData.minFilter !== undefined ? texData.minFilter : LinearFilter;
          texture.anisotropy = texData.anisotropy !== undefined ? texData.anisotropy : 1;
          if (texData.colorSpace !== undefined) {
            texture.colorSpace = texData.colorSpace;
          }
          if (texData.flipY !== undefined) {
            texture.flipY = texData.flipY;
          }
          if (texData.format !== undefined) {
            texture.format = texData.format;
          }
          if (texData.type !== undefined) {
            texture.type = texData.type;
          }
          if (texData.mipmaps !== undefined) {
            texture.mipmaps = texData.mipmaps;
            texture.minFilter = LinearMipmapLinearFilter; // presumably...
          }
          if (texData.mipmapCount === 1) {
            texture.minFilter = LinearFilter;
          }
          if (texData.generateMipmaps !== undefined) {
            texture.generateMipmaps = texData.generateMipmaps;
          }
          texture.needsUpdate = true;
          if (onLoad) onLoad(texture, texData);
        }, onProgress, onError);
        return texture;
      }
    }]);
  }(Loader);
  var TextureLoader = exports.TextureLoader = /*#__PURE__*/function (_Loader7) {
    function TextureLoader(manager) {
      (0, _classCallCheck2.default)(this, TextureLoader);
      return _callSuper(this, TextureLoader, [manager]);
    }
    (0, _inherits2.default)(TextureLoader, _Loader7);
    return (0, _createClass2.default)(TextureLoader, [{
      key: "load",
      value: function load(url, onLoad, onProgress, onError) {
        var texture = new Texture();
        var loader = new ImageLoader(this.manager);
        loader.setCrossOrigin(this.crossOrigin);
        loader.setPath(this.path);
        loader.load(url, function (image) {
          texture.image = image;
          texture.needsUpdate = true;
          if (onLoad !== undefined) {
            onLoad(texture);
          }
        }, onProgress, onError);
        return texture;
      }
    }]);
  }(Loader);
  var Light = exports.Light = /*#__PURE__*/function (_Object3D11) {
    function Light(color) {
      var _this93;
      var intensity = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
      (0, _classCallCheck2.default)(this, Light);
      _this93 = _callSuper(this, Light);
      _this93.isLight = true;
      _this93.type = 'Light';
      _this93.color = new Color(color);
      _this93.intensity = intensity;
      return _this93;
    }
    (0, _inherits2.default)(Light, _Object3D11);
    return (0, _createClass2.default)(Light, [{
      key: "dispose",
      value: function dispose() {

        // Empty here in base class; some subclasses override.
      }
    }, {
      key: "copy",
      value: function copy(source, recursive) {
        _superPropGet(Light, "copy", this, 3)([source, recursive]);
        this.color.copy(source.color);
        this.intensity = source.intensity;
        return this;
      }
    }, {
      key: "toJSON",
      value: function toJSON(meta) {
        var data = _superPropGet(Light, "toJSON", this, 3)([meta]);
        data.object.color = this.color.getHex();
        data.object.intensity = this.intensity;
        if (this.groundColor !== undefined) data.object.groundColor = this.groundColor.getHex();
        if (this.distance !== undefined) data.object.distance = this.distance;
        if (this.angle !== undefined) data.object.angle = this.angle;
        if (this.decay !== undefined) data.object.decay = this.decay;
        if (this.penumbra !== undefined) data.object.penumbra = this.penumbra;
        if (this.shadow !== undefined) data.object.shadow = this.shadow.toJSON();
        if (this.target !== undefined) data.object.target = this.target.uuid;
        return data;
      }
    }]);
  }(Object3D);
  var HemisphereLight = exports.HemisphereLight = /*#__PURE__*/function (_Light) {
    function HemisphereLight(skyColor, groundColor, intensity) {
      var _this94;
      (0, _classCallCheck2.default)(this, HemisphereLight);
      _this94 = _callSuper(this, HemisphereLight, [skyColor, intensity]);
      _this94.isHemisphereLight = true;
      _this94.type = 'HemisphereLight';
      _this94.position.copy(Object3D.DEFAULT_UP);
      _this94.updateMatrix();
      _this94.groundColor = new Color(groundColor);
      return _this94;
    }
    (0, _inherits2.default)(HemisphereLight, _Light);
    return (0, _createClass2.default)(HemisphereLight, [{
      key: "copy",
      value: function copy(source, recursive) {
        _superPropGet(HemisphereLight, "copy", this, 3)([source, recursive]);
        this.groundColor.copy(source.groundColor);
        return this;
      }
    }]);
  }(Light);
  var _projScreenMatrix$1 = /*@__PURE__*/new Matrix4();
  var _lightPositionWorld$1 = /*@__PURE__*/new Vector3();
  var _lookTarget$1 = /*@__PURE__*/new Vector3();
  var LightShadow = /*#__PURE__*/function () {
    function LightShadow(camera) {
      (0, _classCallCheck2.default)(this, LightShadow);
      this.camera = camera;
      this.intensity = 1;
      this.bias = 0;
      this.normalBias = 0;
      this.radius = 1;
      this.blurSamples = 8;
      this.mapSize = new Vector2(512, 512);
      this.map = null;
      this.mapPass = null;
      this.matrix = new Matrix4();
      this.autoUpdate = true;
      this.needsUpdate = false;
      this._frustum = new Frustum();
      this._frameExtents = new Vector2(1, 1);
      this._viewportCount = 1;
      this._viewports = [new Vector4(0, 0, 1, 1)];
    }
    return (0, _createClass2.default)(LightShadow, [{
      key: "getViewportCount",
      value: function getViewportCount() {
        return this._viewportCount;
      }
    }, {
      key: "getFrustum",
      value: function getFrustum() {
        return this._frustum;
      }
    }, {
      key: "updateMatrices",
      value: function updateMatrices(light) {
        var shadowCamera = this.camera;
        var shadowMatrix = this.matrix;
        _lightPositionWorld$1.setFromMatrixPosition(light.matrixWorld);
        shadowCamera.position.copy(_lightPositionWorld$1);
        _lookTarget$1.setFromMatrixPosition(light.target.matrixWorld);
        shadowCamera.lookAt(_lookTarget$1);
        shadowCamera.updateMatrixWorld();
        _projScreenMatrix$1.multiplyMatrices(shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse);
        this._frustum.setFromProjectionMatrix(_projScreenMatrix$1);
        shadowMatrix.set(0.5, 0.0, 0.0, 0.5, 0.0, 0.5, 0.0, 0.5, 0.0, 0.0, 0.5, 0.5, 0.0, 0.0, 0.0, 1.0);
        shadowMatrix.multiply(_projScreenMatrix$1);
      }
    }, {
      key: "getViewport",
      value: function getViewport(viewportIndex) {
        return this._viewports[viewportIndex];
      }
    }, {
      key: "getFrameExtents",
      value: function getFrameExtents() {
        return this._frameExtents;
      }
    }, {
      key: "dispose",
      value: function dispose() {
        if (this.map) {
          this.map.dispose();
        }
        if (this.mapPass) {
          this.mapPass.dispose();
        }
      }
    }, {
      key: "copy",
      value: function copy(source) {
        this.camera = source.camera.clone();
        this.intensity = source.intensity;
        this.bias = source.bias;
        this.radius = source.radius;
        this.mapSize.copy(source.mapSize);
        return this;
      }
    }, {
      key: "clone",
      value: function clone() {
        return new this.constructor().copy(this);
      }
    }, {
      key: "toJSON",
      value: function toJSON() {
        var object = {};
        if (this.intensity !== 1) object.intensity = this.intensity;
        if (this.bias !== 0) object.bias = this.bias;
        if (this.normalBias !== 0) object.normalBias = this.normalBias;
        if (this.radius !== 1) object.radius = this.radius;
        if (this.mapSize.x !== 512 || this.mapSize.y !== 512) object.mapSize = this.mapSize.toArray();
        object.camera = this.camera.toJSON(false).object;
        delete object.camera.matrix;
        return object;
      }
    }]);
  }();
  var SpotLightShadow = /*#__PURE__*/function (_LightShadow) {
    function SpotLightShadow() {
      var _this95;
      (0, _classCallCheck2.default)(this, SpotLightShadow);
      _this95 = _callSuper(this, SpotLightShadow, [new PerspectiveCamera(50, 1, 0.5, 500)]);
      _this95.isSpotLightShadow = true;
      _this95.focus = 1;
      return _this95;
    }
    (0, _inherits2.default)(SpotLightShadow, _LightShadow);
    return (0, _createClass2.default)(SpotLightShadow, [{
      key: "updateMatrices",
      value: function updateMatrices(light) {
        var camera = this.camera;
        var fov = RAD2DEG * 2 * light.angle * this.focus;
        var aspect = this.mapSize.width / this.mapSize.height;
        var far = light.distance || camera.far;
        if (fov !== camera.fov || aspect !== camera.aspect || far !== camera.far) {
          camera.fov = fov;
          camera.aspect = aspect;
          camera.far = far;
          camera.updateProjectionMatrix();
        }
        _superPropGet(SpotLightShadow, "updateMatrices", this, 3)([light]);
      }
    }, {
      key: "copy",
      value: function copy(source) {
        _superPropGet(SpotLightShadow, "copy", this, 3)([source]);
        this.focus = source.focus;
        return this;
      }
    }]);
  }(LightShadow);
  var SpotLight = exports.SpotLight = /*#__PURE__*/function (_Light2) {
    function SpotLight(color, intensity) {
      var _this96;
      var distance = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      var angle = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : Math.PI / 3;
      var penumbra = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;
      var decay = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 2;
      (0, _classCallCheck2.default)(this, SpotLight);
      _this96 = _callSuper(this, SpotLight, [color, intensity]);
      _this96.isSpotLight = true;
      _this96.type = 'SpotLight';
      _this96.position.copy(Object3D.DEFAULT_UP);
      _this96.updateMatrix();
      _this96.target = new Object3D();
      _this96.distance = distance;
      _this96.angle = angle;
      _this96.penumbra = penumbra;
      _this96.decay = decay;
      _this96.map = null;
      _this96.shadow = new SpotLightShadow();
      return _this96;
    }
    (0, _inherits2.default)(SpotLight, _Light2);
    return (0, _createClass2.default)(SpotLight, [{
      key: "power",
      get: function get() {
        // compute the light's luminous power (in lumens) from its intensity (in candela)
        // by convention for a spotlight, luminous power (lm) =  * luminous intensity (cd)
        return this.intensity * Math.PI;
      },
      set: function set(power) {
        // set the light's intensity (in candela) from the desired luminous power (in lumens)
        this.intensity = power / Math.PI;
      }
    }, {
      key: "dispose",
      value: function dispose() {
        this.shadow.dispose();
      }
    }, {
      key: "copy",
      value: function copy(source, recursive) {
        _superPropGet(SpotLight, "copy", this, 3)([source, recursive]);
        this.distance = source.distance;
        this.angle = source.angle;
        this.penumbra = source.penumbra;
        this.decay = source.decay;
        this.target = source.target.clone();
        this.shadow = source.shadow.clone();
        return this;
      }
    }]);
  }(Light);
  var _projScreenMatrix = /*@__PURE__*/new Matrix4();
  var _lightPositionWorld = /*@__PURE__*/new Vector3();
  var _lookTarget = /*@__PURE__*/new Vector3();
  var PointLightShadow = /*#__PURE__*/function (_LightShadow2) {
    function PointLightShadow() {
      var _this97;
      (0, _classCallCheck2.default)(this, PointLightShadow);
      _this97 = _callSuper(this, PointLightShadow, [new PerspectiveCamera(90, 1, 0.5, 500)]);
      _this97.isPointLightShadow = true;
      _this97._frameExtents = new Vector2(4, 2);
      _this97._viewportCount = 6;
      _this97._viewports = [
      // These viewports map a cube-map onto a 2D texture with the
      // following orientation:
      //
      //  xzXZ
      //   y Y
      //
      // X - Positive x direction
      // x - Negative x direction
      // Y - Positive y direction
      // y - Negative y direction
      // Z - Positive z direction
      // z - Negative z direction

      // positive X
      new Vector4(2, 1, 1, 1),
      // negative X
      new Vector4(0, 1, 1, 1),
      // positive Z
      new Vector4(3, 1, 1, 1),
      // negative Z
      new Vector4(1, 1, 1, 1),
      // positive Y
      new Vector4(3, 0, 1, 1),
      // negative Y
      new Vector4(1, 0, 1, 1)];
      _this97._cubeDirections = [new Vector3(1, 0, 0), new Vector3(-1, 0, 0), new Vector3(0, 0, 1), new Vector3(0, 0, -1), new Vector3(0, 1, 0), new Vector3(0, -1, 0)];
      _this97._cubeUps = [new Vector3(0, 1, 0), new Vector3(0, 1, 0), new Vector3(0, 1, 0), new Vector3(0, 1, 0), new Vector3(0, 0, 1), new Vector3(0, 0, -1)];
      return _this97;
    }
    (0, _inherits2.default)(PointLightShadow, _LightShadow2);
    return (0, _createClass2.default)(PointLightShadow, [{
      key: "updateMatrices",
      value: function updateMatrices(light) {
        var viewportIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        var camera = this.camera;
        var shadowMatrix = this.matrix;
        var far = light.distance || camera.far;
        if (far !== camera.far) {
          camera.far = far;
          camera.updateProjectionMatrix();
        }
        _lightPositionWorld.setFromMatrixPosition(light.matrixWorld);
        camera.position.copy(_lightPositionWorld);
        _lookTarget.copy(camera.position);
        _lookTarget.add(this._cubeDirections[viewportIndex]);
        camera.up.copy(this._cubeUps[viewportIndex]);
        camera.lookAt(_lookTarget);
        camera.updateMatrixWorld();
        shadowMatrix.makeTranslation(-_lightPositionWorld.x, -_lightPositionWorld.y, -_lightPositionWorld.z);
        _projScreenMatrix.multiplyMatrices(camera.projectionMatrix, camera.matrixWorldInverse);
        this._frustum.setFromProjectionMatrix(_projScreenMatrix);
      }
    }]);
  }(LightShadow);
  var PointLight = exports.PointLight = /*#__PURE__*/function (_Light3) {
    function PointLight(color, intensity) {
      var _this98;
      var distance = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      var decay = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 2;
      (0, _classCallCheck2.default)(this, PointLight);
      _this98 = _callSuper(this, PointLight, [color, intensity]);
      _this98.isPointLight = true;
      _this98.type = 'PointLight';
      _this98.distance = distance;
      _this98.decay = decay;
      _this98.shadow = new PointLightShadow();
      return _this98;
    }
    (0, _inherits2.default)(PointLight, _Light3);
    return (0, _createClass2.default)(PointLight, [{
      key: "power",
      get: function get() {
        // compute the light's luminous power (in lumens) from its intensity (in candela)
        // for an isotropic light source, luminous power (lm) = 4  luminous intensity (cd)
        return this.intensity * 4 * Math.PI;
      },
      set: function set(power) {
        // set the light's intensity (in candela) from the desired luminous power (in lumens)
        this.intensity = power / (4 * Math.PI);
      }
    }, {
      key: "dispose",
      value: function dispose() {
        this.shadow.dispose();
      }
    }, {
      key: "copy",
      value: function copy(source, recursive) {
        _superPropGet(PointLight, "copy", this, 3)([source, recursive]);
        this.distance = source.distance;
        this.decay = source.decay;
        this.shadow = source.shadow.clone();
        return this;
      }
    }]);
  }(Light);
  var OrthographicCamera = exports.OrthographicCamera = /*#__PURE__*/function (_Camera2) {
    function OrthographicCamera() {
      var _this99;
      var left = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : -1;
      var right = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
      var top = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
      var bottom = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : -1;
      var near = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0.1;
      var far = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 2000;
      (0, _classCallCheck2.default)(this, OrthographicCamera);
      _this99 = _callSuper(this, OrthographicCamera);
      _this99.isOrthographicCamera = true;
      _this99.type = 'OrthographicCamera';
      _this99.zoom = 1;
      _this99.view = null;
      _this99.left = left;
      _this99.right = right;
      _this99.top = top;
      _this99.bottom = bottom;
      _this99.near = near;
      _this99.far = far;
      _this99.updateProjectionMatrix();
      return _this99;
    }
    (0, _inherits2.default)(OrthographicCamera, _Camera2);
    return (0, _createClass2.default)(OrthographicCamera, [{
      key: "copy",
      value: function copy(source, recursive) {
        _superPropGet(OrthographicCamera, "copy", this, 3)([source, recursive]);
        this.left = source.left;
        this.right = source.right;
        this.top = source.top;
        this.bottom = source.bottom;
        this.near = source.near;
        this.far = source.far;
        this.zoom = source.zoom;
        this.view = source.view === null ? null : Object.assign({}, source.view);
        return this;
      }
    }, {
      key: "setViewOffset",
      value: function setViewOffset(fullWidth, fullHeight, x, y, width, height) {
        if (this.view === null) {
          this.view = {
            enabled: true,
            fullWidth: 1,
            fullHeight: 1,
            offsetX: 0,
            offsetY: 0,
            width: 1,
            height: 1
          };
        }
        this.view.enabled = true;
        this.view.fullWidth = fullWidth;
        this.view.fullHeight = fullHeight;
        this.view.offsetX = x;
        this.view.offsetY = y;
        this.view.width = width;
        this.view.height = height;
        this.updateProjectionMatrix();
      }
    }, {
      key: "clearViewOffset",
      value: function clearViewOffset() {
        if (this.view !== null) {
          this.view.enabled = false;
        }
        this.updateProjectionMatrix();
      }
    }, {
      key: "updateProjectionMatrix",
      value: function updateProjectionMatrix() {
        var dx = (this.right - this.left) / (2 * this.zoom);
        var dy = (this.top - this.bottom) / (2 * this.zoom);
        var cx = (this.right + this.left) / 2;
        var cy = (this.top + this.bottom) / 2;
        var left = cx - dx;
        var right = cx + dx;
        var top = cy + dy;
        var bottom = cy - dy;
        if (this.view !== null && this.view.enabled) {
          var scaleW = (this.right - this.left) / this.view.fullWidth / this.zoom;
          var scaleH = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
          left += scaleW * this.view.offsetX;
          right = left + scaleW * this.view.width;
          top -= scaleH * this.view.offsetY;
          bottom = top - scaleH * this.view.height;
        }
        this.projectionMatrix.makeOrthographic(left, right, top, bottom, this.near, this.far, this.coordinateSystem);
        this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
      }
    }, {
      key: "toJSON",
      value: function toJSON(meta) {
        var data = _superPropGet(OrthographicCamera, "toJSON", this, 3)([meta]);
        data.object.zoom = this.zoom;
        data.object.left = this.left;
        data.object.right = this.right;
        data.object.top = this.top;
        data.object.bottom = this.bottom;
        data.object.near = this.near;
        data.object.far = this.far;
        if (this.view !== null) data.object.view = Object.assign({}, this.view);
        return data;
      }
    }]);
  }(Camera);
  var DirectionalLightShadow = /*#__PURE__*/function (_LightShadow3) {
    function DirectionalLightShadow() {
      var _this100;
      (0, _classCallCheck2.default)(this, DirectionalLightShadow);
      _this100 = _callSuper(this, DirectionalLightShadow, [new OrthographicCamera(-5, 5, 5, -5, 0.5, 500)]);
      _this100.isDirectionalLightShadow = true;
      return _this100;
    }
    (0, _inherits2.default)(DirectionalLightShadow, _LightShadow3);
    return (0, _createClass2.default)(DirectionalLightShadow);
  }(LightShadow);
  var DirectionalLight = exports.DirectionalLight = /*#__PURE__*/function (_Light4) {
    function DirectionalLight(color, intensity) {
      var _this101;
      (0, _classCallCheck2.default)(this, DirectionalLight);
      _this101 = _callSuper(this, DirectionalLight, [color, intensity]);
      _this101.isDirectionalLight = true;
      _this101.type = 'DirectionalLight';
      _this101.position.copy(Object3D.DEFAULT_UP);
      _this101.updateMatrix();
      _this101.target = new Object3D();
      _this101.shadow = new DirectionalLightShadow();
      return _this101;
    }
    (0, _inherits2.default)(DirectionalLight, _Light4);
    return (0, _createClass2.default)(DirectionalLight, [{
      key: "dispose",
      value: function dispose() {
        this.shadow.dispose();
      }
    }, {
      key: "copy",
      value: function copy(source) {
        _superPropGet(DirectionalLight, "copy", this, 3)([source]);
        this.target = source.target.clone();
        this.shadow = source.shadow.clone();
        return this;
      }
    }]);
  }(Light);
  var AmbientLight = exports.AmbientLight = /*#__PURE__*/function (_Light5) {
    function AmbientLight(color, intensity) {
      var _this102;
      (0, _classCallCheck2.default)(this, AmbientLight);
      _this102 = _callSuper(this, AmbientLight, [color, intensity]);
      _this102.isAmbientLight = true;
      _this102.type = 'AmbientLight';
      return _this102;
    }
    (0, _inherits2.default)(AmbientLight, _Light5);
    return (0, _createClass2.default)(AmbientLight);
  }(Light);
  var RectAreaLight = exports.RectAreaLight = /*#__PURE__*/function (_Light6) {
    function RectAreaLight(color, intensity) {
      var _this103;
      var width = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 10;
      var height = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 10;
      (0, _classCallCheck2.default)(this, RectAreaLight);
      _this103 = _callSuper(this, RectAreaLight, [color, intensity]);
      _this103.isRectAreaLight = true;
      _this103.type = 'RectAreaLight';
      _this103.width = width;
      _this103.height = height;
      return _this103;
    }
    (0, _inherits2.default)(RectAreaLight, _Light6);
    return (0, _createClass2.default)(RectAreaLight, [{
      key: "power",
      get: function get() {
        // compute the light's luminous power (in lumens) from its intensity (in nits)
        return this.intensity * this.width * this.height * Math.PI;
      },
      set: function set(power) {
        // set the light's intensity (in nits) from the desired luminous power (in lumens)
        this.intensity = power / (this.width * this.height * Math.PI);
      }
    }, {
      key: "copy",
      value: function copy(source) {
        _superPropGet(RectAreaLight, "copy", this, 3)([source]);
        this.width = source.width;
        this.height = source.height;
        return this;
      }
    }, {
      key: "toJSON",
      value: function toJSON(meta) {
        var data = _superPropGet(RectAreaLight, "toJSON", this, 3)([meta]);
        data.object.width = this.width;
        data.object.height = this.height;
        return data;
      }
    }]);
  }(Light);
  /**
   * Primary reference:
   *   https://graphics.stanford.edu/papers/envmap/envmap.pdf
   *
   * Secondary reference:
   *   https://www.ppsloan.org/publications/StupidSH36.pdf
   */
  // 3-band SH defined by 9 coefficients
  var SphericalHarmonics3 = exports.SphericalHarmonics3 = /*#__PURE__*/function () {
    function SphericalHarmonics3() {
      (0, _classCallCheck2.default)(this, SphericalHarmonics3);
      this.isSphericalHarmonics3 = true;
      this.coefficients = [];
      for (var i = 0; i < 9; i++) {
        this.coefficients.push(new Vector3());
      }
    }
    return (0, _createClass2.default)(SphericalHarmonics3, [{
      key: "set",
      value: function set(coefficients) {
        for (var i = 0; i < 9; i++) {
          this.coefficients[i].copy(coefficients[i]);
        }
        return this;
      }
    }, {
      key: "zero",
      value: function zero() {
        for (var i = 0; i < 9; i++) {
          this.coefficients[i].set(0, 0, 0);
        }
        return this;
      }

      // get the radiance in the direction of the normal
      // target is a Vector3
    }, {
      key: "getAt",
      value: function getAt(normal, target) {
        // normal is assumed to be unit length

        var x = normal.x,
          y = normal.y,
          z = normal.z;
        var coeff = this.coefficients;

        // band 0
        target.copy(coeff[0]).multiplyScalar(0.282095);

        // band 1
        target.addScaledVector(coeff[1], 0.488603 * y);
        target.addScaledVector(coeff[2], 0.488603 * z);
        target.addScaledVector(coeff[3], 0.488603 * x);

        // band 2
        target.addScaledVector(coeff[4], 1.092548 * (x * y));
        target.addScaledVector(coeff[5], 1.092548 * (y * z));
        target.addScaledVector(coeff[6], 0.315392 * (3.0 * z * z - 1.0));
        target.addScaledVector(coeff[7], 1.092548 * (x * z));
        target.addScaledVector(coeff[8], 0.546274 * (x * x - y * y));
        return target;
      }

      // get the irradiance (radiance convolved with cosine lobe) in the direction of the normal
      // target is a Vector3
      // https://graphics.stanford.edu/papers/envmap/envmap.pdf
    }, {
      key: "getIrradianceAt",
      value: function getIrradianceAt(normal, target) {
        // normal is assumed to be unit length

        var x = normal.x,
          y = normal.y,
          z = normal.z;
        var coeff = this.coefficients;

        // band 0
        target.copy(coeff[0]).multiplyScalar(0.886227); //  * 0.282095

        // band 1
        target.addScaledVector(coeff[1], 2.0 * 0.511664 * y); // ( 2 *  / 3 ) * 0.488603
        target.addScaledVector(coeff[2], 2.0 * 0.511664 * z);
        target.addScaledVector(coeff[3], 2.0 * 0.511664 * x);

        // band 2
        target.addScaledVector(coeff[4], 2.0 * 0.429043 * x * y); // (  / 4 ) * 1.092548
        target.addScaledVector(coeff[5], 2.0 * 0.429043 * y * z);
        target.addScaledVector(coeff[6], 0.743125 * z * z - 0.247708); // (  / 4 ) * 0.315392 * 3
        target.addScaledVector(coeff[7], 2.0 * 0.429043 * x * z);
        target.addScaledVector(coeff[8], 0.429043 * (x * x - y * y)); // (  / 4 ) * 0.546274

        return target;
      }
    }, {
      key: "add",
      value: function add(sh) {
        for (var i = 0; i < 9; i++) {
          this.coefficients[i].add(sh.coefficients[i]);
        }
        return this;
      }
    }, {
      key: "addScaledSH",
      value: function addScaledSH(sh, s) {
        for (var i = 0; i < 9; i++) {
          this.coefficients[i].addScaledVector(sh.coefficients[i], s);
        }
        return this;
      }
    }, {
      key: "scale",
      value: function scale(s) {
        for (var i = 0; i < 9; i++) {
          this.coefficients[i].multiplyScalar(s);
        }
        return this;
      }
    }, {
      key: "lerp",
      value: function lerp(sh, alpha) {
        for (var i = 0; i < 9; i++) {
          this.coefficients[i].lerp(sh.coefficients[i], alpha);
        }
        return this;
      }
    }, {
      key: "equals",
      value: function equals(sh) {
        for (var i = 0; i < 9; i++) {
          if (!this.coefficients[i].equals(sh.coefficients[i])) {
            return false;
          }
        }
        return true;
      }
    }, {
      key: "copy",
      value: function copy(sh) {
        return this.set(sh.coefficients);
      }
    }, {
      key: "clone",
      value: function clone() {
        return new this.constructor().copy(this);
      }
    }, {
      key: "fromArray",
      value: function fromArray(array) {
        var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        var coefficients = this.coefficients;
        for (var i = 0; i < 9; i++) {
          coefficients[i].fromArray(array, offset + i * 3);
        }
        return this;
      }
    }, {
      key: "toArray",
      value: function toArray() {
        var array = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
        var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        var coefficients = this.coefficients;
        for (var i = 0; i < 9; i++) {
          coefficients[i].toArray(array, offset + i * 3);
        }
        return array;
      }

      // evaluate the basis functions
      // shBasis is an Array[ 9 ]
    }], [{
      key: "getBasisAt",
      value: function getBasisAt(normal, shBasis) {
        // normal is assumed to be unit length

        var x = normal.x,
          y = normal.y,
          z = normal.z;

        // band 0
        shBasis[0] = 0.282095;

        // band 1
        shBasis[1] = 0.488603 * y;
        shBasis[2] = 0.488603 * z;
        shBasis[3] = 0.488603 * x;

        // band 2
        shBasis[4] = 1.092548 * x * y;
        shBasis[5] = 1.092548 * y * z;
        shBasis[6] = 0.315392 * (3 * z * z - 1);
        shBasis[7] = 1.092548 * x * z;
        shBasis[8] = 0.546274 * (x * x - y * y);
      }
    }]);
  }();
  var LightProbe = exports.LightProbe = /*#__PURE__*/function (_Light7) {
    function LightProbe() {
      var _this104;
      var sh = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new SphericalHarmonics3();
      var intensity = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
      (0, _classCallCheck2.default)(this, LightProbe);
      _this104 = _callSuper(this, LightProbe, [undefined, intensity]);
      _this104.isLightProbe = true;
      _this104.sh = sh;
      return _this104;
    }
    (0, _inherits2.default)(LightProbe, _Light7);
    return (0, _createClass2.default)(LightProbe, [{
      key: "copy",
      value: function copy(source) {
        _superPropGet(LightProbe, "copy", this, 3)([source]);
        this.sh.copy(source.sh);
        return this;
      }
    }, {
      key: "fromJSON",
      value: function fromJSON(json) {
        this.intensity = json.intensity; // TODO: Move this bit to Light.fromJSON();
        this.sh.fromArray(json.sh);
        return this;
      }
    }, {
      key: "toJSON",
      value: function toJSON(meta) {
        var data = _superPropGet(LightProbe, "toJSON", this, 3)([meta]);
        data.object.sh = this.sh.toArray();
        return data;
      }
    }]);
  }(Light);
  var MaterialLoader = exports.MaterialLoader = /*#__PURE__*/function (_Loader8) {
    function MaterialLoader(manager) {
      var _this105;
      (0, _classCallCheck2.default)(this, MaterialLoader);
      _this105 = _callSuper(this, MaterialLoader, [manager]);
      _this105.textures = {};
      return _this105;
    }
    (0, _inherits2.default)(MaterialLoader, _Loader8);
    return (0, _createClass2.default)(MaterialLoader, [{
      key: "load",
      value: function load(url, onLoad, onProgress, onError) {
        var scope = this;
        var loader = new FileLoader(scope.manager);
        loader.setPath(scope.path);
        loader.setRequestHeader(scope.requestHeader);
        loader.setWithCredentials(scope.withCredentials);
        loader.load(url, function (text) {
          try {
            onLoad(scope.parse(JSON.parse(text)));
          } catch (e) {
            if (onError) {
              onError(e);
            } else {
              console.error(e);
            }
            scope.manager.itemError(url);
          }
        }, onProgress, onError);
      }
    }, {
      key: "parse",
      value: function parse(json) {
        var textures = this.textures;
        function getTexture(name) {
          if (textures[name] === undefined) {
            console.warn('THREE.MaterialLoader: Undefined texture', name);
          }
          return textures[name];
        }
        var material = this.createMaterialFromType(json.type);
        if (json.uuid !== undefined) material.uuid = json.uuid;
        if (json.name !== undefined) material.name = json.name;
        if (json.color !== undefined && material.color !== undefined) material.color.setHex(json.color);
        if (json.roughness !== undefined) material.roughness = json.roughness;
        if (json.metalness !== undefined) material.metalness = json.metalness;
        if (json.sheen !== undefined) material.sheen = json.sheen;
        if (json.sheenColor !== undefined) material.sheenColor = new Color().setHex(json.sheenColor);
        if (json.sheenRoughness !== undefined) material.sheenRoughness = json.sheenRoughness;
        if (json.emissive !== undefined && material.emissive !== undefined) material.emissive.setHex(json.emissive);
        if (json.specular !== undefined && material.specular !== undefined) material.specular.setHex(json.specular);
        if (json.specularIntensity !== undefined) material.specularIntensity = json.specularIntensity;
        if (json.specularColor !== undefined && material.specularColor !== undefined) material.specularColor.setHex(json.specularColor);
        if (json.shininess !== undefined) material.shininess = json.shininess;
        if (json.clearcoat !== undefined) material.clearcoat = json.clearcoat;
        if (json.clearcoatRoughness !== undefined) material.clearcoatRoughness = json.clearcoatRoughness;
        if (json.dispersion !== undefined) material.dispersion = json.dispersion;
        if (json.iridescence !== undefined) material.iridescence = json.iridescence;
        if (json.iridescenceIOR !== undefined) material.iridescenceIOR = json.iridescenceIOR;
        if (json.iridescenceThicknessRange !== undefined) material.iridescenceThicknessRange = json.iridescenceThicknessRange;
        if (json.transmission !== undefined) material.transmission = json.transmission;
        if (json.thickness !== undefined) material.thickness = json.thickness;
        if (json.attenuationDistance !== undefined) material.attenuationDistance = json.attenuationDistance;
        if (json.attenuationColor !== undefined && material.attenuationColor !== undefined) material.attenuationColor.setHex(json.attenuationColor);
        if (json.anisotropy !== undefined) material.anisotropy = json.anisotropy;
        if (json.anisotropyRotation !== undefined) material.anisotropyRotation = json.anisotropyRotation;
        if (json.fog !== undefined) material.fog = json.fog;
        if (json.flatShading !== undefined) material.flatShading = json.flatShading;
        if (json.blending !== undefined) material.blending = json.blending;
        if (json.combine !== undefined) material.combine = json.combine;
        if (json.side !== undefined) material.side = json.side;
        if (json.shadowSide !== undefined) material.shadowSide = json.shadowSide;
        if (json.opacity !== undefined) material.opacity = json.opacity;
        if (json.transparent !== undefined) material.transparent = json.transparent;
        if (json.alphaTest !== undefined) material.alphaTest = json.alphaTest;
        if (json.alphaHash !== undefined) material.alphaHash = json.alphaHash;
        if (json.depthFunc !== undefined) material.depthFunc = json.depthFunc;
        if (json.depthTest !== undefined) material.depthTest = json.depthTest;
        if (json.depthWrite !== undefined) material.depthWrite = json.depthWrite;
        if (json.colorWrite !== undefined) material.colorWrite = json.colorWrite;
        if (json.blendSrc !== undefined) material.blendSrc = json.blendSrc;
        if (json.blendDst !== undefined) material.blendDst = json.blendDst;
        if (json.blendEquation !== undefined) material.blendEquation = json.blendEquation;
        if (json.blendSrcAlpha !== undefined) material.blendSrcAlpha = json.blendSrcAlpha;
        if (json.blendDstAlpha !== undefined) material.blendDstAlpha = json.blendDstAlpha;
        if (json.blendEquationAlpha !== undefined) material.blendEquationAlpha = json.blendEquationAlpha;
        if (json.blendColor !== undefined && material.blendColor !== undefined) material.blendColor.setHex(json.blendColor);
        if (json.blendAlpha !== undefined) material.blendAlpha = json.blendAlpha;
        if (json.stencilWriteMask !== undefined) material.stencilWriteMask = json.stencilWriteMask;
        if (json.stencilFunc !== undefined) material.stencilFunc = json.stencilFunc;
        if (json.stencilRef !== undefined) material.stencilRef = json.stencilRef;
        if (json.stencilFuncMask !== undefined) material.stencilFuncMask = json.stencilFuncMask;
        if (json.stencilFail !== undefined) material.stencilFail = json.stencilFail;
        if (json.stencilZFail !== undefined) material.stencilZFail = json.stencilZFail;
        if (json.stencilZPass !== undefined) material.stencilZPass = json.stencilZPass;
        if (json.stencilWrite !== undefined) material.stencilWrite = json.stencilWrite;
        if (json.wireframe !== undefined) material.wireframe = json.wireframe;
        if (json.wireframeLinewidth !== undefined) material.wireframeLinewidth = json.wireframeLinewidth;
        if (json.wireframeLinecap !== undefined) material.wireframeLinecap = json.wireframeLinecap;
        if (json.wireframeLinejoin !== undefined) material.wireframeLinejoin = json.wireframeLinejoin;
        if (json.rotation !== undefined) material.rotation = json.rotation;
        if (json.linewidth !== undefined) material.linewidth = json.linewidth;
        if (json.dashSize !== undefined) material.dashSize = json.dashSize;
        if (json.gapSize !== undefined) material.gapSize = json.gapSize;
        if (json.scale !== undefined) material.scale = json.scale;
        if (json.polygonOffset !== undefined) material.polygonOffset = json.polygonOffset;
        if (json.polygonOffsetFactor !== undefined) material.polygonOffsetFactor = json.polygonOffsetFactor;
        if (json.polygonOffsetUnits !== undefined) material.polygonOffsetUnits = json.polygonOffsetUnits;
        if (json.dithering !== undefined) material.dithering = json.dithering;
        if (json.alphaToCoverage !== undefined) material.alphaToCoverage = json.alphaToCoverage;
        if (json.premultipliedAlpha !== undefined) material.premultipliedAlpha = json.premultipliedAlpha;
        if (json.forceSinglePass !== undefined) material.forceSinglePass = json.forceSinglePass;
        if (json.visible !== undefined) material.visible = json.visible;
        if (json.toneMapped !== undefined) material.toneMapped = json.toneMapped;
        if (json.userData !== undefined) material.userData = json.userData;
        if (json.vertexColors !== undefined) {
          if (typeof json.vertexColors === 'number') {
            material.vertexColors = json.vertexColors > 0 ? true : false;
          } else {
            material.vertexColors = json.vertexColors;
          }
        }

        // Shader Material

        if (json.uniforms !== undefined) {
          for (var name in json.uniforms) {
            var uniform = json.uniforms[name];
            material.uniforms[name] = {};
            switch (uniform.type) {
              case 't':
                material.uniforms[name].value = getTexture(uniform.value);
                break;
              case 'c':
                material.uniforms[name].value = new Color().setHex(uniform.value);
                break;
              case 'v2':
                material.uniforms[name].value = new Vector2().fromArray(uniform.value);
                break;
              case 'v3':
                material.uniforms[name].value = new Vector3().fromArray(uniform.value);
                break;
              case 'v4':
                material.uniforms[name].value = new Vector4().fromArray(uniform.value);
                break;
              case 'm3':
                material.uniforms[name].value = new Matrix3().fromArray(uniform.value);
                break;
              case 'm4':
                material.uniforms[name].value = new Matrix4().fromArray(uniform.value);
                break;
              default:
                material.uniforms[name].value = uniform.value;
            }
          }
        }
        if (json.defines !== undefined) material.defines = json.defines;
        if (json.vertexShader !== undefined) material.vertexShader = json.vertexShader;
        if (json.fragmentShader !== undefined) material.fragmentShader = json.fragmentShader;
        if (json.glslVersion !== undefined) material.glslVersion = json.glslVersion;
        if (json.extensions !== undefined) {
          for (var key in json.extensions) {
            material.extensions[key] = json.extensions[key];
          }
        }
        if (json.lights !== undefined) material.lights = json.lights;
        if (json.clipping !== undefined) material.clipping = json.clipping;

        // for PointsMaterial

        if (json.size !== undefined) material.size = json.size;
        if (json.sizeAttenuation !== undefined) material.sizeAttenuation = json.sizeAttenuation;

        // maps

        if (json.map !== undefined) material.map = getTexture(json.map);
        if (json.matcap !== undefined) material.matcap = getTexture(json.matcap);
        if (json.alphaMap !== undefined) material.alphaMap = getTexture(json.alphaMap);
        if (json.bumpMap !== undefined) material.bumpMap = getTexture(json.bumpMap);
        if (json.bumpScale !== undefined) material.bumpScale = json.bumpScale;
        if (json.normalMap !== undefined) material.normalMap = getTexture(json.normalMap);
        if (json.normalMapType !== undefined) material.normalMapType = json.normalMapType;
        if (json.normalScale !== undefined) {
          var normalScale = json.normalScale;
          if (Array.isArray(normalScale) === false) {
            // Blender exporter used to export a scalar. See #7459

            normalScale = [normalScale, normalScale];
          }
          material.normalScale = new Vector2().fromArray(normalScale);
        }
        if (json.displacementMap !== undefined) material.displacementMap = getTexture(json.displacementMap);
        if (json.displacementScale !== undefined) material.displacementScale = json.displacementScale;
        if (json.displacementBias !== undefined) material.displacementBias = json.displacementBias;
        if (json.roughnessMap !== undefined) material.roughnessMap = getTexture(json.roughnessMap);
        if (json.metalnessMap !== undefined) material.metalnessMap = getTexture(json.metalnessMap);
        if (json.emissiveMap !== undefined) material.emissiveMap = getTexture(json.emissiveMap);
        if (json.emissiveIntensity !== undefined) material.emissiveIntensity = json.emissiveIntensity;
        if (json.specularMap !== undefined) material.specularMap = getTexture(json.specularMap);
        if (json.specularIntensityMap !== undefined) material.specularIntensityMap = getTexture(json.specularIntensityMap);
        if (json.specularColorMap !== undefined) material.specularColorMap = getTexture(json.specularColorMap);
        if (json.envMap !== undefined) material.envMap = getTexture(json.envMap);
        if (json.envMapRotation !== undefined) material.envMapRotation.fromArray(json.envMapRotation);
        if (json.envMapIntensity !== undefined) material.envMapIntensity = json.envMapIntensity;
        if (json.reflectivity !== undefined) material.reflectivity = json.reflectivity;
        if (json.refractionRatio !== undefined) material.refractionRatio = json.refractionRatio;
        if (json.lightMap !== undefined) material.lightMap = getTexture(json.lightMap);
        if (json.lightMapIntensity !== undefined) material.lightMapIntensity = json.lightMapIntensity;
        if (json.aoMap !== undefined) material.aoMap = getTexture(json.aoMap);
        if (json.aoMapIntensity !== undefined) material.aoMapIntensity = json.aoMapIntensity;
        if (json.gradientMap !== undefined) material.gradientMap = getTexture(json.gradientMap);
        if (json.clearcoatMap !== undefined) material.clearcoatMap = getTexture(json.clearcoatMap);
        if (json.clearcoatRoughnessMap !== undefined) material.clearcoatRoughnessMap = getTexture(json.clearcoatRoughnessMap);
        if (json.clearcoatNormalMap !== undefined) material.clearcoatNormalMap = getTexture(json.clearcoatNormalMap);
        if (json.clearcoatNormalScale !== undefined) material.clearcoatNormalScale = new Vector2().fromArray(json.clearcoatNormalScale);
        if (json.iridescenceMap !== undefined) material.iridescenceMap = getTexture(json.iridescenceMap);
        if (json.iridescenceThicknessMap !== undefined) material.iridescenceThicknessMap = getTexture(json.iridescenceThicknessMap);
        if (json.transmissionMap !== undefined) material.transmissionMap = getTexture(json.transmissionMap);
        if (json.thicknessMap !== undefined) material.thicknessMap = getTexture(json.thicknessMap);
        if (json.anisotropyMap !== undefined) material.anisotropyMap = getTexture(json.anisotropyMap);
        if (json.sheenColorMap !== undefined) material.sheenColorMap = getTexture(json.sheenColorMap);
        if (json.sheenRoughnessMap !== undefined) material.sheenRoughnessMap = getTexture(json.sheenRoughnessMap);
        return material;
      }
    }, {
      key: "setTextures",
      value: function setTextures(value) {
        this.textures = value;
        return this;
      }
    }, {
      key: "createMaterialFromType",
      value: function createMaterialFromType(type) {
        return MaterialLoader.createMaterialFromType(type);
      }
    }], [{
      key: "createMaterialFromType",
      value: function createMaterialFromType(type) {
        var materialLib = {
          ShadowMaterial: ShadowMaterial,
          SpriteMaterial: SpriteMaterial,
          RawShaderMaterial: RawShaderMaterial,
          ShaderMaterial: ShaderMaterial,
          PointsMaterial: PointsMaterial,
          MeshPhysicalMaterial: MeshPhysicalMaterial,
          MeshStandardMaterial: MeshStandardMaterial,
          MeshPhongMaterial: MeshPhongMaterial,
          MeshToonMaterial: MeshToonMaterial,
          MeshNormalMaterial: MeshNormalMaterial,
          MeshLambertMaterial: MeshLambertMaterial,
          MeshDepthMaterial: MeshDepthMaterial,
          MeshDistanceMaterial: MeshDistanceMaterial,
          MeshBasicMaterial: MeshBasicMaterial,
          MeshMatcapMaterial: MeshMatcapMaterial,
          LineDashedMaterial: LineDashedMaterial,
          LineBasicMaterial: LineBasicMaterial,
          Material: Material
        };
        return new materialLib[type]();
      }
    }]);
  }(Loader);
  var LoaderUtils = exports.LoaderUtils = /*#__PURE__*/function () {
    function LoaderUtils() {
      (0, _classCallCheck2.default)(this, LoaderUtils);
    }
    return (0, _createClass2.default)(LoaderUtils, null, [{
      key: "decodeText",
      value: function decodeText(array) {
        // @deprecated, r165

        console.warn('THREE.LoaderUtils: decodeText() has been deprecated with r165 and will be removed with r175. Use TextDecoder instead.');
        if (typeof TextDecoder !== 'undefined') {
          return new TextDecoder().decode(array);
        }

        // Avoid the String.fromCharCode.apply(null, array) shortcut, which
        // throws a "maximum call stack size exceeded" error for large arrays.

        var s = '';
        for (var i = 0, il = array.length; i < il; i++) {
          // Implicitly assumes little-endian.
          s += String.fromCharCode(array[i]);
        }
        try {
          // merges multi-byte utf-8 characters.

          return decodeURIComponent(escape(s));
        } catch (e) {
          // see #16358

          return s;
        }
      }
    }, {
      key: "extractUrlBase",
      value: function extractUrlBase(url) {
        var index = url.lastIndexOf('/');
        if (index === -1) return './';
        return url.slice(0, index + 1);
      }
    }, {
      key: "resolveURL",
      value: function resolveURL(url, path) {
        // Invalid URL
        if (typeof url !== 'string' || url === '') return '';

        // Host Relative URL
        if (/^https?:\/\//i.test(path) && /^\//.test(url)) {
          path = path.replace(/(^https?:\/\/[^\/]+).*/i, '$1');
        }

        // Absolute URL http://,https://,//
        if (/^(https?:)?\/\//i.test(url)) return url;

        // Data URI
        if (/^data:.*,.*$/i.test(url)) return url;

        // Blob URL
        if (/^blob:.*$/i.test(url)) return url;

        // Relative URL
        return path + url;
      }
    }]);
  }();
  var InstancedBufferGeometry = exports.InstancedBufferGeometry = /*#__PURE__*/function (_BufferGeometry16) {
    function InstancedBufferGeometry() {
      var _this106;
      (0, _classCallCheck2.default)(this, InstancedBufferGeometry);
      _this106 = _callSuper(this, InstancedBufferGeometry);
      _this106.isInstancedBufferGeometry = true;
      _this106.type = 'InstancedBufferGeometry';
      _this106.instanceCount = Infinity;
      return _this106;
    }
    (0, _inherits2.default)(InstancedBufferGeometry, _BufferGeometry16);
    return (0, _createClass2.default)(InstancedBufferGeometry, [{
      key: "copy",
      value: function copy(source) {
        _superPropGet(InstancedBufferGeometry, "copy", this, 3)([source]);
        this.instanceCount = source.instanceCount;
        return this;
      }
    }, {
      key: "toJSON",
      value: function toJSON() {
        var data = _superPropGet(InstancedBufferGeometry, "toJSON", this, 3)([]);
        data.instanceCount = this.instanceCount;
        data.isInstancedBufferGeometry = true;
        return data;
      }
    }]);
  }(BufferGeometry);
  var BufferGeometryLoader = exports.BufferGeometryLoader = /*#__PURE__*/function (_Loader9) {
    function BufferGeometryLoader(manager) {
      (0, _classCallCheck2.default)(this, BufferGeometryLoader);
      return _callSuper(this, BufferGeometryLoader, [manager]);
    }
    (0, _inherits2.default)(BufferGeometryLoader, _Loader9);
    return (0, _createClass2.default)(BufferGeometryLoader, [{
      key: "load",
      value: function load(url, onLoad, onProgress, onError) {
        var scope = this;
        var loader = new FileLoader(scope.manager);
        loader.setPath(scope.path);
        loader.setRequestHeader(scope.requestHeader);
        loader.setWithCredentials(scope.withCredentials);
        loader.load(url, function (text) {
          try {
            onLoad(scope.parse(JSON.parse(text)));
          } catch (e) {
            if (onError) {
              onError(e);
            } else {
              console.error(e);
            }
            scope.manager.itemError(url);
          }
        }, onProgress, onError);
      }
    }, {
      key: "parse",
      value: function parse(json) {
        var interleavedBufferMap = {};
        var arrayBufferMap = {};
        function getInterleavedBuffer(json, uuid) {
          if (interleavedBufferMap[uuid] !== undefined) return interleavedBufferMap[uuid];
          var interleavedBuffers = json.interleavedBuffers;
          var interleavedBuffer = interleavedBuffers[uuid];
          var buffer = getArrayBuffer(json, interleavedBuffer.buffer);
          var array = getTypedArray(interleavedBuffer.type, buffer);
          var ib = new InterleavedBuffer(array, interleavedBuffer.stride);
          ib.uuid = interleavedBuffer.uuid;
          interleavedBufferMap[uuid] = ib;
          return ib;
        }
        function getArrayBuffer(json, uuid) {
          if (arrayBufferMap[uuid] !== undefined) return arrayBufferMap[uuid];
          var arrayBuffers = json.arrayBuffers;
          var arrayBuffer = arrayBuffers[uuid];
          var ab = new Uint32Array(arrayBuffer).buffer;
          arrayBufferMap[uuid] = ab;
          return ab;
        }
        var geometry = json.isInstancedBufferGeometry ? new InstancedBufferGeometry() : new BufferGeometry();
        var index = json.data.index;
        if (index !== undefined) {
          var typedArray = getTypedArray(index.type, index.array);
          geometry.setIndex(new BufferAttribute(typedArray, 1));
        }
        var attributes = json.data.attributes;
        for (var key in attributes) {
          var attribute = attributes[key];
          var bufferAttribute = void 0;
          if (attribute.isInterleavedBufferAttribute) {
            var interleavedBuffer = getInterleavedBuffer(json.data, attribute.data);
            bufferAttribute = new InterleavedBufferAttribute(interleavedBuffer, attribute.itemSize, attribute.offset, attribute.normalized);
          } else {
            var _typedArray = getTypedArray(attribute.type, attribute.array);
            var bufferAttributeConstr = attribute.isInstancedBufferAttribute ? InstancedBufferAttribute : BufferAttribute;
            bufferAttribute = new bufferAttributeConstr(_typedArray, attribute.itemSize, attribute.normalized);
          }
          if (attribute.name !== undefined) bufferAttribute.name = attribute.name;
          if (attribute.usage !== undefined) bufferAttribute.setUsage(attribute.usage);
          geometry.setAttribute(key, bufferAttribute);
        }
        var morphAttributes = json.data.morphAttributes;
        if (morphAttributes) {
          for (var _key3 in morphAttributes) {
            var attributeArray = morphAttributes[_key3];
            var array = [];
            for (var i = 0, il = attributeArray.length; i < il; i++) {
              var _attribute3 = attributeArray[i];
              var _bufferAttribute = void 0;
              if (_attribute3.isInterleavedBufferAttribute) {
                var _interleavedBuffer = getInterleavedBuffer(json.data, _attribute3.data);
                _bufferAttribute = new InterleavedBufferAttribute(_interleavedBuffer, _attribute3.itemSize, _attribute3.offset, _attribute3.normalized);
              } else {
                var _typedArray2 = getTypedArray(_attribute3.type, _attribute3.array);
                _bufferAttribute = new BufferAttribute(_typedArray2, _attribute3.itemSize, _attribute3.normalized);
              }
              if (_attribute3.name !== undefined) _bufferAttribute.name = _attribute3.name;
              array.push(_bufferAttribute);
            }
            geometry.morphAttributes[_key3] = array;
          }
        }
        var morphTargetsRelative = json.data.morphTargetsRelative;
        if (morphTargetsRelative) {
          geometry.morphTargetsRelative = true;
        }
        var groups = json.data.groups || json.data.drawcalls || json.data.offsets;
        if (groups !== undefined) {
          for (var _i61 = 0, n = groups.length; _i61 !== n; ++_i61) {
            var group = groups[_i61];
            geometry.addGroup(group.start, group.count, group.materialIndex);
          }
        }
        var boundingSphere = json.data.boundingSphere;
        if (boundingSphere !== undefined) {
          var center = new Vector3();
          if (boundingSphere.center !== undefined) {
            center.fromArray(boundingSphere.center);
          }
          geometry.boundingSphere = new Sphere(center, boundingSphere.radius);
        }
        if (json.name) geometry.name = json.name;
        if (json.userData) geometry.userData = json.userData;
        return geometry;
      }
    }]);
  }(Loader);
  var ObjectLoader = exports.ObjectLoader = /*#__PURE__*/function (_Loader10) {
    function ObjectLoader(manager) {
      (0, _classCallCheck2.default)(this, ObjectLoader);
      return _callSuper(this, ObjectLoader, [manager]);
    }
    (0, _inherits2.default)(ObjectLoader, _Loader10);
    return (0, _createClass2.default)(ObjectLoader, [{
      key: "load",
      value: function load(url, onLoad, onProgress, onError) {
        var scope = this;
        var path = this.path === '' ? LoaderUtils.extractUrlBase(url) : this.path;
        this.resourcePath = this.resourcePath || path;
        var loader = new FileLoader(this.manager);
        loader.setPath(this.path);
        loader.setRequestHeader(this.requestHeader);
        loader.setWithCredentials(this.withCredentials);
        loader.load(url, function (text) {
          var json = null;
          try {
            json = JSON.parse(text);
          } catch (error) {
            if (onError !== undefined) onError(error);
            console.error('THREE:ObjectLoader: Can\'t parse ' + url + '.', error.message);
            return;
          }
          var metadata = json.metadata;
          if (metadata === undefined || metadata.type === undefined || metadata.type.toLowerCase() === 'geometry') {
            if (onError !== undefined) onError(new Error('THREE.ObjectLoader: Can\'t load ' + url));
            console.error('THREE.ObjectLoader: Can\'t load ' + url);
            return;
          }
          scope.parse(json, onLoad);
        }, onProgress, onError);
      }
    }, {
      key: "loadAsync",
      value: function () {
        var _loadAsync = (0, _asyncToGenerator2.default)(function* (url, onProgress) {
          var scope = this;
          var path = this.path === '' ? LoaderUtils.extractUrlBase(url) : this.path;
          this.resourcePath = this.resourcePath || path;
          var loader = new FileLoader(this.manager);
          loader.setPath(this.path);
          loader.setRequestHeader(this.requestHeader);
          loader.setWithCredentials(this.withCredentials);
          var text = yield loader.loadAsync(url, onProgress);
          var json = JSON.parse(text);
          var metadata = json.metadata;
          if (metadata === undefined || metadata.type === undefined || metadata.type.toLowerCase() === 'geometry') {
            throw new Error('THREE.ObjectLoader: Can\'t load ' + url);
          }
          return yield scope.parseAsync(json);
        });
        function loadAsync(_x5, _x6) {
          return _loadAsync.apply(this, arguments);
        }
        return loadAsync;
      }()
    }, {
      key: "parse",
      value: function parse(json, onLoad) {
        var animations = this.parseAnimations(json.animations);
        var shapes = this.parseShapes(json.shapes);
        var geometries = this.parseGeometries(json.geometries, shapes);
        var images = this.parseImages(json.images, function () {
          if (onLoad !== undefined) onLoad(object);
        });
        var textures = this.parseTextures(json.textures, images);
        var materials = this.parseMaterials(json.materials, textures);
        var object = this.parseObject(json.object, geometries, materials, textures, animations);
        var skeletons = this.parseSkeletons(json.skeletons, object);
        this.bindSkeletons(object, skeletons);
        this.bindLightTargets(object);

        //

        if (onLoad !== undefined) {
          var hasImages = false;
          for (var uuid in images) {
            if (images[uuid].data instanceof HTMLImageElement) {
              hasImages = true;
              break;
            }
          }
          if (hasImages === false) onLoad(object);
        }
        return object;
      }
    }, {
      key: "parseAsync",
      value: function () {
        var _parseAsync = (0, _asyncToGenerator2.default)(function* (json) {
          var animations = this.parseAnimations(json.animations);
          var shapes = this.parseShapes(json.shapes);
          var geometries = this.parseGeometries(json.geometries, shapes);
          var images = yield this.parseImagesAsync(json.images);
          var textures = this.parseTextures(json.textures, images);
          var materials = this.parseMaterials(json.materials, textures);
          var object = this.parseObject(json.object, geometries, materials, textures, animations);
          var skeletons = this.parseSkeletons(json.skeletons, object);
          this.bindSkeletons(object, skeletons);
          this.bindLightTargets(object);
          return object;
        });
        function parseAsync(_x7) {
          return _parseAsync.apply(this, arguments);
        }
        return parseAsync;
      }()
    }, {
      key: "parseShapes",
      value: function parseShapes(json) {
        var shapes = {};
        if (json !== undefined) {
          for (var i = 0, l = json.length; i < l; i++) {
            var shape = new Shape().fromJSON(json[i]);
            shapes[shape.uuid] = shape;
          }
        }
        return shapes;
      }
    }, {
      key: "parseSkeletons",
      value: function parseSkeletons(json, object) {
        var skeletons = {};
        var bones = {};

        // generate bone lookup table

        object.traverse(function (child) {
          if (child.isBone) bones[child.uuid] = child;
        });

        // create skeletons

        if (json !== undefined) {
          for (var i = 0, l = json.length; i < l; i++) {
            var skeleton = new Skeleton().fromJSON(json[i], bones);
            skeletons[skeleton.uuid] = skeleton;
          }
        }
        return skeletons;
      }
    }, {
      key: "parseGeometries",
      value: function parseGeometries(json, shapes) {
        var geometries = {};
        if (json !== undefined) {
          var bufferGeometryLoader = new BufferGeometryLoader();
          for (var i = 0, l = json.length; i < l; i++) {
            var geometry = void 0;
            var data = json[i];
            switch (data.type) {
              case 'BufferGeometry':
              case 'InstancedBufferGeometry':
                geometry = bufferGeometryLoader.parse(data);
                break;
              default:
                if (data.type in Geometries) {
                  geometry = Geometries[data.type].fromJSON(data, shapes);
                } else {
                  console.warn(`THREE.ObjectLoader: Unsupported geometry type "${data.type}"`);
                }
            }
            geometry.uuid = data.uuid;
            if (data.name !== undefined) geometry.name = data.name;
            if (data.userData !== undefined) geometry.userData = data.userData;
            geometries[data.uuid] = geometry;
          }
        }
        return geometries;
      }
    }, {
      key: "parseMaterials",
      value: function parseMaterials(json, textures) {
        var cache = {}; // MultiMaterial
        var materials = {};
        if (json !== undefined) {
          var loader = new MaterialLoader();
          loader.setTextures(textures);
          for (var i = 0, l = json.length; i < l; i++) {
            var data = json[i];
            if (cache[data.uuid] === undefined) {
              cache[data.uuid] = loader.parse(data);
            }
            materials[data.uuid] = cache[data.uuid];
          }
        }
        return materials;
      }
    }, {
      key: "parseAnimations",
      value: function parseAnimations(json) {
        var animations = {};
        if (json !== undefined) {
          for (var i = 0; i < json.length; i++) {
            var data = json[i];
            var clip = AnimationClip.parse(data);
            animations[clip.uuid] = clip;
          }
        }
        return animations;
      }
    }, {
      key: "parseImages",
      value: function parseImages(json, onLoad) {
        var scope = this;
        var images = {};
        var loader;
        function loadImage(url) {
          scope.manager.itemStart(url);
          return loader.load(url, function () {
            scope.manager.itemEnd(url);
          }, undefined, function () {
            scope.manager.itemError(url);
            scope.manager.itemEnd(url);
          });
        }
        function deserializeImage(image) {
          if (typeof image === 'string') {
            var url = image;
            var path = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(url) ? url : scope.resourcePath + url;
            return loadImage(path);
          } else {
            if (image.data) {
              return {
                data: getTypedArray(image.type, image.data),
                width: image.width,
                height: image.height
              };
            } else {
              return null;
            }
          }
        }
        if (json !== undefined && json.length > 0) {
          var manager = new LoadingManager(onLoad);
          loader = new ImageLoader(manager);
          loader.setCrossOrigin(this.crossOrigin);
          for (var i = 0, il = json.length; i < il; i++) {
            var image = json[i];
            var url = image.url;
            if (Array.isArray(url)) {
              // load array of images e.g CubeTexture

              var imageArray = [];
              for (var j = 0, jl = url.length; j < jl; j++) {
                var currentUrl = url[j];
                var deserializedImage = deserializeImage(currentUrl);
                if (deserializedImage !== null) {
                  if (deserializedImage instanceof HTMLImageElement) {
                    imageArray.push(deserializedImage);
                  } else {
                    // special case: handle array of data textures for cube textures

                    imageArray.push(new DataTexture(deserializedImage.data, deserializedImage.width, deserializedImage.height));
                  }
                }
              }
              images[image.uuid] = new Source(imageArray);
            } else {
              // load single image

              var _deserializedImage = deserializeImage(image.url);
              images[image.uuid] = new Source(_deserializedImage);
            }
          }
        }
        return images;
      }
    }, {
      key: "parseImagesAsync",
      value: function () {
        var _parseImagesAsync = (0, _asyncToGenerator2.default)(function* (json) {
          var scope = this;
          var images = {};
          var loader;
          function deserializeImage(_x9) {
            return _deserializeImage.apply(this, arguments);
          }
          function _deserializeImage() {
            _deserializeImage = (0, _asyncToGenerator2.default)(function* (image) {
              if (typeof image === 'string') {
                var _url = image;
                var path = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(_url) ? _url : scope.resourcePath + _url;
                return yield loader.loadAsync(path);
              } else {
                if (image.data) {
                  return {
                    data: getTypedArray(image.type, image.data),
                    width: image.width,
                    height: image.height
                  };
                } else {
                  return null;
                }
              }
            });
            return _deserializeImage.apply(this, arguments);
          }
          if (json !== undefined && json.length > 0) {
            loader = new ImageLoader(this.manager);
            loader.setCrossOrigin(this.crossOrigin);
            for (var i = 0, il = json.length; i < il; i++) {
              var image = json[i];
              var url = image.url;
              if (Array.isArray(url)) {
                // load array of images e.g CubeTexture

                var imageArray = [];
                for (var j = 0, jl = url.length; j < jl; j++) {
                  var currentUrl = url[j];
                  var deserializedImage = yield deserializeImage(currentUrl);
                  if (deserializedImage !== null) {
                    if (deserializedImage instanceof HTMLImageElement) {
                      imageArray.push(deserializedImage);
                    } else {
                      // special case: handle array of data textures for cube textures

                      imageArray.push(new DataTexture(deserializedImage.data, deserializedImage.width, deserializedImage.height));
                    }
                  }
                }
                images[image.uuid] = new Source(imageArray);
              } else {
                // load single image

                var _deserializedImage2 = yield deserializeImage(image.url);
                images[image.uuid] = new Source(_deserializedImage2);
              }
            }
          }
          return images;
        });
        function parseImagesAsync(_x8) {
          return _parseImagesAsync.apply(this, arguments);
        }
        return parseImagesAsync;
      }()
    }, {
      key: "parseTextures",
      value: function parseTextures(json, images) {
        function parseConstant(value, type) {
          if (typeof value === 'number') return value;
          console.warn('THREE.ObjectLoader.parseTexture: Constant should be in numeric form.', value);
          return type[value];
        }
        var textures = {};
        if (json !== undefined) {
          for (var i = 0, l = json.length; i < l; i++) {
            var data = json[i];
            if (data.image === undefined) {
              console.warn('THREE.ObjectLoader: No "image" specified for', data.uuid);
            }
            if (images[data.image] === undefined) {
              console.warn('THREE.ObjectLoader: Undefined image', data.image);
            }
            var source = images[data.image];
            var image = source.data;
            var texture = void 0;
            if (Array.isArray(image)) {
              texture = new CubeTexture();
              if (image.length === 6) texture.needsUpdate = true;
            } else {
              if (image && image.data) {
                texture = new DataTexture();
              } else {
                texture = new Texture();
              }
              if (image) texture.needsUpdate = true; // textures can have undefined image data
            }
            texture.source = source;
            texture.uuid = data.uuid;
            if (data.name !== undefined) texture.name = data.name;
            if (data.mapping !== undefined) texture.mapping = parseConstant(data.mapping, TEXTURE_MAPPING);
            if (data.channel !== undefined) texture.channel = data.channel;
            if (data.offset !== undefined) texture.offset.fromArray(data.offset);
            if (data.repeat !== undefined) texture.repeat.fromArray(data.repeat);
            if (data.center !== undefined) texture.center.fromArray(data.center);
            if (data.rotation !== undefined) texture.rotation = data.rotation;
            if (data.wrap !== undefined) {
              texture.wrapS = parseConstant(data.wrap[0], TEXTURE_WRAPPING);
              texture.wrapT = parseConstant(data.wrap[1], TEXTURE_WRAPPING);
            }
            if (data.format !== undefined) texture.format = data.format;
            if (data.internalFormat !== undefined) texture.internalFormat = data.internalFormat;
            if (data.type !== undefined) texture.type = data.type;
            if (data.colorSpace !== undefined) texture.colorSpace = data.colorSpace;
            if (data.minFilter !== undefined) texture.minFilter = parseConstant(data.minFilter, TEXTURE_FILTER);
            if (data.magFilter !== undefined) texture.magFilter = parseConstant(data.magFilter, TEXTURE_FILTER);
            if (data.anisotropy !== undefined) texture.anisotropy = data.anisotropy;
            if (data.flipY !== undefined) texture.flipY = data.flipY;
            if (data.generateMipmaps !== undefined) texture.generateMipmaps = data.generateMipmaps;
            if (data.premultiplyAlpha !== undefined) texture.premultiplyAlpha = data.premultiplyAlpha;
            if (data.unpackAlignment !== undefined) texture.unpackAlignment = data.unpackAlignment;
            if (data.compareFunction !== undefined) texture.compareFunction = data.compareFunction;
            if (data.userData !== undefined) texture.userData = data.userData;
            textures[data.uuid] = texture;
          }
        }
        return textures;
      }
    }, {
      key: "parseObject",
      value: function parseObject(data, geometries, materials, textures, animations) {
        var object;
        function getGeometry(name) {
          if (geometries[name] === undefined) {
            console.warn('THREE.ObjectLoader: Undefined geometry', name);
          }
          return geometries[name];
        }
        function getMaterial(name) {
          if (name === undefined) return undefined;
          if (Array.isArray(name)) {
            var array = [];
            for (var i = 0, l = name.length; i < l; i++) {
              var uuid = name[i];
              if (materials[uuid] === undefined) {
                console.warn('THREE.ObjectLoader: Undefined material', uuid);
              }
              array.push(materials[uuid]);
            }
            return array;
          }
          if (materials[name] === undefined) {
            console.warn('THREE.ObjectLoader: Undefined material', name);
          }
          return materials[name];
        }
        function getTexture(uuid) {
          if (textures[uuid] === undefined) {
            console.warn('THREE.ObjectLoader: Undefined texture', uuid);
          }
          return textures[uuid];
        }
        var geometry, material;
        switch (data.type) {
          case 'Scene':
            object = new Scene();
            if (data.background !== undefined) {
              if (Number.isInteger(data.background)) {
                object.background = new Color(data.background);
              } else {
                object.background = getTexture(data.background);
              }
            }
            if (data.environment !== undefined) {
              object.environment = getTexture(data.environment);
            }
            if (data.fog !== undefined) {
              if (data.fog.type === 'Fog') {
                object.fog = new Fog(data.fog.color, data.fog.near, data.fog.far);
              } else if (data.fog.type === 'FogExp2') {
                object.fog = new FogExp2(data.fog.color, data.fog.density);
              }
              if (data.fog.name !== '') {
                object.fog.name = data.fog.name;
              }
            }
            if (data.backgroundBlurriness !== undefined) object.backgroundBlurriness = data.backgroundBlurriness;
            if (data.backgroundIntensity !== undefined) object.backgroundIntensity = data.backgroundIntensity;
            if (data.backgroundRotation !== undefined) object.backgroundRotation.fromArray(data.backgroundRotation);
            if (data.environmentIntensity !== undefined) object.environmentIntensity = data.environmentIntensity;
            if (data.environmentRotation !== undefined) object.environmentRotation.fromArray(data.environmentRotation);
            break;
          case 'PerspectiveCamera':
            object = new PerspectiveCamera(data.fov, data.aspect, data.near, data.far);
            if (data.focus !== undefined) object.focus = data.focus;
            if (data.zoom !== undefined) object.zoom = data.zoom;
            if (data.filmGauge !== undefined) object.filmGauge = data.filmGauge;
            if (data.filmOffset !== undefined) object.filmOffset = data.filmOffset;
            if (data.view !== undefined) object.view = Object.assign({}, data.view);
            break;
          case 'OrthographicCamera':
            object = new OrthographicCamera(data.left, data.right, data.top, data.bottom, data.near, data.far);
            if (data.zoom !== undefined) object.zoom = data.zoom;
            if (data.view !== undefined) object.view = Object.assign({}, data.view);
            break;
          case 'AmbientLight':
            object = new AmbientLight(data.color, data.intensity);
            break;
          case 'DirectionalLight':
            object = new DirectionalLight(data.color, data.intensity);
            object.target = data.target || '';
            break;
          case 'PointLight':
            object = new PointLight(data.color, data.intensity, data.distance, data.decay);
            break;
          case 'RectAreaLight':
            object = new RectAreaLight(data.color, data.intensity, data.width, data.height);
            break;
          case 'SpotLight':
            object = new SpotLight(data.color, data.intensity, data.distance, data.angle, data.penumbra, data.decay);
            object.target = data.target || '';
            break;
          case 'HemisphereLight':
            object = new HemisphereLight(data.color, data.groundColor, data.intensity);
            break;
          case 'LightProbe':
            object = new LightProbe().fromJSON(data);
            break;
          case 'SkinnedMesh':
            geometry = getGeometry(data.geometry);
            material = getMaterial(data.material);
            object = new SkinnedMesh(geometry, material);
            if (data.bindMode !== undefined) object.bindMode = data.bindMode;
            if (data.bindMatrix !== undefined) object.bindMatrix.fromArray(data.bindMatrix);
            if (data.skeleton !== undefined) object.skeleton = data.skeleton;
            break;
          case 'Mesh':
            geometry = getGeometry(data.geometry);
            material = getMaterial(data.material);
            object = new Mesh(geometry, material);
            break;
          case 'InstancedMesh':
            geometry = getGeometry(data.geometry);
            material = getMaterial(data.material);
            var count = data.count;
            var instanceMatrix = data.instanceMatrix;
            var instanceColor = data.instanceColor;
            object = new InstancedMesh(geometry, material, count);
            object.instanceMatrix = new InstancedBufferAttribute(new Float32Array(instanceMatrix.array), 16);
            if (instanceColor !== undefined) object.instanceColor = new InstancedBufferAttribute(new Float32Array(instanceColor.array), instanceColor.itemSize);
            break;
          case 'BatchedMesh':
            geometry = getGeometry(data.geometry);
            material = getMaterial(data.material);
            object = new BatchedMesh(data.maxInstanceCount, data.maxVertexCount, data.maxIndexCount, material);
            object.geometry = geometry;
            object.perObjectFrustumCulled = data.perObjectFrustumCulled;
            object.sortObjects = data.sortObjects;
            object._drawRanges = data.drawRanges;
            object._reservedRanges = data.reservedRanges;
            object._visibility = data.visibility;
            object._active = data.active;
            object._bounds = data.bounds.map(function (bound) {
              var box = new Box3();
              box.min.fromArray(bound.boxMin);
              box.max.fromArray(bound.boxMax);
              var sphere = new Sphere();
              sphere.radius = bound.sphereRadius;
              sphere.center.fromArray(bound.sphereCenter);
              return {
                boxInitialized: bound.boxInitialized,
                box: box,
                sphereInitialized: bound.sphereInitialized,
                sphere: sphere
              };
            });
            object._maxInstanceCount = data.maxInstanceCount;
            object._maxVertexCount = data.maxVertexCount;
            object._maxIndexCount = data.maxIndexCount;
            object._geometryInitialized = data.geometryInitialized;
            object._geometryCount = data.geometryCount;
            object._matricesTexture = getTexture(data.matricesTexture.uuid);
            if (data.colorsTexture !== undefined) object._colorsTexture = getTexture(data.colorsTexture.uuid);
            break;
          case 'LOD':
            object = new LOD();
            break;
          case 'Line':
            object = new Line(getGeometry(data.geometry), getMaterial(data.material));
            break;
          case 'LineLoop':
            object = new LineLoop(getGeometry(data.geometry), getMaterial(data.material));
            break;
          case 'LineSegments':
            object = new LineSegments(getGeometry(data.geometry), getMaterial(data.material));
            break;
          case 'PointCloud':
          case 'Points':
            object = new Points(getGeometry(data.geometry), getMaterial(data.material));
            break;
          case 'Sprite':
            object = new Sprite(getMaterial(data.material));
            break;
          case 'Group':
            object = new Group();
            break;
          case 'Bone':
            object = new Bone();
            break;
          default:
            object = new Object3D();
        }
        object.uuid = data.uuid;
        if (data.name !== undefined) object.name = data.name;
        if (data.matrix !== undefined) {
          object.matrix.fromArray(data.matrix);
          if (data.matrixAutoUpdate !== undefined) object.matrixAutoUpdate = data.matrixAutoUpdate;
          if (object.matrixAutoUpdate) object.matrix.decompose(object.position, object.quaternion, object.scale);
        } else {
          if (data.position !== undefined) object.position.fromArray(data.position);
          if (data.rotation !== undefined) object.rotation.fromArray(data.rotation);
          if (data.quaternion !== undefined) object.quaternion.fromArray(data.quaternion);
          if (data.scale !== undefined) object.scale.fromArray(data.scale);
        }
        if (data.up !== undefined) object.up.fromArray(data.up);
        if (data.castShadow !== undefined) object.castShadow = data.castShadow;
        if (data.receiveShadow !== undefined) object.receiveShadow = data.receiveShadow;
        if (data.shadow) {
          if (data.shadow.intensity !== undefined) object.shadow.intensity = data.shadow.intensity;
          if (data.shadow.bias !== undefined) object.shadow.bias = data.shadow.bias;
          if (data.shadow.normalBias !== undefined) object.shadow.normalBias = data.shadow.normalBias;
          if (data.shadow.radius !== undefined) object.shadow.radius = data.shadow.radius;
          if (data.shadow.mapSize !== undefined) object.shadow.mapSize.fromArray(data.shadow.mapSize);
          if (data.shadow.camera !== undefined) object.shadow.camera = this.parseObject(data.shadow.camera);
        }
        if (data.visible !== undefined) object.visible = data.visible;
        if (data.frustumCulled !== undefined) object.frustumCulled = data.frustumCulled;
        if (data.renderOrder !== undefined) object.renderOrder = data.renderOrder;
        if (data.userData !== undefined) object.userData = data.userData;
        if (data.layers !== undefined) object.layers.mask = data.layers;
        if (data.children !== undefined) {
          var children = data.children;
          for (var i = 0; i < children.length; i++) {
            object.add(this.parseObject(children[i], geometries, materials, textures, animations));
          }
        }
        if (data.animations !== undefined) {
          var objectAnimations = data.animations;
          for (var _i62 = 0; _i62 < objectAnimations.length; _i62++) {
            var uuid = objectAnimations[_i62];
            object.animations.push(animations[uuid]);
          }
        }
        if (data.type === 'LOD') {
          if (data.autoUpdate !== undefined) object.autoUpdate = data.autoUpdate;
          var levels = data.levels;
          for (var l = 0; l < levels.length; l++) {
            var level = levels[l];
            var child = object.getObjectByProperty('uuid', level.object);
            if (child !== undefined) {
              object.addLevel(child, level.distance, level.hysteresis);
            }
          }
        }
        return object;
      }
    }, {
      key: "bindSkeletons",
      value: function bindSkeletons(object, skeletons) {
        if (Object.keys(skeletons).length === 0) return;
        object.traverse(function (child) {
          if (child.isSkinnedMesh === true && child.skeleton !== undefined) {
            var skeleton = skeletons[child.skeleton];
            if (skeleton === undefined) {
              console.warn('THREE.ObjectLoader: No skeleton found with UUID:', child.skeleton);
            } else {
              child.bind(skeleton, child.bindMatrix);
            }
          }
        });
      }
    }, {
      key: "bindLightTargets",
      value: function bindLightTargets(object) {
        object.traverse(function (child) {
          if (child.isDirectionalLight || child.isSpotLight) {
            var uuid = child.target;
            var target = object.getObjectByProperty('uuid', uuid);
            if (target !== undefined) {
              child.target = target;
            } else {
              child.target = new Object3D();
            }
          }
        });
      }
    }]);
  }(Loader);
  var TEXTURE_MAPPING = {
    UVMapping: UVMapping,
    CubeReflectionMapping: CubeReflectionMapping,
    CubeRefractionMapping: CubeRefractionMapping,
    EquirectangularReflectionMapping: EquirectangularReflectionMapping,
    EquirectangularRefractionMapping: EquirectangularRefractionMapping,
    CubeUVReflectionMapping: CubeUVReflectionMapping
  };
  var TEXTURE_WRAPPING = {
    RepeatWrapping: RepeatWrapping,
    ClampToEdgeWrapping: ClampToEdgeWrapping,
    MirroredRepeatWrapping: MirroredRepeatWrapping
  };
  var TEXTURE_FILTER = {
    NearestFilter: NearestFilter,
    NearestMipmapNearestFilter: NearestMipmapNearestFilter,
    NearestMipmapLinearFilter: NearestMipmapLinearFilter,
    LinearFilter: LinearFilter,
    LinearMipmapNearestFilter: LinearMipmapNearestFilter,
    LinearMipmapLinearFilter: LinearMipmapLinearFilter
  };
  var ImageBitmapLoader = exports.ImageBitmapLoader = /*#__PURE__*/function (_Loader11) {
    function ImageBitmapLoader(manager) {
      var _this107;
      (0, _classCallCheck2.default)(this, ImageBitmapLoader);
      _this107 = _callSuper(this, ImageBitmapLoader, [manager]);
      _this107.isImageBitmapLoader = true;
      if (typeof createImageBitmap === 'undefined') {
        console.warn('THREE.ImageBitmapLoader: createImageBitmap() not supported.');
      }
      if (typeof fetch === 'undefined') {
        console.warn('THREE.ImageBitmapLoader: fetch() not supported.');
      }
      _this107.options = {
        premultiplyAlpha: 'none'
      };
      return _this107;
    }
    (0, _inherits2.default)(ImageBitmapLoader, _Loader11);
    return (0, _createClass2.default)(ImageBitmapLoader, [{
      key: "setOptions",
      value: function setOptions(options) {
        this.options = options;
        return this;
      }
    }, {
      key: "load",
      value: function load(url, onLoad, onProgress, onError) {
        if (url === undefined) url = '';
        if (this.path !== undefined) url = this.path + url;
        url = this.manager.resolveURL(url);
        var scope = this;
        var cached = Cache.get(url);
        if (cached !== undefined) {
          scope.manager.itemStart(url);

          // If cached is a promise, wait for it to resolve
          if (cached.then) {
            cached.then(function (imageBitmap) {
              if (onLoad) onLoad(imageBitmap);
              scope.manager.itemEnd(url);
            }).catch(function (e) {
              if (onError) onError(e);
            });
            return;
          }

          // If cached is not a promise (i.e., it's already an imageBitmap)
          setTimeout(function () {
            if (onLoad) onLoad(cached);
            scope.manager.itemEnd(url);
          }, 0);
          return cached;
        }
        var fetchOptions = {};
        fetchOptions.credentials = this.crossOrigin === 'anonymous' ? 'same-origin' : 'include';
        fetchOptions.headers = this.requestHeader;
        var promise = fetch(url, fetchOptions).then(function (res) {
          return res.blob();
        }).then(function (blob) {
          return createImageBitmap(blob, Object.assign(scope.options, {
            colorSpaceConversion: 'none'
          }));
        }).then(function (imageBitmap) {
          Cache.add(url, imageBitmap);
          if (onLoad) onLoad(imageBitmap);
          scope.manager.itemEnd(url);
          return imageBitmap;
        }).catch(function (e) {
          if (onError) onError(e);
          Cache.remove(url);
          scope.manager.itemError(url);
          scope.manager.itemEnd(url);
        });
        Cache.add(url, promise);
        scope.manager.itemStart(url);
      }
    }]);
  }(Loader);
  var _context;
  var AudioContext = exports.AudioContext = /*#__PURE__*/function () {
    function AudioContext() {
      (0, _classCallCheck2.default)(this, AudioContext);
    }
    return (0, _createClass2.default)(AudioContext, null, [{
      key: "getContext",
      value: function getContext() {
        if (_context === undefined) {
          _context = new (window.AudioContext || window.webkitAudioContext)();
        }
        return _context;
      }
    }, {
      key: "setContext",
      value: function setContext(value) {
        _context = value;
      }
    }]);
  }();
  var AudioLoader = exports.AudioLoader = /*#__PURE__*/function (_Loader12) {
    function AudioLoader(manager) {
      (0, _classCallCheck2.default)(this, AudioLoader);
      return _callSuper(this, AudioLoader, [manager]);
    }
    (0, _inherits2.default)(AudioLoader, _Loader12);
    return (0, _createClass2.default)(AudioLoader, [{
      key: "load",
      value: function load(url, onLoad, onProgress, onError) {
        var scope = this;
        var loader = new FileLoader(this.manager);
        loader.setResponseType('arraybuffer');
        loader.setPath(this.path);
        loader.setRequestHeader(this.requestHeader);
        loader.setWithCredentials(this.withCredentials);
        loader.load(url, function (buffer) {
          try {
            // Create a copy of the buffer. The `decodeAudioData` method
            // detaches the buffer when complete, preventing reuse.
            var bufferCopy = buffer.slice(0);
            var context = AudioContext.getContext();
            context.decodeAudioData(bufferCopy, function (audioBuffer) {
              onLoad(audioBuffer);
            }).catch(handleError);
          } catch (e) {
            handleError(e);
          }
        }, onProgress, onError);
        function handleError(e) {
          if (onError) {
            onError(e);
          } else {
            console.error(e);
          }
          scope.manager.itemError(url);
        }
      }
    }]);
  }(Loader);
  var _eyeRight = /*@__PURE__*/new Matrix4();
  var _eyeLeft = /*@__PURE__*/new Matrix4();
  var _projectionMatrix = /*@__PURE__*/new Matrix4();
  var StereoCamera = exports.StereoCamera = /*#__PURE__*/function () {
    function StereoCamera() {
      (0, _classCallCheck2.default)(this, StereoCamera);
      this.type = 'StereoCamera';
      this.aspect = 1;
      this.eyeSep = 0.064;
      this.cameraL = new PerspectiveCamera();
      this.cameraL.layers.enable(1);
      this.cameraL.matrixAutoUpdate = false;
      this.cameraR = new PerspectiveCamera();
      this.cameraR.layers.enable(2);
      this.cameraR.matrixAutoUpdate = false;
      this._cache = {
        focus: null,
        fov: null,
        aspect: null,
        near: null,
        far: null,
        zoom: null,
        eyeSep: null
      };
    }
    return (0, _createClass2.default)(StereoCamera, [{
      key: "update",
      value: function update(camera) {
        var cache = this._cache;
        var needsUpdate = cache.focus !== camera.focus || cache.fov !== camera.fov || cache.aspect !== camera.aspect * this.aspect || cache.near !== camera.near || cache.far !== camera.far || cache.zoom !== camera.zoom || cache.eyeSep !== this.eyeSep;
        if (needsUpdate) {
          cache.focus = camera.focus;
          cache.fov = camera.fov;
          cache.aspect = camera.aspect * this.aspect;
          cache.near = camera.near;
          cache.far = camera.far;
          cache.zoom = camera.zoom;
          cache.eyeSep = this.eyeSep;

          // Off-axis stereoscopic effect based on
          // http://paulbourke.net/stereographics/stereorender/

          _projectionMatrix.copy(camera.projectionMatrix);
          var eyeSepHalf = cache.eyeSep / 2;
          var eyeSepOnProjection = eyeSepHalf * cache.near / cache.focus;
          var ymax = cache.near * Math.tan(DEG2RAD * cache.fov * 0.5) / cache.zoom;
          var xmin, xmax;

          // translate xOffset

          _eyeLeft.elements[12] = -eyeSepHalf;
          _eyeRight.elements[12] = eyeSepHalf;

          // for left eye

          xmin = -ymax * cache.aspect + eyeSepOnProjection;
          xmax = ymax * cache.aspect + eyeSepOnProjection;
          _projectionMatrix.elements[0] = 2 * cache.near / (xmax - xmin);
          _projectionMatrix.elements[8] = (xmax + xmin) / (xmax - xmin);
          this.cameraL.projectionMatrix.copy(_projectionMatrix);

          // for right eye

          xmin = -ymax * cache.aspect - eyeSepOnProjection;
          xmax = ymax * cache.aspect - eyeSepOnProjection;
          _projectionMatrix.elements[0] = 2 * cache.near / (xmax - xmin);
          _projectionMatrix.elements[8] = (xmax + xmin) / (xmax - xmin);
          this.cameraR.projectionMatrix.copy(_projectionMatrix);
        }
        this.cameraL.matrixWorld.copy(camera.matrixWorld).multiply(_eyeLeft);
        this.cameraR.matrixWorld.copy(camera.matrixWorld).multiply(_eyeRight);
      }
    }]);
  }();
  var ArrayCamera = exports.ArrayCamera = /*#__PURE__*/function (_PerspectiveCamera) {
    function ArrayCamera() {
      var _this108;
      var array = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      (0, _classCallCheck2.default)(this, ArrayCamera);
      _this108 = _callSuper(this, ArrayCamera);
      _this108.isArrayCamera = true;
      _this108.cameras = array;
      return _this108;
    }
    (0, _inherits2.default)(ArrayCamera, _PerspectiveCamera);
    return (0, _createClass2.default)(ArrayCamera);
  }(PerspectiveCamera);
  var Clock = exports.Clock = /*#__PURE__*/function () {
    function Clock() {
      var autoStart = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
      (0, _classCallCheck2.default)(this, Clock);
      this.autoStart = autoStart;
      this.startTime = 0;
      this.oldTime = 0;
      this.elapsedTime = 0;
      this.running = false;
    }
    return (0, _createClass2.default)(Clock, [{
      key: "start",
      value: function start() {
        this.startTime = now();
        this.oldTime = this.startTime;
        this.elapsedTime = 0;
        this.running = true;
      }
    }, {
      key: "stop",
      value: function stop() {
        this.getElapsedTime();
        this.running = false;
        this.autoStart = false;
      }
    }, {
      key: "getElapsedTime",
      value: function getElapsedTime() {
        this.getDelta();
        return this.elapsedTime;
      }
    }, {
      key: "getDelta",
      value: function getDelta() {
        var diff = 0;
        if (this.autoStart && !this.running) {
          this.start();
          return 0;
        }
        if (this.running) {
          var newTime = now();
          diff = (newTime - this.oldTime) / 1000;
          this.oldTime = newTime;
          this.elapsedTime += diff;
        }
        return diff;
      }
    }]);
  }();
  function now() {
    return performance.now();
  }
  var _position$1 = /*@__PURE__*/new Vector3();
  var _quaternion$1 = /*@__PURE__*/new Quaternion();
  var _scale$1 = /*@__PURE__*/new Vector3();
  var _orientation$1 = /*@__PURE__*/new Vector3();
  var AudioListener = exports.AudioListener = /*#__PURE__*/function (_Object3D12) {
    function AudioListener() {
      var _this109;
      (0, _classCallCheck2.default)(this, AudioListener);
      _this109 = _callSuper(this, AudioListener);
      _this109.type = 'AudioListener';
      _this109.context = AudioContext.getContext();
      _this109.gain = _this109.context.createGain();
      _this109.gain.connect(_this109.context.destination);
      _this109.filter = null;
      _this109.timeDelta = 0;

      // private

      _this109._clock = new Clock();
      return _this109;
    }
    (0, _inherits2.default)(AudioListener, _Object3D12);
    return (0, _createClass2.default)(AudioListener, [{
      key: "getInput",
      value: function getInput() {
        return this.gain;
      }
    }, {
      key: "removeFilter",
      value: function removeFilter() {
        if (this.filter !== null) {
          this.gain.disconnect(this.filter);
          this.filter.disconnect(this.context.destination);
          this.gain.connect(this.context.destination);
          this.filter = null;
        }
        return this;
      }
    }, {
      key: "getFilter",
      value: function getFilter() {
        return this.filter;
      }
    }, {
      key: "setFilter",
      value: function setFilter(value) {
        if (this.filter !== null) {
          this.gain.disconnect(this.filter);
          this.filter.disconnect(this.context.destination);
        } else {
          this.gain.disconnect(this.context.destination);
        }
        this.filter = value;
        this.gain.connect(this.filter);
        this.filter.connect(this.context.destination);
        return this;
      }
    }, {
      key: "getMasterVolume",
      value: function getMasterVolume() {
        return this.gain.gain.value;
      }
    }, {
      key: "setMasterVolume",
      value: function setMasterVolume(value) {
        this.gain.gain.setTargetAtTime(value, this.context.currentTime, 0.01);
        return this;
      }
    }, {
      key: "updateMatrixWorld",
      value: function updateMatrixWorld(force) {
        _superPropGet(AudioListener, "updateMatrixWorld", this, 3)([force]);
        var listener = this.context.listener;
        var up = this.up;
        this.timeDelta = this._clock.getDelta();
        this.matrixWorld.decompose(_position$1, _quaternion$1, _scale$1);
        _orientation$1.set(0, 0, -1).applyQuaternion(_quaternion$1);
        if (listener.positionX) {
          // code path for Chrome (see #14393)

          var endTime = this.context.currentTime + this.timeDelta;
          listener.positionX.linearRampToValueAtTime(_position$1.x, endTime);
          listener.positionY.linearRampToValueAtTime(_position$1.y, endTime);
          listener.positionZ.linearRampToValueAtTime(_position$1.z, endTime);
          listener.forwardX.linearRampToValueAtTime(_orientation$1.x, endTime);
          listener.forwardY.linearRampToValueAtTime(_orientation$1.y, endTime);
          listener.forwardZ.linearRampToValueAtTime(_orientation$1.z, endTime);
          listener.upX.linearRampToValueAtTime(up.x, endTime);
          listener.upY.linearRampToValueAtTime(up.y, endTime);
          listener.upZ.linearRampToValueAtTime(up.z, endTime);
        } else {
          listener.setPosition(_position$1.x, _position$1.y, _position$1.z);
          listener.setOrientation(_orientation$1.x, _orientation$1.y, _orientation$1.z, up.x, up.y, up.z);
        }
      }
    }]);
  }(Object3D);
  var Audio = exports.Audio = /*#__PURE__*/function (_Object3D13) {
    function Audio(listener) {
      var _this110;
      (0, _classCallCheck2.default)(this, Audio);
      _this110 = _callSuper(this, Audio);
      _this110.type = 'Audio';
      _this110.listener = listener;
      _this110.context = listener.context;
      _this110.gain = _this110.context.createGain();
      _this110.gain.connect(listener.getInput());
      _this110.autoplay = false;
      _this110.buffer = null;
      _this110.detune = 0;
      _this110.loop = false;
      _this110.loopStart = 0;
      _this110.loopEnd = 0;
      _this110.offset = 0;
      _this110.duration = undefined;
      _this110.playbackRate = 1;
      _this110.isPlaying = false;
      _this110.hasPlaybackControl = true;
      _this110.source = null;
      _this110.sourceType = 'empty';
      _this110._startedAt = 0;
      _this110._progress = 0;
      _this110._connected = false;
      _this110.filters = [];
      return _this110;
    }
    (0, _inherits2.default)(Audio, _Object3D13);
    return (0, _createClass2.default)(Audio, [{
      key: "getOutput",
      value: function getOutput() {
        return this.gain;
      }
    }, {
      key: "setNodeSource",
      value: function setNodeSource(audioNode) {
        this.hasPlaybackControl = false;
        this.sourceType = 'audioNode';
        this.source = audioNode;
        this.connect();
        return this;
      }
    }, {
      key: "setMediaElementSource",
      value: function setMediaElementSource(mediaElement) {
        this.hasPlaybackControl = false;
        this.sourceType = 'mediaNode';
        this.source = this.context.createMediaElementSource(mediaElement);
        this.connect();
        return this;
      }
    }, {
      key: "setMediaStreamSource",
      value: function setMediaStreamSource(mediaStream) {
        this.hasPlaybackControl = false;
        this.sourceType = 'mediaStreamNode';
        this.source = this.context.createMediaStreamSource(mediaStream);
        this.connect();
        return this;
      }
    }, {
      key: "setBuffer",
      value: function setBuffer(audioBuffer) {
        this.buffer = audioBuffer;
        this.sourceType = 'buffer';
        if (this.autoplay) this.play();
        return this;
      }
    }, {
      key: "play",
      value: function play() {
        var delay = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
        if (this.isPlaying === true) {
          console.warn('THREE.Audio: Audio is already playing.');
          return;
        }
        if (this.hasPlaybackControl === false) {
          console.warn('THREE.Audio: this Audio has no playback control.');
          return;
        }
        this._startedAt = this.context.currentTime + delay;
        var source = this.context.createBufferSource();
        source.buffer = this.buffer;
        source.loop = this.loop;
        source.loopStart = this.loopStart;
        source.loopEnd = this.loopEnd;
        source.onended = this.onEnded.bind(this);
        source.start(this._startedAt, this._progress + this.offset, this.duration);
        this.isPlaying = true;
        this.source = source;
        this.setDetune(this.detune);
        this.setPlaybackRate(this.playbackRate);
        return this.connect();
      }
    }, {
      key: "pause",
      value: function pause() {
        if (this.hasPlaybackControl === false) {
          console.warn('THREE.Audio: this Audio has no playback control.');
          return;
        }
        if (this.isPlaying === true) {
          // update current progress

          this._progress += Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate;
          if (this.loop === true) {
            // ensure _progress does not exceed duration with looped audios

            this._progress = this._progress % (this.duration || this.buffer.duration);
          }
          this.source.stop();
          this.source.onended = null;
          this.isPlaying = false;
        }
        return this;
      }
    }, {
      key: "stop",
      value: function stop() {
        var delay = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
        if (this.hasPlaybackControl === false) {
          console.warn('THREE.Audio: this Audio has no playback control.');
          return;
        }
        this._progress = 0;
        if (this.source !== null) {
          this.source.stop(this.context.currentTime + delay);
          this.source.onended = null;
        }
        this.isPlaying = false;
        return this;
      }
    }, {
      key: "connect",
      value: function connect() {
        if (this.filters.length > 0) {
          this.source.connect(this.filters[0]);
          for (var i = 1, l = this.filters.length; i < l; i++) {
            this.filters[i - 1].connect(this.filters[i]);
          }
          this.filters[this.filters.length - 1].connect(this.getOutput());
        } else {
          this.source.connect(this.getOutput());
        }
        this._connected = true;
        return this;
      }
    }, {
      key: "disconnect",
      value: function disconnect() {
        if (this._connected === false) {
          return;
        }
        if (this.filters.length > 0) {
          this.source.disconnect(this.filters[0]);
          for (var i = 1, l = this.filters.length; i < l; i++) {
            this.filters[i - 1].disconnect(this.filters[i]);
          }
          this.filters[this.filters.length - 1].disconnect(this.getOutput());
        } else {
          this.source.disconnect(this.getOutput());
        }
        this._connected = false;
        return this;
      }
    }, {
      key: "getFilters",
      value: function getFilters() {
        return this.filters;
      }
    }, {
      key: "setFilters",
      value: function setFilters(value) {
        if (!value) value = [];
        if (this._connected === true) {
          this.disconnect();
          this.filters = value.slice();
          this.connect();
        } else {
          this.filters = value.slice();
        }
        return this;
      }
    }, {
      key: "setDetune",
      value: function setDetune(value) {
        this.detune = value;
        if (this.isPlaying === true && this.source.detune !== undefined) {
          this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, 0.01);
        }
        return this;
      }
    }, {
      key: "getDetune",
      value: function getDetune() {
        return this.detune;
      }
    }, {
      key: "getFilter",
      value: function getFilter() {
        return this.getFilters()[0];
      }
    }, {
      key: "setFilter",
      value: function setFilter(filter) {
        return this.setFilters(filter ? [filter] : []);
      }
    }, {
      key: "setPlaybackRate",
      value: function setPlaybackRate(value) {
        if (this.hasPlaybackControl === false) {
          console.warn('THREE.Audio: this Audio has no playback control.');
          return;
        }
        this.playbackRate = value;
        if (this.isPlaying === true) {
          this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, 0.01);
        }
        return this;
      }
    }, {
      key: "getPlaybackRate",
      value: function getPlaybackRate() {
        return this.playbackRate;
      }
    }, {
      key: "onEnded",
      value: function onEnded() {
        this.isPlaying = false;
        this._progress = 0;
      }
    }, {
      key: "getLoop",
      value: function getLoop() {
        if (this.hasPlaybackControl === false) {
          console.warn('THREE.Audio: this Audio has no playback control.');
          return false;
        }
        return this.loop;
      }
    }, {
      key: "setLoop",
      value: function setLoop(value) {
        if (this.hasPlaybackControl === false) {
          console.warn('THREE.Audio: this Audio has no playback control.');
          return;
        }
        this.loop = value;
        if (this.isPlaying === true) {
          this.source.loop = this.loop;
        }
        return this;
      }
    }, {
      key: "setLoopStart",
      value: function setLoopStart(value) {
        this.loopStart = value;
        return this;
      }
    }, {
      key: "setLoopEnd",
      value: function setLoopEnd(value) {
        this.loopEnd = value;
        return this;
      }
    }, {
      key: "getVolume",
      value: function getVolume() {
        return this.gain.gain.value;
      }
    }, {
      key: "setVolume",
      value: function setVolume(value) {
        this.gain.gain.setTargetAtTime(value, this.context.currentTime, 0.01);
        return this;
      }
    }, {
      key: "copy",
      value: function copy(source, recursive) {
        _superPropGet(Audio, "copy", this, 3)([source, recursive]);
        if (source.sourceType !== 'buffer') {
          console.warn('THREE.Audio: Audio source type cannot be copied.');
          return this;
        }
        this.autoplay = source.autoplay;
        this.buffer = source.buffer;
        this.detune = source.detune;
        this.loop = source.loop;
        this.loopStart = source.loopStart;
        this.loopEnd = source.loopEnd;
        this.offset = source.offset;
        this.duration = source.duration;
        this.playbackRate = source.playbackRate;
        this.hasPlaybackControl = source.hasPlaybackControl;
        this.sourceType = source.sourceType;
        this.filters = source.filters.slice();
        return this;
      }
    }, {
      key: "clone",
      value: function clone(recursive) {
        return new this.constructor(this.listener).copy(this, recursive);
      }
    }]);
  }(Object3D);
  var _position = /*@__PURE__*/new Vector3();
  var _quaternion = /*@__PURE__*/new Quaternion();
  var _scale = /*@__PURE__*/new Vector3();
  var _orientation = /*@__PURE__*/new Vector3();
  var PositionalAudio = exports.PositionalAudio = /*#__PURE__*/function (_Audio) {
    function PositionalAudio(listener) {
      var _this111;
      (0, _classCallCheck2.default)(this, PositionalAudio);
      _this111 = _callSuper(this, PositionalAudio, [listener]);
      _this111.panner = _this111.context.createPanner();
      _this111.panner.panningModel = 'HRTF';
      _this111.panner.connect(_this111.gain);
      return _this111;
    }
    (0, _inherits2.default)(PositionalAudio, _Audio);
    return (0, _createClass2.default)(PositionalAudio, [{
      key: "connect",
      value: function connect() {
        _superPropGet(PositionalAudio, "connect", this, 3)([]);
        this.panner.connect(this.gain);
      }
    }, {
      key: "disconnect",
      value: function disconnect() {
        _superPropGet(PositionalAudio, "disconnect", this, 3)([]);
        this.panner.disconnect(this.gain);
      }
    }, {
      key: "getOutput",
      value: function getOutput() {
        return this.panner;
      }
    }, {
      key: "getRefDistance",
      value: function getRefDistance() {
        return this.panner.refDistance;
      }
    }, {
      key: "setRefDistance",
      value: function setRefDistance(value) {
        this.panner.refDistance = value;
        return this;
      }
    }, {
      key: "getRolloffFactor",
      value: function getRolloffFactor() {
        return this.panner.rolloffFactor;
      }
    }, {
      key: "setRolloffFactor",
      value: function setRolloffFactor(value) {
        this.panner.rolloffFactor = value;
        return this;
      }
    }, {
      key: "getDistanceModel",
      value: function getDistanceModel() {
        return this.panner.distanceModel;
      }
    }, {
      key: "setDistanceModel",
      value: function setDistanceModel(value) {
        this.panner.distanceModel = value;
        return this;
      }
    }, {
      key: "getMaxDistance",
      value: function getMaxDistance() {
        return this.panner.maxDistance;
      }
    }, {
      key: "setMaxDistance",
      value: function setMaxDistance(value) {
        this.panner.maxDistance = value;
        return this;
      }
    }, {
      key: "setDirectionalCone",
      value: function setDirectionalCone(coneInnerAngle, coneOuterAngle, coneOuterGain) {
        this.panner.coneInnerAngle = coneInnerAngle;
        this.panner.coneOuterAngle = coneOuterAngle;
        this.panner.coneOuterGain = coneOuterGain;
        return this;
      }
    }, {
      key: "updateMatrixWorld",
      value: function updateMatrixWorld(force) {
        _superPropGet(PositionalAudio, "updateMatrixWorld", this, 3)([force]);
        if (this.hasPlaybackControl === true && this.isPlaying === false) return;
        this.matrixWorld.decompose(_position, _quaternion, _scale);
        _orientation.set(0, 0, 1).applyQuaternion(_quaternion);
        var panner = this.panner;
        if (panner.positionX) {
          // code path for Chrome and Firefox (see #14393)

          var endTime = this.context.currentTime + this.listener.timeDelta;
          panner.positionX.linearRampToValueAtTime(_position.x, endTime);
          panner.positionY.linearRampToValueAtTime(_position.y, endTime);
          panner.positionZ.linearRampToValueAtTime(_position.z, endTime);
          panner.orientationX.linearRampToValueAtTime(_orientation.x, endTime);
          panner.orientationY.linearRampToValueAtTime(_orientation.y, endTime);
          panner.orientationZ.linearRampToValueAtTime(_orientation.z, endTime);
        } else {
          panner.setPosition(_position.x, _position.y, _position.z);
          panner.setOrientation(_orientation.x, _orientation.y, _orientation.z);
        }
      }
    }]);
  }(Audio);
  var AudioAnalyser = exports.AudioAnalyser = /*#__PURE__*/function () {
    function AudioAnalyser(audio) {
      var fftSize = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2048;
      (0, _classCallCheck2.default)(this, AudioAnalyser);
      this.analyser = audio.context.createAnalyser();
      this.analyser.fftSize = fftSize;
      this.data = new Uint8Array(this.analyser.frequencyBinCount);
      audio.getOutput().connect(this.analyser);
    }
    return (0, _createClass2.default)(AudioAnalyser, [{
      key: "getFrequencyData",
      value: function getFrequencyData() {
        this.analyser.getByteFrequencyData(this.data);
        return this.data;
      }
    }, {
      key: "getAverageFrequency",
      value: function getAverageFrequency() {
        var value = 0;
        var data = this.getFrequencyData();
        for (var i = 0; i < data.length; i++) {
          value += data[i];
        }
        return value / data.length;
      }
    }]);
  }();
  var PropertyMixer = exports.PropertyMixer = /*#__PURE__*/function () {
    function PropertyMixer(binding, typeName, valueSize) {
      (0, _classCallCheck2.default)(this, PropertyMixer);
      this.binding = binding;
      this.valueSize = valueSize;
      var mixFunction, mixFunctionAdditive, setIdentity;

      // buffer layout: [ incoming | accu0 | accu1 | orig | addAccu | (optional work) ]
      //
      // interpolators can use .buffer as their .result
      // the data then goes to 'incoming'
      //
      // 'accu0' and 'accu1' are used frame-interleaved for
      // the cumulative result and are compared to detect
      // changes
      //
      // 'orig' stores the original state of the property
      //
      // 'add' is used for additive cumulative results
      //
      // 'work' is optional and is only present for quaternion types. It is used
      // to store intermediate quaternion multiplication results

      switch (typeName) {
        case 'quaternion':
          mixFunction = this._slerp;
          mixFunctionAdditive = this._slerpAdditive;
          setIdentity = this._setAdditiveIdentityQuaternion;
          this.buffer = new Float64Array(valueSize * 6);
          this._workIndex = 5;
          break;
        case 'string':
        case 'bool':
          mixFunction = this._select;

          // Use the regular mix function and for additive on these types,
          // additive is not relevant for non-numeric types
          mixFunctionAdditive = this._select;
          setIdentity = this._setAdditiveIdentityOther;
          this.buffer = new Array(valueSize * 5);
          break;
        default:
          mixFunction = this._lerp;
          mixFunctionAdditive = this._lerpAdditive;
          setIdentity = this._setAdditiveIdentityNumeric;
          this.buffer = new Float64Array(valueSize * 5);
      }
      this._mixBufferRegion = mixFunction;
      this._mixBufferRegionAdditive = mixFunctionAdditive;
      this._setIdentity = setIdentity;
      this._origIndex = 3;
      this._addIndex = 4;
      this.cumulativeWeight = 0;
      this.cumulativeWeightAdditive = 0;
      this.useCount = 0;
      this.referenceCount = 0;
    }

    // accumulate data in the 'incoming' region into 'accu<i>'
    return (0, _createClass2.default)(PropertyMixer, [{
      key: "accumulate",
      value: function accumulate(accuIndex, weight) {
        // note: happily accumulating nothing when weight = 0, the caller knows
        // the weight and shouldn't have made the call in the first place

        var buffer = this.buffer,
          stride = this.valueSize,
          offset = accuIndex * stride + stride;
        var currentWeight = this.cumulativeWeight;
        if (currentWeight === 0) {
          // accuN := incoming * weight

          for (var i = 0; i !== stride; ++i) {
            buffer[offset + i] = buffer[i];
          }
          currentWeight = weight;
        } else {
          // accuN := accuN + incoming * weight

          currentWeight += weight;
          var mix = weight / currentWeight;
          this._mixBufferRegion(buffer, offset, 0, mix, stride);
        }
        this.cumulativeWeight = currentWeight;
      }

      // accumulate data in the 'incoming' region into 'add'
    }, {
      key: "accumulateAdditive",
      value: function accumulateAdditive(weight) {
        var buffer = this.buffer,
          stride = this.valueSize,
          offset = stride * this._addIndex;
        if (this.cumulativeWeightAdditive === 0) {
          // add = identity

          this._setIdentity();
        }

        // add := add + incoming * weight

        this._mixBufferRegionAdditive(buffer, offset, 0, weight, stride);
        this.cumulativeWeightAdditive += weight;
      }

      // apply the state of 'accu<i>' to the binding when accus differ
    }, {
      key: "apply",
      value: function apply(accuIndex) {
        var stride = this.valueSize,
          buffer = this.buffer,
          offset = accuIndex * stride + stride,
          weight = this.cumulativeWeight,
          weightAdditive = this.cumulativeWeightAdditive,
          binding = this.binding;
        this.cumulativeWeight = 0;
        this.cumulativeWeightAdditive = 0;
        if (weight < 1) {
          // accuN := accuN + original * ( 1 - cumulativeWeight )

          var originalValueOffset = stride * this._origIndex;
          this._mixBufferRegion(buffer, offset, originalValueOffset, 1 - weight, stride);
        }
        if (weightAdditive > 0) {
          // accuN := accuN + additive accuN

          this._mixBufferRegionAdditive(buffer, offset, this._addIndex * stride, 1, stride);
        }
        for (var i = stride, e = stride + stride; i !== e; ++i) {
          if (buffer[i] !== buffer[i + stride]) {
            // value has changed -> update scene graph

            binding.setValue(buffer, offset);
            break;
          }
        }
      }

      // remember the state of the bound property and copy it to both accus
    }, {
      key: "saveOriginalState",
      value: function saveOriginalState() {
        var binding = this.binding;
        var buffer = this.buffer,
          stride = this.valueSize,
          originalValueOffset = stride * this._origIndex;
        binding.getValue(buffer, originalValueOffset);

        // accu[0..1] := orig -- initially detect changes against the original
        for (var i = stride, e = originalValueOffset; i !== e; ++i) {
          buffer[i] = buffer[originalValueOffset + i % stride];
        }

        // Add to identity for additive
        this._setIdentity();
        this.cumulativeWeight = 0;
        this.cumulativeWeightAdditive = 0;
      }

      // apply the state previously taken via 'saveOriginalState' to the binding
    }, {
      key: "restoreOriginalState",
      value: function restoreOriginalState() {
        var originalValueOffset = this.valueSize * 3;
        this.binding.setValue(this.buffer, originalValueOffset);
      }
    }, {
      key: "_setAdditiveIdentityNumeric",
      value: function _setAdditiveIdentityNumeric() {
        var startIndex = this._addIndex * this.valueSize;
        var endIndex = startIndex + this.valueSize;
        for (var i = startIndex; i < endIndex; i++) {
          this.buffer[i] = 0;
        }
      }
    }, {
      key: "_setAdditiveIdentityQuaternion",
      value: function _setAdditiveIdentityQuaternion() {
        this._setAdditiveIdentityNumeric();
        this.buffer[this._addIndex * this.valueSize + 3] = 1;
      }
    }, {
      key: "_setAdditiveIdentityOther",
      value: function _setAdditiveIdentityOther() {
        var startIndex = this._origIndex * this.valueSize;
        var targetIndex = this._addIndex * this.valueSize;
        for (var i = 0; i < this.valueSize; i++) {
          this.buffer[targetIndex + i] = this.buffer[startIndex + i];
        }
      }

      // mix functions
    }, {
      key: "_select",
      value: function _select(buffer, dstOffset, srcOffset, t, stride) {
        if (t >= 0.5) {
          for (var i = 0; i !== stride; ++i) {
            buffer[dstOffset + i] = buffer[srcOffset + i];
          }
        }
      }
    }, {
      key: "_slerp",
      value: function _slerp(buffer, dstOffset, srcOffset, t) {
        Quaternion.slerpFlat(buffer, dstOffset, buffer, dstOffset, buffer, srcOffset, t);
      }
    }, {
      key: "_slerpAdditive",
      value: function _slerpAdditive(buffer, dstOffset, srcOffset, t, stride) {
        var workOffset = this._workIndex * stride;

        // Store result in intermediate buffer offset
        Quaternion.multiplyQuaternionsFlat(buffer, workOffset, buffer, dstOffset, buffer, srcOffset);

        // Slerp to the intermediate result
        Quaternion.slerpFlat(buffer, dstOffset, buffer, dstOffset, buffer, workOffset, t);
      }
    }, {
      key: "_lerp",
      value: function _lerp(buffer, dstOffset, srcOffset, t, stride) {
        var s = 1 - t;
        for (var i = 0; i !== stride; ++i) {
          var j = dstOffset + i;
          buffer[j] = buffer[j] * s + buffer[srcOffset + i] * t;
        }
      }
    }, {
      key: "_lerpAdditive",
      value: function _lerpAdditive(buffer, dstOffset, srcOffset, t, stride) {
        for (var i = 0; i !== stride; ++i) {
          var j = dstOffset + i;
          buffer[j] = buffer[j] + buffer[srcOffset + i] * t;
        }
      }
    }]);
  }(); // Characters [].:/ are reserved for track binding syntax.
  var _RESERVED_CHARS_RE = '\\[\\]\\.:\\/';
  var _reservedRe = new RegExp('[' + _RESERVED_CHARS_RE + ']', 'g');

  // Attempts to allow node names from any language. ES5's `\w` regexp matches
  // only latin characters, and the unicode \p{L} is not yet supported. So
  // instead, we exclude reserved characters and match everything else.
  var _wordChar = '[^' + _RESERVED_CHARS_RE + ']';
  var _wordCharOrDot = '[^' + _RESERVED_CHARS_RE.replace('\\.', '') + ']';

  // Parent directories, delimited by '/' or ':'. Currently unused, but must
  // be matched to parse the rest of the track name.
  var _directoryRe = /*@__PURE__*//((?:WC+[\/:])*)/.source.replace('WC', _wordChar);

  // Target node. May contain word characters (a-zA-Z0-9_) and '.' or '-'.
  var _nodeRe = /*@__PURE__*//(WCOD+)?/.source.replace('WCOD', _wordCharOrDot);

  // Object on target node, and accessor. May not contain reserved
  // characters. Accessor may contain any character except closing bracket.
  var _objectRe = /*@__PURE__*//(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace('WC', _wordChar);

  // Property and accessor. May not contain reserved characters. Accessor may
  // contain any non-bracket characters.
  var _propertyRe = /*@__PURE__*//\.(WC+)(?:\[(.+)\])?/.source.replace('WC', _wordChar);
  var _trackRe = new RegExp('' + '^' + _directoryRe + _nodeRe + _objectRe + _propertyRe + '$');
  var _supportedObjectNames = ['material', 'materials', 'bones', 'map'];
  var Composite = /*#__PURE__*/function () {
    function Composite(targetGroup, path, optionalParsedPath) {
      (0, _classCallCheck2.default)(this, Composite);
      var parsedPath = optionalParsedPath || PropertyBinding.parseTrackName(path);
      this._targetGroup = targetGroup;
      this._bindings = targetGroup.subscribe_(path, parsedPath);
    }
    return (0, _createClass2.default)(Composite, [{
      key: "getValue",
      value: function getValue(array, offset) {
        this.bind(); // bind all binding

        var firstValidIndex = this._targetGroup.nCachedObjects_,
          binding = this._bindings[firstValidIndex];

        // and only call .getValue on the first
        if (binding !== undefined) binding.getValue(array, offset);
      }
    }, {
      key: "setValue",
      value: function setValue(array, offset) {
        var bindings = this._bindings;
        for (var i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++i) {
          bindings[i].setValue(array, offset);
        }
      }
    }, {
      key: "bind",
      value: function bind() {
        var bindings = this._bindings;
        for (var i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++i) {
          bindings[i].bind();
        }
      }
    }, {
      key: "unbind",
      value: function unbind() {
        var bindings = this._bindings;
        for (var i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++i) {
          bindings[i].unbind();
        }
      }
    }]);
  }(); // Note: This class uses a State pattern on a per-method basis:
  // 'bind' sets 'this.getValue' / 'setValue' and shadows the
  // prototype version of these methods with one that represents
  // the bound state. When the property is not found, the methods
  // become no-ops.
  var PropertyBinding = exports.PropertyBinding = /*#__PURE__*/function () {
    function PropertyBinding(rootNode, path, parsedPath) {
      (0, _classCallCheck2.default)(this, PropertyBinding);
      this.path = path;
      this.parsedPath = parsedPath || PropertyBinding.parseTrackName(path);
      this.node = PropertyBinding.findNode(rootNode, this.parsedPath.nodeName);
      this.rootNode = rootNode;

      // initial state of these methods that calls 'bind'
      this.getValue = this._getValue_unbound;
      this.setValue = this._setValue_unbound;
    }
    return (0, _createClass2.default)(PropertyBinding, [{
      key: "_getValue_unavailable",
      value:
      // these are used to "bind" a nonexistent property
      function _getValue_unavailable() {}
    }, {
      key: "_setValue_unavailable",
      value: function _setValue_unavailable() {}

      // Getters
    }, {
      key: "_getValue_direct",
      value: function _getValue_direct(buffer, offset) {
        buffer[offset] = this.targetObject[this.propertyName];
      }
    }, {
      key: "_getValue_array",
      value: function _getValue_array(buffer, offset) {
        var source = this.resolvedProperty;
        for (var i = 0, n = source.length; i !== n; ++i) {
          buffer[offset++] = source[i];
        }
      }
    }, {
      key: "_getValue_arrayElement",
      value: function _getValue_arrayElement(buffer, offset) {
        buffer[offset] = this.resolvedProperty[this.propertyIndex];
      }
    }, {
      key: "_getValue_toArray",
      value: function _getValue_toArray(buffer, offset) {
        this.resolvedProperty.toArray(buffer, offset);
      }

      // Direct
    }, {
      key: "_setValue_direct",
      value: function _setValue_direct(buffer, offset) {
        this.targetObject[this.propertyName] = buffer[offset];
      }
    }, {
      key: "_setValue_direct_setNeedsUpdate",
      value: function _setValue_direct_setNeedsUpdate(buffer, offset) {
        this.targetObject[this.propertyName] = buffer[offset];
        this.targetObject.needsUpdate = true;
      }
    }, {
      key: "_setValue_direct_setMatrixWorldNeedsUpdate",
      value: function _setValue_direct_setMatrixWorldNeedsUpdate(buffer, offset) {
        this.targetObject[this.propertyName] = buffer[offset];
        this.targetObject.matrixWorldNeedsUpdate = true;
      }

      // EntireArray
    }, {
      key: "_setValue_array",
      value: function _setValue_array(buffer, offset) {
        var dest = this.resolvedProperty;
        for (var i = 0, n = dest.length; i !== n; ++i) {
          dest[i] = buffer[offset++];
        }
      }
    }, {
      key: "_setValue_array_setNeedsUpdate",
      value: function _setValue_array_setNeedsUpdate(buffer, offset) {
        var dest = this.resolvedProperty;
        for (var i = 0, n = dest.length; i !== n; ++i) {
          dest[i] = buffer[offset++];
        }
        this.targetObject.needsUpdate = true;
      }
    }, {
      key: "_setValue_array_setMatrixWorldNeedsUpdate",
      value: function _setValue_array_setMatrixWorldNeedsUpdate(buffer, offset) {
        var dest = this.resolvedProperty;
        for (var i = 0, n = dest.length; i !== n; ++i) {
          dest[i] = buffer[offset++];
        }
        this.targetObject.matrixWorldNeedsUpdate = true;
      }

      // ArrayElement
    }, {
      key: "_setValue_arrayElement",
      value: function _setValue_arrayElement(buffer, offset) {
        this.resolvedProperty[this.propertyIndex] = buffer[offset];
      }
    }, {
      key: "_setValue_arrayElement_setNeedsUpdate",
      value: function _setValue_arrayElement_setNeedsUpdate(buffer, offset) {
        this.resolvedProperty[this.propertyIndex] = buffer[offset];
        this.targetObject.needsUpdate = true;
      }
    }, {
      key: "_setValue_arrayElement_setMatrixWorldNeedsUpdate",
      value: function _setValue_arrayElement_setMatrixWorldNeedsUpdate(buffer, offset) {
        this.resolvedProperty[this.propertyIndex] = buffer[offset];
        this.targetObject.matrixWorldNeedsUpdate = true;
      }

      // HasToFromArray
    }, {
      key: "_setValue_fromArray",
      value: function _setValue_fromArray(buffer, offset) {
        this.resolvedProperty.fromArray(buffer, offset);
      }
    }, {
      key: "_setValue_fromArray_setNeedsUpdate",
      value: function _setValue_fromArray_setNeedsUpdate(buffer, offset) {
        this.resolvedProperty.fromArray(buffer, offset);
        this.targetObject.needsUpdate = true;
      }
    }, {
      key: "_setValue_fromArray_setMatrixWorldNeedsUpdate",
      value: function _setValue_fromArray_setMatrixWorldNeedsUpdate(buffer, offset) {
        this.resolvedProperty.fromArray(buffer, offset);
        this.targetObject.matrixWorldNeedsUpdate = true;
      }
    }, {
      key: "_getValue_unbound",
      value: function _getValue_unbound(targetArray, offset) {
        this.bind();
        this.getValue(targetArray, offset);
      }
    }, {
      key: "_setValue_unbound",
      value: function _setValue_unbound(sourceArray, offset) {
        this.bind();
        this.setValue(sourceArray, offset);
      }

      // create getter / setter pair for a property in the scene graph
    }, {
      key: "bind",
      value: function bind() {
        var targetObject = this.node;
        var parsedPath = this.parsedPath;
        var objectName = parsedPath.objectName;
        var propertyName = parsedPath.propertyName;
        var propertyIndex = parsedPath.propertyIndex;
        if (!targetObject) {
          targetObject = PropertyBinding.findNode(this.rootNode, parsedPath.nodeName);
          this.node = targetObject;
        }

        // set fail state so we can just 'return' on error
        this.getValue = this._getValue_unavailable;
        this.setValue = this._setValue_unavailable;

        // ensure there is a value node
        if (!targetObject) {
          console.warn('THREE.PropertyBinding: No target node found for track: ' + this.path + '.');
          return;
        }
        if (objectName) {
          var objectIndex = parsedPath.objectIndex;

          // special cases were we need to reach deeper into the hierarchy to get the face materials....
          switch (objectName) {
            case 'materials':
              if (!targetObject.material) {
                console.error('THREE.PropertyBinding: Can not bind to material as node does not have a material.', this);
                return;
              }
              if (!targetObject.material.materials) {
                console.error('THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.', this);
                return;
              }
              targetObject = targetObject.material.materials;
              break;
            case 'bones':
              if (!targetObject.skeleton) {
                console.error('THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.', this);
                return;
              }

              // potential future optimization: skip this if propertyIndex is already an integer
              // and convert the integer string to a true integer.

              targetObject = targetObject.skeleton.bones;

              // support resolving morphTarget names into indices.
              for (var i = 0; i < targetObject.length; i++) {
                if (targetObject[i].name === objectIndex) {
                  objectIndex = i;
                  break;
                }
              }
              break;
            case 'map':
              if ('map' in targetObject) {
                targetObject = targetObject.map;
                break;
              }
              if (!targetObject.material) {
                console.error('THREE.PropertyBinding: Can not bind to material as node does not have a material.', this);
                return;
              }
              if (!targetObject.material.map) {
                console.error('THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.', this);
                return;
              }
              targetObject = targetObject.material.map;
              break;
            default:
              if (targetObject[objectName] === undefined) {
                console.error('THREE.PropertyBinding: Can not bind to objectName of node undefined.', this);
                return;
              }
              targetObject = targetObject[objectName];
          }
          if (objectIndex !== undefined) {
            if (targetObject[objectIndex] === undefined) {
              console.error('THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.', this, targetObject);
              return;
            }
            targetObject = targetObject[objectIndex];
          }
        }

        // resolve property
        var nodeProperty = targetObject[propertyName];
        if (nodeProperty === undefined) {
          var nodeName = parsedPath.nodeName;
          console.error('THREE.PropertyBinding: Trying to update property for track: ' + nodeName + '.' + propertyName + ' but it wasn\'t found.', targetObject);
          return;
        }

        // determine versioning scheme
        var versioning = this.Versioning.None;
        this.targetObject = targetObject;
        if (targetObject.isMaterial === true) {
          versioning = this.Versioning.NeedsUpdate;
        } else if (targetObject.isObject3D === true) {
          versioning = this.Versioning.MatrixWorldNeedsUpdate;
        }

        // determine how the property gets bound
        var bindingType = this.BindingType.Direct;
        if (propertyIndex !== undefined) {
          // access a sub element of the property array (only primitives are supported right now)

          if (propertyName === 'morphTargetInfluences') {
            // potential optimization, skip this if propertyIndex is already an integer, and convert the integer string to a true integer.

            // support resolving morphTarget names into indices.
            if (!targetObject.geometry) {
              console.error('THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.', this);
              return;
            }
            if (!targetObject.geometry.morphAttributes) {
              console.error('THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.', this);
              return;
            }
            if (targetObject.morphTargetDictionary[propertyIndex] !== undefined) {
              propertyIndex = targetObject.morphTargetDictionary[propertyIndex];
            }
          }
          bindingType = this.BindingType.ArrayElement;
          this.resolvedProperty = nodeProperty;
          this.propertyIndex = propertyIndex;
        } else if (nodeProperty.fromArray !== undefined && nodeProperty.toArray !== undefined) {
          // must use copy for Object3D.Euler/Quaternion

          bindingType = this.BindingType.HasFromToArray;
          this.resolvedProperty = nodeProperty;
        } else if (Array.isArray(nodeProperty)) {
          bindingType = this.BindingType.EntireArray;
          this.resolvedProperty = nodeProperty;
        } else {
          this.propertyName = propertyName;
        }

        // select getter / setter
        this.getValue = this.GetterByBindingType[bindingType];
        this.setValue = this.SetterByBindingTypeAndVersioning[bindingType][versioning];
      }
    }, {
      key: "unbind",
      value: function unbind() {
        this.node = null;

        // back to the prototype version of getValue / setValue
        // note: avoiding to mutate the shape of 'this' via 'delete'
        this.getValue = this._getValue_unbound;
        this.setValue = this._setValue_unbound;
      }
    }], [{
      key: "create",
      value: function create(root, path, parsedPath) {
        if (!(root && root.isAnimationObjectGroup)) {
          return new PropertyBinding(root, path, parsedPath);
        } else {
          return new PropertyBinding.Composite(root, path, parsedPath);
        }
      }

      /**
       * Replaces spaces with underscores and removes unsupported characters from
       * node names, to ensure compatibility with parseTrackName().
       *
       * @param {string} name Node name to be sanitized.
       * @return {string}
       */
    }, {
      key: "sanitizeNodeName",
      value: function sanitizeNodeName(name) {
        return name.replace(/\s/g, '_').replace(_reservedRe, '');
      }
    }, {
      key: "parseTrackName",
      value: function parseTrackName(trackName) {
        var matches = _trackRe.exec(trackName);
        if (matches === null) {
          throw new Error('PropertyBinding: Cannot parse trackName: ' + trackName);
        }
        var results = {
          // directoryName: matches[ 1 ], // (tschw) currently unused
          nodeName: matches[2],
          objectName: matches[3],
          objectIndex: matches[4],
          propertyName: matches[5],
          // required
          propertyIndex: matches[6]
        };
        var lastDot = results.nodeName && results.nodeName.lastIndexOf('.');
        if (lastDot !== undefined && lastDot !== -1) {
          var objectName = results.nodeName.substring(lastDot + 1);

          // Object names must be checked against an allowlist. Otherwise, there
          // is no way to parse 'foo.bar.baz': 'baz' must be a property, but
          // 'bar' could be the objectName, or part of a nodeName (which can
          // include '.' characters).
          if (_supportedObjectNames.indexOf(objectName) !== -1) {
            results.nodeName = results.nodeName.substring(0, lastDot);
            results.objectName = objectName;
          }
        }
        if (results.propertyName === null || results.propertyName.length === 0) {
          throw new Error('PropertyBinding: can not parse propertyName from trackName: ' + trackName);
        }
        return results;
      }
    }, {
      key: "findNode",
      value: function findNode(root, nodeName) {
        if (nodeName === undefined || nodeName === '' || nodeName === '.' || nodeName === -1 || nodeName === root.name || nodeName === root.uuid) {
          return root;
        }

        // search into skeleton bones.
        if (root.skeleton) {
          var bone = root.skeleton.getBoneByName(nodeName);
          if (bone !== undefined) {
            return bone;
          }
        }

        // search into node subtree.
        if (root.children) {
          var _searchNodeSubtree = function searchNodeSubtree(children) {
            for (var i = 0; i < children.length; i++) {
              var childNode = children[i];
              if (childNode.name === nodeName || childNode.uuid === nodeName) {
                return childNode;
              }
              var result = _searchNodeSubtree(childNode.children);
              if (result) return result;
            }
            return null;
          };
          var subTreeNode = _searchNodeSubtree(root.children);
          if (subTreeNode) {
            return subTreeNode;
          }
        }
        return null;
      }
    }]);
  }();
  PropertyBinding.Composite = Composite;
  PropertyBinding.prototype.BindingType = {
    Direct: 0,
    EntireArray: 1,
    ArrayElement: 2,
    HasFromToArray: 3
  };
  PropertyBinding.prototype.Versioning = {
    None: 0,
    NeedsUpdate: 1,
    MatrixWorldNeedsUpdate: 2
  };
  PropertyBinding.prototype.GetterByBindingType = [PropertyBinding.prototype._getValue_direct, PropertyBinding.prototype._getValue_array, PropertyBinding.prototype._getValue_arrayElement, PropertyBinding.prototype._getValue_toArray];
  PropertyBinding.prototype.SetterByBindingTypeAndVersioning = [[
  // Direct
  PropertyBinding.prototype._setValue_direct, PropertyBinding.prototype._setValue_direct_setNeedsUpdate, PropertyBinding.prototype._setValue_direct_setMatrixWorldNeedsUpdate], [
  // EntireArray

  PropertyBinding.prototype._setValue_array, PropertyBinding.prototype._setValue_array_setNeedsUpdate, PropertyBinding.prototype._setValue_array_setMatrixWorldNeedsUpdate], [
  // ArrayElement
  PropertyBinding.prototype._setValue_arrayElement, PropertyBinding.prototype._setValue_arrayElement_setNeedsUpdate, PropertyBinding.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate], [
  // HasToFromArray
  PropertyBinding.prototype._setValue_fromArray, PropertyBinding.prototype._setValue_fromArray_setNeedsUpdate, PropertyBinding.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]];

  /**
   *
   * A group of objects that receives a shared animation state.
   *
   * Usage:
   *
   *  - Add objects you would otherwise pass as 'root' to the
   *    constructor or the .clipAction method of AnimationMixer.
   *
   *  - Instead pass this object as 'root'.
   *
   *  - You can also add and remove objects later when the mixer
   *    is running.
   *
   * Note:
   *
   *    Objects of this class appear as one object to the mixer,
   *    so cache control of the individual objects must be done
   *    on the group.
   *
   * Limitation:
   *
   *  - The animated properties must be compatible among the
   *    all objects in the group.
   *
   *  - A single property can either be controlled through a
   *    target group or directly, but not both.
   */
  var AnimationObjectGroup = exports.AnimationObjectGroup = /*#__PURE__*/function () {
    function AnimationObjectGroup() {
      (0, _classCallCheck2.default)(this, AnimationObjectGroup);
      this.isAnimationObjectGroup = true;
      this.uuid = generateUUID();

      // cached objects followed by the active ones
      this._objects = Array.prototype.slice.call(arguments);
      this.nCachedObjects_ = 0; // threshold
      // note: read by PropertyBinding.Composite

      var indices = {};
      this._indicesByUUID = indices; // for bookkeeping

      for (var i = 0, n = arguments.length; i !== n; ++i) {
        indices[arguments[i].uuid] = i;
      }
      this._paths = []; // inside: string
      this._parsedPaths = []; // inside: { we don't care, here }
      this._bindings = []; // inside: Array< PropertyBinding >
      this._bindingsIndicesByPath = {}; // inside: indices in these arrays

      var scope = this;
      this.stats = {
        objects: {
          get total() {
            return scope._objects.length;
          },
          get inUse() {
            return this.total - scope.nCachedObjects_;
          }
        },
        get bindingsPerObject() {
          return scope._bindings.length;
        }
      };
    }
    return (0, _createClass2.default)(AnimationObjectGroup, [{
      key: "add",
      value: function add() {
        var objects = this._objects,
          indicesByUUID = this._indicesByUUID,
          paths = this._paths,
          parsedPaths = this._parsedPaths,
          bindings = this._bindings,
          nBindings = bindings.length;
        var knownObject = undefined,
          nObjects = objects.length,
          nCachedObjects = this.nCachedObjects_;
        for (var i = 0, n = arguments.length; i !== n; ++i) {
          var object = arguments[i],
            uuid = object.uuid;
          var index = indicesByUUID[uuid];
          if (index === undefined) {
            // unknown object -> add it to the ACTIVE region

            index = nObjects++;
            indicesByUUID[uuid] = index;
            objects.push(object);

            // accounting is done, now do the same for all bindings

            for (var j = 0, m = nBindings; j !== m; ++j) {
              bindings[j].push(new PropertyBinding(object, paths[j], parsedPaths[j]));
            }
          } else if (index < nCachedObjects) {
            knownObject = objects[index];

            // move existing object to the ACTIVE region

            var firstActiveIndex = --nCachedObjects,
              lastCachedObject = objects[firstActiveIndex];
            indicesByUUID[lastCachedObject.uuid] = index;
            objects[index] = lastCachedObject;
            indicesByUUID[uuid] = firstActiveIndex;
            objects[firstActiveIndex] = object;

            // accounting is done, now do the same for all bindings

            for (var _j14 = 0, _m2 = nBindings; _j14 !== _m2; ++_j14) {
              var bindingsForPath = bindings[_j14],
                lastCached = bindingsForPath[firstActiveIndex];
              var binding = bindingsForPath[index];
              bindingsForPath[index] = lastCached;
              if (binding === undefined) {
                // since we do not bother to create new bindings
                // for objects that are cached, the binding may
                // or may not exist

                binding = new PropertyBinding(object, paths[_j14], parsedPaths[_j14]);
              }
              bindingsForPath[firstActiveIndex] = binding;
            }
          } else if (objects[index] !== knownObject) {
            console.error('THREE.AnimationObjectGroup: Different objects with the same UUID ' + 'detected. Clean the caches or recreate your infrastructure when reloading scenes.');
          } // else the object is already where we want it to be
        } // for arguments

        this.nCachedObjects_ = nCachedObjects;
      }
    }, {
      key: "remove",
      value: function remove() {
        var objects = this._objects,
          indicesByUUID = this._indicesByUUID,
          bindings = this._bindings,
          nBindings = bindings.length;
        var nCachedObjects = this.nCachedObjects_;
        for (var i = 0, n = arguments.length; i !== n; ++i) {
          var object = arguments[i],
            uuid = object.uuid,
            index = indicesByUUID[uuid];
          if (index !== undefined && index >= nCachedObjects) {
            // move existing object into the CACHED region

            var lastCachedIndex = nCachedObjects++,
              firstActiveObject = objects[lastCachedIndex];
            indicesByUUID[firstActiveObject.uuid] = index;
            objects[index] = firstActiveObject;
            indicesByUUID[uuid] = lastCachedIndex;
            objects[lastCachedIndex] = object;

            // accounting is done, now do the same for all bindings

            for (var j = 0, m = nBindings; j !== m; ++j) {
              var bindingsForPath = bindings[j],
                firstActive = bindingsForPath[lastCachedIndex],
                binding = bindingsForPath[index];
              bindingsForPath[index] = firstActive;
              bindingsForPath[lastCachedIndex] = binding;
            }
          }
        } // for arguments

        this.nCachedObjects_ = nCachedObjects;
      }

      // remove & forget
    }, {
      key: "uncache",
      value: function uncache() {
        var objects = this._objects,
          indicesByUUID = this._indicesByUUID,
          bindings = this._bindings,
          nBindings = bindings.length;
        var nCachedObjects = this.nCachedObjects_,
          nObjects = objects.length;
        for (var i = 0, n = arguments.length; i !== n; ++i) {
          var object = arguments[i],
            uuid = object.uuid,
            index = indicesByUUID[uuid];
          if (index !== undefined) {
            delete indicesByUUID[uuid];
            if (index < nCachedObjects) {
              // object is cached, shrink the CACHED region

              var firstActiveIndex = --nCachedObjects,
                lastCachedObject = objects[firstActiveIndex],
                lastIndex = --nObjects,
                lastObject = objects[lastIndex];

              // last cached object takes this object's place
              indicesByUUID[lastCachedObject.uuid] = index;
              objects[index] = lastCachedObject;

              // last object goes to the activated slot and pop
              indicesByUUID[lastObject.uuid] = firstActiveIndex;
              objects[firstActiveIndex] = lastObject;
              objects.pop();

              // accounting is done, now do the same for all bindings

              for (var j = 0, m = nBindings; j !== m; ++j) {
                var bindingsForPath = bindings[j],
                  lastCached = bindingsForPath[firstActiveIndex],
                  last = bindingsForPath[lastIndex];
                bindingsForPath[index] = lastCached;
                bindingsForPath[firstActiveIndex] = last;
                bindingsForPath.pop();
              }
            } else {
              // object is active, just swap with the last and pop

              var _lastIndex = --nObjects,
                _lastObject = objects[_lastIndex];
              if (_lastIndex > 0) {
                indicesByUUID[_lastObject.uuid] = index;
              }
              objects[index] = _lastObject;
              objects.pop();

              // accounting is done, now do the same for all bindings

              for (var _j15 = 0, _m4 = nBindings; _j15 !== _m4; ++_j15) {
                var _bindingsForPath = bindings[_j15];
                _bindingsForPath[index] = _bindingsForPath[_lastIndex];
                _bindingsForPath.pop();
              }
            } // cached or active
          } // if object is known
        } // for arguments

        this.nCachedObjects_ = nCachedObjects;
      }

      // Internal interface used by befriended PropertyBinding.Composite:
    }, {
      key: "subscribe_",
      value: function subscribe_(path, parsedPath) {
        // returns an array of bindings for the given path that is changed
        // according to the contained objects in the group

        var indicesByPath = this._bindingsIndicesByPath;
        var index = indicesByPath[path];
        var bindings = this._bindings;
        if (index !== undefined) return bindings[index];
        var paths = this._paths,
          parsedPaths = this._parsedPaths,
          objects = this._objects,
          nObjects = objects.length,
          nCachedObjects = this.nCachedObjects_,
          bindingsForPath = new Array(nObjects);
        index = bindings.length;
        indicesByPath[path] = index;
        paths.push(path);
        parsedPaths.push(parsedPath);
        bindings.push(bindingsForPath);
        for (var i = nCachedObjects, n = objects.length; i !== n; ++i) {
          var object = objects[i];
          bindingsForPath[i] = new PropertyBinding(object, path, parsedPath);
        }
        return bindingsForPath;
      }
    }, {
      key: "unsubscribe_",
      value: function unsubscribe_(path) {
        // tells the group to forget about a property path and no longer
        // update the array previously obtained with 'subscribe_'

        var indicesByPath = this._bindingsIndicesByPath,
          index = indicesByPath[path];
        if (index !== undefined) {
          var paths = this._paths,
            parsedPaths = this._parsedPaths,
            bindings = this._bindings,
            lastBindingsIndex = bindings.length - 1,
            lastBindings = bindings[lastBindingsIndex],
            lastBindingsPath = path[lastBindingsIndex];
          indicesByPath[lastBindingsPath] = index;
          bindings[index] = lastBindings;
          bindings.pop();
          parsedPaths[index] = parsedPaths[lastBindingsIndex];
          parsedPaths.pop();
          paths[index] = paths[lastBindingsIndex];
          paths.pop();
        }
      }
    }]);
  }();
  var AnimationAction = exports.AnimationAction = /*#__PURE__*/function () {
    function AnimationAction(mixer, clip) {
      var localRoot = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
      var blendMode = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : clip.blendMode;
      (0, _classCallCheck2.default)(this, AnimationAction);
      this._mixer = mixer;
      this._clip = clip;
      this._localRoot = localRoot;
      this.blendMode = blendMode;
      var tracks = clip.tracks,
        nTracks = tracks.length,
        interpolants = new Array(nTracks);
      var interpolantSettings = {
        endingStart: ZeroCurvatureEnding,
        endingEnd: ZeroCurvatureEnding
      };
      for (var i = 0; i !== nTracks; ++i) {
        var interpolant = tracks[i].createInterpolant(null);
        interpolants[i] = interpolant;
        interpolant.settings = interpolantSettings;
      }
      this._interpolantSettings = interpolantSettings;
      this._interpolants = interpolants; // bound by the mixer

      // inside: PropertyMixer (managed by the mixer)
      this._propertyBindings = new Array(nTracks);
      this._cacheIndex = null; // for the memory manager
      this._byClipCacheIndex = null; // for the memory manager

      this._timeScaleInterpolant = null;
      this._weightInterpolant = null;
      this.loop = LoopRepeat;
      this._loopCount = -1;

      // global mixer time when the action is to be started
      // it's set back to 'null' upon start of the action
      this._startTime = null;

      // scaled local time of the action
      // gets clamped or wrapped to 0..clip.duration according to loop
      this.time = 0;
      this.timeScale = 1;
      this._effectiveTimeScale = 1;
      this.weight = 1;
      this._effectiveWeight = 1;
      this.repetitions = Infinity; // no. of repetitions when looping

      this.paused = false; // true -> zero effective time scale
      this.enabled = true; // false -> zero effective weight

      this.clampWhenFinished = false; // keep feeding the last frame?

      this.zeroSlopeAtStart = true; // for smooth interpolation w/o separate
      this.zeroSlopeAtEnd = true; // clips for start, loop and end
    }

    // State & Scheduling
    return (0, _createClass2.default)(AnimationAction, [{
      key: "play",
      value: function play() {
        this._mixer._activateAction(this);
        return this;
      }
    }, {
      key: "stop",
      value: function stop() {
        this._mixer._deactivateAction(this);
        return this.reset();
      }
    }, {
      key: "reset",
      value: function reset() {
        this.paused = false;
        this.enabled = true;
        this.time = 0; // restart clip
        this._loopCount = -1; // forget previous loops
        this._startTime = null; // forget scheduling

        return this.stopFading().stopWarping();
      }
    }, {
      key: "isRunning",
      value: function isRunning() {
        return this.enabled && !this.paused && this.timeScale !== 0 && this._startTime === null && this._mixer._isActiveAction(this);
      }

      // return true when play has been called
    }, {
      key: "isScheduled",
      value: function isScheduled() {
        return this._mixer._isActiveAction(this);
      }
    }, {
      key: "startAt",
      value: function startAt(time) {
        this._startTime = time;
        return this;
      }
    }, {
      key: "setLoop",
      value: function setLoop(mode, repetitions) {
        this.loop = mode;
        this.repetitions = repetitions;
        return this;
      }

      // Weight

      // set the weight stopping any scheduled fading
      // although .enabled = false yields an effective weight of zero, this
      // method does *not* change .enabled, because it would be confusing
    }, {
      key: "setEffectiveWeight",
      value: function setEffectiveWeight(weight) {
        this.weight = weight;

        // note: same logic as when updated at runtime
        this._effectiveWeight = this.enabled ? weight : 0;
        return this.stopFading();
      }

      // return the weight considering fading and .enabled
    }, {
      key: "getEffectiveWeight",
      value: function getEffectiveWeight() {
        return this._effectiveWeight;
      }
    }, {
      key: "fadeIn",
      value: function fadeIn(duration) {
        return this._scheduleFading(duration, 0, 1);
      }
    }, {
      key: "fadeOut",
      value: function fadeOut(duration) {
        return this._scheduleFading(duration, 1, 0);
      }
    }, {
      key: "crossFadeFrom",
      value: function crossFadeFrom(fadeOutAction, duration, warp) {
        fadeOutAction.fadeOut(duration);
        this.fadeIn(duration);
        if (warp) {
          var fadeInDuration = this._clip.duration,
            fadeOutDuration = fadeOutAction._clip.duration,
            startEndRatio = fadeOutDuration / fadeInDuration,
            endStartRatio = fadeInDuration / fadeOutDuration;
          fadeOutAction.warp(1.0, startEndRatio, duration);
          this.warp(endStartRatio, 1.0, duration);
        }
        return this;
      }
    }, {
      key: "crossFadeTo",
      value: function crossFadeTo(fadeInAction, duration, warp) {
        return fadeInAction.crossFadeFrom(this, duration, warp);
      }
    }, {
      key: "stopFading",
      value: function stopFading() {
        var weightInterpolant = this._weightInterpolant;
        if (weightInterpolant !== null) {
          this._weightInterpolant = null;
          this._mixer._takeBackControlInterpolant(weightInterpolant);
        }
        return this;
      }

      // Time Scale Control

      // set the time scale stopping any scheduled warping
      // although .paused = true yields an effective time scale of zero, this
      // method does *not* change .paused, because it would be confusing
    }, {
      key: "setEffectiveTimeScale",
      value: function setEffectiveTimeScale(timeScale) {
        this.timeScale = timeScale;
        this._effectiveTimeScale = this.paused ? 0 : timeScale;
        return this.stopWarping();
      }

      // return the time scale considering warping and .paused
    }, {
      key: "getEffectiveTimeScale",
      value: function getEffectiveTimeScale() {
        return this._effectiveTimeScale;
      }
    }, {
      key: "setDuration",
      value: function setDuration(duration) {
        this.timeScale = this._clip.duration / duration;
        return this.stopWarping();
      }
    }, {
      key: "syncWith",
      value: function syncWith(action) {
        this.time = action.time;
        this.timeScale = action.timeScale;
        return this.stopWarping();
      }
    }, {
      key: "halt",
      value: function halt(duration) {
        return this.warp(this._effectiveTimeScale, 0, duration);
      }
    }, {
      key: "warp",
      value: function warp(startTimeScale, endTimeScale, duration) {
        var mixer = this._mixer,
          now = mixer.time,
          timeScale = this.timeScale;
        var interpolant = this._timeScaleInterpolant;
        if (interpolant === null) {
          interpolant = mixer._lendControlInterpolant();
          this._timeScaleInterpolant = interpolant;
        }
        var times = interpolant.parameterPositions,
          values = interpolant.sampleValues;
        times[0] = now;
        times[1] = now + duration;
        values[0] = startTimeScale / timeScale;
        values[1] = endTimeScale / timeScale;
        return this;
      }
    }, {
      key: "stopWarping",
      value: function stopWarping() {
        var timeScaleInterpolant = this._timeScaleInterpolant;
        if (timeScaleInterpolant !== null) {
          this._timeScaleInterpolant = null;
          this._mixer._takeBackControlInterpolant(timeScaleInterpolant);
        }
        return this;
      }

      // Object Accessors
    }, {
      key: "getMixer",
      value: function getMixer() {
        return this._mixer;
      }
    }, {
      key: "getClip",
      value: function getClip() {
        return this._clip;
      }
    }, {
      key: "getRoot",
      value: function getRoot() {
        return this._localRoot || this._mixer._root;
      }

      // Interna
    }, {
      key: "_update",
      value: function _update(time, deltaTime, timeDirection, accuIndex) {
        // called by the mixer

        if (!this.enabled) {
          // call ._updateWeight() to update ._effectiveWeight

          this._updateWeight(time);
          return;
        }
        var startTime = this._startTime;
        if (startTime !== null) {
          // check for scheduled start of action

          var timeRunning = (time - startTime) * timeDirection;
          if (timeRunning < 0 || timeDirection === 0) {
            deltaTime = 0;
          } else {
            this._startTime = null; // unschedule
            deltaTime = timeDirection * timeRunning;
          }
        }

        // apply time scale and advance time

        deltaTime *= this._updateTimeScale(time);
        var clipTime = this._updateTime(deltaTime);

        // note: _updateTime may disable the action resulting in
        // an effective weight of 0

        var weight = this._updateWeight(time);
        if (weight > 0) {
          var interpolants = this._interpolants;
          var propertyMixers = this._propertyBindings;
          switch (this.blendMode) {
            case AdditiveAnimationBlendMode:
              for (var j = 0, m = interpolants.length; j !== m; ++j) {
                interpolants[j].evaluate(clipTime);
                propertyMixers[j].accumulateAdditive(weight);
              }
              break;
            case NormalAnimationBlendMode:
            default:
              for (var _j16 = 0, _m5 = interpolants.length; _j16 !== _m5; ++_j16) {
                interpolants[_j16].evaluate(clipTime);
                propertyMixers[_j16].accumulate(accuIndex, weight);
              }
          }
        }
      }
    }, {
      key: "_updateWeight",
      value: function _updateWeight(time) {
        var weight = 0;
        if (this.enabled) {
          weight = this.weight;
          var interpolant = this._weightInterpolant;
          if (interpolant !== null) {
            var interpolantValue = interpolant.evaluate(time)[0];
            weight *= interpolantValue;
            if (time > interpolant.parameterPositions[1]) {
              this.stopFading();
              if (interpolantValue === 0) {
                // faded out, disable
                this.enabled = false;
              }
            }
          }
        }
        this._effectiveWeight = weight;
        return weight;
      }
    }, {
      key: "_updateTimeScale",
      value: function _updateTimeScale(time) {
        var timeScale = 0;
        if (!this.paused) {
          timeScale = this.timeScale;
          var interpolant = this._timeScaleInterpolant;
          if (interpolant !== null) {
            var interpolantValue = interpolant.evaluate(time)[0];
            timeScale *= interpolantValue;
            if (time > interpolant.parameterPositions[1]) {
              this.stopWarping();
              if (timeScale === 0) {
                // motion has halted, pause
                this.paused = true;
              } else {
                // warp done - apply final time scale
                this.timeScale = timeScale;
              }
            }
          }
        }
        this._effectiveTimeScale = timeScale;
        return timeScale;
      }
    }, {
      key: "_updateTime",
      value: function _updateTime(deltaTime) {
        var duration = this._clip.duration;
        var loop = this.loop;
        var time = this.time + deltaTime;
        var loopCount = this._loopCount;
        var pingPong = loop === LoopPingPong;
        if (deltaTime === 0) {
          if (loopCount === -1) return time;
          return pingPong && (loopCount & 1) === 1 ? duration - time : time;
        }
        if (loop === LoopOnce) {
          if (loopCount === -1) {
            // just started

            this._loopCount = 0;
            this._setEndings(true, true, false);
          }
          handle_stop: {
            if (time >= duration) {
              time = duration;
            } else if (time < 0) {
              time = 0;
            } else {
              this.time = time;
              break handle_stop;
            }
            if (this.clampWhenFinished) this.paused = true;else this.enabled = false;
            this.time = time;
            this._mixer.dispatchEvent({
              type: 'finished',
              action: this,
              direction: deltaTime < 0 ? -1 : 1
            });
          }
        } else {
          // repetitive Repeat or PingPong

          if (loopCount === -1) {
            // just started

            if (deltaTime >= 0) {
              loopCount = 0;
              this._setEndings(true, this.repetitions === 0, pingPong);
            } else {
              // when looping in reverse direction, the initial
              // transition through zero counts as a repetition,
              // so leave loopCount at -1

              this._setEndings(this.repetitions === 0, true, pingPong);
            }
          }
          if (time >= duration || time < 0) {
            // wrap around

            var loopDelta = Math.floor(time / duration); // signed
            time -= duration * loopDelta;
            loopCount += Math.abs(loopDelta);
            var pending = this.repetitions - loopCount;
            if (pending <= 0) {
              // have to stop (switch state, clamp time, fire event)

              if (this.clampWhenFinished) this.paused = true;else this.enabled = false;
              time = deltaTime > 0 ? duration : 0;
              this.time = time;
              this._mixer.dispatchEvent({
                type: 'finished',
                action: this,
                direction: deltaTime > 0 ? 1 : -1
              });
            } else {
              // keep running

              if (pending === 1) {
                // entering the last round

                var atStart = deltaTime < 0;
                this._setEndings(atStart, !atStart, pingPong);
              } else {
                this._setEndings(false, false, pingPong);
              }
              this._loopCount = loopCount;
              this.time = time;
              this._mixer.dispatchEvent({
                type: 'loop',
                action: this,
                loopDelta: loopDelta
              });
            }
          } else {
            this.time = time;
          }
          if (pingPong && (loopCount & 1) === 1) {
            // invert time for the "pong round"

            return duration - time;
          }
        }
        return time;
      }
    }, {
      key: "_setEndings",
      value: function _setEndings(atStart, atEnd, pingPong) {
        var settings = this._interpolantSettings;
        if (pingPong) {
          settings.endingStart = ZeroSlopeEnding;
          settings.endingEnd = ZeroSlopeEnding;
        } else {
          // assuming for LoopOnce atStart == atEnd == true

          if (atStart) {
            settings.endingStart = this.zeroSlopeAtStart ? ZeroSlopeEnding : ZeroCurvatureEnding;
          } else {
            settings.endingStart = WrapAroundEnding;
          }
          if (atEnd) {
            settings.endingEnd = this.zeroSlopeAtEnd ? ZeroSlopeEnding : ZeroCurvatureEnding;
          } else {
            settings.endingEnd = WrapAroundEnding;
          }
        }
      }
    }, {
      key: "_scheduleFading",
      value: function _scheduleFading(duration, weightNow, weightThen) {
        var mixer = this._mixer,
          now = mixer.time;
        var interpolant = this._weightInterpolant;
        if (interpolant === null) {
          interpolant = mixer._lendControlInterpolant();
          this._weightInterpolant = interpolant;
        }
        var times = interpolant.parameterPositions,
          values = interpolant.sampleValues;
        times[0] = now;
        values[0] = weightNow;
        times[1] = now + duration;
        values[1] = weightThen;
        return this;
      }
    }]);
  }();
  var _controlInterpolantsResultBuffer = new Float32Array(1);
  var AnimationMixer = exports.AnimationMixer = /*#__PURE__*/function (_EventDispatcher6) {
    function AnimationMixer(root) {
      var _this112;
      (0, _classCallCheck2.default)(this, AnimationMixer);
      _this112 = _callSuper(this, AnimationMixer);
      _this112._root = root;
      _this112._initMemoryManager();
      _this112._accuIndex = 0;
      _this112.time = 0;
      _this112.timeScale = 1.0;
      return _this112;
    }
    (0, _inherits2.default)(AnimationMixer, _EventDispatcher6);
    return (0, _createClass2.default)(AnimationMixer, [{
      key: "_bindAction",
      value: function _bindAction(action, prototypeAction) {
        var root = action._localRoot || this._root,
          tracks = action._clip.tracks,
          nTracks = tracks.length,
          bindings = action._propertyBindings,
          interpolants = action._interpolants,
          rootUuid = root.uuid,
          bindingsByRoot = this._bindingsByRootAndName;
        var bindingsByName = bindingsByRoot[rootUuid];
        if (bindingsByName === undefined) {
          bindingsByName = {};
          bindingsByRoot[rootUuid] = bindingsByName;
        }
        for (var i = 0; i !== nTracks; ++i) {
          var track = tracks[i],
            trackName = track.name;
          var binding = bindingsByName[trackName];
          if (binding !== undefined) {
            ++binding.referenceCount;
            bindings[i] = binding;
          } else {
            binding = bindings[i];
            if (binding !== undefined) {
              // existing binding, make sure the cache knows

              if (binding._cacheIndex === null) {
                ++binding.referenceCount;
                this._addInactiveBinding(binding, rootUuid, trackName);
              }
              continue;
            }
            var path = prototypeAction && prototypeAction._propertyBindings[i].binding.parsedPath;
            binding = new PropertyMixer(PropertyBinding.create(root, trackName, path), track.ValueTypeName, track.getValueSize());
            ++binding.referenceCount;
            this._addInactiveBinding(binding, rootUuid, trackName);
            bindings[i] = binding;
          }
          interpolants[i].resultBuffer = binding.buffer;
        }
      }
    }, {
      key: "_activateAction",
      value: function _activateAction(action) {
        if (!this._isActiveAction(action)) {
          if (action._cacheIndex === null) {
            // this action has been forgotten by the cache, but the user
            // appears to be still using it -> rebind

            var rootUuid = (action._localRoot || this._root).uuid,
              clipUuid = action._clip.uuid,
              actionsForClip = this._actionsByClip[clipUuid];
            this._bindAction(action, actionsForClip && actionsForClip.knownActions[0]);
            this._addInactiveAction(action, clipUuid, rootUuid);
          }
          var bindings = action._propertyBindings;

          // increment reference counts / sort out state
          for (var i = 0, n = bindings.length; i !== n; ++i) {
            var binding = bindings[i];
            if (binding.useCount++ === 0) {
              this._lendBinding(binding);
              binding.saveOriginalState();
            }
          }
          this._lendAction(action);
        }
      }
    }, {
      key: "_deactivateAction",
      value: function _deactivateAction(action) {
        if (this._isActiveAction(action)) {
          var bindings = action._propertyBindings;

          // decrement reference counts / sort out state
          for (var i = 0, n = bindings.length; i !== n; ++i) {
            var binding = bindings[i];
            if (--binding.useCount === 0) {
              binding.restoreOriginalState();
              this._takeBackBinding(binding);
            }
          }
          this._takeBackAction(action);
        }
      }

      // Memory manager
    }, {
      key: "_initMemoryManager",
      value: function _initMemoryManager() {
        this._actions = []; // 'nActiveActions' followed by inactive ones
        this._nActiveActions = 0;
        this._actionsByClip = {};
        // inside:
        // {
        // 	knownActions: Array< AnimationAction > - used as prototypes
        // 	actionByRoot: AnimationAction - lookup
        // }

        this._bindings = []; // 'nActiveBindings' followed by inactive ones
        this._nActiveBindings = 0;
        this._bindingsByRootAndName = {}; // inside: Map< name, PropertyMixer >

        this._controlInterpolants = []; // same game as above
        this._nActiveControlInterpolants = 0;
        var scope = this;
        this.stats = {
          actions: {
            get total() {
              return scope._actions.length;
            },
            get inUse() {
              return scope._nActiveActions;
            }
          },
          bindings: {
            get total() {
              return scope._bindings.length;
            },
            get inUse() {
              return scope._nActiveBindings;
            }
          },
          controlInterpolants: {
            get total() {
              return scope._controlInterpolants.length;
            },
            get inUse() {
              return scope._nActiveControlInterpolants;
            }
          }
        };
      }

      // Memory management for AnimationAction objects
    }, {
      key: "_isActiveAction",
      value: function _isActiveAction(action) {
        var index = action._cacheIndex;
        return index !== null && index < this._nActiveActions;
      }
    }, {
      key: "_addInactiveAction",
      value: function _addInactiveAction(action, clipUuid, rootUuid) {
        var actions = this._actions,
          actionsByClip = this._actionsByClip;
        var actionsForClip = actionsByClip[clipUuid];
        if (actionsForClip === undefined) {
          actionsForClip = {
            knownActions: [action],
            actionByRoot: {}
          };
          action._byClipCacheIndex = 0;
          actionsByClip[clipUuid] = actionsForClip;
        } else {
          var knownActions = actionsForClip.knownActions;
          action._byClipCacheIndex = knownActions.length;
          knownActions.push(action);
        }
        action._cacheIndex = actions.length;
        actions.push(action);
        actionsForClip.actionByRoot[rootUuid] = action;
      }
    }, {
      key: "_removeInactiveAction",
      value: function _removeInactiveAction(action) {
        var actions = this._actions,
          lastInactiveAction = actions[actions.length - 1],
          cacheIndex = action._cacheIndex;
        lastInactiveAction._cacheIndex = cacheIndex;
        actions[cacheIndex] = lastInactiveAction;
        actions.pop();
        action._cacheIndex = null;
        var clipUuid = action._clip.uuid,
          actionsByClip = this._actionsByClip,
          actionsForClip = actionsByClip[clipUuid],
          knownActionsForClip = actionsForClip.knownActions,
          lastKnownAction = knownActionsForClip[knownActionsForClip.length - 1],
          byClipCacheIndex = action._byClipCacheIndex;
        lastKnownAction._byClipCacheIndex = byClipCacheIndex;
        knownActionsForClip[byClipCacheIndex] = lastKnownAction;
        knownActionsForClip.pop();
        action._byClipCacheIndex = null;
        var actionByRoot = actionsForClip.actionByRoot,
          rootUuid = (action._localRoot || this._root).uuid;
        delete actionByRoot[rootUuid];
        if (knownActionsForClip.length === 0) {
          delete actionsByClip[clipUuid];
        }
        this._removeInactiveBindingsForAction(action);
      }
    }, {
      key: "_removeInactiveBindingsForAction",
      value: function _removeInactiveBindingsForAction(action) {
        var bindings = action._propertyBindings;
        for (var i = 0, n = bindings.length; i !== n; ++i) {
          var binding = bindings[i];
          if (--binding.referenceCount === 0) {
            this._removeInactiveBinding(binding);
          }
        }
      }
    }, {
      key: "_lendAction",
      value: function _lendAction(action) {
        // [ active actions |  inactive actions  ]
        // [  active actions >| inactive actions ]
        //                 s        a
        //                  <-swap->
        //                 a        s

        var actions = this._actions,
          prevIndex = action._cacheIndex,
          lastActiveIndex = this._nActiveActions++,
          firstInactiveAction = actions[lastActiveIndex];
        action._cacheIndex = lastActiveIndex;
        actions[lastActiveIndex] = action;
        firstInactiveAction._cacheIndex = prevIndex;
        actions[prevIndex] = firstInactiveAction;
      }
    }, {
      key: "_takeBackAction",
      value: function _takeBackAction(action) {
        // [  active actions  | inactive actions ]
        // [ active actions |< inactive actions  ]
        //        a        s
        //         <-swap->
        //        s        a

        var actions = this._actions,
          prevIndex = action._cacheIndex,
          firstInactiveIndex = --this._nActiveActions,
          lastActiveAction = actions[firstInactiveIndex];
        action._cacheIndex = firstInactiveIndex;
        actions[firstInactiveIndex] = action;
        lastActiveAction._cacheIndex = prevIndex;
        actions[prevIndex] = lastActiveAction;
      }

      // Memory management for PropertyMixer objects
    }, {
      key: "_addInactiveBinding",
      value: function _addInactiveBinding(binding, rootUuid, trackName) {
        var bindingsByRoot = this._bindingsByRootAndName,
          bindings = this._bindings;
        var bindingByName = bindingsByRoot[rootUuid];
        if (bindingByName === undefined) {
          bindingByName = {};
          bindingsByRoot[rootUuid] = bindingByName;
        }
        bindingByName[trackName] = binding;
        binding._cacheIndex = bindings.length;
        bindings.push(binding);
      }
    }, {
      key: "_removeInactiveBinding",
      value: function _removeInactiveBinding(binding) {
        var bindings = this._bindings,
          propBinding = binding.binding,
          rootUuid = propBinding.rootNode.uuid,
          trackName = propBinding.path,
          bindingsByRoot = this._bindingsByRootAndName,
          bindingByName = bindingsByRoot[rootUuid],
          lastInactiveBinding = bindings[bindings.length - 1],
          cacheIndex = binding._cacheIndex;
        lastInactiveBinding._cacheIndex = cacheIndex;
        bindings[cacheIndex] = lastInactiveBinding;
        bindings.pop();
        delete bindingByName[trackName];
        if (Object.keys(bindingByName).length === 0) {
          delete bindingsByRoot[rootUuid];
        }
      }
    }, {
      key: "_lendBinding",
      value: function _lendBinding(binding) {
        var bindings = this._bindings,
          prevIndex = binding._cacheIndex,
          lastActiveIndex = this._nActiveBindings++,
          firstInactiveBinding = bindings[lastActiveIndex];
        binding._cacheIndex = lastActiveIndex;
        bindings[lastActiveIndex] = binding;
        firstInactiveBinding._cacheIndex = prevIndex;
        bindings[prevIndex] = firstInactiveBinding;
      }
    }, {
      key: "_takeBackBinding",
      value: function _takeBackBinding(binding) {
        var bindings = this._bindings,
          prevIndex = binding._cacheIndex,
          firstInactiveIndex = --this._nActiveBindings,
          lastActiveBinding = bindings[firstInactiveIndex];
        binding._cacheIndex = firstInactiveIndex;
        bindings[firstInactiveIndex] = binding;
        lastActiveBinding._cacheIndex = prevIndex;
        bindings[prevIndex] = lastActiveBinding;
      }

      // Memory management of Interpolants for weight and time scale
    }, {
      key: "_lendControlInterpolant",
      value: function _lendControlInterpolant() {
        var interpolants = this._controlInterpolants,
          lastActiveIndex = this._nActiveControlInterpolants++;
        var interpolant = interpolants[lastActiveIndex];
        if (interpolant === undefined) {
          interpolant = new LinearInterpolant(new Float32Array(2), new Float32Array(2), 1, _controlInterpolantsResultBuffer);
          interpolant.__cacheIndex = lastActiveIndex;
          interpolants[lastActiveIndex] = interpolant;
        }
        return interpolant;
      }
    }, {
      key: "_takeBackControlInterpolant",
      value: function _takeBackControlInterpolant(interpolant) {
        var interpolants = this._controlInterpolants,
          prevIndex = interpolant.__cacheIndex,
          firstInactiveIndex = --this._nActiveControlInterpolants,
          lastActiveInterpolant = interpolants[firstInactiveIndex];
        interpolant.__cacheIndex = firstInactiveIndex;
        interpolants[firstInactiveIndex] = interpolant;
        lastActiveInterpolant.__cacheIndex = prevIndex;
        interpolants[prevIndex] = lastActiveInterpolant;
      }

      // return an action for a clip optionally using a custom root target
      // object (this method allocates a lot of dynamic memory in case a
      // previously unknown clip/root combination is specified)
    }, {
      key: "clipAction",
      value: function clipAction(clip, optionalRoot, blendMode) {
        var root = optionalRoot || this._root,
          rootUuid = root.uuid;
        var clipObject = typeof clip === 'string' ? AnimationClip.findByName(root, clip) : clip;
        var clipUuid = clipObject !== null ? clipObject.uuid : clip;
        var actionsForClip = this._actionsByClip[clipUuid];
        var prototypeAction = null;
        if (blendMode === undefined) {
          if (clipObject !== null) {
            blendMode = clipObject.blendMode;
          } else {
            blendMode = NormalAnimationBlendMode;
          }
        }
        if (actionsForClip !== undefined) {
          var existingAction = actionsForClip.actionByRoot[rootUuid];
          if (existingAction !== undefined && existingAction.blendMode === blendMode) {
            return existingAction;
          }

          // we know the clip, so we don't have to parse all
          // the bindings again but can just copy
          prototypeAction = actionsForClip.knownActions[0];

          // also, take the clip from the prototype action
          if (clipObject === null) clipObject = prototypeAction._clip;
        }

        // clip must be known when specified via string
        if (clipObject === null) return null;

        // allocate all resources required to run it
        var newAction = new AnimationAction(this, clipObject, optionalRoot, blendMode);
        this._bindAction(newAction, prototypeAction);

        // and make the action known to the memory manager
        this._addInactiveAction(newAction, clipUuid, rootUuid);
        return newAction;
      }

      // get an existing action
    }, {
      key: "existingAction",
      value: function existingAction(clip, optionalRoot) {
        var root = optionalRoot || this._root,
          rootUuid = root.uuid,
          clipObject = typeof clip === 'string' ? AnimationClip.findByName(root, clip) : clip,
          clipUuid = clipObject ? clipObject.uuid : clip,
          actionsForClip = this._actionsByClip[clipUuid];
        if (actionsForClip !== undefined) {
          return actionsForClip.actionByRoot[rootUuid] || null;
        }
        return null;
      }

      // deactivates all previously scheduled actions
    }, {
      key: "stopAllAction",
      value: function stopAllAction() {
        var actions = this._actions,
          nActions = this._nActiveActions;
        for (var i = nActions - 1; i >= 0; --i) {
          actions[i].stop();
        }
        return this;
      }

      // advance the time and update apply the animation
    }, {
      key: "update",
      value: function update(deltaTime) {
        deltaTime *= this.timeScale;
        var actions = this._actions,
          nActions = this._nActiveActions,
          time = this.time += deltaTime,
          timeDirection = Math.sign(deltaTime),
          accuIndex = this._accuIndex ^= 1;

        // run active actions

        for (var i = 0; i !== nActions; ++i) {
          var action = actions[i];
          action._update(time, deltaTime, timeDirection, accuIndex);
        }

        // update scene graph

        var bindings = this._bindings,
          nBindings = this._nActiveBindings;
        for (var _i63 = 0; _i63 !== nBindings; ++_i63) {
          bindings[_i63].apply(accuIndex);
        }
        return this;
      }

      // Allows you to seek to a specific time in an animation.
    }, {
      key: "setTime",
      value: function setTime(timeInSeconds) {
        this.time = 0; // Zero out time attribute for AnimationMixer object;
        for (var i = 0; i < this._actions.length; i++) {
          this._actions[i].time = 0; // Zero out time attribute for all associated AnimationAction objects.
        }
        return this.update(timeInSeconds); // Update used to set exact time. Returns "this" AnimationMixer object.
      }

      // return this mixer's root target object
    }, {
      key: "getRoot",
      value: function getRoot() {
        return this._root;
      }

      // free all resources specific to a particular clip
    }, {
      key: "uncacheClip",
      value: function uncacheClip(clip) {
        var actions = this._actions,
          clipUuid = clip.uuid,
          actionsByClip = this._actionsByClip,
          actionsForClip = actionsByClip[clipUuid];
        if (actionsForClip !== undefined) {
          // note: just calling _removeInactiveAction would mess up the
          // iteration state and also require updating the state we can
          // just throw away

          var actionsToRemove = actionsForClip.knownActions;
          for (var i = 0, n = actionsToRemove.length; i !== n; ++i) {
            var action = actionsToRemove[i];
            this._deactivateAction(action);
            var cacheIndex = action._cacheIndex,
              lastInactiveAction = actions[actions.length - 1];
            action._cacheIndex = null;
            action._byClipCacheIndex = null;
            lastInactiveAction._cacheIndex = cacheIndex;
            actions[cacheIndex] = lastInactiveAction;
            actions.pop();
            this._removeInactiveBindingsForAction(action);
          }
          delete actionsByClip[clipUuid];
        }
      }

      // free all resources specific to a particular root target object
    }, {
      key: "uncacheRoot",
      value: function uncacheRoot(root) {
        var rootUuid = root.uuid,
          actionsByClip = this._actionsByClip;
        for (var clipUuid in actionsByClip) {
          var actionByRoot = actionsByClip[clipUuid].actionByRoot,
            action = actionByRoot[rootUuid];
          if (action !== undefined) {
            this._deactivateAction(action);
            this._removeInactiveAction(action);
          }
        }
        var bindingsByRoot = this._bindingsByRootAndName,
          bindingByName = bindingsByRoot[rootUuid];
        if (bindingByName !== undefined) {
          for (var trackName in bindingByName) {
            var binding = bindingByName[trackName];
            binding.restoreOriginalState();
            this._removeInactiveBinding(binding);
          }
        }
      }

      // remove a targeted clip from the cache
    }, {
      key: "uncacheAction",
      value: function uncacheAction(clip, optionalRoot) {
        var action = this.existingAction(clip, optionalRoot);
        if (action !== null) {
          this._deactivateAction(action);
          this._removeInactiveAction(action);
        }
      }
    }]);
  }(EventDispatcher);
  var RenderTarget3D = exports.RenderTarget3D = /*#__PURE__*/function (_RenderTarget2) {
    function RenderTarget3D() {
      var _this113;
      var width = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
      var height = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
      var depth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
      var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
      (0, _classCallCheck2.default)(this, RenderTarget3D);
      _this113 = _callSuper(this, RenderTarget3D, [width, height, options]);
      _this113.isRenderTarget3D = true;
      _this113.depth = depth;
      _this113.texture = new Data3DTexture(null, width, height, depth);
      _this113.texture.isRenderTargetTexture = true;
      return _this113;
    }
    (0, _inherits2.default)(RenderTarget3D, _RenderTarget2);
    return (0, _createClass2.default)(RenderTarget3D);
  }(RenderTarget);
  var RenderTargetArray = exports.RenderTargetArray = /*#__PURE__*/function (_RenderTarget3) {
    function RenderTargetArray() {
      var _this114;
      var width = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
      var height = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
      var depth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
      var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
      (0, _classCallCheck2.default)(this, RenderTargetArray);
      _this114 = _callSuper(this, RenderTargetArray, [width, height, options]);
      _this114.isRenderTargetArray = true;
      _this114.depth = depth;
      _this114.texture = new DataArrayTexture(null, width, height, depth);
      _this114.texture.isRenderTargetTexture = true;
      return _this114;
    }
    (0, _inherits2.default)(RenderTargetArray, _RenderTarget3);
    return (0, _createClass2.default)(RenderTargetArray);
  }(RenderTarget);
  var Uniform = exports.Uniform = /*#__PURE__*/function () {
    function Uniform(value) {
      (0, _classCallCheck2.default)(this, Uniform);
      this.value = value;
    }
    return (0, _createClass2.default)(Uniform, [{
      key: "clone",
      value: function clone() {
        return new Uniform(this.value.clone === undefined ? this.value : this.value.clone());
      }
    }]);
  }();
  var _id = 0;
  var UniformsGroup = exports.UniformsGroup = /*#__PURE__*/function (_EventDispatcher7) {
    function UniformsGroup() {
      var _this115;
      (0, _classCallCheck2.default)(this, UniformsGroup);
      _this115 = _callSuper(this, UniformsGroup);
      _this115.isUniformsGroup = true;
      Object.defineProperty(_this115, 'id', {
        value: _id++
      });
      _this115.name = '';
      _this115.usage = StaticDrawUsage;
      _this115.uniforms = [];
      return _this115;
    }
    (0, _inherits2.default)(UniformsGroup, _EventDispatcher7);
    return (0, _createClass2.default)(UniformsGroup, [{
      key: "add",
      value: function add(uniform) {
        this.uniforms.push(uniform);
        return this;
      }
    }, {
      key: "remove",
      value: function remove(uniform) {
        var index = this.uniforms.indexOf(uniform);
        if (index !== -1) this.uniforms.splice(index, 1);
        return this;
      }
    }, {
      key: "setName",
      value: function setName(name) {
        this.name = name;
        return this;
      }
    }, {
      key: "setUsage",
      value: function setUsage(value) {
        this.usage = value;
        return this;
      }
    }, {
      key: "dispose",
      value: function dispose() {
        this.dispatchEvent({
          type: 'dispose'
        });
        return this;
      }
    }, {
      key: "copy",
      value: function copy(source) {
        this.name = source.name;
        this.usage = source.usage;
        var uniformsSource = source.uniforms;
        this.uniforms.length = 0;
        for (var i = 0, l = uniformsSource.length; i < l; i++) {
          var uniforms = Array.isArray(uniformsSource[i]) ? uniformsSource[i] : [uniformsSource[i]];
          for (var j = 0; j < uniforms.length; j++) {
            this.uniforms.push(uniforms[j].clone());
          }
        }
        return this;
      }
    }, {
      key: "clone",
      value: function clone() {
        return new this.constructor().copy(this);
      }
    }]);
  }(EventDispatcher);
  var InstancedInterleavedBuffer = exports.InstancedInterleavedBuffer = /*#__PURE__*/function (_InterleavedBuffer) {
    function InstancedInterleavedBuffer(array, stride) {
      var _this116;
      var meshPerAttribute = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
      (0, _classCallCheck2.default)(this, InstancedInterleavedBuffer);
      _this116 = _callSuper(this, InstancedInterleavedBuffer, [array, stride]);
      _this116.isInstancedInterleavedBuffer = true;
      _this116.meshPerAttribute = meshPerAttribute;
      return _this116;
    }
    (0, _inherits2.default)(InstancedInterleavedBuffer, _InterleavedBuffer);
    return (0, _createClass2.default)(InstancedInterleavedBuffer, [{
      key: "copy",
      value: function copy(source) {
        _superPropGet(InstancedInterleavedBuffer, "copy", this, 3)([source]);
        this.meshPerAttribute = source.meshPerAttribute;
        return this;
      }
    }, {
      key: "clone",
      value: function clone(data) {
        var ib = _superPropGet(InstancedInterleavedBuffer, "clone", this, 3)([data]);
        ib.meshPerAttribute = this.meshPerAttribute;
        return ib;
      }
    }, {
      key: "toJSON",
      value: function toJSON(data) {
        var json = _superPropGet(InstancedInterleavedBuffer, "toJSON", this, 3)([data]);
        json.isInstancedInterleavedBuffer = true;
        json.meshPerAttribute = this.meshPerAttribute;
        return json;
      }
    }]);
  }(InterleavedBuffer);
  var GLBufferAttribute = exports.GLBufferAttribute = /*#__PURE__*/function () {
    function GLBufferAttribute(buffer, type, itemSize, elementSize, count) {
      (0, _classCallCheck2.default)(this, GLBufferAttribute);
      this.isGLBufferAttribute = true;
      this.name = '';
      this.buffer = buffer;
      this.type = type;
      this.itemSize = itemSize;
      this.elementSize = elementSize;
      this.count = count;
      this.version = 0;
    }
    return (0, _createClass2.default)(GLBufferAttribute, [{
      key: "needsUpdate",
      set: function set(value) {
        if (value === true) this.version++;
      }
    }, {
      key: "setBuffer",
      value: function setBuffer(buffer) {
        this.buffer = buffer;
        return this;
      }
    }, {
      key: "setType",
      value: function setType(type, elementSize) {
        this.type = type;
        this.elementSize = elementSize;
        return this;
      }
    }, {
      key: "setItemSize",
      value: function setItemSize(itemSize) {
        this.itemSize = itemSize;
        return this;
      }
    }, {
      key: "setCount",
      value: function setCount(count) {
        this.count = count;
        return this;
      }
    }]);
  }();
  var _matrix = /*@__PURE__*/new Matrix4();
  var Raycaster = exports.Raycaster = /*#__PURE__*/function () {
    function Raycaster(origin, direction) {
      var near = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      var far = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : Infinity;
      (0, _classCallCheck2.default)(this, Raycaster);
      this.ray = new Ray(origin, direction);
      // direction is assumed to be normalized (for accurate distance calculations)

      this.near = near;
      this.far = far;
      this.camera = null;
      this.layers = new Layers();
      this.params = {
        Mesh: {},
        Line: {
          threshold: 1
        },
        LOD: {},
        Points: {
          threshold: 1
        },
        Sprite: {}
      };
    }
    return (0, _createClass2.default)(Raycaster, [{
      key: "set",
      value: function set(origin, direction) {
        // direction is assumed to be normalized (for accurate distance calculations)

        this.ray.set(origin, direction);
      }
    }, {
      key: "setFromCamera",
      value: function setFromCamera(coords, camera) {
        if (camera.isPerspectiveCamera) {
          this.ray.origin.setFromMatrixPosition(camera.matrixWorld);
          this.ray.direction.set(coords.x, coords.y, 0.5).unproject(camera).sub(this.ray.origin).normalize();
          this.camera = camera;
        } else if (camera.isOrthographicCamera) {
          this.ray.origin.set(coords.x, coords.y, (camera.near + camera.far) / (camera.near - camera.far)).unproject(camera); // set origin in plane of camera
          this.ray.direction.set(0, 0, -1).transformDirection(camera.matrixWorld);
          this.camera = camera;
        } else {
          console.error('THREE.Raycaster: Unsupported camera type: ' + camera.type);
        }
      }
    }, {
      key: "setFromXRController",
      value: function setFromXRController(controller) {
        _matrix.identity().extractRotation(controller.matrixWorld);
        this.ray.origin.setFromMatrixPosition(controller.matrixWorld);
        this.ray.direction.set(0, 0, -1).applyMatrix4(_matrix);
        return this;
      }
    }, {
      key: "intersectObject",
      value: function intersectObject(object) {
        var recursive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
        var intersects = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
        intersect(object, this, intersects, recursive);
        intersects.sort(ascSort);
        return intersects;
      }
    }, {
      key: "intersectObjects",
      value: function intersectObjects(objects) {
        var recursive = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
        var intersects = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
        for (var i = 0, l = objects.length; i < l; i++) {
          intersect(objects[i], this, intersects, recursive);
        }
        intersects.sort(ascSort);
        return intersects;
      }
    }]);
  }();
  function ascSort(a, b) {
    return a.distance - b.distance;
  }
  function intersect(object, raycaster, intersects, recursive) {
    var propagate = true;
    if (object.layers.test(raycaster.layers)) {
      var result = object.raycast(raycaster, intersects);
      if (result === false) propagate = false;
    }
    if (propagate === true && recursive === true) {
      var children = object.children;
      for (var i = 0, l = children.length; i < l; i++) {
        intersect(children[i], raycaster, intersects, true);
      }
    }
  }

  /**
   * Ref: https://en.wikipedia.org/wiki/Spherical_coordinate_system
   *
   * phi (the polar angle) is measured from the positive y-axis. The positive y-axis is up.
   * theta (the azimuthal angle) is measured from the positive z-axis.
   */
  var Spherical = exports.Spherical = /*#__PURE__*/function () {
    function Spherical() {
      var radius = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
      var phi = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var theta = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      (0, _classCallCheck2.default)(this, Spherical);
      this.radius = radius;
      this.phi = phi; // polar angle
      this.theta = theta; // azimuthal angle

      return this;
    }
    return (0, _createClass2.default)(Spherical, [{
      key: "set",
      value: function set(radius, phi, theta) {
        this.radius = radius;
        this.phi = phi;
        this.theta = theta;
        return this;
      }
    }, {
      key: "copy",
      value: function copy(other) {
        this.radius = other.radius;
        this.phi = other.phi;
        this.theta = other.theta;
        return this;
      }

      // restrict phi to be between EPS and PI-EPS
    }, {
      key: "makeSafe",
      value: function makeSafe() {
        var EPS = 0.000001;
        this.phi = _clamp(this.phi, EPS, Math.PI - EPS);
        return this;
      }
    }, {
      key: "setFromVector3",
      value: function setFromVector3(v) {
        return this.setFromCartesianCoords(v.x, v.y, v.z);
      }
    }, {
      key: "setFromCartesianCoords",
      value: function setFromCartesianCoords(x, y, z) {
        this.radius = Math.sqrt(x * x + y * y + z * z);
        if (this.radius === 0) {
          this.theta = 0;
          this.phi = 0;
        } else {
          this.theta = Math.atan2(x, z);
          this.phi = Math.acos(_clamp(y / this.radius, -1, 1));
        }
        return this;
      }
    }, {
      key: "clone",
      value: function clone() {
        return new this.constructor().copy(this);
      }
    }]);
  }();
  /**
   * Ref: https://en.wikipedia.org/wiki/Cylindrical_coordinate_system
   */
  var Cylindrical = exports.Cylindrical = /*#__PURE__*/function () {
    function Cylindrical() {
      var radius = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
      var theta = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var y = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      (0, _classCallCheck2.default)(this, Cylindrical);
      this.radius = radius; // distance from the origin to a point in the x-z plane
      this.theta = theta; // counterclockwise angle in the x-z plane measured in radians from the positive z-axis
      this.y = y; // height above the x-z plane

      return this;
    }
    return (0, _createClass2.default)(Cylindrical, [{
      key: "set",
      value: function set(radius, theta, y) {
        this.radius = radius;
        this.theta = theta;
        this.y = y;
        return this;
      }
    }, {
      key: "copy",
      value: function copy(other) {
        this.radius = other.radius;
        this.theta = other.theta;
        this.y = other.y;
        return this;
      }
    }, {
      key: "setFromVector3",
      value: function setFromVector3(v) {
        return this.setFromCartesianCoords(v.x, v.y, v.z);
      }
    }, {
      key: "setFromCartesianCoords",
      value: function setFromCartesianCoords(x, y, z) {
        this.radius = Math.sqrt(x * x + z * z);
        this.theta = Math.atan2(x, z);
        this.y = y;
        return this;
      }
    }, {
      key: "clone",
      value: function clone() {
        return new this.constructor().copy(this);
      }
    }]);
  }();
  var Matrix2 = exports.Matrix2 = /*#__PURE__*/function () {
    function Matrix2(n11, n12, n21, n22) {
      (0, _classCallCheck2.default)(this, Matrix2);
      Matrix2.prototype.isMatrix2 = true;
      this.elements = [1, 0, 0, 1];
      if (n11 !== undefined) {
        this.set(n11, n12, n21, n22);
      }
    }
    return (0, _createClass2.default)(Matrix2, [{
      key: "identity",
      value: function identity() {
        this.set(1, 0, 0, 1);
        return this;
      }
    }, {
      key: "fromArray",
      value: function fromArray(array) {
        var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        for (var i = 0; i < 4; i++) {
          this.elements[i] = array[i + offset];
        }
        return this;
      }
    }, {
      key: "set",
      value: function set(n11, n12, n21, n22) {
        var te = this.elements;
        te[0] = n11;
        te[2] = n12;
        te[1] = n21;
        te[3] = n22;
        return this;
      }
    }]);
  }();
  var _vector$4 = /*@__PURE__*/new Vector2();
  var Box2 = exports.Box2 = /*#__PURE__*/function () {
    function Box2() {
      var min = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Vector2(+Infinity, +Infinity);
      var max = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Vector2(-Infinity, -Infinity);
      (0, _classCallCheck2.default)(this, Box2);
      this.isBox2 = true;
      this.min = min;
      this.max = max;
    }
    return (0, _createClass2.default)(Box2, [{
      key: "set",
      value: function set(min, max) {
        this.min.copy(min);
        this.max.copy(max);
        return this;
      }
    }, {
      key: "setFromPoints",
      value: function setFromPoints(points) {
        this.makeEmpty();
        for (var i = 0, il = points.length; i < il; i++) {
          this.expandByPoint(points[i]);
        }
        return this;
      }
    }, {
      key: "setFromCenterAndSize",
      value: function setFromCenterAndSize(center, size) {
        var halfSize = _vector$4.copy(size).multiplyScalar(0.5);
        this.min.copy(center).sub(halfSize);
        this.max.copy(center).add(halfSize);
        return this;
      }
    }, {
      key: "clone",
      value: function clone() {
        return new this.constructor().copy(this);
      }
    }, {
      key: "copy",
      value: function copy(box) {
        this.min.copy(box.min);
        this.max.copy(box.max);
        return this;
      }
    }, {
      key: "makeEmpty",
      value: function makeEmpty() {
        this.min.x = this.min.y = +Infinity;
        this.max.x = this.max.y = -Infinity;
        return this;
      }
    }, {
      key: "isEmpty",
      value: function isEmpty() {
        // this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes

        return this.max.x < this.min.x || this.max.y < this.min.y;
      }
    }, {
      key: "getCenter",
      value: function getCenter(target) {
        return this.isEmpty() ? target.set(0, 0) : target.addVectors(this.min, this.max).multiplyScalar(0.5);
      }
    }, {
      key: "getSize",
      value: function getSize(target) {
        return this.isEmpty() ? target.set(0, 0) : target.subVectors(this.max, this.min);
      }
    }, {
      key: "expandByPoint",
      value: function expandByPoint(point) {
        this.min.min(point);
        this.max.max(point);
        return this;
      }
    }, {
      key: "expandByVector",
      value: function expandByVector(vector) {
        this.min.sub(vector);
        this.max.add(vector);
        return this;
      }
    }, {
      key: "expandByScalar",
      value: function expandByScalar(scalar) {
        this.min.addScalar(-scalar);
        this.max.addScalar(scalar);
        return this;
      }
    }, {
      key: "containsPoint",
      value: function containsPoint(point) {
        return point.x >= this.min.x && point.x <= this.max.x && point.y >= this.min.y && point.y <= this.max.y;
      }
    }, {
      key: "containsBox",
      value: function containsBox(box) {
        return this.min.x <= box.min.x && box.max.x <= this.max.x && this.min.y <= box.min.y && box.max.y <= this.max.y;
      }
    }, {
      key: "getParameter",
      value: function getParameter(point, target) {
        // This can potentially have a divide by zero if the box
        // has a size dimension of 0.

        return target.set((point.x - this.min.x) / (this.max.x - this.min.x), (point.y - this.min.y) / (this.max.y - this.min.y));
      }
    }, {
      key: "intersectsBox",
      value: function intersectsBox(box) {
        // using 4 splitting planes to rule out intersections

        return box.max.x >= this.min.x && box.min.x <= this.max.x && box.max.y >= this.min.y && box.min.y <= this.max.y;
      }
    }, {
      key: "clampPoint",
      value: function clampPoint(point, target) {
        return target.copy(point).clamp(this.min, this.max);
      }
    }, {
      key: "distanceToPoint",
      value: function distanceToPoint(point) {
        return this.clampPoint(point, _vector$4).distanceTo(point);
      }
    }, {
      key: "intersect",
      value: function intersect(box) {
        this.min.max(box.min);
        this.max.min(box.max);
        if (this.isEmpty()) this.makeEmpty();
        return this;
      }
    }, {
      key: "union",
      value: function union(box) {
        this.min.min(box.min);
        this.max.max(box.max);
        return this;
      }
    }, {
      key: "translate",
      value: function translate(offset) {
        this.min.add(offset);
        this.max.add(offset);
        return this;
      }
    }, {
      key: "equals",
      value: function equals(box) {
        return box.min.equals(this.min) && box.max.equals(this.max);
      }
    }]);
  }();
  var _startP = /*@__PURE__*/new Vector3();
  var _startEnd = /*@__PURE__*/new Vector3();
  var Line3 = exports.Line3 = /*#__PURE__*/function () {
    function Line3() {
      var start = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Vector3();
      var end = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Vector3();
      (0, _classCallCheck2.default)(this, Line3);
      this.start = start;
      this.end = end;
    }
    return (0, _createClass2.default)(Line3, [{
      key: "set",
      value: function set(start, end) {
        this.start.copy(start);
        this.end.copy(end);
        return this;
      }
    }, {
      key: "copy",
      value: function copy(line) {
        this.start.copy(line.start);
        this.end.copy(line.end);
        return this;
      }
    }, {
      key: "getCenter",
      value: function getCenter(target) {
        return target.addVectors(this.start, this.end).multiplyScalar(0.5);
      }
    }, {
      key: "delta",
      value: function delta(target) {
        return target.subVectors(this.end, this.start);
      }
    }, {
      key: "distanceSq",
      value: function distanceSq() {
        return this.start.distanceToSquared(this.end);
      }
    }, {
      key: "distance",
      value: function distance() {
        return this.start.distanceTo(this.end);
      }
    }, {
      key: "at",
      value: function at(t, target) {
        return this.delta(target).multiplyScalar(t).add(this.start);
      }
    }, {
      key: "closestPointToPointParameter",
      value: function closestPointToPointParameter(point, clampToLine) {
        _startP.subVectors(point, this.start);
        _startEnd.subVectors(this.end, this.start);
        var startEnd2 = _startEnd.dot(_startEnd);
        var startEnd_startP = _startEnd.dot(_startP);
        var t = startEnd_startP / startEnd2;
        if (clampToLine) {
          t = _clamp(t, 0, 1);
        }
        return t;
      }
    }, {
      key: "closestPointToPoint",
      value: function closestPointToPoint(point, clampToLine, target) {
        var t = this.closestPointToPointParameter(point, clampToLine);
        return this.delta(target).multiplyScalar(t).add(this.start);
      }
    }, {
      key: "applyMatrix4",
      value: function applyMatrix4(matrix) {
        this.start.applyMatrix4(matrix);
        this.end.applyMatrix4(matrix);
        return this;
      }
    }, {
      key: "equals",
      value: function equals(line) {
        return line.start.equals(this.start) && line.end.equals(this.end);
      }
    }, {
      key: "clone",
      value: function clone() {
        return new this.constructor().copy(this);
      }
    }]);
  }();
  var _vector$3 = /*@__PURE__*/new Vector3();
  var SpotLightHelper = exports.SpotLightHelper = /*#__PURE__*/function (_Object3D14) {
    function SpotLightHelper(light, color) {
      var _this117;
      (0, _classCallCheck2.default)(this, SpotLightHelper);
      _this117 = _callSuper(this, SpotLightHelper);
      _this117.light = light;
      _this117.matrixAutoUpdate = false;
      _this117.color = color;
      _this117.type = 'SpotLightHelper';
      var geometry = new BufferGeometry();
      var positions = [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, -1, 1];
      for (var i = 0, j = 1, l = 32; i < l; i++, j++) {
        var p1 = i / l * Math.PI * 2;
        var p2 = j / l * Math.PI * 2;
        positions.push(Math.cos(p1), Math.sin(p1), 1, Math.cos(p2), Math.sin(p2), 1);
      }
      geometry.setAttribute('position', new Float32BufferAttribute(positions, 3));
      var material = new LineBasicMaterial({
        fog: false,
        toneMapped: false
      });
      _this117.cone = new LineSegments(geometry, material);
      _this117.add(_this117.cone);
      _this117.update();
      return _this117;
    }
    (0, _inherits2.default)(SpotLightHelper, _Object3D14);
    return (0, _createClass2.default)(SpotLightHelper, [{
      key: "dispose",
      value: function dispose() {
        this.cone.geometry.dispose();
        this.cone.material.dispose();
      }
    }, {
      key: "update",
      value: function update() {
        this.light.updateWorldMatrix(true, false);
        this.light.target.updateWorldMatrix(true, false);

        // update the local matrix based on the parent and light target transforms
        if (this.parent) {
          this.parent.updateWorldMatrix(true);
          this.matrix.copy(this.parent.matrixWorld).invert().multiply(this.light.matrixWorld);
        } else {
          this.matrix.copy(this.light.matrixWorld);
        }
        this.matrixWorld.copy(this.light.matrixWorld);
        var coneLength = this.light.distance ? this.light.distance : 1000;
        var coneWidth = coneLength * Math.tan(this.light.angle);
        this.cone.scale.set(coneWidth, coneWidth, coneLength);
        _vector$3.setFromMatrixPosition(this.light.target.matrixWorld);
        this.cone.lookAt(_vector$3);
        if (this.color !== undefined) {
          this.cone.material.color.set(this.color);
        } else {
          this.cone.material.color.copy(this.light.color);
        }
      }
    }]);
  }(Object3D);
  var _vector$2 = /*@__PURE__*/new Vector3();
  var _boneMatrix = /*@__PURE__*/new Matrix4();
  var _matrixWorldInv = /*@__PURE__*/new Matrix4();
  var SkeletonHelper = exports.SkeletonHelper = /*#__PURE__*/function (_LineSegments) {
    function SkeletonHelper(object) {
      var _this118;
      (0, _classCallCheck2.default)(this, SkeletonHelper);
      var bones = getBoneList(object);
      var geometry = new BufferGeometry();
      var vertices = [];
      var colors = [];
      var color1 = new Color(0, 0, 1);
      var color2 = new Color(0, 1, 0);
      for (var i = 0; i < bones.length; i++) {
        var bone = bones[i];
        if (bone.parent && bone.parent.isBone) {
          vertices.push(0, 0, 0);
          vertices.push(0, 0, 0);
          colors.push(color1.r, color1.g, color1.b);
          colors.push(color2.r, color2.g, color2.b);
        }
      }
      geometry.setAttribute('position', new Float32BufferAttribute(vertices, 3));
      geometry.setAttribute('color', new Float32BufferAttribute(colors, 3));
      var material = new LineBasicMaterial({
        vertexColors: true,
        depthTest: false,
        depthWrite: false,
        toneMapped: false,
        transparent: true
      });
      _this118 = _callSuper(this, SkeletonHelper, [geometry, material]);
      _this118.isSkeletonHelper = true;
      _this118.type = 'SkeletonHelper';
      _this118.root = object;
      _this118.bones = bones;
      _this118.matrix = object.matrixWorld;
      _this118.matrixAutoUpdate = false;
      return _this118;
    }
    (0, _inherits2.default)(SkeletonHelper, _LineSegments);
    return (0, _createClass2.default)(SkeletonHelper, [{
      key: "updateMatrixWorld",
      value: function updateMatrixWorld(force) {
        var bones = this.bones;
        var geometry = this.geometry;
        var position = geometry.getAttribute('position');
        _matrixWorldInv.copy(this.root.matrixWorld).invert();
        for (var i = 0, j = 0; i < bones.length; i++) {
          var bone = bones[i];
          if (bone.parent && bone.parent.isBone) {
            _boneMatrix.multiplyMatrices(_matrixWorldInv, bone.matrixWorld);
            _vector$2.setFromMatrixPosition(_boneMatrix);
            position.setXYZ(j, _vector$2.x, _vector$2.y, _vector$2.z);
            _boneMatrix.multiplyMatrices(_matrixWorldInv, bone.parent.matrixWorld);
            _vector$2.setFromMatrixPosition(_boneMatrix);
            position.setXYZ(j + 1, _vector$2.x, _vector$2.y, _vector$2.z);
            j += 2;
          }
        }
        geometry.getAttribute('position').needsUpdate = true;
        _superPropGet(SkeletonHelper, "updateMatrixWorld", this, 3)([force]);
      }
    }, {
      key: "dispose",
      value: function dispose() {
        this.geometry.dispose();
        this.material.dispose();
      }
    }]);
  }(LineSegments);
  function getBoneList(object) {
    var boneList = [];
    if (object.isBone === true) {
      boneList.push(object);
    }
    for (var i = 0; i < object.children.length; i++) {
      boneList.push.apply(boneList, getBoneList(object.children[i]));
    }
    return boneList;
  }
  var PointLightHelper = exports.PointLightHelper = /*#__PURE__*/function (_Mesh4) {
    function PointLightHelper(light, sphereSize, color) {
      var _this119;
      (0, _classCallCheck2.default)(this, PointLightHelper);
      var geometry = new SphereGeometry(sphereSize, 4, 2);
      var material = new MeshBasicMaterial({
        wireframe: true,
        fog: false,
        toneMapped: false
      });
      _this119 = _callSuper(this, PointLightHelper, [geometry, material]);
      _this119.light = light;
      _this119.color = color;
      _this119.type = 'PointLightHelper';
      _this119.matrix = _this119.light.matrixWorld;
      _this119.matrixAutoUpdate = false;
      _this119.update();

      /*
      // TODO: delete this comment?
      const distanceGeometry = new THREE.IcosahedronGeometry( 1, 2 );
      const distanceMaterial = new THREE.MeshBasicMaterial( { color: hexColor, fog: false, wireframe: true, opacity: 0.1, transparent: true } );
      this.lightSphere = new THREE.Mesh( bulbGeometry, bulbMaterial );
      this.lightDistance = new THREE.Mesh( distanceGeometry, distanceMaterial );
      const d = light.distance;
      if ( d === 0.0 ) {
      	this.lightDistance.visible = false;
      } else {
      	this.lightDistance.scale.set( d, d, d );
      }
      this.add( this.lightDistance );
      */
      return _this119;
    }
    (0, _inherits2.default)(PointLightHelper, _Mesh4);
    return (0, _createClass2.default)(PointLightHelper, [{
      key: "dispose",
      value: function dispose() {
        this.geometry.dispose();
        this.material.dispose();
      }
    }, {
      key: "update",
      value: function update() {
        this.light.updateWorldMatrix(true, false);
        if (this.color !== undefined) {
          this.material.color.set(this.color);
        } else {
          this.material.color.copy(this.light.color);
        }

        /*
        const d = this.light.distance;
        	if ( d === 0.0 ) {
        		this.lightDistance.visible = false;
        	} else {
        		this.lightDistance.visible = true;
        	this.lightDistance.scale.set( d, d, d );
        	}
        */
      }
    }]);
  }(Mesh);
  var _vector$1 = /*@__PURE__*/new Vector3();
  var _color1 = /*@__PURE__*/new Color();
  var _color2 = /*@__PURE__*/new Color();
  var HemisphereLightHelper = exports.HemisphereLightHelper = /*#__PURE__*/function (_Object3D15) {
    function HemisphereLightHelper(light, size, color) {
      var _this120;
      (0, _classCallCheck2.default)(this, HemisphereLightHelper);
      _this120 = _callSuper(this, HemisphereLightHelper);
      _this120.light = light;
      _this120.matrix = light.matrixWorld;
      _this120.matrixAutoUpdate = false;
      _this120.color = color;
      _this120.type = 'HemisphereLightHelper';
      var geometry = new OctahedronGeometry(size);
      geometry.rotateY(Math.PI * 0.5);
      _this120.material = new MeshBasicMaterial({
        wireframe: true,
        fog: false,
        toneMapped: false
      });
      if (_this120.color === undefined) _this120.material.vertexColors = true;
      var position = geometry.getAttribute('position');
      var colors = new Float32Array(position.count * 3);
      geometry.setAttribute('color', new BufferAttribute(colors, 3));
      _this120.add(new Mesh(geometry, _this120.material));
      _this120.update();
      return _this120;
    }
    (0, _inherits2.default)(HemisphereLightHelper, _Object3D15);
    return (0, _createClass2.default)(HemisphereLightHelper, [{
      key: "dispose",
      value: function dispose() {
        this.children[0].geometry.dispose();
        this.children[0].material.dispose();
      }
    }, {
      key: "update",
      value: function update() {
        var mesh = this.children[0];
        if (this.color !== undefined) {
          this.material.color.set(this.color);
        } else {
          var colors = mesh.geometry.getAttribute('color');
          _color1.copy(this.light.color);
          _color2.copy(this.light.groundColor);
          for (var i = 0, l = colors.count; i < l; i++) {
            var color = i < l / 2 ? _color1 : _color2;
            colors.setXYZ(i, color.r, color.g, color.b);
          }
          colors.needsUpdate = true;
        }
        this.light.updateWorldMatrix(true, false);
        mesh.lookAt(_vector$1.setFromMatrixPosition(this.light.matrixWorld).negate());
      }
    }]);
  }(Object3D);
  var GridHelper = exports.GridHelper = /*#__PURE__*/function (_LineSegments2) {
    function GridHelper() {
      var _this121;
      var size = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 10;
      var divisions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 10;
      var color1 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0x444444;
      var color2 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0x888888;
      (0, _classCallCheck2.default)(this, GridHelper);
      color1 = new Color(color1);
      color2 = new Color(color2);
      var center = divisions / 2;
      var step = size / divisions;
      var halfSize = size / 2;
      var vertices = [],
        colors = [];
      for (var i = 0, j = 0, k = -halfSize; i <= divisions; i++, k += step) {
        vertices.push(-halfSize, 0, k, halfSize, 0, k);
        vertices.push(k, 0, -halfSize, k, 0, halfSize);
        var color = i === center ? color1 : color2;
        color.toArray(colors, j);
        j += 3;
        color.toArray(colors, j);
        j += 3;
        color.toArray(colors, j);
        j += 3;
        color.toArray(colors, j);
        j += 3;
      }
      var geometry = new BufferGeometry();
      geometry.setAttribute('position', new Float32BufferAttribute(vertices, 3));
      geometry.setAttribute('color', new Float32BufferAttribute(colors, 3));
      var material = new LineBasicMaterial({
        vertexColors: true,
        toneMapped: false
      });
      _this121 = _callSuper(this, GridHelper, [geometry, material]);
      _this121.type = 'GridHelper';
      return _this121;
    }
    (0, _inherits2.default)(GridHelper, _LineSegments2);
    return (0, _createClass2.default)(GridHelper, [{
      key: "dispose",
      value: function dispose() {
        this.geometry.dispose();
        this.material.dispose();
      }
    }]);
  }(LineSegments);
  var PolarGridHelper = exports.PolarGridHelper = /*#__PURE__*/function (_LineSegments3) {
    function PolarGridHelper() {
      var _this122;
      var radius = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 10;
      var sectors = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 16;
      var rings = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 8;
      var divisions = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 64;
      var color1 = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0x444444;
      var color2 = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0x888888;
      (0, _classCallCheck2.default)(this, PolarGridHelper);
      color1 = new Color(color1);
      color2 = new Color(color2);
      var vertices = [];
      var colors = [];

      // create the sectors

      if (sectors > 1) {
        for (var i = 0; i < sectors; i++) {
          var v = i / sectors * (Math.PI * 2);
          var x = Math.sin(v) * radius;
          var z = Math.cos(v) * radius;
          vertices.push(0, 0, 0);
          vertices.push(x, 0, z);
          var color = i & 1 ? color1 : color2;
          colors.push(color.r, color.g, color.b);
          colors.push(color.r, color.g, color.b);
        }
      }

      // create the rings

      for (var _i64 = 0; _i64 < rings; _i64++) {
        var _color3 = _i64 & 1 ? color1 : color2;
        var r = radius - radius / rings * _i64;
        for (var j = 0; j < divisions; j++) {
          // first vertex

          var _v = j / divisions * (Math.PI * 2);
          var _x10 = Math.sin(_v) * r;
          var _z3 = Math.cos(_v) * r;
          vertices.push(_x10, 0, _z3);
          colors.push(_color3.r, _color3.g, _color3.b);

          // second vertex

          _v = (j + 1) / divisions * (Math.PI * 2);
          _x10 = Math.sin(_v) * r;
          _z3 = Math.cos(_v) * r;
          vertices.push(_x10, 0, _z3);
          colors.push(_color3.r, _color3.g, _color3.b);
        }
      }
      var geometry = new BufferGeometry();
      geometry.setAttribute('position', new Float32BufferAttribute(vertices, 3));
      geometry.setAttribute('color', new Float32BufferAttribute(colors, 3));
      var material = new LineBasicMaterial({
        vertexColors: true,
        toneMapped: false
      });
      _this122 = _callSuper(this, PolarGridHelper, [geometry, material]);
      _this122.type = 'PolarGridHelper';
      return _this122;
    }
    (0, _inherits2.default)(PolarGridHelper, _LineSegments3);
    return (0, _createClass2.default)(PolarGridHelper, [{
      key: "dispose",
      value: function dispose() {
        this.geometry.dispose();
        this.material.dispose();
      }
    }]);
  }(LineSegments);
  var _v1 = /*@__PURE__*/new Vector3();
  var _v2 = /*@__PURE__*/new Vector3();
  var _v3 = /*@__PURE__*/new Vector3();
  var DirectionalLightHelper = exports.DirectionalLightHelper = /*#__PURE__*/function (_Object3D16) {
    function DirectionalLightHelper(light, size, color) {
      var _this123;
      (0, _classCallCheck2.default)(this, DirectionalLightHelper);
      _this123 = _callSuper(this, DirectionalLightHelper);
      _this123.light = light;
      _this123.matrix = light.matrixWorld;
      _this123.matrixAutoUpdate = false;
      _this123.color = color;
      _this123.type = 'DirectionalLightHelper';
      if (size === undefined) size = 1;
      var geometry = new BufferGeometry();
      geometry.setAttribute('position', new Float32BufferAttribute([-size, size, 0, size, size, 0, size, -size, 0, -size, -size, 0, -size, size, 0], 3));
      var material = new LineBasicMaterial({
        fog: false,
        toneMapped: false
      });
      _this123.lightPlane = new Line(geometry, material);
      _this123.add(_this123.lightPlane);
      geometry = new BufferGeometry();
      geometry.setAttribute('position', new Float32BufferAttribute([0, 0, 0, 0, 0, 1], 3));
      _this123.targetLine = new Line(geometry, material);
      _this123.add(_this123.targetLine);
      _this123.update();
      return _this123;
    }
    (0, _inherits2.default)(DirectionalLightHelper, _Object3D16);
    return (0, _createClass2.default)(DirectionalLightHelper, [{
      key: "dispose",
      value: function dispose() {
        this.lightPlane.geometry.dispose();
        this.lightPlane.material.dispose();
        this.targetLine.geometry.dispose();
        this.targetLine.material.dispose();
      }
    }, {
      key: "update",
      value: function update() {
        this.light.updateWorldMatrix(true, false);
        this.light.target.updateWorldMatrix(true, false);
        _v1.setFromMatrixPosition(this.light.matrixWorld);
        _v2.setFromMatrixPosition(this.light.target.matrixWorld);
        _v3.subVectors(_v2, _v1);
        this.lightPlane.lookAt(_v2);
        if (this.color !== undefined) {
          this.lightPlane.material.color.set(this.color);
          this.targetLine.material.color.set(this.color);
        } else {
          this.lightPlane.material.color.copy(this.light.color);
          this.targetLine.material.color.copy(this.light.color);
        }
        this.targetLine.lookAt(_v2);
        this.targetLine.scale.z = _v3.length();
      }
    }]);
  }(Object3D);
  var _vector = /*@__PURE__*/new Vector3();
  var _camera = /*@__PURE__*/new Camera();

  /**
   *	- shows frustum, line of sight and up of the camera
   *	- suitable for fast updates
   * 	- based on frustum visualization in lightgl.js shadowmap example
   *		https://github.com/evanw/lightgl.js/blob/master/tests/shadowmap.html
   */
  var CameraHelper = exports.CameraHelper = /*#__PURE__*/function (_LineSegments4) {
    function CameraHelper(camera) {
      var _this124;
      (0, _classCallCheck2.default)(this, CameraHelper);
      var geometry = new BufferGeometry();
      var material = new LineBasicMaterial({
        color: 0xffffff,
        vertexColors: true,
        toneMapped: false
      });
      var vertices = [];
      var colors = [];
      var pointMap = {};

      // near

      addLine('n1', 'n2');
      addLine('n2', 'n4');
      addLine('n4', 'n3');
      addLine('n3', 'n1');

      // far

      addLine('f1', 'f2');
      addLine('f2', 'f4');
      addLine('f4', 'f3');
      addLine('f3', 'f1');

      // sides

      addLine('n1', 'f1');
      addLine('n2', 'f2');
      addLine('n3', 'f3');
      addLine('n4', 'f4');

      // cone

      addLine('p', 'n1');
      addLine('p', 'n2');
      addLine('p', 'n3');
      addLine('p', 'n4');

      // up

      addLine('u1', 'u2');
      addLine('u2', 'u3');
      addLine('u3', 'u1');

      // target

      addLine('c', 't');
      addLine('p', 'c');

      // cross

      addLine('cn1', 'cn2');
      addLine('cn3', 'cn4');
      addLine('cf1', 'cf2');
      addLine('cf3', 'cf4');
      function addLine(a, b) {
        addPoint(a);
        addPoint(b);
      }
      function addPoint(id) {
        vertices.push(0, 0, 0);
        colors.push(0, 0, 0);
        if (pointMap[id] === undefined) {
          pointMap[id] = [];
        }
        pointMap[id].push(vertices.length / 3 - 1);
      }
      geometry.setAttribute('position', new Float32BufferAttribute(vertices, 3));
      geometry.setAttribute('color', new Float32BufferAttribute(colors, 3));
      _this124 = _callSuper(this, CameraHelper, [geometry, material]);
      _this124.type = 'CameraHelper';
      _this124.camera = camera;
      if (_this124.camera.updateProjectionMatrix) _this124.camera.updateProjectionMatrix();
      _this124.matrix = camera.matrixWorld;
      _this124.matrixAutoUpdate = false;
      _this124.pointMap = pointMap;
      _this124.update();

      // colors

      var colorFrustum = new Color(0xffaa00);
      var colorCone = new Color(0xff0000);
      var colorUp = new Color(0x00aaff);
      var colorTarget = new Color(0xffffff);
      var colorCross = new Color(0x333333);
      _this124.setColors(colorFrustum, colorCone, colorUp, colorTarget, colorCross);
      return _this124;
    }
    (0, _inherits2.default)(CameraHelper, _LineSegments4);
    return (0, _createClass2.default)(CameraHelper, [{
      key: "setColors",
      value: function setColors(frustum, cone, up, target, cross) {
        var geometry = this.geometry;
        var colorAttribute = geometry.getAttribute('color');

        // near

        colorAttribute.setXYZ(0, frustum.r, frustum.g, frustum.b);
        colorAttribute.setXYZ(1, frustum.r, frustum.g, frustum.b); // n1, n2
        colorAttribute.setXYZ(2, frustum.r, frustum.g, frustum.b);
        colorAttribute.setXYZ(3, frustum.r, frustum.g, frustum.b); // n2, n4
        colorAttribute.setXYZ(4, frustum.r, frustum.g, frustum.b);
        colorAttribute.setXYZ(5, frustum.r, frustum.g, frustum.b); // n4, n3
        colorAttribute.setXYZ(6, frustum.r, frustum.g, frustum.b);
        colorAttribute.setXYZ(7, frustum.r, frustum.g, frustum.b); // n3, n1

        // far

        colorAttribute.setXYZ(8, frustum.r, frustum.g, frustum.b);
        colorAttribute.setXYZ(9, frustum.r, frustum.g, frustum.b); // f1, f2
        colorAttribute.setXYZ(10, frustum.r, frustum.g, frustum.b);
        colorAttribute.setXYZ(11, frustum.r, frustum.g, frustum.b); // f2, f4
        colorAttribute.setXYZ(12, frustum.r, frustum.g, frustum.b);
        colorAttribute.setXYZ(13, frustum.r, frustum.g, frustum.b); // f4, f3
        colorAttribute.setXYZ(14, frustum.r, frustum.g, frustum.b);
        colorAttribute.setXYZ(15, frustum.r, frustum.g, frustum.b); // f3, f1

        // sides

        colorAttribute.setXYZ(16, frustum.r, frustum.g, frustum.b);
        colorAttribute.setXYZ(17, frustum.r, frustum.g, frustum.b); // n1, f1
        colorAttribute.setXYZ(18, frustum.r, frustum.g, frustum.b);
        colorAttribute.setXYZ(19, frustum.r, frustum.g, frustum.b); // n2, f2
        colorAttribute.setXYZ(20, frustum.r, frustum.g, frustum.b);
        colorAttribute.setXYZ(21, frustum.r, frustum.g, frustum.b); // n3, f3
        colorAttribute.setXYZ(22, frustum.r, frustum.g, frustum.b);
        colorAttribute.setXYZ(23, frustum.r, frustum.g, frustum.b); // n4, f4

        // cone

        colorAttribute.setXYZ(24, cone.r, cone.g, cone.b);
        colorAttribute.setXYZ(25, cone.r, cone.g, cone.b); // p, n1
        colorAttribute.setXYZ(26, cone.r, cone.g, cone.b);
        colorAttribute.setXYZ(27, cone.r, cone.g, cone.b); // p, n2
        colorAttribute.setXYZ(28, cone.r, cone.g, cone.b);
        colorAttribute.setXYZ(29, cone.r, cone.g, cone.b); // p, n3
        colorAttribute.setXYZ(30, cone.r, cone.g, cone.b);
        colorAttribute.setXYZ(31, cone.r, cone.g, cone.b); // p, n4

        // up

        colorAttribute.setXYZ(32, up.r, up.g, up.b);
        colorAttribute.setXYZ(33, up.r, up.g, up.b); // u1, u2
        colorAttribute.setXYZ(34, up.r, up.g, up.b);
        colorAttribute.setXYZ(35, up.r, up.g, up.b); // u2, u3
        colorAttribute.setXYZ(36, up.r, up.g, up.b);
        colorAttribute.setXYZ(37, up.r, up.g, up.b); // u3, u1

        // target

        colorAttribute.setXYZ(38, target.r, target.g, target.b);
        colorAttribute.setXYZ(39, target.r, target.g, target.b); // c, t
        colorAttribute.setXYZ(40, cross.r, cross.g, cross.b);
        colorAttribute.setXYZ(41, cross.r, cross.g, cross.b); // p, c

        // cross

        colorAttribute.setXYZ(42, cross.r, cross.g, cross.b);
        colorAttribute.setXYZ(43, cross.r, cross.g, cross.b); // cn1, cn2
        colorAttribute.setXYZ(44, cross.r, cross.g, cross.b);
        colorAttribute.setXYZ(45, cross.r, cross.g, cross.b); // cn3, cn4

        colorAttribute.setXYZ(46, cross.r, cross.g, cross.b);
        colorAttribute.setXYZ(47, cross.r, cross.g, cross.b); // cf1, cf2
        colorAttribute.setXYZ(48, cross.r, cross.g, cross.b);
        colorAttribute.setXYZ(49, cross.r, cross.g, cross.b); // cf3, cf4

        colorAttribute.needsUpdate = true;
      }
    }, {
      key: "update",
      value: function update() {
        var geometry = this.geometry;
        var pointMap = this.pointMap;
        var w = 1,
          h = 1;

        // we need just camera projection matrix inverse
        // world matrix must be identity

        _camera.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse);

        // Adjust z values based on coordinate system
        var nearZ = this.camera.coordinateSystem === WebGLCoordinateSystem ? -1 : 0;

        // center / target
        setPoint('c', pointMap, geometry, _camera, 0, 0, nearZ);
        setPoint('t', pointMap, geometry, _camera, 0, 0, 1);

        // near

        setPoint('n1', pointMap, geometry, _camera, -w, -h, nearZ);
        setPoint('n2', pointMap, geometry, _camera, w, -h, nearZ);
        setPoint('n3', pointMap, geometry, _camera, -w, h, nearZ);
        setPoint('n4', pointMap, geometry, _camera, w, h, nearZ);

        // far

        setPoint('f1', pointMap, geometry, _camera, -w, -h, 1);
        setPoint('f2', pointMap, geometry, _camera, w, -h, 1);
        setPoint('f3', pointMap, geometry, _camera, -w, h, 1);
        setPoint('f4', pointMap, geometry, _camera, w, h, 1);

        // up

        setPoint('u1', pointMap, geometry, _camera, w * 0.7, h * 1.1, nearZ);
        setPoint('u2', pointMap, geometry, _camera, -w * 0.7, h * 1.1, nearZ);
        setPoint('u3', pointMap, geometry, _camera, 0, h * 2, nearZ);

        // cross

        setPoint('cf1', pointMap, geometry, _camera, -w, 0, 1);
        setPoint('cf2', pointMap, geometry, _camera, w, 0, 1);
        setPoint('cf3', pointMap, geometry, _camera, 0, -h, 1);
        setPoint('cf4', pointMap, geometry, _camera, 0, h, 1);
        setPoint('cn1', pointMap, geometry, _camera, -w, 0, nearZ);
        setPoint('cn2', pointMap, geometry, _camera, w, 0, nearZ);
        setPoint('cn3', pointMap, geometry, _camera, 0, -h, nearZ);
        setPoint('cn4', pointMap, geometry, _camera, 0, h, nearZ);
        geometry.getAttribute('position').needsUpdate = true;
      }
    }, {
      key: "dispose",
      value: function dispose() {
        this.geometry.dispose();
        this.material.dispose();
      }
    }]);
  }(LineSegments);
  function setPoint(point, pointMap, geometry, camera, x, y, z) {
    _vector.set(x, y, z).unproject(camera);
    var points = pointMap[point];
    if (points !== undefined) {
      var position = geometry.getAttribute('position');
      for (var i = 0, l = points.length; i < l; i++) {
        position.setXYZ(points[i], _vector.x, _vector.y, _vector.z);
      }
    }
  }
  var _box = /*@__PURE__*/new Box3();
  var BoxHelper = exports.BoxHelper = /*#__PURE__*/function (_LineSegments5) {
    function BoxHelper(object) {
      var _this125;
      var color = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0xffff00;
      (0, _classCallCheck2.default)(this, BoxHelper);
      var indices = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]);
      var positions = new Float32Array(8 * 3);
      var geometry = new BufferGeometry();
      geometry.setIndex(new BufferAttribute(indices, 1));
      geometry.setAttribute('position', new BufferAttribute(positions, 3));
      _this125 = _callSuper(this, BoxHelper, [geometry, new LineBasicMaterial({
        color: color,
        toneMapped: false
      })]);
      _this125.object = object;
      _this125.type = 'BoxHelper';
      _this125.matrixAutoUpdate = false;
      _this125.update();
      return _this125;
    }
    (0, _inherits2.default)(BoxHelper, _LineSegments5);
    return (0, _createClass2.default)(BoxHelper, [{
      key: "update",
      value: function update(object) {
        if (object !== undefined) {
          console.warn('THREE.BoxHelper: .update() has no longer arguments.');
        }
        if (this.object !== undefined) {
          _box.setFromObject(this.object);
        }
        if (_box.isEmpty()) return;
        var min = _box.min;
        var max = _box.max;

        /*
        	5____4
        1/___0/|
        | 6__|_7
        2/___3/
        	0: max.x, max.y, max.z
        1: min.x, max.y, max.z
        2: min.x, min.y, max.z
        3: max.x, min.y, max.z
        4: max.x, max.y, min.z
        5: min.x, max.y, min.z
        6: min.x, min.y, min.z
        7: max.x, min.y, min.z
        */

        var position = this.geometry.attributes.position;
        var array = position.array;
        array[0] = max.x;
        array[1] = max.y;
        array[2] = max.z;
        array[3] = min.x;
        array[4] = max.y;
        array[5] = max.z;
        array[6] = min.x;
        array[7] = min.y;
        array[8] = max.z;
        array[9] = max.x;
        array[10] = min.y;
        array[11] = max.z;
        array[12] = max.x;
        array[13] = max.y;
        array[14] = min.z;
        array[15] = min.x;
        array[16] = max.y;
        array[17] = min.z;
        array[18] = min.x;
        array[19] = min.y;
        array[20] = min.z;
        array[21] = max.x;
        array[22] = min.y;
        array[23] = min.z;
        position.needsUpdate = true;
        this.geometry.computeBoundingSphere();
      }
    }, {
      key: "setFromObject",
      value: function setFromObject(object) {
        this.object = object;
        this.update();
        return this;
      }
    }, {
      key: "copy",
      value: function copy(source, recursive) {
        _superPropGet(BoxHelper, "copy", this, 3)([source, recursive]);
        this.object = source.object;
        return this;
      }
    }, {
      key: "dispose",
      value: function dispose() {
        this.geometry.dispose();
        this.material.dispose();
      }
    }]);
  }(LineSegments);
  var Box3Helper = exports.Box3Helper = /*#__PURE__*/function (_LineSegments6) {
    function Box3Helper(box) {
      var _this126;
      var color = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0xffff00;
      (0, _classCallCheck2.default)(this, Box3Helper);
      var indices = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]);
      var positions = [1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1];
      var geometry = new BufferGeometry();
      geometry.setIndex(new BufferAttribute(indices, 1));
      geometry.setAttribute('position', new Float32BufferAttribute(positions, 3));
      _this126 = _callSuper(this, Box3Helper, [geometry, new LineBasicMaterial({
        color: color,
        toneMapped: false
      })]);
      _this126.box = box;
      _this126.type = 'Box3Helper';
      _this126.geometry.computeBoundingSphere();
      return _this126;
    }
    (0, _inherits2.default)(Box3Helper, _LineSegments6);
    return (0, _createClass2.default)(Box3Helper, [{
      key: "updateMatrixWorld",
      value: function updateMatrixWorld(force) {
        var box = this.box;
        if (box.isEmpty()) return;
        box.getCenter(this.position);
        box.getSize(this.scale);
        this.scale.multiplyScalar(0.5);
        _superPropGet(Box3Helper, "updateMatrixWorld", this, 3)([force]);
      }
    }, {
      key: "dispose",
      value: function dispose() {
        this.geometry.dispose();
        this.material.dispose();
      }
    }]);
  }(LineSegments);
  var PlaneHelper = exports.PlaneHelper = /*#__PURE__*/function (_Line3) {
    function PlaneHelper(plane) {
      var _this127;
      var size = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
      var hex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0xffff00;
      (0, _classCallCheck2.default)(this, PlaneHelper);
      var color = hex;
      var positions = [1, -1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, 1, 0, -1, -1, 0, 1, -1, 0, 1, 1, 0];
      var geometry = new BufferGeometry();
      geometry.setAttribute('position', new Float32BufferAttribute(positions, 3));
      geometry.computeBoundingSphere();
      _this127 = _callSuper(this, PlaneHelper, [geometry, new LineBasicMaterial({
        color: color,
        toneMapped: false
      })]);
      _this127.type = 'PlaneHelper';
      _this127.plane = plane;
      _this127.size = size;
      var positions2 = [1, 1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, -1, 0, 1, -1, 0];
      var geometry2 = new BufferGeometry();
      geometry2.setAttribute('position', new Float32BufferAttribute(positions2, 3));
      geometry2.computeBoundingSphere();
      _this127.add(new Mesh(geometry2, new MeshBasicMaterial({
        color: color,
        opacity: 0.2,
        transparent: true,
        depthWrite: false,
        toneMapped: false
      })));
      return _this127;
    }
    (0, _inherits2.default)(PlaneHelper, _Line3);
    return (0, _createClass2.default)(PlaneHelper, [{
      key: "updateMatrixWorld",
      value: function updateMatrixWorld(force) {
        this.position.set(0, 0, 0);
        this.scale.set(0.5 * this.size, 0.5 * this.size, 1);
        this.lookAt(this.plane.normal);
        this.translateZ(-this.plane.constant);
        _superPropGet(PlaneHelper, "updateMatrixWorld", this, 3)([force]);
      }
    }, {
      key: "dispose",
      value: function dispose() {
        this.geometry.dispose();
        this.material.dispose();
        this.children[0].geometry.dispose();
        this.children[0].material.dispose();
      }
    }]);
  }(Line);
  var _axis = /*@__PURE__*/new Vector3();
  var _lineGeometry, _coneGeometry;
  var ArrowHelper = exports.ArrowHelper = /*#__PURE__*/function (_Object3D17) {
    // dir is assumed to be normalized

    function ArrowHelper() {
      var _this128;
      var dir = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Vector3(0, 0, 1);
      var origin = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Vector3(0, 0, 0);
      var length = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
      var color = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0xffff00;
      var headLength = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : length * 0.2;
      var headWidth = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : headLength * 0.2;
      (0, _classCallCheck2.default)(this, ArrowHelper);
      _this128 = _callSuper(this, ArrowHelper);
      _this128.type = 'ArrowHelper';
      if (_lineGeometry === undefined) {
        _lineGeometry = new BufferGeometry();
        _lineGeometry.setAttribute('position', new Float32BufferAttribute([0, 0, 0, 0, 1, 0], 3));
        _coneGeometry = new CylinderGeometry(0, 0.5, 1, 5, 1);
        _coneGeometry.translate(0, -0.5, 0);
      }
      _this128.position.copy(origin);
      _this128.line = new Line(_lineGeometry, new LineBasicMaterial({
        color: color,
        toneMapped: false
      }));
      _this128.line.matrixAutoUpdate = false;
      _this128.add(_this128.line);
      _this128.cone = new Mesh(_coneGeometry, new MeshBasicMaterial({
        color: color,
        toneMapped: false
      }));
      _this128.cone.matrixAutoUpdate = false;
      _this128.add(_this128.cone);
      _this128.setDirection(dir);
      _this128.setLength(length, headLength, headWidth);
      return _this128;
    }
    (0, _inherits2.default)(ArrowHelper, _Object3D17);
    return (0, _createClass2.default)(ArrowHelper, [{
      key: "setDirection",
      value: function setDirection(dir) {
        // dir is assumed to be normalized

        if (dir.y > 0.99999) {
          this.quaternion.set(0, 0, 0, 1);
        } else if (dir.y < -0.99999) {
          this.quaternion.set(1, 0, 0, 0);
        } else {
          _axis.set(dir.z, 0, -dir.x).normalize();
          var radians = Math.acos(dir.y);
          this.quaternion.setFromAxisAngle(_axis, radians);
        }
      }
    }, {
      key: "setLength",
      value: function setLength(length) {
        var headLength = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : length * 0.2;
        var headWidth = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : headLength * 0.2;
        this.line.scale.set(1, Math.max(0.0001, length - headLength), 1); // see #17458
        this.line.updateMatrix();
        this.cone.scale.set(headWidth, headLength, headWidth);
        this.cone.position.y = length;
        this.cone.updateMatrix();
      }
    }, {
      key: "setColor",
      value: function setColor(color) {
        this.line.material.color.set(color);
        this.cone.material.color.set(color);
      }
    }, {
      key: "copy",
      value: function copy(source) {
        _superPropGet(ArrowHelper, "copy", this, 3)([source, false]);
        this.line.copy(source.line);
        this.cone.copy(source.cone);
        return this;
      }
    }, {
      key: "dispose",
      value: function dispose() {
        this.line.geometry.dispose();
        this.line.material.dispose();
        this.cone.geometry.dispose();
        this.cone.material.dispose();
      }
    }]);
  }(Object3D);
  var AxesHelper = exports.AxesHelper = /*#__PURE__*/function (_LineSegments7) {
    function AxesHelper() {
      var _this129;
      var size = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
      (0, _classCallCheck2.default)(this, AxesHelper);
      var vertices = [0, 0, 0, size, 0, 0, 0, 0, 0, 0, size, 0, 0, 0, 0, 0, 0, size];
      var colors = [1, 0, 0, 1, 0.6, 0, 0, 1, 0, 0.6, 1, 0, 0, 0, 1, 0, 0.6, 1];
      var geometry = new BufferGeometry();
      geometry.setAttribute('position', new Float32BufferAttribute(vertices, 3));
      geometry.setAttribute('color', new Float32BufferAttribute(colors, 3));
      var material = new LineBasicMaterial({
        vertexColors: true,
        toneMapped: false
      });
      _this129 = _callSuper(this, AxesHelper, [geometry, material]);
      _this129.type = 'AxesHelper';
      return _this129;
    }
    (0, _inherits2.default)(AxesHelper, _LineSegments7);
    return (0, _createClass2.default)(AxesHelper, [{
      key: "setColors",
      value: function setColors(xAxisColor, yAxisColor, zAxisColor) {
        var color = new Color();
        var array = this.geometry.attributes.color.array;
        color.set(xAxisColor);
        color.toArray(array, 0);
        color.toArray(array, 3);
        color.set(yAxisColor);
        color.toArray(array, 6);
        color.toArray(array, 9);
        color.set(zAxisColor);
        color.toArray(array, 12);
        color.toArray(array, 15);
        this.geometry.attributes.color.needsUpdate = true;
        return this;
      }
    }, {
      key: "dispose",
      value: function dispose() {
        this.geometry.dispose();
        this.material.dispose();
      }
    }]);
  }(LineSegments);
  var ShapePath = exports.ShapePath = /*#__PURE__*/function () {
    function ShapePath() {
      (0, _classCallCheck2.default)(this, ShapePath);
      this.type = 'ShapePath';
      this.color = new Color();
      this.subPaths = [];
      this.currentPath = null;
    }
    return (0, _createClass2.default)(ShapePath, [{
      key: "moveTo",
      value: function moveTo(x, y) {
        this.currentPath = new Path();
        this.subPaths.push(this.currentPath);
        this.currentPath.moveTo(x, y);
        return this;
      }
    }, {
      key: "lineTo",
      value: function lineTo(x, y) {
        this.currentPath.lineTo(x, y);
        return this;
      }
    }, {
      key: "quadraticCurveTo",
      value: function quadraticCurveTo(aCPx, aCPy, aX, aY) {
        this.currentPath.quadraticCurveTo(aCPx, aCPy, aX, aY);
        return this;
      }
    }, {
      key: "bezierCurveTo",
      value: function bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) {
        this.currentPath.bezierCurveTo(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY);
        return this;
      }
    }, {
      key: "splineThru",
      value: function splineThru(pts) {
        this.currentPath.splineThru(pts);
        return this;
      }
    }, {
      key: "toShapes",
      value: function toShapes(isCCW) {
        function toShapesNoHoles(inSubpaths) {
          var shapes = [];
          for (var i = 0, l = inSubpaths.length; i < l; i++) {
            var _tmpPath = inSubpaths[i];
            var _tmpShape = new Shape();
            _tmpShape.curves = _tmpPath.curves;
            shapes.push(_tmpShape);
          }
          return shapes;
        }
        function isPointInsidePolygon(inPt, inPolygon) {
          var polyLen = inPolygon.length;

          // inPt on polygon contour => immediate success    or
          // toggling of inside/outside at every single! intersection point of an edge
          //  with the horizontal line through inPt, left of inPt
          //  not counting lowerY endpoints of edges and whole edges on that line
          var inside = false;
          for (var p = polyLen - 1, q = 0; q < polyLen; p = q++) {
            var edgeLowPt = inPolygon[p];
            var edgeHighPt = inPolygon[q];
            var edgeDx = edgeHighPt.x - edgeLowPt.x;
            var edgeDy = edgeHighPt.y - edgeLowPt.y;
            if (Math.abs(edgeDy) > Number.EPSILON) {
              // not parallel
              if (edgeDy < 0) {
                edgeLowPt = inPolygon[q];
                edgeDx = -edgeDx;
                edgeHighPt = inPolygon[p];
                edgeDy = -edgeDy;
              }
              if (inPt.y < edgeLowPt.y || inPt.y > edgeHighPt.y) continue;
              if (inPt.y === edgeLowPt.y) {
                if (inPt.x === edgeLowPt.x) return true; // inPt is on contour ?
                // continue;				// no intersection or edgeLowPt => doesn't count !!!
              } else {
                var perpEdge = edgeDy * (inPt.x - edgeLowPt.x) - edgeDx * (inPt.y - edgeLowPt.y);
                if (perpEdge === 0) return true; // inPt is on contour ?
                if (perpEdge < 0) continue;
                inside = !inside; // true intersection left of inPt
              }
            } else {
              // parallel or collinear
              if (inPt.y !== edgeLowPt.y) continue; // parallel
              // edge lies on the same horizontal line as inPt
              if (edgeHighPt.x <= inPt.x && inPt.x <= edgeLowPt.x || edgeLowPt.x <= inPt.x && inPt.x <= edgeHighPt.x) return true; // inPt: Point on contour !
              // continue;
            }
          }
          return inside;
        }
        var isClockWise = ShapeUtils.isClockWise;
        var subPaths = this.subPaths;
        if (subPaths.length === 0) return [];
        var solid, tmpPath, tmpShape;
        var shapes = [];
        if (subPaths.length === 1) {
          tmpPath = subPaths[0];
          tmpShape = new Shape();
          tmpShape.curves = tmpPath.curves;
          shapes.push(tmpShape);
          return shapes;
        }
        var holesFirst = !isClockWise(subPaths[0].getPoints());
        holesFirst = isCCW ? !holesFirst : holesFirst;

        // console.log("Holes first", holesFirst);

        var betterShapeHoles = [];
        var newShapes = [];
        var newShapeHoles = [];
        var mainIdx = 0;
        var tmpPoints;
        newShapes[mainIdx] = undefined;
        newShapeHoles[mainIdx] = [];
        for (var i = 0, l = subPaths.length; i < l; i++) {
          tmpPath = subPaths[i];
          tmpPoints = tmpPath.getPoints();
          solid = isClockWise(tmpPoints);
          solid = isCCW ? !solid : solid;
          if (solid) {
            if (!holesFirst && newShapes[mainIdx]) mainIdx++;
            newShapes[mainIdx] = {
              s: new Shape(),
              p: tmpPoints
            };
            newShapes[mainIdx].s.curves = tmpPath.curves;
            if (holesFirst) mainIdx++;
            newShapeHoles[mainIdx] = [];

            //console.log('cw', i);
          } else {
            newShapeHoles[mainIdx].push({
              h: tmpPath,
              p: tmpPoints[0]
            });

            //console.log('ccw', i);
          }
        }

        // only Holes? -> probably all Shapes with wrong orientation
        if (!newShapes[0]) return toShapesNoHoles(subPaths);
        if (newShapes.length > 1) {
          var ambiguous = false;
          var toChange = 0;
          for (var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx++) {
            betterShapeHoles[sIdx] = [];
          }
          for (var _sIdx = 0, _sLen = newShapes.length; _sIdx < _sLen; _sIdx++) {
            var sho = newShapeHoles[_sIdx];
            for (var hIdx = 0; hIdx < sho.length; hIdx++) {
              var ho = sho[hIdx];
              var hole_unassigned = true;
              for (var s2Idx = 0; s2Idx < newShapes.length; s2Idx++) {
                if (isPointInsidePolygon(ho.p, newShapes[s2Idx].p)) {
                  if (_sIdx !== s2Idx) toChange++;
                  if (hole_unassigned) {
                    hole_unassigned = false;
                    betterShapeHoles[s2Idx].push(ho);
                  } else {
                    ambiguous = true;
                  }
                }
              }
              if (hole_unassigned) {
                betterShapeHoles[_sIdx].push(ho);
              }
            }
          }
          if (toChange > 0 && ambiguous === false) {
            newShapeHoles = betterShapeHoles;
          }
        }
        var tmpHoles;
        for (var _i65 = 0, il = newShapes.length; _i65 < il; _i65++) {
          tmpShape = newShapes[_i65].s;
          shapes.push(tmpShape);
          tmpHoles = newShapeHoles[_i65];
          for (var j = 0, jl = tmpHoles.length; j < jl; j++) {
            tmpShape.holes.push(tmpHoles[j].h);
          }
        }

        //console.log("shape", shapes);

        return shapes;
      }
    }]);
  }();
  var Controls = exports.Controls = /*#__PURE__*/function (_EventDispatcher8) {
    function Controls(object) {
      var _this130;
      var domElement = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      (0, _classCallCheck2.default)(this, Controls);
      _this130 = _callSuper(this, Controls);
      _this130.object = object;
      _this130.domElement = domElement;
      _this130.enabled = true;
      _this130.state = -1;
      _this130.keys = {};
      _this130.mouseButtons = {
        LEFT: null,
        MIDDLE: null,
        RIGHT: null
      };
      _this130.touches = {
        ONE: null,
        TWO: null
      };
      return _this130;
    }
    (0, _inherits2.default)(Controls, _EventDispatcher8);
    return (0, _createClass2.default)(Controls, [{
      key: "connect",
      value: function connect() {}
    }, {
      key: "disconnect",
      value: function disconnect() {}
    }, {
      key: "dispose",
      value: function dispose() {}
    }, {
      key: "update",
      value: function update(/* delta */) {}
    }]);
  }(EventDispatcher);
  function contain(texture, aspect) {
    var imageAspect = texture.image && texture.image.width ? texture.image.width / texture.image.height : 1;
    if (imageAspect > aspect) {
      texture.repeat.x = 1;
      texture.repeat.y = imageAspect / aspect;
      texture.offset.x = 0;
      texture.offset.y = (1 - texture.repeat.y) / 2;
    } else {
      texture.repeat.x = aspect / imageAspect;
      texture.repeat.y = 1;
      texture.offset.x = (1 - texture.repeat.x) / 2;
      texture.offset.y = 0;
    }
    return texture;
  }
  function cover(texture, aspect) {
    var imageAspect = texture.image && texture.image.width ? texture.image.width / texture.image.height : 1;
    if (imageAspect > aspect) {
      texture.repeat.x = aspect / imageAspect;
      texture.repeat.y = 1;
      texture.offset.x = (1 - texture.repeat.x) / 2;
      texture.offset.y = 0;
    } else {
      texture.repeat.x = 1;
      texture.repeat.y = imageAspect / aspect;
      texture.offset.x = 0;
      texture.offset.y = (1 - texture.repeat.y) / 2;
    }
    return texture;
  }
  function fill(texture) {
    texture.repeat.x = 1;
    texture.repeat.y = 1;
    texture.offset.x = 0;
    texture.offset.y = 0;
    return texture;
  }

  /**
   * Given the width, height, format, and type of a texture. Determines how many
   * bytes must be used to represent the texture.
   *
   * @param {Number} width
   * @param {Number} height
   * @param {Number} format
   * @param {Number} type
   * @return {Number} The number of bytes required to represent the texture.
   */
  function getByteLength(width, height, format, type) {
    var typeByteLength = getTextureTypeByteLength(type);
    switch (format) {
      // https://registry.khronos.org/OpenGL-Refpages/es3.0/html/glTexImage2D.xhtml
      case AlphaFormat:
        return width * height;
      case LuminanceFormat:
        return width * height;
      case LuminanceAlphaFormat:
        return width * height * 2;
      case RedFormat:
        return width * height / typeByteLength.components * typeByteLength.byteLength;
      case RedIntegerFormat:
        return width * height / typeByteLength.components * typeByteLength.byteLength;
      case RGFormat:
        return width * height * 2 / typeByteLength.components * typeByteLength.byteLength;
      case RGIntegerFormat:
        return width * height * 2 / typeByteLength.components * typeByteLength.byteLength;
      case RGBFormat:
        return width * height * 3 / typeByteLength.components * typeByteLength.byteLength;
      case RGBAFormat:
        return width * height * 4 / typeByteLength.components * typeByteLength.byteLength;
      case RGBAIntegerFormat:
        return width * height * 4 / typeByteLength.components * typeByteLength.byteLength;

      // https://registry.khronos.org/webgl/extensions/WEBGL_compressed_texture_s3tc_srgb/
      case RGB_S3TC_DXT1_Format:
      case RGBA_S3TC_DXT1_Format:
        return Math.floor((width + 3) / 4) * Math.floor((height + 3) / 4) * 8;
      case RGBA_S3TC_DXT3_Format:
      case RGBA_S3TC_DXT5_Format:
        return Math.floor((width + 3) / 4) * Math.floor((height + 3) / 4) * 16;

      // https://registry.khronos.org/webgl/extensions/WEBGL_compressed_texture_pvrtc/
      case RGB_PVRTC_2BPPV1_Format:
      case RGBA_PVRTC_2BPPV1_Format:
        return Math.max(width, 16) * Math.max(height, 8) / 4;
      case RGB_PVRTC_4BPPV1_Format:
      case RGBA_PVRTC_4BPPV1_Format:
        return Math.max(width, 8) * Math.max(height, 8) / 2;

      // https://registry.khronos.org/webgl/extensions/WEBGL_compressed_texture_etc/
      case RGB_ETC1_Format:
      case RGB_ETC2_Format:
        return Math.floor((width + 3) / 4) * Math.floor((height + 3) / 4) * 8;
      case RGBA_ETC2_EAC_Format:
        return Math.floor((width + 3) / 4) * Math.floor((height + 3) / 4) * 16;

      // https://registry.khronos.org/webgl/extensions/WEBGL_compressed_texture_astc/
      case RGBA_ASTC_4x4_Format:
        return Math.floor((width + 3) / 4) * Math.floor((height + 3) / 4) * 16;
      case RGBA_ASTC_5x4_Format:
        return Math.floor((width + 4) / 5) * Math.floor((height + 3) / 4) * 16;
      case RGBA_ASTC_5x5_Format:
        return Math.floor((width + 4) / 5) * Math.floor((height + 4) / 5) * 16;
      case RGBA_ASTC_6x5_Format:
        return Math.floor((width + 5) / 6) * Math.floor((height + 4) / 5) * 16;
      case RGBA_ASTC_6x6_Format:
        return Math.floor((width + 5) / 6) * Math.floor((height + 5) / 6) * 16;
      case RGBA_ASTC_8x5_Format:
        return Math.floor((width + 7) / 8) * Math.floor((height + 4) / 5) * 16;
      case RGBA_ASTC_8x6_Format:
        return Math.floor((width + 7) / 8) * Math.floor((height + 5) / 6) * 16;
      case RGBA_ASTC_8x8_Format:
        return Math.floor((width + 7) / 8) * Math.floor((height + 7) / 8) * 16;
      case RGBA_ASTC_10x5_Format:
        return Math.floor((width + 9) / 10) * Math.floor((height + 4) / 5) * 16;
      case RGBA_ASTC_10x6_Format:
        return Math.floor((width + 9) / 10) * Math.floor((height + 5) / 6) * 16;
      case RGBA_ASTC_10x8_Format:
        return Math.floor((width + 9) / 10) * Math.floor((height + 7) / 8) * 16;
      case RGBA_ASTC_10x10_Format:
        return Math.floor((width + 9) / 10) * Math.floor((height + 9) / 10) * 16;
      case RGBA_ASTC_12x10_Format:
        return Math.floor((width + 11) / 12) * Math.floor((height + 9) / 10) * 16;
      case RGBA_ASTC_12x12_Format:
        return Math.floor((width + 11) / 12) * Math.floor((height + 11) / 12) * 16;

      // https://registry.khronos.org/webgl/extensions/EXT_texture_compression_bptc/
      case RGBA_BPTC_Format:
      case RGB_BPTC_SIGNED_Format:
      case RGB_BPTC_UNSIGNED_Format:
        return Math.ceil(width / 4) * Math.ceil(height / 4) * 16;

      // https://registry.khronos.org/webgl/extensions/EXT_texture_compression_rgtc/
      case RED_RGTC1_Format:
      case SIGNED_RED_RGTC1_Format:
        return Math.ceil(width / 4) * Math.ceil(height / 4) * 8;
      case RED_GREEN_RGTC2_Format:
      case SIGNED_RED_GREEN_RGTC2_Format:
        return Math.ceil(width / 4) * Math.ceil(height / 4) * 16;
    }
    throw new Error(`Unable to determine texture byte length for ${format} format.`);
  }
  function getTextureTypeByteLength(type) {
    switch (type) {
      case UnsignedByteType:
      case ByteType:
        return {
          byteLength: 1,
          components: 1
        };
      case UnsignedShortType:
      case ShortType:
      case HalfFloatType:
        return {
          byteLength: 2,
          components: 1
        };
      case UnsignedShort4444Type:
      case UnsignedShort5551Type:
        return {
          byteLength: 2,
          components: 4
        };
      case UnsignedIntType:
      case IntType:
      case FloatType:
        return {
          byteLength: 4,
          components: 1
        };
      case UnsignedInt5999Type:
        return {
          byteLength: 4,
          components: 3
        };
    }
    throw new Error(`Unknown texture type ${type}.`);
  }
  var TextureUtils = exports.TextureUtils = {
    contain: contain,
    cover: cover,
    fill: fill,
    getByteLength: getByteLength
  };
  if (typeof __THREE_DEVTOOLS__ !== 'undefined') {
    __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent('register', {
      detail: {
        revision: REVISION
      }
    }));
  }
  if (typeof window !== 'undefined') {
    if (window.__THREE__) {
      console.warn('WARNING: Multiple instances of Three.js being imported.');
    } else {
      window.__THREE__ = REVISION;
    }
  }
},4,[3,5,6,12,18,20,24,11,27,28,31,32,33],"../../node_modules/three/build/three.core.js");
global.__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  function asyncGeneratorStep(n, t, e, r, o, a, c) {
    try {
      var i = n[a](c),
        u = i.value;
    } catch (n) {
      return void e(n);
    }
    i.done ? t(u) : Promise.resolve(u).then(r, o);
  }
  function _asyncToGenerator(n) {
    return function () {
      var t = this,
        e = arguments;
      return new Promise(function (r, o) {
        var a = n.apply(t, e);
        function _next(n) {
          asyncGeneratorStep(a, r, o, _next, _throw, "next", n);
        }
        function _throw(n) {
          asyncGeneratorStep(a, r, o, _next, _throw, "throw", n);
        }
        _next(void 0);
      });
    };
  }
  module.exports = _asyncToGenerator, module.exports.__esModule = true, module.exports["default"] = module.exports;
},5,[],"../../node_modules/@babel/runtime/helpers/asyncToGenerator.js");
global.__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  function _wrapNativeSuper(t) {
    var r = "function" == typeof Map ? new Map() : void 0;
    return module.exports = _wrapNativeSuper = function _wrapNativeSuper(t) {
      if (null === t || !_$$_REQUIRE(_dependencyMap[0], "./isNativeFunction.js")(t)) return t;
      if ("function" != typeof t) throw new TypeError("Super expression must either be null or a function");
      if (void 0 !== r) {
        if (r.has(t)) return r.get(t);
        r.set(t, Wrapper);
      }
      function Wrapper() {
        return _$$_REQUIRE(_dependencyMap[1], "./construct.js")(t, arguments, _$$_REQUIRE(_dependencyMap[2], "./getPrototypeOf.js")(this).constructor);
      }
      return Wrapper.prototype = Object.create(t.prototype, {
        constructor: {
          value: Wrapper,
          enumerable: !1,
          writable: !0,
          configurable: !0
        }
      }), _$$_REQUIRE(_dependencyMap[3], "./setPrototypeOf.js")(Wrapper, t);
    }, module.exports.__esModule = true, module.exports["default"] = module.exports, _wrapNativeSuper(t);
  }
  module.exports = _wrapNativeSuper, module.exports.__esModule = true, module.exports["default"] = module.exports;
},6,[7,8,11,10],"../../node_modules/@babel/runtime/helpers/wrapNativeSuper.js");
global.__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  function _isNativeFunction(t) {
    try {
      return -1 !== Function.toString.call(t).indexOf("[native code]");
    } catch (n) {
      return "function" == typeof t;
    }
  }
  module.exports = _isNativeFunction, module.exports.__esModule = true, module.exports["default"] = module.exports;
},7,[],"../../node_modules/@babel/runtime/helpers/isNativeFunction.js");
global.__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  function _construct(t, e, r) {
    if (_$$_REQUIRE(_dependencyMap[0], "./isNativeReflectConstruct.js")()) return Reflect.construct.apply(null, arguments);
    var o = [null];
    o.push.apply(o, e);
    var p = new (t.bind.apply(t, o))();
    return r && _$$_REQUIRE(_dependencyMap[1], "./setPrototypeOf.js")(p, r.prototype), p;
  }
  module.exports = _construct, module.exports.__esModule = true, module.exports["default"] = module.exports;
},8,[9,10],"../../node_modules/@babel/runtime/helpers/construct.js");
global.__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  function _isNativeReflectConstruct() {
    try {
      var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    } catch (t) {}
    return (module.exports = _isNativeReflectConstruct = function _isNativeReflectConstruct() {
      return !!t;
    }, module.exports.__esModule = true, module.exports["default"] = module.exports)();
  }
  module.exports = _isNativeReflectConstruct, module.exports.__esModule = true, module.exports["default"] = module.exports;
},9,[],"../../node_modules/@babel/runtime/helpers/isNativeReflectConstruct.js");
global.__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  function _setPrototypeOf(t, e) {
    return module.exports = _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) {
      return t.__proto__ = e, t;
    }, module.exports.__esModule = true, module.exports["default"] = module.exports, _setPrototypeOf(t, e);
  }
  module.exports = _setPrototypeOf, module.exports.__esModule = true, module.exports["default"] = module.exports;
},10,[],"../../node_modules/@babel/runtime/helpers/setPrototypeOf.js");
global.__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  function _getPrototypeOf(t) {
    return module.exports = _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) {
      return t.__proto__ || Object.getPrototypeOf(t);
    }, module.exports.__esModule = true, module.exports["default"] = module.exports, _getPrototypeOf(t);
  }
  module.exports = _getPrototypeOf, module.exports.__esModule = true, module.exports["default"] = module.exports;
},11,[],"../../node_modules/@babel/runtime/helpers/getPrototypeOf.js");
global.__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  function _slicedToArray(r, e) {
    return _$$_REQUIRE(_dependencyMap[0], "./arrayWithHoles.js")(r) || _$$_REQUIRE(_dependencyMap[1], "./iterableToArrayLimit.js")(r, e) || _$$_REQUIRE(_dependencyMap[2], "./unsupportedIterableToArray.js")(r, e) || _$$_REQUIRE(_dependencyMap[3], "./nonIterableRest.js")();
  }
  module.exports = _slicedToArray, module.exports.__esModule = true, module.exports["default"] = module.exports;
},12,[13,14,15,17],"../../node_modules/@babel/runtime/helpers/slicedToArray.js");
global.__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  function _arrayWithHoles(r) {
    if (Array.isArray(r)) return r;
  }
  module.exports = _arrayWithHoles, module.exports.__esModule = true, module.exports["default"] = module.exports;
},13,[],"../../node_modules/@babel/runtime/helpers/arrayWithHoles.js");
global.__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  function _iterableToArrayLimit(r, l) {
    var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
    if (null != t) {
      var e,
        n,
        i,
        u,
        a = [],
        f = !0,
        o = !1;
      try {
        if (i = (t = t.call(r)).next, 0 === l) {
          if (Object(t) !== t) return;
          f = !1;
        } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0);
      } catch (r) {
        o = !0, n = r;
      } finally {
        try {
          if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return;
        } finally {
          if (o) throw n;
        }
      }
      return a;
    }
  }
  module.exports = _iterableToArrayLimit, module.exports.__esModule = true, module.exports["default"] = module.exports;
},14,[],"../../node_modules/@babel/runtime/helpers/iterableToArrayLimit.js");
global.__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  function _unsupportedIterableToArray(r, a) {
    if (r) {
      if ("string" == typeof r) return _$$_REQUIRE(_dependencyMap[0], "./arrayLikeToArray.js")(r, a);
      var t = {}.toString.call(r).slice(8, -1);
      return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _$$_REQUIRE(_dependencyMap[0], "./arrayLikeToArray.js")(r, a) : void 0;
    }
  }
  module.exports = _unsupportedIterableToArray, module.exports.__esModule = true, module.exports["default"] = module.exports;
},15,[16],"../../node_modules/@babel/runtime/helpers/unsupportedIterableToArray.js");
global.__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  function _arrayLikeToArray(r, a) {
    (null == a || a > r.length) && (a = r.length);
    for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
    return n;
  }
  module.exports = _arrayLikeToArray, module.exports.__esModule = true, module.exports["default"] = module.exports;
},16,[],"../../node_modules/@babel/runtime/helpers/arrayLikeToArray.js");
global.__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  module.exports = _nonIterableRest, module.exports.__esModule = true, module.exports["default"] = module.exports;
},17,[],"../../node_modules/@babel/runtime/helpers/nonIterableRest.js");
global.__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  function _get() {
    return module.exports = _get = "undefined" != typeof Reflect && Reflect.get ? Reflect.get.bind() : function (e, t, r) {
      var p = _$$_REQUIRE(_dependencyMap[0], "./superPropBase.js")(e, t);
      if (p) {
        var n = Object.getOwnPropertyDescriptor(p, t);
        return n.get ? n.get.call(arguments.length < 3 ? e : r) : n.value;
      }
    }, module.exports.__esModule = true, module.exports["default"] = module.exports, _get.apply(null, arguments);
  }
  module.exports = _get, module.exports.__esModule = true, module.exports["default"] = module.exports;
},18,[19],"../../node_modules/@babel/runtime/helpers/get.js");
global.__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  function _superPropBase(t, o) {
    for (; !{}.hasOwnProperty.call(t, o) && null !== (t = _$$_REQUIRE(_dependencyMap[0], "./getPrototypeOf.js")(t)););
    return t;
  }
  module.exports = _superPropBase, module.exports.__esModule = true, module.exports["default"] = module.exports;
},19,[11],"../../node_modules/@babel/runtime/helpers/superPropBase.js");
global.__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  function _toConsumableArray(r) {
    return _$$_REQUIRE(_dependencyMap[0], "./arrayWithoutHoles.js")(r) || _$$_REQUIRE(_dependencyMap[1], "./iterableToArray.js")(r) || _$$_REQUIRE(_dependencyMap[2], "./unsupportedIterableToArray.js")(r) || _$$_REQUIRE(_dependencyMap[3], "./nonIterableSpread.js")();
  }
  module.exports = _toConsumableArray, module.exports.__esModule = true, module.exports["default"] = module.exports;
},20,[21,22,15,23],"../../node_modules/@babel/runtime/helpers/toConsumableArray.js");
global.__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  function _arrayWithoutHoles(r) {
    if (Array.isArray(r)) return _$$_REQUIRE(_dependencyMap[0], "./arrayLikeToArray.js")(r);
  }
  module.exports = _arrayWithoutHoles, module.exports.__esModule = true, module.exports["default"] = module.exports;
},21,[16],"../../node_modules/@babel/runtime/helpers/arrayWithoutHoles.js");
global.__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  function _iterableToArray(r) {
    if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r);
  }
  module.exports = _iterableToArray, module.exports.__esModule = true, module.exports["default"] = module.exports;
},22,[],"../../node_modules/@babel/runtime/helpers/iterableToArray.js");
global.__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  module.exports = _nonIterableSpread, module.exports.__esModule = true, module.exports["default"] = module.exports;
},23,[],"../../node_modules/@babel/runtime/helpers/nonIterableSpread.js");
global.__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  function _possibleConstructorReturn(t, e) {
    if (e && ("object" == _$$_REQUIRE(_dependencyMap[0], "./typeof.js")["default"](e) || "function" == typeof e)) return e;
    if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
    return _$$_REQUIRE(_dependencyMap[1], "./assertThisInitialized.js")(t);
  }
  module.exports = _possibleConstructorReturn, module.exports.__esModule = true, module.exports["default"] = module.exports;
},24,[25,26],"../../node_modules/@babel/runtime/helpers/possibleConstructorReturn.js");
global.__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  function _typeof(o) {
    "@babel/helpers - typeof";

    return module.exports = _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) {
      return typeof o;
    } : function (o) {
      return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
    }, module.exports.__esModule = true, module.exports["default"] = module.exports, _typeof(o);
  }
  module.exports = _typeof, module.exports.__esModule = true, module.exports["default"] = module.exports;
},25,[],"../../node_modules/@babel/runtime/helpers/typeof.js");
global.__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  function _assertThisInitialized(e) {
    if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return e;
  }
  module.exports = _assertThisInitialized, module.exports.__esModule = true, module.exports["default"] = module.exports;
},26,[],"../../node_modules/@babel/runtime/helpers/assertThisInitialized.js");
global.__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  function _inherits(t, e) {
    if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
    t.prototype = Object.create(e && e.prototype, {
      constructor: {
        value: t,
        writable: !0,
        configurable: !0
      }
    }), Object.defineProperty(t, "prototype", {
      writable: !1
    }), e && _$$_REQUIRE(_dependencyMap[0], "./setPrototypeOf.js")(t, e);
  }
  module.exports = _inherits, module.exports.__esModule = true, module.exports["default"] = module.exports;
},27,[10],"../../node_modules/@babel/runtime/helpers/inherits.js");
global.__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  function _defineProperty(e, r, t) {
    return (r = _$$_REQUIRE(_dependencyMap[0], "./toPropertyKey.js")(r)) in e ? Object.defineProperty(e, r, {
      value: t,
      enumerable: !0,
      configurable: !0,
      writable: !0
    }) : e[r] = t, e;
  }
  module.exports = _defineProperty, module.exports.__esModule = true, module.exports["default"] = module.exports;
},28,[29],"../../node_modules/@babel/runtime/helpers/defineProperty.js");
global.__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  function toPropertyKey(t) {
    var i = _$$_REQUIRE(_dependencyMap[0], "./toPrimitive.js")(t, "string");
    return "symbol" == _$$_REQUIRE(_dependencyMap[1], "./typeof.js")["default"](i) ? i : i + "";
  }
  module.exports = toPropertyKey, module.exports.__esModule = true, module.exports["default"] = module.exports;
},29,[30,25],"../../node_modules/@babel/runtime/helpers/toPropertyKey.js");
global.__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  function toPrimitive(t, r) {
    if ("object" != _$$_REQUIRE(_dependencyMap[0], "./typeof.js")["default"](t) || !t) return t;
    var e = t[Symbol.toPrimitive];
    if (void 0 !== e) {
      var i = e.call(t, r || "default");
      if ("object" != _$$_REQUIRE(_dependencyMap[0], "./typeof.js")["default"](i)) return i;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === r ? String : Number)(t);
  }
  module.exports = toPrimitive, module.exports.__esModule = true, module.exports["default"] = module.exports;
},30,[25],"../../node_modules/@babel/runtime/helpers/toPrimitive.js");
global.__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  function _readOnlyError(r) {
    throw new TypeError('"' + r + '" is read-only');
  }
  module.exports = _readOnlyError, module.exports.__esModule = true, module.exports["default"] = module.exports;
},31,[],"../../node_modules/@babel/runtime/helpers/readOnlyError.js");
global.__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  function _classCallCheck(a, n) {
    if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
  }
  module.exports = _classCallCheck, module.exports.__esModule = true, module.exports["default"] = module.exports;
},32,[],"../../node_modules/@babel/runtime/helpers/classCallCheck.js");
global.__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  function _defineProperties(e, r) {
    for (var t = 0; t < r.length; t++) {
      var o = r[t];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, _$$_REQUIRE(_dependencyMap[0], "./toPropertyKey.js")(o.key), o);
    }
  }
  function _createClass(e, r, t) {
    return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", {
      writable: !1
    }), e;
  }
  module.exports = _createClass, module.exports.__esModule = true, module.exports["default"] = module.exports;
},33,[29],"../../node_modules/@babel/runtime/helpers/createClass.js");
global.__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.frameCorners = frameCorners;
  var _va = /*@__PURE__*/new (_$$_REQUIRE(_dependencyMap[0], "three").Vector3)(),
    // from pe to pa
    _vb = /*@__PURE__*/new (_$$_REQUIRE(_dependencyMap[0], "three").Vector3)(),
    // from pe to pb
    _vc = /*@__PURE__*/new (_$$_REQUIRE(_dependencyMap[0], "three").Vector3)(),
    // from pe to pc
    _vr = /*@__PURE__*/new (_$$_REQUIRE(_dependencyMap[0], "three").Vector3)(),
    // right axis of screen
    _vu = /*@__PURE__*/new (_$$_REQUIRE(_dependencyMap[0], "three").Vector3)(),
    // up axis of screen
    _vn = /*@__PURE__*/new (_$$_REQUIRE(_dependencyMap[0], "three").Vector3)(),
    // normal vector of screen
    _vec = /*@__PURE__*/new (_$$_REQUIRE(_dependencyMap[0], "three").Vector3)(),
    // temporary vector
    _quat = /*@__PURE__*/new (_$$_REQUIRE(_dependencyMap[0], "three").Quaternion)(); // temporary quaternion

  /** Set a PerspectiveCamera's projectionMatrix and quaternion
   * to exactly frame the corners of an arbitrary rectangle.
   * NOTE: This function ignores the standard parameters;
   * do not call updateProjectionMatrix() after this!
   *
   * @param {PerspectiveCamera} camera
   * @param {Vector3} bottomLeftCorner
   * @param {Vector3} bottomRightCorner
   * @param {Vector3} topLeftCorner
   * @param {boolean} [estimateViewFrustum=false]
   */
  function frameCorners(camera, bottomLeftCorner, bottomRightCorner, topLeftCorner) {
    var estimateViewFrustum = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
    var pa = bottomLeftCorner,
      pb = bottomRightCorner,
      pc = topLeftCorner;
    var pe = camera.position; // eye position
    var n = camera.near; // distance of near clipping plane
    var f = camera.far; //distance of far clipping plane

    _vr.copy(pb).sub(pa).normalize();
    _vu.copy(pc).sub(pa).normalize();
    _vn.crossVectors(_vr, _vu).normalize();
    _va.copy(pa).sub(pe); // from pe to pa
    _vb.copy(pb).sub(pe); // from pe to pb
    _vc.copy(pc).sub(pe); // from pe to pc

    var d = -_va.dot(_vn); // distance from eye to screen
    var l = _vr.dot(_va) * n / d; // distance to left screen edge
    var r = _vr.dot(_vb) * n / d; // distance to right screen edge
    var b = _vu.dot(_va) * n / d; // distance to bottom screen edge
    var t = _vu.dot(_vc) * n / d; // distance to top screen edge

    // Set the camera rotation to match the focal plane to the corners' plane
    _quat.setFromUnitVectors(_vec.set(0, 1, 0), _vu);
    camera.quaternion.setFromUnitVectors(_vec.set(0, 0, 1).applyQuaternion(_quat), _vn).multiply(_quat);

    // Set the off-axis projection matrix to match the corners
    camera.projectionMatrix.set(2.0 * n / (r - l), 0.0, (r + l) / (r - l), 0.0, 0.0, 2.0 * n / (t - b), (t + b) / (t - b), 0.0, 0.0, 0.0, (f + n) / (n - f), 2.0 * f * n / (n - f), 0.0, 0.0, -1.0, 0.0);
    camera.projectionMatrixInverse.copy(camera.projectionMatrix).invert();

    // FoV estimation to fix frustum culling
    if (estimateViewFrustum) {
      // Set fieldOfView to a conservative estimate
      // to make frustum tall/wide enough to encompass it
      camera.fov = _$$_REQUIRE(_dependencyMap[0], "three").MathUtils.RAD2DEG / Math.min(1.0, camera.aspect) * Math.atan((_vec.copy(pb).sub(pa).length() + _vec.copy(pc).sub(pa).length()) / _va.length());
    }
  }
},34,[2],"../../node_modules/three/examples/jsm/utils/CameraUtils.js");
global.__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.compressNormals = compressNormals;
  exports.compressPositions = compressPositions;
  exports.compressUvs = compressUvs;
  /**
   * Octahedron and Quantization encodings based on work by:
   *
   * @link https://github.com/tsherif/mesh-quantization-example
   *
   */

  /**
   * Make the input geometry's normal attribute encoded and compressed by 3 different methods.
   *
   * @param {THREE.BufferGeometry} geometry
   * @param {String} encodeMethod		"DEFAULT" || "OCT1Byte" || "OCT2Byte" || "ANGLES"
   *
   */
  function compressNormals(geometry, encodeMethod) {
    var normal = geometry.attributes.normal;
    if (!normal) {
      console.error('Geometry must contain normal attribute. ');
    }
    if (normal.isPacked) return;
    if (normal.itemSize != 3) {
      console.error('normal.itemSize is not 3, which cannot be encoded. ');
    }
    var array = normal.array;
    var count = normal.count;
    var result;
    if (encodeMethod == 'DEFAULT') {
      // TODO: Add 1 byte to the result, making the encoded length to be 4 bytes.
      result = new Uint8Array(count * 3);
      for (var idx = 0; idx < array.length; idx += 3) {
        var encoded = defaultEncode(array[idx], array[idx + 1], array[idx + 2], 1);
        result[idx + 0] = encoded[0];
        result[idx + 1] = encoded[1];
        result[idx + 2] = encoded[2];
      }
      geometry.setAttribute('normal', new (_$$_REQUIRE(_dependencyMap[0], "three").BufferAttribute)(result, 3, true));
      geometry.attributes.normal.bytes = result.length * 1;
    } else if (encodeMethod == 'OCT1Byte') {
      /**
      * It is not recommended to use 1-byte octahedron normals encoding unless you want to extremely reduce the memory usage
      * As it makes vertex data not aligned to a 4 byte boundary which may harm some WebGL implementations and sometimes the normal distortion is visible
      * Please refer to @zeux 's comments in https://github.com/mrdoob/three.js/pull/18208
      */

      result = new Int8Array(count * 2);
      for (var _idx = 0; _idx < array.length; _idx += 3) {
        var _encoded = octEncodeBest(array[_idx], array[_idx + 1], array[_idx + 2], 1);
        result[_idx / 3 * 2 + 0] = _encoded[0];
        result[_idx / 3 * 2 + 1] = _encoded[1];
      }
      geometry.setAttribute('normal', new (_$$_REQUIRE(_dependencyMap[0], "three").BufferAttribute)(result, 2, true));
      geometry.attributes.normal.bytes = result.length * 1;
    } else if (encodeMethod == 'OCT2Byte') {
      result = new Int16Array(count * 2);
      for (var _idx2 = 0; _idx2 < array.length; _idx2 += 3) {
        var _encoded2 = octEncodeBest(array[_idx2], array[_idx2 + 1], array[_idx2 + 2], 2);
        result[_idx2 / 3 * 2 + 0] = _encoded2[0];
        result[_idx2 / 3 * 2 + 1] = _encoded2[1];
      }
      geometry.setAttribute('normal', new (_$$_REQUIRE(_dependencyMap[0], "three").BufferAttribute)(result, 2, true));
      geometry.attributes.normal.bytes = result.length * 2;
    } else if (encodeMethod == 'ANGLES') {
      result = new Uint16Array(count * 2);
      for (var _idx3 = 0; _idx3 < array.length; _idx3 += 3) {
        var _encoded3 = anglesEncode(array[_idx3], array[_idx3 + 1], array[_idx3 + 2]);
        result[_idx3 / 3 * 2 + 0] = _encoded3[0];
        result[_idx3 / 3 * 2 + 1] = _encoded3[1];
      }
      geometry.setAttribute('normal', new (_$$_REQUIRE(_dependencyMap[0], "three").BufferAttribute)(result, 2, true));
      geometry.attributes.normal.bytes = result.length * 2;
    } else {
      console.error('Unrecognized encoding method, should be `DEFAULT` or `ANGLES` or `OCT`. ');
    }
    geometry.attributes.normal.needsUpdate = true;
    geometry.attributes.normal.isPacked = true;
    geometry.attributes.normal.packingMethod = encodeMethod;
  }

  /**
  	 * Make the input geometry's position attribute encoded and compressed.
  	 *
  	 * @param {THREE.BufferGeometry} geometry
  	 *
  	 */
  function compressPositions(geometry) {
    var position = geometry.attributes.position;
    if (!position) {
      console.error('Geometry must contain position attribute. ');
    }
    if (position.isPacked) return;
    if (position.itemSize != 3) {
      console.error('position.itemSize is not 3, which cannot be packed. ');
    }
    var array = position.array;
    var encodingBytes = 2;
    var result = quantizedEncode(array, encodingBytes);
    var quantized = result.quantized;

    // IMPORTANT: calculate original geometry bounding info first, before updating packed positions
    if (geometry.boundingBox == null) geometry.computeBoundingBox();
    if (geometry.boundingSphere == null) geometry.computeBoundingSphere();
    geometry.setAttribute('position', new (_$$_REQUIRE(_dependencyMap[0], "three").BufferAttribute)(quantized, 3));
    geometry.attributes.position.isPacked = true;
    geometry.attributes.position.needsUpdate = true;
    geometry.attributes.position.bytes = quantized.length * encodingBytes;
  }

  /**
   * Make the input geometry's uv attribute encoded and compressed.
   *
   * @param {THREE.BufferGeometry} geometry
   *
   */
  function compressUvs(geometry) {
    var uvs = geometry.attributes.uv;
    if (!uvs) {
      console.error('Geometry must contain uv attribute. ');
    }
    if (uvs.isPacked) return;
    var range = {
      min: Infinity,
      max: -Infinity
    };
    var array = uvs.array;
    for (var i = 0; i < array.length; i++) {
      range.min = Math.min(range.min, array[i]);
      range.max = Math.max(range.max, array[i]);
    }
    var result;
    if (range.min >= -1.0 && range.max <= 1.0) {
      // use default encoding method
      result = new Uint16Array(array.length);
      for (var _i = 0; _i < array.length; _i += 2) {
        var encoded = defaultEncode(array[_i], array[_i + 1], 0, 2);
        result[_i] = encoded[0];
        result[_i + 1] = encoded[1];
      }
      geometry.setAttribute('uv', new (_$$_REQUIRE(_dependencyMap[0], "three").BufferAttribute)(result, 2, true));
      geometry.attributes.uv.isPacked = true;
      geometry.attributes.uv.needsUpdate = true;
      geometry.attributes.uv.bytes = result.length * 2;
    } else {
      // use quantized encoding method
      result = quantizedEncodeUV(array, 2);
      geometry.setAttribute('uv', new (_$$_REQUIRE(_dependencyMap[0], "three").BufferAttribute)(result.quantized, 2));
      geometry.attributes.uv.isPacked = true;
      geometry.attributes.uv.needsUpdate = true;
      geometry.attributes.uv.bytes = result.quantized.length * 2;
    }
  }

  // Encoding functions

  function defaultEncode(x, y, z, bytes) {
    if (bytes == 1) {
      var tmpx = Math.round((x + 1) * 0.5 * 255);
      var tmpy = Math.round((y + 1) * 0.5 * 255);
      var tmpz = Math.round((z + 1) * 0.5 * 255);
      return new Uint8Array([tmpx, tmpy, tmpz]);
    } else if (bytes == 2) {
      var _tmpx = Math.round((x + 1) * 0.5 * 65535);
      var _tmpy = Math.round((y + 1) * 0.5 * 65535);
      var _tmpz = Math.round((z + 1) * 0.5 * 65535);
      return new Uint16Array([_tmpx, _tmpy, _tmpz]);
    } else {
      console.error('number of bytes must be 1 or 2');
    }
  }

  // for `Angles` encoding
  function anglesEncode(x, y, z) {
    var normal0 = parseInt(0.5 * (1.0 + Math.atan2(y, x) / Math.PI) * 65535);
    var normal1 = parseInt(0.5 * (1.0 + z) * 65535);
    return new Uint16Array([normal0, normal1]);
  }

  // for `Octahedron` encoding
  function octEncodeBest(x, y, z, bytes) {
    var oct, dec, best, currentCos, bestCos;

    // Test various combinations of ceil and floor
    // to minimize rounding errors
    best = oct = octEncodeVec3(x, y, z, 'floor', 'floor');
    dec = octDecodeVec2(oct);
    bestCos = dot(x, y, z, dec);
    oct = octEncodeVec3(x, y, z, 'ceil', 'floor');
    dec = octDecodeVec2(oct);
    currentCos = dot(x, y, z, dec);
    if (currentCos > bestCos) {
      best = oct;
      bestCos = currentCos;
    }
    oct = octEncodeVec3(x, y, z, 'floor', 'ceil');
    dec = octDecodeVec2(oct);
    currentCos = dot(x, y, z, dec);
    if (currentCos > bestCos) {
      best = oct;
      bestCos = currentCos;
    }
    oct = octEncodeVec3(x, y, z, 'ceil', 'ceil');
    dec = octDecodeVec2(oct);
    currentCos = dot(x, y, z, dec);
    if (currentCos > bestCos) {
      best = oct;
    }
    return best;
    function octEncodeVec3(x0, y0, z0, xfunc, yfunc) {
      var x = x0 / (Math.abs(x0) + Math.abs(y0) + Math.abs(z0));
      var y = y0 / (Math.abs(x0) + Math.abs(y0) + Math.abs(z0));
      if (z < 0) {
        var tempx = (1 - Math.abs(y)) * (x >= 0 ? 1 : -1);
        var tempy = (1 - Math.abs(x)) * (y >= 0 ? 1 : -1);
        x = tempx;
        y = tempy;
        var diff = 1 - Math.abs(x) - Math.abs(y);
        if (diff > 0) {
          diff += 0.001;
          x += x > 0 ? diff / 2 : -diff / 2;
          y += y > 0 ? diff / 2 : -diff / 2;
        }
      }
      if (bytes == 1) {
        return new Int8Array([Math[xfunc](x * 127.5 + (x < 0 ? 1 : 0)), Math[yfunc](y * 127.5 + (y < 0 ? 1 : 0))]);
      }
      if (bytes == 2) {
        return new Int16Array([Math[xfunc](x * 32767.5 + (x < 0 ? 1 : 0)), Math[yfunc](y * 32767.5 + (y < 0 ? 1 : 0))]);
      }
    }
    function octDecodeVec2(oct) {
      var x = oct[0];
      var y = oct[1];
      if (bytes == 1) {
        x /= x < 0 ? 127 : 128;
        y /= y < 0 ? 127 : 128;
      } else if (bytes == 2) {
        x /= x < 0 ? 32767 : 32768;
        y /= y < 0 ? 32767 : 32768;
      }
      var z = 1 - Math.abs(x) - Math.abs(y);
      if (z < 0) {
        var tmpx = x;
        x = (1 - Math.abs(y)) * (x >= 0 ? 1 : -1);
        y = (1 - Math.abs(tmpx)) * (y >= 0 ? 1 : -1);
      }
      var length = Math.sqrt(x * x + y * y + z * z);
      return [x / length, y / length, z / length];
    }
    function dot(x, y, z, vec3) {
      return x * vec3[0] + y * vec3[1] + z * vec3[2];
    }
  }
  function quantizedEncode(array, bytes) {
    var quantized, segments;
    if (bytes == 1) {
      quantized = new Uint8Array(array.length);
      segments = 255;
    } else if (bytes == 2) {
      quantized = new Uint16Array(array.length);
      segments = 65535;
    } else {
      console.error('number of bytes error! ');
    }
    var decodeMat = new (_$$_REQUIRE(_dependencyMap[0], "three").Matrix4)();
    var min = new Float32Array(3);
    var max = new Float32Array(3);
    min[0] = min[1] = min[2] = Number.MAX_VALUE;
    max[0] = max[1] = max[2] = -Number.MAX_VALUE;
    for (var i = 0; i < array.length; i += 3) {
      min[0] = Math.min(min[0], array[i + 0]);
      min[1] = Math.min(min[1], array[i + 1]);
      min[2] = Math.min(min[2], array[i + 2]);
      max[0] = Math.max(max[0], array[i + 0]);
      max[1] = Math.max(max[1], array[i + 1]);
      max[2] = Math.max(max[2], array[i + 2]);
    }
    decodeMat.scale(new (_$$_REQUIRE(_dependencyMap[0], "three").Vector3)((max[0] - min[0]) / segments, (max[1] - min[1]) / segments, (max[2] - min[2]) / segments));
    decodeMat.elements[12] = min[0];
    decodeMat.elements[13] = min[1];
    decodeMat.elements[14] = min[2];
    decodeMat.transpose();
    var multiplier = new Float32Array([max[0] !== min[0] ? segments / (max[0] - min[0]) : 0, max[1] !== min[1] ? segments / (max[1] - min[1]) : 0, max[2] !== min[2] ? segments / (max[2] - min[2]) : 0]);
    for (var _i2 = 0; _i2 < array.length; _i2 += 3) {
      quantized[_i2 + 0] = Math.floor((array[_i2 + 0] - min[0]) * multiplier[0]);
      quantized[_i2 + 1] = Math.floor((array[_i2 + 1] - min[1]) * multiplier[1]);
      quantized[_i2 + 2] = Math.floor((array[_i2 + 2] - min[2]) * multiplier[2]);
    }
    return {
      quantized: quantized,
      decodeMat: decodeMat
    };
  }
  function quantizedEncodeUV(array, bytes) {
    var quantized, segments;
    if (bytes == 1) {
      quantized = new Uint8Array(array.length);
      segments = 255;
    } else if (bytes == 2) {
      quantized = new Uint16Array(array.length);
      segments = 65535;
    } else {
      console.error('number of bytes error! ');
    }
    var decodeMat = new (_$$_REQUIRE(_dependencyMap[0], "three").Matrix3)();
    var min = new Float32Array(2);
    var max = new Float32Array(2);
    min[0] = min[1] = Number.MAX_VALUE;
    max[0] = max[1] = -Number.MAX_VALUE;
    for (var i = 0; i < array.length; i += 2) {
      min[0] = Math.min(min[0], array[i + 0]);
      min[1] = Math.min(min[1], array[i + 1]);
      max[0] = Math.max(max[0], array[i + 0]);
      max[1] = Math.max(max[1], array[i + 1]);
    }
    decodeMat.scale((max[0] - min[0]) / segments, (max[1] - min[1]) / segments);
    decodeMat.elements[6] = min[0];
    decodeMat.elements[7] = min[1];
    decodeMat.transpose();
    var multiplier = new Float32Array([max[0] !== min[0] ? segments / (max[0] - min[0]) : 0, max[1] !== min[1] ? segments / (max[1] - min[1]) : 0]);
    for (var _i3 = 0; _i3 < array.length; _i3 += 2) {
      quantized[_i3 + 0] = Math.floor((array[_i3 + 0] - min[0]) * multiplier[0]);
      quantized[_i3 + 1] = Math.floor((array[_i3 + 1] - min[1]) * multiplier[1]);
    }
    return {
      quantized: quantized,
      decodeMat: decodeMat
    };
  }
},35,[2],"../../node_modules/three/examples/jsm/utils/GeometryCompressionUtils.js");
global.__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.gosper = gosper;
  exports.hilbert2D = hilbert2D;
  exports.hilbert3D = hilbert3D;
  var _toConsumableArray2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[1], "@babel/runtime/helpers/toConsumableArray"));
  /**
   * Generates 2D-Coordinates in a very fast way.
   *
   * Based on work by:
   * @link http://www.openprocessing.org/sketch/15493
   *
   * @param {Vector3} center - Center of Hilbert curve.
   * @param {number} [size=10] - Total width of Hilbert curve.
   * @param {number} [iterations=10] - Number of subdivisions.
   * @param {number} [v0=0] - Corner index -X, -Z.
   * @param {number} [v1=1] - Corner index -X, +Z.
   * @param {number} [v2=2] - Corner index +X, +Z.
   * @param {number} [v3=3] - Corner index +X, -Z.
   * @returns {Array<Array<number>>} The Hilbert curve points.
   */
  function hilbert2D() {
    var center = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new (_$$_REQUIRE(_dependencyMap[2], "three").Vector3)(0, 0, 0);
    var size = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 10;
    var iterations = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
    var v0 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
    var v1 = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 1;
    var v2 = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 2;
    var v3 = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 3;
    var half = size / 2;
    var vec_s = [new (_$$_REQUIRE(_dependencyMap[2], "three").Vector3)(center.x - half, center.y, center.z - half), new (_$$_REQUIRE(_dependencyMap[2], "three").Vector3)(center.x - half, center.y, center.z + half), new (_$$_REQUIRE(_dependencyMap[2], "three").Vector3)(center.x + half, center.y, center.z + half), new (_$$_REQUIRE(_dependencyMap[2], "three").Vector3)(center.x + half, center.y, center.z - half)];
    var vec = [vec_s[v0], vec_s[v1], vec_s[v2], vec_s[v3]];

    // Recurse iterations
    if (0 <= --iterations) {
      return [].concat((0, _toConsumableArray2.default)(hilbert2D(vec[0], half, iterations, v0, v3, v2, v1)), (0, _toConsumableArray2.default)(hilbert2D(vec[1], half, iterations, v0, v1, v2, v3)), (0, _toConsumableArray2.default)(hilbert2D(vec[2], half, iterations, v0, v1, v2, v3)), (0, _toConsumableArray2.default)(hilbert2D(vec[3], half, iterations, v2, v1, v0, v3)));
    }

    // Return complete Hilbert Curve.
    return vec;
  }

  /**
   * Generates 3D-Coordinates in a very fast way.
   *
   * Based on work by:
   * @link https://openprocessing.org/user/5654
   *
   * @param {Vector3} [center=new Vector3( 0, 0, 0 )] - Center of Hilbert curve.
   * @param {number} [size=10] - Total width of Hilbert curve.
   * @param {number} [iterations=1] - Number of subdivisions.
   * @param {number} [v0=0] - Corner index -X, +Y, -Z.
   * @param {number} [v1=1] - Corner index -X, +Y, +Z.
   * @param {number} [v2=2] - Corner index -X, -Y, +Z.
   * @param {number} [v3=3] - Corner index -X, -Y, -Z.
   * @param {number} [v4=4] - Corner index +X, -Y, -Z.
   * @param {number} [v5=5] - Corner index +X, -Y, +Z.
   * @param {number} [v6=6] - Corner index +X, +Y, +Z.
   * @param {number} [v7=7] - Corner index +X, +Y, -Z.
   * @returns {Array<Array<number>>}  - The Hilbert curve points.
   */
  function hilbert3D() {
    var center = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new (_$$_REQUIRE(_dependencyMap[2], "three").Vector3)(0, 0, 0);
    var size = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 10;
    var iterations = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
    var v0 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
    var v1 = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 1;
    var v2 = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 2;
    var v3 = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 3;
    var v4 = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : 4;
    var v5 = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : 5;
    var v6 = arguments.length > 9 && arguments[9] !== undefined ? arguments[9] : 6;
    var v7 = arguments.length > 10 && arguments[10] !== undefined ? arguments[10] : 7;
    // Default Vars
    var half = size / 2;
    var vec_s = [new (_$$_REQUIRE(_dependencyMap[2], "three").Vector3)(center.x - half, center.y + half, center.z - half), new (_$$_REQUIRE(_dependencyMap[2], "three").Vector3)(center.x - half, center.y + half, center.z + half), new (_$$_REQUIRE(_dependencyMap[2], "three").Vector3)(center.x - half, center.y - half, center.z + half), new (_$$_REQUIRE(_dependencyMap[2], "three").Vector3)(center.x - half, center.y - half, center.z - half), new (_$$_REQUIRE(_dependencyMap[2], "three").Vector3)(center.x + half, center.y - half, center.z - half), new (_$$_REQUIRE(_dependencyMap[2], "three").Vector3)(center.x + half, center.y - half, center.z + half), new (_$$_REQUIRE(_dependencyMap[2], "three").Vector3)(center.x + half, center.y + half, center.z + half), new (_$$_REQUIRE(_dependencyMap[2], "three").Vector3)(center.x + half, center.y + half, center.z - half)];
    var vec = [vec_s[v0], vec_s[v1], vec_s[v2], vec_s[v3], vec_s[v4], vec_s[v5], vec_s[v6], vec_s[v7]];

    // Recurse iterations
    if (--iterations >= 0) {
      return [].concat((0, _toConsumableArray2.default)(hilbert3D(vec[0], half, iterations, v0, v3, v4, v7, v6, v5, v2, v1)), (0, _toConsumableArray2.default)(hilbert3D(vec[1], half, iterations, v0, v7, v6, v1, v2, v5, v4, v3)), (0, _toConsumableArray2.default)(hilbert3D(vec[2], half, iterations, v0, v7, v6, v1, v2, v5, v4, v3)), (0, _toConsumableArray2.default)(hilbert3D(vec[3], half, iterations, v2, v3, v0, v1, v6, v7, v4, v5)), (0, _toConsumableArray2.default)(hilbert3D(vec[4], half, iterations, v2, v3, v0, v1, v6, v7, v4, v5)), (0, _toConsumableArray2.default)(hilbert3D(vec[5], half, iterations, v4, v3, v2, v5, v6, v1, v0, v7)), (0, _toConsumableArray2.default)(hilbert3D(vec[6], half, iterations, v4, v3, v2, v5, v6, v1, v0, v7)), (0, _toConsumableArray2.default)(hilbert3D(vec[7], half, iterations, v6, v5, v2, v1, v0, v3, v4, v7)));
    }

    // Return complete Hilbert Curve.
    return vec;
  }

  /**
   * Generates a Gosper curve (lying in the XY plane)
   *
   * https://gist.github.com/nitaku/6521802
   *
   * @param {number} [size=1] - The size of a single gosper island.
   * @return {Array<[number, number, number]>} The gosper island points.
   */
  function gosper() {
    var size = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;
    function fractalize(config) {
      var output;
      var input = config.axiom;
      for (var i = 0, il = config.steps; 0 <= il ? i < il : i > il; 0 <= il ? i++ : i--) {
        output = '';
        for (var j = 0, jl = input.length; j < jl; j++) {
          var char = input[j];
          if (char in config.rules) {
            output += config.rules[char];
          } else {
            output += char;
          }
        }
        input = output;
      }
      return output;
    }
    function toPoints(config) {
      var currX = 0,
        currY = 0;
      var angle = 0;
      var path = [0, 0, 0];
      var fractal = config.fractal;
      for (var i = 0, l = fractal.length; i < l; i++) {
        var char = fractal[i];
        if (char === '+') {
          angle += config.angle;
        } else if (char === '-') {
          angle -= config.angle;
        } else if (char === 'F') {
          currX += config.size * Math.cos(angle);
          currY += -config.size * Math.sin(angle);
          path.push(currX, currY, 0);
        }
      }
      return path;
    }

    //

    var gosper = fractalize({
      axiom: 'A',
      steps: 4,
      rules: {
        A: 'A+BF++BF-FA--FAFA-BF+',
        B: '-FA+BFBF++BF+FA--FA-B'
      }
    });
    var points = toPoints({
      fractal: gosper,
      size: size,
      angle: Math.PI / 3 // 60 degrees
    });
    return points;
  }
},36,[3,20,2],"../../node_modules/three/examples/jsm/utils/GeometryUtils.js");
global.__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.LDrawUtils = void 0;
  var _classCallCheck2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[1], "@babel/runtime/helpers/classCallCheck"));
  var _createClass2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[2], "@babel/runtime/helpers/createClass"));
  var LDrawUtils = exports.LDrawUtils = /*#__PURE__*/function () {
    function LDrawUtils() {
      (0, _classCallCheck2.default)(this, LDrawUtils);
    }
    return (0, _createClass2.default)(LDrawUtils, null, [{
      key: "mergeObject",
      value: function mergeObject(object) {
        // Merges geometries in object by materials and returns new object. Use on not indexed geometries.
        // The object buffers reference the old object ones.
        // Special treatment is done to the conditional lines generated by LDrawLoader.

        function extractGroup(geometry, group, elementSize, isConditionalLine) {
          // Extracts a group from a geometry as a new geometry (with attribute buffers referencing original buffers)

          var newGeometry = new (_$$_REQUIRE(_dependencyMap[3], "three").BufferGeometry)();
          var originalPositions = geometry.getAttribute('position').array;
          var originalNormals = elementSize === 3 ? geometry.getAttribute('normal').array : null;
          var numVertsGroup = Math.min(group.count, Math.floor(originalPositions.length / 3) - group.start);
          var vertStart = group.start * 3;
          var vertEnd = (group.start + numVertsGroup) * 3;
          var positions = originalPositions.subarray(vertStart, vertEnd);
          var normals = originalNormals !== null ? originalNormals.subarray(vertStart, vertEnd) : null;
          newGeometry.setAttribute('position', new (_$$_REQUIRE(_dependencyMap[3], "three").BufferAttribute)(positions, 3));
          if (normals !== null) newGeometry.setAttribute('normal', new (_$$_REQUIRE(_dependencyMap[3], "three").BufferAttribute)(normals, 3));
          if (isConditionalLine) {
            var controlArray0 = geometry.getAttribute('control0').array.subarray(vertStart, vertEnd);
            var controlArray1 = geometry.getAttribute('control1').array.subarray(vertStart, vertEnd);
            var directionArray = geometry.getAttribute('direction').array.subarray(vertStart, vertEnd);
            newGeometry.setAttribute('control0', new (_$$_REQUIRE(_dependencyMap[3], "three").BufferAttribute)(controlArray0, 3, false));
            newGeometry.setAttribute('control1', new (_$$_REQUIRE(_dependencyMap[3], "three").BufferAttribute)(controlArray1, 3, false));
            newGeometry.setAttribute('direction', new (_$$_REQUIRE(_dependencyMap[3], "three").BufferAttribute)(directionArray, 3, false));
          }
          return newGeometry;
        }
        function addGeometry(mat, geometry, geometries) {
          var geoms = geometries[mat.uuid];
          if (!geoms) {
            geometries[mat.uuid] = {
              mat: mat,
              arr: [geometry]
            };
          } else {
            geoms.arr.push(geometry);
          }
        }
        function permuteAttribute(attribute, elemSize) {
          // Permutes first two vertices of each attribute element

          if (!attribute) return;
          var verts = attribute.array;
          var numVerts = Math.floor(verts.length / 3);
          var offset = 0;
          for (var i = 0; i < numVerts; i++) {
            var x = verts[offset];
            var y = verts[offset + 1];
            var z = verts[offset + 2];
            verts[offset] = verts[offset + 3];
            verts[offset + 1] = verts[offset + 4];
            verts[offset + 2] = verts[offset + 5];
            verts[offset + 3] = x;
            verts[offset + 4] = y;
            verts[offset + 5] = z;
            offset += elemSize * 3;
          }
        }

        // Traverse the object hierarchy collecting geometries and transforming them to world space

        var meshGeometries = {};
        var linesGeometries = {};
        var condLinesGeometries = {};
        object.updateMatrixWorld(true);
        var normalMatrix = new (_$$_REQUIRE(_dependencyMap[3], "three").Matrix3)();
        object.traverse(function (c) {
          if (c.isMesh | c.isLineSegments) {
            var elemSize = c.isMesh ? 3 : 2;
            var geometry = c.geometry.clone();
            var matrixIsInverted = c.matrixWorld.determinant() < 0;
            if (matrixIsInverted) {
              permuteAttribute(geometry.attributes.position, elemSize);
              permuteAttribute(geometry.attributes.normal, elemSize);
            }
            geometry.applyMatrix4(c.matrixWorld);
            if (c.isConditionalLine) {
              geometry.attributes.control0.applyMatrix4(c.matrixWorld);
              geometry.attributes.control1.applyMatrix4(c.matrixWorld);
              normalMatrix.getNormalMatrix(c.matrixWorld);
              geometry.attributes.direction.applyNormalMatrix(normalMatrix);
            }
            var geometries = c.isMesh ? meshGeometries : c.isConditionalLine ? condLinesGeometries : linesGeometries;
            if (Array.isArray(c.material)) {
              for (var groupIndex in geometry.groups) {
                var group = geometry.groups[groupIndex];
                var mat = c.material[group.materialIndex];
                var newGeometry = extractGroup(geometry, group, elemSize, c.isConditionalLine);
                addGeometry(mat, newGeometry, geometries);
              }
            } else {
              addGeometry(c.material, geometry, geometries);
            }
          }
        });

        // Create object with merged geometries

        var mergedObject = new (_$$_REQUIRE(_dependencyMap[3], "three").Group)();
        var meshMaterialsIds = Object.keys(meshGeometries);
        for (var meshMaterialsId of meshMaterialsIds) {
          var meshGeometry = meshGeometries[meshMaterialsId];
          var mergedGeometry = (0, _$$_REQUIRE(_dependencyMap[4], "./BufferGeometryUtils.js").mergeGeometries)(meshGeometry.arr);
          mergedObject.add(new (_$$_REQUIRE(_dependencyMap[3], "three").Mesh)(mergedGeometry, meshGeometry.mat));
        }
        var linesMaterialsIds = Object.keys(linesGeometries);
        for (var linesMaterialsId of linesMaterialsIds) {
          var lineGeometry = linesGeometries[linesMaterialsId];
          var _mergedGeometry = (0, _$$_REQUIRE(_dependencyMap[4], "./BufferGeometryUtils.js").mergeGeometries)(lineGeometry.arr);
          mergedObject.add(new (_$$_REQUIRE(_dependencyMap[3], "three").LineSegments)(_mergedGeometry, lineGeometry.mat));
        }
        var condLinesMaterialsIds = Object.keys(condLinesGeometries);
        for (var condLinesMaterialsId of condLinesMaterialsIds) {
          var condLineGeometry = condLinesGeometries[condLinesMaterialsId];
          var _mergedGeometry2 = (0, _$$_REQUIRE(_dependencyMap[4], "./BufferGeometryUtils.js").mergeGeometries)(condLineGeometry.arr);
          var condLines = new (_$$_REQUIRE(_dependencyMap[3], "three").LineSegments)(_mergedGeometry2, condLineGeometry.mat);
          condLines.isConditionalLine = true;
          mergedObject.add(condLines);
        }
        mergedObject.userData.constructionStep = 0;
        mergedObject.userData.numConstructionSteps = 1;
        return mergedObject;
      }
    }]);
  }();
},37,[3,32,33,2,1],"../../node_modules/three/examples/jsm/utils/LDrawUtils.js");
global.__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.createMeshesFromInstancedMesh = createMeshesFromInstancedMesh;
  exports.createMeshesFromMultiMaterialMesh = createMeshesFromMultiMaterialMesh;
  exports.createMultiMaterialObject = createMultiMaterialObject;
  exports.reduceVertices = reduceVertices;
  exports.sortInstancedMesh = sortInstancedMesh;
  exports.traverseAncestorsGenerator = traverseAncestorsGenerator;
  exports.traverseGenerator = traverseGenerator;
  exports.traverseVisibleGenerator = traverseVisibleGenerator;
  var _color = /*@__PURE__*/new (_$$_REQUIRE(_dependencyMap[0], "three").Color)();
  var _matrix = /*@__PURE__*/new (_$$_REQUIRE(_dependencyMap[0], "three").Matrix4)();
  function createMeshesFromInstancedMesh(instancedMesh) {
    var group = new (_$$_REQUIRE(_dependencyMap[0], "three").Group)();
    var count = instancedMesh.count;
    var geometry = instancedMesh.geometry;
    var material = instancedMesh.material;
    for (var i = 0; i < count; i++) {
      var mesh = new (_$$_REQUIRE(_dependencyMap[0], "three").Mesh)(geometry, material);
      instancedMesh.getMatrixAt(i, mesh.matrix);
      mesh.matrix.decompose(mesh.position, mesh.quaternion, mesh.scale);
      group.add(mesh);
    }
    group.copy(instancedMesh);
    group.updateMatrixWorld(); // ensure correct world matrices of meshes

    return group;
  }
  function createMeshesFromMultiMaterialMesh(mesh) {
    if (Array.isArray(mesh.material) === false) {
      console.warn('THREE.SceneUtils.createMeshesFromMultiMaterialMesh(): The given mesh has no multiple materials.');
      return mesh;
    }
    var object = new (_$$_REQUIRE(_dependencyMap[0], "three").Group)();
    object.copy(mesh);

    // merge groups (which automatically sorts them)

    var geometry = (0, _$$_REQUIRE(_dependencyMap[1], "./BufferGeometryUtils.js").mergeGroups)(mesh.geometry);
    var index = geometry.index;
    var groups = geometry.groups;
    var attributeNames = Object.keys(geometry.attributes);

    // create a mesh for each group by extracting the buffer data into a new geometry

    for (var i = 0; i < groups.length; i++) {
      var group = groups[i];
      var start = group.start;
      var end = start + group.count;
      var newGeometry = new (_$$_REQUIRE(_dependencyMap[0], "three").BufferGeometry)();
      var newMaterial = mesh.material[group.materialIndex];

      // process all buffer attributes

      for (var j = 0; j < attributeNames.length; j++) {
        var name = attributeNames[j];
        var attribute = geometry.attributes[name];
        var itemSize = attribute.itemSize;
        var newLength = group.count * itemSize;
        var type = attribute.array.constructor;
        var newArray = new type(newLength);
        var newAttribute = new (_$$_REQUIRE(_dependencyMap[0], "three").BufferAttribute)(newArray, itemSize);
        for (var k = start, n = 0; k < end; k++, n++) {
          var ind = index.getX(k);
          if (itemSize >= 1) newAttribute.setX(n, attribute.getX(ind));
          if (itemSize >= 2) newAttribute.setY(n, attribute.getY(ind));
          if (itemSize >= 3) newAttribute.setZ(n, attribute.getZ(ind));
          if (itemSize >= 4) newAttribute.setW(n, attribute.getW(ind));
        }
        newGeometry.setAttribute(name, newAttribute);
      }
      var newMesh = new (_$$_REQUIRE(_dependencyMap[0], "three").Mesh)(newGeometry, newMaterial);
      object.add(newMesh);
    }
    return object;
  }
  function createMultiMaterialObject(geometry, materials) {
    var group = new (_$$_REQUIRE(_dependencyMap[0], "three").Group)();
    for (var i = 0, l = materials.length; i < l; i++) {
      group.add(new (_$$_REQUIRE(_dependencyMap[0], "three").Mesh)(geometry, materials[i]));
    }
    return group;
  }
  function reduceVertices(object, func, initialValue) {
    var value = initialValue;
    var vertex = new (_$$_REQUIRE(_dependencyMap[0], "three").Vector3)();
    object.updateWorldMatrix(true, true);
    object.traverseVisible(function (child) {
      var geometry = child.geometry;
      if (geometry !== undefined) {
        var position = geometry.attributes.position;
        if (position !== undefined) {
          for (var i = 0, l = position.count; i < l; i++) {
            if (child.isMesh) {
              child.getVertexPosition(i, vertex);
            } else {
              vertex.fromBufferAttribute(position, i);
            }
            if (!child.isSkinnedMesh) {
              vertex.applyMatrix4(child.matrixWorld);
            }
            value = func(value, vertex);
          }
        }
      }
    });
    return value;
  }

  /**
   * @param {InstancedMesh} mesh
   * @param {function(int, int):int} compareFn
   */
  function sortInstancedMesh(mesh, compareFn) {
    // store copy of instanced attributes for lookups

    var instanceMatrixRef = (0, _$$_REQUIRE(_dependencyMap[1], "./BufferGeometryUtils.js").deepCloneAttribute)(mesh.instanceMatrix);
    var instanceColorRef = mesh.instanceColor ? (0, _$$_REQUIRE(_dependencyMap[1], "./BufferGeometryUtils.js").deepCloneAttribute)(mesh.instanceColor) : null;
    var attributeRefs = new Map();
    for (var name in mesh.geometry.attributes) {
      var attribute = mesh.geometry.attributes[name];
      if (attribute.isInstancedBufferAttribute) {
        attributeRefs.set(attribute, (0, _$$_REQUIRE(_dependencyMap[1], "./BufferGeometryUtils.js").deepCloneAttribute)(attribute));
      }
    }

    // compute sort order

    var tokens = [];
    for (var i = 0; i < mesh.count; i++) tokens.push(i);
    tokens.sort(compareFn);

    // apply sort order

    for (var _i = 0; _i < tokens.length; _i++) {
      var refIndex = tokens[_i];
      _matrix.fromArray(instanceMatrixRef.array, refIndex * mesh.instanceMatrix.itemSize);
      _matrix.toArray(mesh.instanceMatrix.array, _i * mesh.instanceMatrix.itemSize);
      if (mesh.instanceColor) {
        _color.fromArray(instanceColorRef.array, refIndex * mesh.instanceColor.itemSize);
        _color.toArray(mesh.instanceColor.array, _i * mesh.instanceColor.itemSize);
      }
      for (var _name in mesh.geometry.attributes) {
        var _attribute = mesh.geometry.attributes[_name];
        if (_attribute.isInstancedBufferAttribute) {
          var attributeRef = attributeRefs.get(_attribute);
          _attribute.setX(_i, attributeRef.getX(refIndex));
          if (_attribute.itemSize > 1) _attribute.setY(_i, attributeRef.getY(refIndex));
          if (_attribute.itemSize > 2) _attribute.setZ(_i, attributeRef.getZ(refIndex));
          if (_attribute.itemSize > 3) _attribute.setW(_i, attributeRef.getW(refIndex));
        }
      }
    }
  }

  /**
   * @param {Object3D} object Object to traverse.
   * @yields {Object3D} Objects that passed the filter condition.
   */
  function* traverseGenerator(object) {
    yield object;
    var children = object.children;
    for (var i = 0, l = children.length; i < l; i++) {
      yield* traverseGenerator(children[i]);
    }
  }

  /**
   * @param {Object3D} object Object to traverse.
   * @yields {Object3D} Objects that passed the filter condition.
   */
  function* traverseVisibleGenerator(object) {
    if (object.visible === false) return;
    yield object;
    var children = object.children;
    for (var i = 0, l = children.length; i < l; i++) {
      yield* traverseVisibleGenerator(children[i]);
    }
  }

  /**
   * @param {Object3D} object Object to traverse.
   * @yields {Object3D} Objects that passed the filter condition.
   */
  function* traverseAncestorsGenerator(object) {
    var parent = object.parent;
    if (parent !== null) {
      yield parent;
      yield* traverseAncestorsGenerator(parent);
    }
  }
},38,[2,1],"../../node_modules/three/examples/jsm/utils/SceneUtils.js");
global.__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.ShadowMapViewer = void 0;
  var _createClass2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[1], "@babel/runtime/helpers/createClass"));
  var _classCallCheck2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[2], "@babel/runtime/helpers/classCallCheck"));
  /**
   * This is a helper for visualising a given light's shadow map.
   * It works for shadow casting lights: DirectionalLight and SpotLight.
   * It renders out the shadow map and displays it on a HUD.
   *
   * Example usage:
   *	1) Import ShadowMapViewer into your app.
   *
   *	2) Create a shadow casting light and name it optionally:
   *		let light = new DirectionalLight( 0xffffff, 1 );
   *		light.castShadow = true;
   *		light.name = 'Sun';
   *
   *	3) Create a shadow map viewer for that light and set its size and position optionally:
   *		let shadowMapViewer = new ShadowMapViewer( light );
   *		shadowMapViewer.size.set( 128, 128 );	//width, height  default: 256, 256
   *		shadowMapViewer.position.set( 10, 10 );	//x, y in pixel	 default: 0, 0 (top left corner)
   *
   *	4) Render the shadow map viewer in your render loop:
   *		shadowMapViewer.render( renderer );
   *
   *	5) Optionally: Update the shadow map viewer on window resize:
   *		shadowMapViewer.updateForWindowResize();
   *
   *	6) If you set the position or size members directly, you need to call shadowMapViewer.update();
   */
  var ShadowMapViewer = exports.ShadowMapViewer = /*#__PURE__*/(0, _createClass2.default)(function ShadowMapViewer(light) {
    (0, _classCallCheck2.default)(this, ShadowMapViewer);
    //- Internals
    var scope = this;
    var doRenderLabel = light.name !== undefined && light.name !== '';
    var userAutoClearSetting;

    //Holds the initial position and dimension of the HUD
    var frame = {
      x: 10,
      y: 10,
      width: 256,
      height: 256
    };
    var camera = new (_$$_REQUIRE(_dependencyMap[3], "three").OrthographicCamera)(window.innerWidth / -2, window.innerWidth / 2, window.innerHeight / 2, window.innerHeight / -2, 1, 10);
    camera.position.set(0, 0, 2);
    var scene = new (_$$_REQUIRE(_dependencyMap[3], "three").Scene)();

    //HUD for shadow map
    var shader = _$$_REQUIRE(_dependencyMap[4], "../shaders/UnpackDepthRGBAShader.js").UnpackDepthRGBAShader;
    var uniforms = _$$_REQUIRE(_dependencyMap[3], "three").UniformsUtils.clone(shader.uniforms);
    var material = new (_$$_REQUIRE(_dependencyMap[3], "three").ShaderMaterial)({
      uniforms: uniforms,
      vertexShader: shader.vertexShader,
      fragmentShader: shader.fragmentShader
    });
    var plane = new (_$$_REQUIRE(_dependencyMap[3], "three").PlaneGeometry)(frame.width, frame.height);
    var mesh = new (_$$_REQUIRE(_dependencyMap[3], "three").Mesh)(plane, material);
    scene.add(mesh);

    //Label for light's name
    var labelCanvas, labelMesh;
    if (doRenderLabel) {
      labelCanvas = document.createElement('canvas');
      var context = labelCanvas.getContext('2d');
      context.font = 'Bold 20px Arial';
      var labelWidth = context.measureText(light.name).width;
      labelCanvas.width = labelWidth;
      labelCanvas.height = 25; //25 to account for g, p, etc.

      context.font = 'Bold 20px Arial';
      context.fillStyle = 'rgba( 255, 0, 0, 1 )';
      context.fillText(light.name, 0, 20);
      var labelTexture = new (_$$_REQUIRE(_dependencyMap[3], "three").CanvasTexture)(labelCanvas);
      var labelMaterial = new (_$$_REQUIRE(_dependencyMap[3], "three").MeshBasicMaterial)({
        map: labelTexture,
        side: _$$_REQUIRE(_dependencyMap[3], "three").DoubleSide,
        transparent: true
      });
      var labelPlane = new (_$$_REQUIRE(_dependencyMap[3], "three").PlaneGeometry)(labelCanvas.width, labelCanvas.height);
      labelMesh = new (_$$_REQUIRE(_dependencyMap[3], "three").Mesh)(labelPlane, labelMaterial);
      scene.add(labelMesh);
    }
    function resetPosition() {
      scope.position.set(scope.position.x, scope.position.y);
    }

    //- API
    // Set to false to disable displaying this shadow map
    this.enabled = true;

    // Set the size of the displayed shadow map on the HUD
    this.size = {
      width: frame.width,
      height: frame.height,
      set: function set(width, height) {
        this.width = width;
        this.height = height;
        mesh.scale.set(this.width / frame.width, this.height / frame.height, 1);

        //Reset the position as it is off when we scale stuff
        resetPosition();
      }
    };

    // Set the position of the displayed shadow map on the HUD
    this.position = {
      x: frame.x,
      y: frame.y,
      set: function set(x, y) {
        this.x = x;
        this.y = y;
        var width = scope.size.width;
        var height = scope.size.height;
        mesh.position.set(-window.innerWidth / 2 + width / 2 + this.x, window.innerHeight / 2 - height / 2 - this.y, 0);
        if (doRenderLabel) labelMesh.position.set(mesh.position.x, mesh.position.y - scope.size.height / 2 + labelCanvas.height / 2, 0);
      }
    };
    this.render = function (renderer) {
      if (this.enabled) {
        //Because a light's .shadowMap is only initialised after the first render pass
        //we have to make sure the correct map is sent into the shader, otherwise we
        //always end up with the scene's first added shadow casting light's shadowMap
        //in the shader
        //See: https://github.com/mrdoob/three.js/issues/5932
        uniforms.tDiffuse.value = light.shadow.map.texture;
        userAutoClearSetting = renderer.autoClear;
        renderer.autoClear = false; // To allow render overlay
        renderer.clearDepth();
        renderer.render(scene, camera);
        renderer.autoClear = userAutoClearSetting; //Restore user's setting
      }
    };
    this.updateForWindowResize = function () {
      if (this.enabled) {
        camera.left = window.innerWidth / -2;
        camera.right = window.innerWidth / 2;
        camera.top = window.innerHeight / 2;
        camera.bottom = window.innerHeight / -2;
        camera.updateProjectionMatrix();
        this.update();
      }
    };
    this.update = function () {
      this.position.set(this.position.x, this.position.y);
      this.size.set(this.size.width, this.size.height);
    };

    //Force an update to set position/size
    this.update();
  });
},39,[3,33,32,2,40],"../../node_modules/three/examples/jsm/utils/ShadowMapViewer.js");
global.__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.UnpackDepthRGBAShader = void 0;
  /**
   * Unpack RGBA depth shader
   * - show RGBA encoded depth as monochrome color
   */

  var UnpackDepthRGBAShader = exports.UnpackDepthRGBAShader = {
    name: 'UnpackDepthRGBAShader',
    uniforms: {
      'tDiffuse': {
        value: null
      },
      'opacity': {
        value: 1.0
      }
    },
    vertexShader: /* glsl */`

		varying vec2 vUv;

		void main() {

			vUv = uv;
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`,
    fragmentShader: /* glsl */`

		uniform float opacity;

		uniform sampler2D tDiffuse;

		varying vec2 vUv;

		#include <packing>

		void main() {

			float depth = 1.0 - unpackRGBAToDepth( texture2D( tDiffuse, vUv ) );
			gl_FragColor = vec4( vec3( depth ), opacity );

		}`
  };
},40,[],"../../node_modules/three/examples/jsm/shaders/UnpackDepthRGBAShader.js");
global.__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  var _interopRequireDefault = _$$_REQUIRE(_dependencyMap[0], "@babel/runtime/helpers/interopRequireDefault");
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.clone = clone;
  exports.retarget = retarget;
  exports.retargetClip = retargetClip;
  var _toConsumableArray2 = _interopRequireDefault(_$$_REQUIRE(_dependencyMap[1], "@babel/runtime/helpers/toConsumableArray"));
  function getBoneName(bone, options) {
    if (options.getBoneName !== undefined) {
      return options.getBoneName(bone);
    }
    return options.names[bone.name];
  }
  function retarget(target, source) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var quat = new (_$$_REQUIRE(_dependencyMap[2], "three").Quaternion)(),
      scale = new (_$$_REQUIRE(_dependencyMap[2], "three").Vector3)(),
      relativeMatrix = new (_$$_REQUIRE(_dependencyMap[2], "three").Matrix4)(),
      globalMatrix = new (_$$_REQUIRE(_dependencyMap[2], "three").Matrix4)();
    options.preserveBoneMatrix = options.preserveBoneMatrix !== undefined ? options.preserveBoneMatrix : true;
    options.preserveBonePositions = options.preserveBonePositions !== undefined ? options.preserveBonePositions : true;
    options.useTargetMatrix = options.useTargetMatrix !== undefined ? options.useTargetMatrix : false;
    options.hip = options.hip !== undefined ? options.hip : 'hip';
    options.hipInfluence = options.hipInfluence !== undefined ? options.hipInfluence : new (_$$_REQUIRE(_dependencyMap[2], "three").Vector3)(1, 1, 1);
    options.scale = options.scale !== undefined ? options.scale : 1;
    options.names = options.names || {};
    var sourceBones = source.isObject3D ? source.skeleton.bones : getBones(source),
      bones = target.isObject3D ? target.skeleton.bones : getBones(target);
    var bone, name, boneTo, bonesPosition;

    // reset bones

    if (target.isObject3D) {
      target.skeleton.pose();
    } else {
      options.useTargetMatrix = true;
      options.preserveBoneMatrix = false;
    }
    if (options.preserveBonePositions) {
      bonesPosition = [];
      for (var i = 0; i < bones.length; i++) {
        bonesPosition.push(bones[i].position.clone());
      }
    }
    if (options.preserveBoneMatrix) {
      // reset matrix

      target.updateMatrixWorld();
      target.matrixWorld.identity();

      // reset children matrix

      for (var _i = 0; _i < target.children.length; ++_i) {
        target.children[_i].updateMatrixWorld(true);
      }
    }
    for (var _i2 = 0; _i2 < bones.length; ++_i2) {
      bone = bones[_i2];
      name = getBoneName(bone, options);
      boneTo = getBoneByName(name, sourceBones);
      globalMatrix.copy(bone.matrixWorld);
      if (boneTo) {
        boneTo.updateMatrixWorld();
        if (options.useTargetMatrix) {
          relativeMatrix.copy(boneTo.matrixWorld);
        } else {
          relativeMatrix.copy(target.matrixWorld).invert();
          relativeMatrix.multiply(boneTo.matrixWorld);
        }

        // ignore scale to extract rotation

        scale.setFromMatrixScale(relativeMatrix);
        relativeMatrix.scale(scale.set(1 / scale.x, 1 / scale.y, 1 / scale.z));

        // apply to global matrix

        globalMatrix.makeRotationFromQuaternion(quat.setFromRotationMatrix(relativeMatrix));
        if (target.isObject3D) {
          if (options.localOffsets) {
            if (options.localOffsets[bone.name]) {
              globalMatrix.multiply(options.localOffsets[bone.name]);
            }
          }
        }
        globalMatrix.copyPosition(relativeMatrix);
      }
      if (name === options.hip) {
        globalMatrix.elements[12] *= options.scale * options.hipInfluence.x;
        globalMatrix.elements[13] *= options.scale * options.hipInfluence.y;
        globalMatrix.elements[14] *= options.scale * options.hipInfluence.z;
        if (options.hipPosition !== undefined) {
          globalMatrix.elements[12] += options.hipPosition.x * options.scale;
          globalMatrix.elements[13] += options.hipPosition.y * options.scale;
          globalMatrix.elements[14] += options.hipPosition.z * options.scale;
        }
      }
      if (bone.parent) {
        bone.matrix.copy(bone.parent.matrixWorld).invert();
        bone.matrix.multiply(globalMatrix);
      } else {
        bone.matrix.copy(globalMatrix);
      }
      bone.matrix.decompose(bone.position, bone.quaternion, bone.scale);
      bone.updateMatrixWorld();
    }
    if (options.preserveBonePositions) {
      for (var _i3 = 0; _i3 < bones.length; ++_i3) {
        bone = bones[_i3];
        name = getBoneName(bone, options) || bone.name;
        if (name !== options.hip) {
          bone.position.copy(bonesPosition[_i3]);
        }
      }
    }
    if (options.preserveBoneMatrix) {
      // restore matrix

      target.updateMatrixWorld(true);
    }
  }
  function retargetClip(target, source, clip) {
    var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
    options.useFirstFramePosition = options.useFirstFramePosition !== undefined ? options.useFirstFramePosition : false;

    // Calculate the fps from the source clip based on the track with the most frames, unless fps is already provided.
    options.fps = options.fps !== undefined ? options.fps : Math.max.apply(Math, (0, _toConsumableArray2.default)(clip.tracks.map(function (track) {
      return track.times.length;
    }))) / clip.duration;
    options.names = options.names || [];
    if (!source.isObject3D) {
      source = getHelperFromSkeleton(source);
    }
    var numFrames = Math.round(clip.duration * (options.fps / 1000) * 1000),
      delta = clip.duration / (numFrames - 1),
      convertedTracks = [],
      mixer = new (_$$_REQUIRE(_dependencyMap[2], "three").AnimationMixer)(source),
      bones = getBones(target.skeleton),
      boneDatas = [];
    var positionOffset, bone, boneTo, boneData, name;
    mixer.clipAction(clip).play();

    // trim

    var start = 0,
      end = numFrames;
    if (options.trim !== undefined) {
      start = Math.round(options.trim[0] * options.fps);
      end = Math.min(Math.round(options.trim[1] * options.fps), numFrames) - start;
      mixer.update(options.trim[0]);
    } else {
      mixer.update(0);
    }
    source.updateMatrixWorld();

    //

    for (var frame = 0; frame < end; ++frame) {
      var time = frame * delta;
      retarget(target, source, options);
      for (var j = 0; j < bones.length; ++j) {
        bone = bones[j];
        name = getBoneName(bone, options) || bone.name;
        boneTo = getBoneByName(name, source.skeleton);
        if (boneTo) {
          boneData = boneDatas[j] = boneDatas[j] || {
            bone: bone
          };
          if (options.hip === name) {
            if (!boneData.pos) {
              boneData.pos = {
                times: new Float32Array(end),
                values: new Float32Array(end * 3)
              };
            }
            if (options.useFirstFramePosition) {
              if (frame === 0) {
                positionOffset = bone.position.clone();
              }
              bone.position.sub(positionOffset);
            }
            boneData.pos.times[frame] = time;
            bone.position.toArray(boneData.pos.values, frame * 3);
          }
          if (!boneData.quat) {
            boneData.quat = {
              times: new Float32Array(end),
              values: new Float32Array(end * 4)
            };
          }
          boneData.quat.times[frame] = time;
          bone.quaternion.toArray(boneData.quat.values, frame * 4);
        }
      }
      if (frame === end - 2) {
        // last mixer update before final loop iteration
        // make sure we do not go over or equal to clip duration
        mixer.update(delta - 0.0000001);
      } else {
        mixer.update(delta);
      }
      source.updateMatrixWorld();
    }
    for (var i = 0; i < boneDatas.length; ++i) {
      boneData = boneDatas[i];
      if (boneData) {
        if (boneData.pos) {
          convertedTracks.push(new (_$$_REQUIRE(_dependencyMap[2], "three").VectorKeyframeTrack)('.bones[' + boneData.bone.name + '].position', boneData.pos.times, boneData.pos.values));
        }
        convertedTracks.push(new (_$$_REQUIRE(_dependencyMap[2], "three").QuaternionKeyframeTrack)('.bones[' + boneData.bone.name + '].quaternion', boneData.quat.times, boneData.quat.values));
      }
    }
    mixer.uncacheAction(clip);
    return new (_$$_REQUIRE(_dependencyMap[2], "three").AnimationClip)(clip.name, -1, convertedTracks);
  }
  function clone(source) {
    var sourceLookup = new Map();
    var cloneLookup = new Map();
    var clone = source.clone();
    parallelTraverse(source, clone, function (sourceNode, clonedNode) {
      sourceLookup.set(clonedNode, sourceNode);
      cloneLookup.set(sourceNode, clonedNode);
    });
    clone.traverse(function (node) {
      if (!node.isSkinnedMesh) return;
      var clonedMesh = node;
      var sourceMesh = sourceLookup.get(node);
      var sourceBones = sourceMesh.skeleton.bones;
      clonedMesh.skeleton = sourceMesh.skeleton.clone();
      clonedMesh.bindMatrix.copy(sourceMesh.bindMatrix);
      clonedMesh.skeleton.bones = sourceBones.map(function (bone) {
        return cloneLookup.get(bone);
      });
      clonedMesh.bind(clonedMesh.skeleton, clonedMesh.bindMatrix);
    });
    return clone;
  }

  // internal helper

  function getBoneByName(name, skeleton) {
    for (var i = 0, bones = getBones(skeleton); i < bones.length; i++) {
      if (name === bones[i].name) return bones[i];
    }
  }
  function getBones(skeleton) {
    return Array.isArray(skeleton) ? skeleton : skeleton.bones;
  }
  function getHelperFromSkeleton(skeleton) {
    var source = new (_$$_REQUIRE(_dependencyMap[2], "three").SkeletonHelper)(skeleton.bones[0]);
    source.skeleton = skeleton;
    return source;
  }
  function parallelTraverse(a, b, callback) {
    callback(a, b);
    for (var i = 0; i < a.children.length; i++) {
      parallelTraverse(a.children[i], b.children[i], callback);
    }
  }
},41,[3,20,2],"../../node_modules/three/examples/jsm/utils/SkeletonUtils.js");
global.__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.radixSort = void 0;
  // Hybrid radix sort from
  // - https://gist.github.com/sciecode/93ed864dd77c5c8803c6a86698d68dab
  // - https://github.com/mrdoob/three.js/pull/27202#issuecomment-1817640271
  //
  // expects unsigned 32b integer values

  var POWER = 3;
  var BIT_MAX = 32;
  var BIN_BITS = 1 << POWER;
  var BIN_SIZE = 1 << BIN_BITS;
  var BIN_MAX = BIN_SIZE - 1;
  var ITERATIONS = BIT_MAX / BIN_BITS;
  var bins = new Array(ITERATIONS);
  var bins_buffer = new ArrayBuffer((ITERATIONS + 1) * BIN_SIZE * 4);
  var c = 0;
  for (var i = 0; i < ITERATIONS + 1; i++) {
    bins[i] = new Uint32Array(bins_buffer, c, BIN_SIZE);
    c += BIN_SIZE * 4;
  }
  var defaultGet = function defaultGet(el) {
    return el;
  };
  var radixSort = exports.radixSort = function radixSort(arr, opt) {
    var len = arr.length;
    var options = opt || {};
    var aux = options.aux || new arr.constructor(len);
    var get = options.get || defaultGet;
    var data = [arr, aux];
    var compare, accumulate, recurse;
    if (options.reversed) {
      compare = function compare(a, b) {
        return a < b;
      };
      accumulate = function accumulate(bin) {
        for (var j = BIN_SIZE - 2; j >= 0; j--) bin[j] += bin[j + 1];
      };
      recurse = function recurse(cache, depth, start) {
        var prev = 0;
        for (var j = BIN_MAX; j >= 0; j--) {
          var cur = cache[j],
            diff = cur - prev;
          if (diff != 0) {
            if (diff > 32) radixSortBlock(depth + 1, start + prev, diff);else insertionSortBlock(depth + 1, start + prev, diff);
            prev = cur;
          }
        }
      };
    } else {
      compare = function compare(a, b) {
        return a > b;
      };
      accumulate = function accumulate(bin) {
        for (var j = 1; j < BIN_SIZE; j++) bin[j] += bin[j - 1];
      };
      recurse = function recurse(cache, depth, start) {
        var prev = 0;
        for (var j = 0; j < BIN_SIZE; j++) {
          var cur = cache[j],
            diff = cur - prev;
          if (diff != 0) {
            if (diff > 32) radixSortBlock(depth + 1, start + prev, diff);else insertionSortBlock(depth + 1, start + prev, diff);
            prev = cur;
          }
        }
      };
    }
    var insertionSortBlock = function insertionSortBlock(depth, start, len) {
      var a = data[depth & 1];
      var b = data[depth + 1 & 1];
      for (var j = start + 1; j < start + len; j++) {
        var p = a[j],
          t = get(p) >>> 0;
        var _i = j;
        while (_i > start) {
          if (compare(get(a[_i - 1]) >>> 0, t)) a[_i] = a[--_i];else break;
        }
        a[_i] = p;
      }
      if ((depth & 1) == 1) {
        for (var _i2 = start; _i2 < start + len; _i2++) b[_i2] = a[_i2];
      }
    };
    var radixSortBlock = function radixSortBlock(depth, start, len) {
      var a = data[depth & 1];
      var b = data[depth + 1 & 1];
      var shift = 3 - depth << POWER;
      var end = start + len;
      var cache = bins[depth];
      var bin = bins[depth + 1];
      bin.fill(0);
      for (var j = start; j < end; j++) bin[get(a[j]) >>> shift & BIN_MAX]++;
      accumulate(bin);
      cache.set(bin);
      for (var _j = end - 1; _j >= start; _j--) b[start + --bin[get(a[_j]) >>> shift & BIN_MAX]] = a[_j];
      if (depth == ITERATIONS - 1) return;
      recurse(cache, depth, start);
    };
    radixSortBlock(0, 0, len);
  };
},42,[],"../../node_modules/three/examples/jsm/utils/SortUtils.js");
global.__d(function (global, _$$_REQUIRE, _$$_IMPORT_DEFAULT, _$$_IMPORT_ALL, module, exports, _dependencyMap) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.UVsDebug = UVsDebug;
  /**
   * tool for "unwrapping" and debugging three.js geometries UV mapping
   *
   * Sample usage:
   *	document.body.appendChild( UVsDebug( new THREE.SphereGeometry( 10, 10, 10, 10 ) ) );
   *
   */

  function UVsDebug(geometry) {
    var size = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1024;
    // handles wrapping of uv.x > 1 only

    var abc = 'abc';
    var a = new (_$$_REQUIRE(_dependencyMap[0], "three").Vector2)();
    var b = new (_$$_REQUIRE(_dependencyMap[0], "three").Vector2)();
    var uvs = [new (_$$_REQUIRE(_dependencyMap[0], "three").Vector2)(), new (_$$_REQUIRE(_dependencyMap[0], "three").Vector2)(), new (_$$_REQUIRE(_dependencyMap[0], "three").Vector2)()];
    var face = [];
    var canvas = document.createElement('canvas');
    var width = size; // power of 2 required for wrapping
    var height = size;
    canvas.width = width;
    canvas.height = height;
    var ctx = canvas.getContext('2d');
    ctx.lineWidth = 1;
    ctx.strokeStyle = 'rgb( 63, 63, 63 )';
    ctx.textAlign = 'center';

    // paint background white

    ctx.fillStyle = 'rgb( 255, 255, 255 )';
    ctx.fillRect(0, 0, width, height);
    var index = geometry.index;
    var uvAttribute = geometry.attributes.uv;
    if (index) {
      // indexed geometry

      for (var i = 0, il = index.count; i < il; i += 3) {
        face[0] = index.getX(i);
        face[1] = index.getX(i + 1);
        face[2] = index.getX(i + 2);
        uvs[0].fromBufferAttribute(uvAttribute, face[0]);
        uvs[1].fromBufferAttribute(uvAttribute, face[1]);
        uvs[2].fromBufferAttribute(uvAttribute, face[2]);
        processFace(face, uvs, i / 3);
      }
    } else {
      // non-indexed geometry

      for (var _i = 0, _il = uvAttribute.count; _i < _il; _i += 3) {
        face[0] = _i;
        face[1] = _i + 1;
        face[2] = _i + 2;
        uvs[0].fromBufferAttribute(uvAttribute, face[0]);
        uvs[1].fromBufferAttribute(uvAttribute, face[1]);
        uvs[2].fromBufferAttribute(uvAttribute, face[2]);
        processFace(face, uvs, _i / 3);
      }
    }
    return canvas;
    function processFace(face, uvs, index) {
      // draw contour of face

      ctx.beginPath();
      a.set(0, 0);
      for (var j = 0, jl = uvs.length; j < jl; j++) {
        var uv = uvs[j];
        a.x += uv.x;
        a.y += uv.y;
        if (j === 0) {
          ctx.moveTo(uv.x * (width - 2) + 0.5, (1 - uv.y) * (height - 2) + 0.5);
        } else {
          ctx.lineTo(uv.x * (width - 2) + 0.5, (1 - uv.y) * (height - 2) + 0.5);
        }
      }
      ctx.closePath();
      ctx.stroke();

      // calculate center of face

      a.divideScalar(uvs.length);

      // label the face number

      ctx.font = '18px Arial';
      ctx.fillStyle = 'rgb( 63, 63, 63 )';
      ctx.fillText(index, a.x * width, (1 - a.y) * height);
      if (a.x > 0.95) {
        // wrap x // 0.95 is arbitrary

        ctx.fillText(index, a.x % 1 * width, (1 - a.y) * height);
      }

      //

      ctx.font = '12px Arial';
      ctx.fillStyle = 'rgb( 191, 191, 191 )';

      // label uv edge orders

      for (var _j = 0, _jl = uvs.length; _j < _jl; _j++) {
        var _uv = uvs[_j];
        b.addVectors(a, _uv).divideScalar(2);
        var vnum = face[_j];
        ctx.fillText(abc[_j] + vnum, b.x * width, (1 - b.y) * height);
        if (b.x > 0.95) {
          // wrap x

          ctx.fillText(abc[_j] + vnum, b.x % 1 * width, (1 - b.y) * height);
        }
      }
    }
  }
},43,[2],"../../node_modules/three/examples/jsm/utils/UVsDebug.js");

// ---------------------------------------------------------------------------

if (global.__UIModules.threeJSAddons === undefined) {
  global.__UIModules.threeJSAddons = {};
}
global.__UIModules.threeJSAddons.utils = {
  ...global.__r(1),
  ...global.__r(34),
  ...global.__r(35),
  ...global.__r(36),
  ...global.__r(37),
  ...global.__r(38),
  ...global.__r(39),
  ...global.__r(40),
  ...global.__r(41),
  ...global.__r(42),
  ...global.__r(43),
};

}

runOnUI(init)();
runOnBackground(init)();

}
